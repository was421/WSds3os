// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: DS3_Frpg2RequestMessage.proto

#ifndef PROTOBUF_DS3_5fFrpg2RequestMessage_2eproto__INCLUDED
#define PROTOBUF_DS3_5fFrpg2RequestMessage_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "DS3_Frpg2PlayerData.pb.h"
// @@protoc_insertion_point(includes)

namespace DS3_Frpg2RequestMessage {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

class EmptyResponse;
class RequestWaitForUserLogin;
class RequestWaitForUserLoginResponse;
class PlayerStatusUploadConfig;
class AnnounceMessageData;
class AnnounceMessageDataList;
class RequestGetAnnounceMessageList;
class RequestGetAnnounceMessageListResponse;
class PlayerCharacterData;
class PlayerCharacterID;
class PlayerInfoUploadConfigPushMessage;
class RequestUpdateLoginPlayerCharacter;
class RequestUpdateLoginPlayerCharacterResponse;
class RequestUpdatePlayerStatus;
class RequestUpdatePlayerStatusResponse;
class RequestUpdatePlayerCharacter;
class RequestUpdatePlayerCharacterResponse;
class RequestGetPlayerCharacter;
class RequestGetPlayerCharacterResponse;
class BloodMessageData;
class LocatedBloodMessage;
class BloodMessageDomainLimitData;
class RequestReentryBloodMessage;
class RequestReentryBloodMessageResponse;
class RequestCreateBloodMessage;
class RequestCreateBloodMessageResponse;
class RequestReCreateBloodMessageList;
class RequestReCreateBloodMessageList_Blood_message_info_list;
class RequestReCreateBloodMessageListResponse;
class RequestRemoveBloodMessage;
class RequestRemoveBloodMessageResponse;
class RequestGetBloodMessageList;
class RequestGetBloodMessageListResponse;
class RequestEvaluateBloodMessage;
class RequestEvaluateBloodMessageResponse;
class RequestGetBloodMessageEvaluation;
class BloodMessageEvaluationData;
class RequestGetBloodMessageEvaluationResponse;
class PushRequestEvaluateBloodMessage;
class BloodstainInfo;
class RequestCreateBloodstain;
class RequestGetBloodstainList;
class RequestGetBloodstainListResponse;
class RequestGetDeadingGhost;
class RequestGetDeadingGhostResponse;
class LogCommonInfo_1;
class LogCommonInfo;
class DomainLimitData;
class KillerInfo;
class KillEnemyInfo;
class PartyMemberInfo;
class RequestNotifyProtoBufLog;
class RequestNotifyDie;
class RequestNotifyKillEnemy;
class RequestNotifyKillBoss;
class RequestNotifyJoinMultiplay;
class RequestNotifyLeaveMultiplay;
class RequestNotifyCreateSignResult;
class RequestNotifySummonSignResult;
class RequestNotifyBreakInResult;
class RequestNotifyDisconnectSession;
class RequestNotifyDisconnectSessionResponse;
class RequestNotifyRegisterCharacter;
class SummonSignMessage;
class RemoveSignMessage;
class RejectSignMessage;
class CachedSign;
class GetSignResult;
class SignInfo;
class SignData;
class MatchingParameter;
class SignGetFlags;
class SignDomainGetInfo;
class RequestGetSignList;
class RequestGetSignListResponse;
class RequestCreateSign;
class RequestCreateSignResponse;
class RequestSummonSign;
class RequestSummonSignResponse;
class RequestRemoveSign;
class RequestRemoveSignResponse;
class RequestUpdateSign;
class RequestUpdateSignResponse;
class RequestRejectSign;
class RequestRejectSignResponse;
class RequestGetRightMatchingArea;
class RequestGetRightMatchingAreaResponse;
class RequestGetRightMatchingAreaResponse_Area_info;
class PushRequestRemoveSign;
class PushRequestSummonSign;
class PushRequestRejectSign;
class BreakInTargetData;
class RequestGetBreakInTargetList;
class RequestGetBreakInTargetListResponse;
class PushRequestAllowBreakInTarget;
class PushRequestBreakInTarget;
class PushRequestRemoveBreakInTarget;
class RequestBreakInTarget;
class RequestRejectBreakInTarget;
class PushRequestRejectBreakInTarget;
class RequestBreakInTargetResponse;
class RequestRejectBreakInTargetResponse;
class RequestGetGhostDataList;
class GhostData;
class RequestCreateGhostData;
class RequestCreateGhostDataResponse;
class RequestGetGhostDataListResponse;
class RequestGetVisitorList;
class VisitorData;
class RequestGetVisitorListResponse;
class PushRequestRemoveVisitor;
class RequestVisit;
class PushRequestVisit;
class RequestRejectVisit;
class PushRequestRejectVisit;
class RequestVisitResponse;
class RequestRejectVisitResponse;
class RequestNotifyRingBell;
class RequestNotifyRingBellResponse;
class PushRequestNotifyRingBell;
class RequestGetRegulationFile;
class RequestGetRegulationFileResponse;
class RegulationFileMessage;
class RegulationFileDiffData;
class RegulationFileUpdateMessage;
class RegulationFileUpdatePushMessage;
class RequestBenchmarkThroughput;
class RequestBenchmarkThroughputResponse;
class RequestGetLoginPlayerCharacter;
class RequestGetLoginPlayerCharacterResponse;
class RequestGetPlayerCharacterList;
class RequestGetPlayerCharacterListResponse;
class RequestMeasureUploadBandwidth;
class RequestMeasureUploadBandwidthResponse;
class RequestMeasureDownloadBandwidth;
class RequestMeasureDownloadBandwidthResponse;
class RequestSendMessageToPlayers;
class RequestSendMessageToPlayersResponse;
class RequestSendMessageToSelectLanguagePlayers;
class RequestSendMessageToSelectLanguagePlayersResponse;
class RequestSendMessageToAllPlayers;
class RequestSendMessageToAllPlayersResponse;
class RequestSendPlayerList;
class RankingData;
class RankingRotationID;
class RankingRecordCount;
class RankingDataPack;
class RequestRegisterRankingData;
class RequestRegisterRankingDataResponse;
class RequestGetRankingData;
class RequestGetRankingDataResponse;
class RequestGetCharacterRankingData;
class RequestGetCharacterRankingDataResponse;
class RequestCountRankingData;
class RequestCountRankingDataResponse;
class RequestGetCurrentRank;
class RequestGetCurrentRankResponse;
class QuickMatchRank;
class QuickMatchRankCache;
class QuickMatchSession;
class QuickMatchSession_Result_list;
class QuickMatchApologyPoint;
class QuickMatchData;
class QuickMatchSearchResult;
class AcceptQuickMatchMessage;
class RejectQuickMatchMessage;
class RemoveQuickMatchMessage;
class JoinQuickMatchMessage;
class PushRequestJoinQuickMatch;
class PushRequestAcceptQuickMatch;
class PushRequestRejectQuickMatch;
class RequestSearchQuickMatch;
class RequestSearchQuickMatch_Map_id_list;
class RequestSearchQuickMatchResponse;
class RequestRegisterQuickMatch;
class RequestUnregisterQuickMatch;
class RequestRegisterQuickMatchResponse;
class RequestUnregisterQuickMatchResponse;
class RequestUpdateQuickMatch;
class RequestUpdateQuickMatchResponse;
class RequestJoinQuickMatch;
class RequestJoinQuickMatchResponse;
class RequestAcceptQuickMatch;
class RequestAcceptQuickMatchResponse;
class RequestRejectQuickMatch;
class RequestRejectQuickMatchResponse;
class RequestSendQuickMatchStart;
class RequestSendQuickMatchStart_Session_member_list;
class RequestSendQuickMatchStartResponse;
class RequestSendQuickMatchResult;
class RequestSendQuickMatchResultResponse;
class RequestPushSendQuickMatchStart;
class RitualMarkData;
class LocatedRitualMark;
class RitualMarkDomainLimit;
class RequestCreateMark;
class RequestCreateMarkResponse;
class RequestRemoveMark;
class RequestRemoveMarkResponse;
class RequestReentryMark;
class RequestReentryMarkResponse;
class RequestGetMarkList;
class RequestGetMarkListResponse;
class PushRequestHeader;
class RangedLimit;
class PlayerUserIDPair;
class ManagementTextMessage;
class NRLogUploadRequest;
class NRLoggingMessage;
class ServerPing;
class RequestGetOnlineShopItemList;
class RequestGetOnlineShopItemListResponse;
class RequestGetOnlineShopItemListResponse_Lineup;
class LoginForXboxOne;
class SocketOptionSetting;
class GetConnectGameServerPortIdResponse;
class NotifyLoginToPushServer;
class NotifyLogoutToPushServer;
class UserLoginInfo;
class UserLogout;
class LoginClientInfo;
class NotifyClientServerInfoToPushServer;
class PushLoginUserInfo;
class RequestCheckLogin;
class RequestCheckLoginResponse;
class RequestGetPlayerConnectGameServer;
class PlayerConnectServerInfo;
class RequestGetPlayerConnectGameServerResponse;
class RequestGetServerConnectTime;
class RequestGetServerConnectTimeResponse;
class RequestGetConnectionCount;
class RequestGetConnectionCountResponse;
class RequestDisconnectUser;
class RequestDisconnectAllUser;
class RequestSendMessageToPushClient;
class RequestGetServerSidePlayerStatus;

enum PushMessageId {
  PushID_PushRequestRemoveSign = 829,
  PushID_PushRequestSummonSign = 830,
  PushID_PushRequestRejectSign = 831,
  PushID_PushRequestJoinQuickMatch = 832,
  PushID_PushRequestAcceptQuickMatch = 833,
  PushID_PushRequestRejectQuickMatch = 834,
  PushID_PlayerInfoUploadConfigPushMessage = 908,
  PushID_PushRequestEvaluateBloodMessage = 918,
  PushID_PushRequestBreakInTarget = 933,
  PushID_PushRequestRejectBreakInTarget = 934,
  PushID_PushRequestAllowBreakInTarget = 935,
  PushID_PushRequestVisit = 951,
  PushID_PushRequestRejectVisit = 952,
  PushID_PushRequestRemoveVisitor = 953,
  PushID_PushRequestNotifyRingBell = 969,
  PushID_RegulationFileUpdatePushMessage = 907,
  PushID_ManagementTextMessage = 905
};
bool PushMessageId_IsValid(int value);
const PushMessageId PushMessageId_MIN = PushID_PushRequestRemoveSign;
const PushMessageId PushMessageId_MAX = PushID_PushRequestNotifyRingBell;
const int PushMessageId_ARRAYSIZE = PushMessageId_MAX + 1;

enum LogType {
  UseMagicLog = 2020,
  ActGestureLog = 2021,
  UseItemLog = 3000,
  PurchaseItemLog = 3001,
  GetItemLog = 3002,
  DropItemLog = 3003,
  LeaveItemLog = 3004,
  SaleItemLog = 3005,
  StrengthenWeaponLog = 3010,
  GlobalEventLog = 5001,
  SystemOptionLog = 8001,
  VisitResultLog = 7040,
  QuickMatchResultLog = 7050,
  QuickMatchEndLog = 7060
};
bool LogType_IsValid(int value);
const LogType LogType_MIN = UseMagicLog;
const LogType LogType_MAX = SystemOptionLog;
const int LogType_ARRAYSIZE = LogType_MAX + 1;

enum CauseOfDeath {
  Unknown = 0,
  Physical = 1,
  Fire = 2,
  Fall = 3,
  Cursed = 4,
  PosionToxicMagic = 5
};
bool CauseOfDeath_IsValid(int value);
const CauseOfDeath CauseOfDeath_MIN = Unknown;
const CauseOfDeath CauseOfDeath_MAX = PosionToxicMagic;
const int CauseOfDeath_ARRAYSIZE = CauseOfDeath_MAX + 1;

enum Covenant {
  Covenant_None = 0,
  Covenant_Blade_of_the_Darkmoon = 1,
  Covenant_Warriors_of_Sunlight = 2,
  Covenant_Mound_Makers = 3,
  Covenant_Spears_of_the_Church = 4,
  Covenant_Fingers_of_Rosaria = 5,
  Covenant_Watchdogs_of_Farron = 6,
  Covenant_Aldrich_Faithfuls = 7,
  Covenant_Way_of_Blue = 8,
  Covenant_Blue_Sentinels = 9
};
bool Covenant_IsValid(int value);
const Covenant Covenant_MIN = Covenant_None;
const Covenant Covenant_MAX = Covenant_Blue_Sentinels;
const int Covenant_ARRAYSIZE = Covenant_MAX + 1;

enum SignType {
  SignType_WhiteSoapstone = 0,
  SignType_RedSoapstone = 1
};
bool SignType_IsValid(int value);
const SignType SignType_MIN = SignType_WhiteSoapstone;
const SignType SignType_MAX = SignType_RedSoapstone;
const int SignType_ARRAYSIZE = SignType_MAX + 1;

enum VisitorPool {
  VisitorPool_None = -1,
  VisitorPool_Way_of_Blue = 0,
  VisitorPool_Debug = 1,
  VisitorPool_Watchdog_of_Farron = 2,
  VisitorPool_Aldrich_Faithful = 3,
  VisitorPool_Spear_of_the_Church = 4
};
bool VisitorPool_IsValid(int value);
const VisitorPool VisitorPool_MIN = VisitorPool_None;
const VisitorPool VisitorPool_MAX = VisitorPool_Spear_of_the_Church;
const int VisitorPool_ARRAYSIZE = VisitorPool_MAX + 1;

enum QuickMatchGameMode {
  Duel = 0,
  TwoPlayerBrawl = 1,
  FourPlayerBrawl = 2,
  SixPlayerBrawl = 3,
  TwoVersusTwo = 4,
  ThreeVersusThree = 5,
  TwoVersusTwo_Team = 6,
  ThreeVersusThree_Team = 7
};
bool QuickMatchGameMode_IsValid(int value);
const QuickMatchGameMode QuickMatchGameMode_MIN = Duel;
const QuickMatchGameMode QuickMatchGameMode_MAX = ThreeVersusThree_Team;
const int QuickMatchGameMode_ARRAYSIZE = QuickMatchGameMode_MAX + 1;

enum QuickMatchResult {
  QuickMatchResult_Win = 0,
  QuickMatchResult_Lose = 1,
  QuickMatchResult_Draw = 2,
  QuickMatchResult_Disconnect = 3
};
bool QuickMatchResult_IsValid(int value);
const QuickMatchResult QuickMatchResult_MIN = QuickMatchResult_Win;
const QuickMatchResult QuickMatchResult_MAX = QuickMatchResult_Disconnect;
const int QuickMatchResult_ARRAYSIZE = QuickMatchResult_MAX + 1;

// ===================================================================

class EmptyResponse : public ::google::protobuf::MessageLite {
 public:
  EmptyResponse();
  virtual ~EmptyResponse();

  EmptyResponse(const EmptyResponse& from);

  inline EmptyResponse& operator=(const EmptyResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const EmptyResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const EmptyResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(EmptyResponse* other);

  // implements Message ----------------------------------------------

  EmptyResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const EmptyResponse& from);
  void MergeFrom(const EmptyResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.EmptyResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static EmptyResponse* default_instance_;
};
// -------------------------------------------------------------------

class RequestWaitForUserLogin : public ::google::protobuf::MessageLite {
 public:
  RequestWaitForUserLogin();
  virtual ~RequestWaitForUserLogin();

  RequestWaitForUserLogin(const RequestWaitForUserLogin& from);

  inline RequestWaitForUserLogin& operator=(const RequestWaitForUserLogin& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestWaitForUserLogin& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestWaitForUserLogin* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestWaitForUserLogin* other);

  // implements Message ----------------------------------------------

  RequestWaitForUserLogin* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestWaitForUserLogin& from);
  void MergeFrom(const RequestWaitForUserLogin& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string steam_id = 1;
  inline bool has_steam_id() const;
  inline void clear_steam_id();
  static const int kSteamIdFieldNumber = 1;
  inline const ::std::string& steam_id() const;
  inline void set_steam_id(const ::std::string& value);
  inline void set_steam_id(const char* value);
  inline void set_steam_id(const char* value, size_t size);
  inline ::std::string* mutable_steam_id();
  inline ::std::string* release_steam_id();
  inline void set_allocated_steam_id(::std::string* steam_id);

  // required uint32 unknown_1 = 2;
  inline bool has_unknown_1() const;
  inline void clear_unknown_1();
  static const int kUnknown1FieldNumber = 2;
  inline ::google::protobuf::uint32 unknown_1() const;
  inline void set_unknown_1(::google::protobuf::uint32 value);

  // required uint32 unknown_2 = 3;
  inline bool has_unknown_2() const;
  inline void clear_unknown_2();
  static const int kUnknown2FieldNumber = 3;
  inline ::google::protobuf::uint32 unknown_2() const;
  inline void set_unknown_2(::google::protobuf::uint32 value);

  // required uint32 unknown_3 = 4;
  inline bool has_unknown_3() const;
  inline void clear_unknown_3();
  static const int kUnknown3FieldNumber = 4;
  inline ::google::protobuf::uint32 unknown_3() const;
  inline void set_unknown_3(::google::protobuf::uint32 value);

  // required uint32 unknown_4 = 5;
  inline bool has_unknown_4() const;
  inline void clear_unknown_4();
  static const int kUnknown4FieldNumber = 5;
  inline ::google::protobuf::uint32 unknown_4() const;
  inline void set_unknown_4(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestWaitForUserLogin)
 private:
  inline void set_has_steam_id();
  inline void clear_has_steam_id();
  inline void set_has_unknown_1();
  inline void clear_has_unknown_1();
  inline void set_has_unknown_2();
  inline void clear_has_unknown_2();
  inline void set_has_unknown_3();
  inline void clear_has_unknown_3();
  inline void set_has_unknown_4();
  inline void clear_has_unknown_4();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* steam_id_;
  ::google::protobuf::uint32 unknown_1_;
  ::google::protobuf::uint32 unknown_2_;
  ::google::protobuf::uint32 unknown_3_;
  ::google::protobuf::uint32 unknown_4_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestWaitForUserLogin* default_instance_;
};
// -------------------------------------------------------------------

class RequestWaitForUserLoginResponse : public ::google::protobuf::MessageLite {
 public:
  RequestWaitForUserLoginResponse();
  virtual ~RequestWaitForUserLoginResponse();

  RequestWaitForUserLoginResponse(const RequestWaitForUserLoginResponse& from);

  inline RequestWaitForUserLoginResponse& operator=(const RequestWaitForUserLoginResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestWaitForUserLoginResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestWaitForUserLoginResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestWaitForUserLoginResponse* other);

  // implements Message ----------------------------------------------

  RequestWaitForUserLoginResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestWaitForUserLoginResponse& from);
  void MergeFrom(const RequestWaitForUserLoginResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string steam_id = 1;
  inline bool has_steam_id() const;
  inline void clear_steam_id();
  static const int kSteamIdFieldNumber = 1;
  inline const ::std::string& steam_id() const;
  inline void set_steam_id(const ::std::string& value);
  inline void set_steam_id(const char* value);
  inline void set_steam_id(const char* value, size_t size);
  inline ::std::string* mutable_steam_id();
  inline ::std::string* release_steam_id();
  inline void set_allocated_steam_id(::std::string* steam_id);

  // required uint32 player_id = 2;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 2;
  inline ::google::protobuf::uint32 player_id() const;
  inline void set_player_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestWaitForUserLoginResponse)
 private:
  inline void set_has_steam_id();
  inline void clear_has_steam_id();
  inline void set_has_player_id();
  inline void clear_has_player_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* steam_id_;
  ::google::protobuf::uint32 player_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestWaitForUserLoginResponse* default_instance_;
};
// -------------------------------------------------------------------

class PlayerStatusUploadConfig : public ::google::protobuf::MessageLite {
 public:
  PlayerStatusUploadConfig();
  virtual ~PlayerStatusUploadConfig();

  PlayerStatusUploadConfig(const PlayerStatusUploadConfig& from);

  inline PlayerStatusUploadConfig& operator=(const PlayerStatusUploadConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const PlayerStatusUploadConfig& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PlayerStatusUploadConfig* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PlayerStatusUploadConfig* other);

  // implements Message ----------------------------------------------

  PlayerStatusUploadConfig* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PlayerStatusUploadConfig& from);
  void MergeFrom(const PlayerStatusUploadConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 player_data_mask = 1;
  inline int player_data_mask_size() const;
  inline void clear_player_data_mask();
  static const int kPlayerDataMaskFieldNumber = 1;
  inline ::google::protobuf::uint32 player_data_mask(int index) const;
  inline void set_player_data_mask(int index, ::google::protobuf::uint32 value);
  inline void add_player_data_mask(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      player_data_mask() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_player_data_mask();

  // required uint32 upload_interval = 2;
  inline bool has_upload_interval() const;
  inline void clear_upload_interval();
  static const int kUploadIntervalFieldNumber = 2;
  inline ::google::protobuf::uint32 upload_interval() const;
  inline void set_upload_interval(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.PlayerStatusUploadConfig)
 private:
  inline void set_has_upload_interval();
  inline void clear_has_upload_interval();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > player_data_mask_;
  ::google::protobuf::uint32 upload_interval_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static PlayerStatusUploadConfig* default_instance_;
};
// -------------------------------------------------------------------

class AnnounceMessageData : public ::google::protobuf::MessageLite {
 public:
  AnnounceMessageData();
  virtual ~AnnounceMessageData();

  AnnounceMessageData(const AnnounceMessageData& from);

  inline AnnounceMessageData& operator=(const AnnounceMessageData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const AnnounceMessageData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AnnounceMessageData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AnnounceMessageData* other);

  // implements Message ----------------------------------------------

  AnnounceMessageData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AnnounceMessageData& from);
  void MergeFrom(const AnnounceMessageData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 unknown_1 = 1;
  inline bool has_unknown_1() const;
  inline void clear_unknown_1();
  static const int kUnknown1FieldNumber = 1;
  inline ::google::protobuf::uint32 unknown_1() const;
  inline void set_unknown_1(::google::protobuf::uint32 value);

  // required uint32 index = 2;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 2;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // required uint32 unknown_2 = 3;
  inline bool has_unknown_2() const;
  inline void clear_unknown_2();
  static const int kUnknown2FieldNumber = 3;
  inline ::google::protobuf::uint32 unknown_2() const;
  inline void set_unknown_2(::google::protobuf::uint32 value);

  // required string header = 4;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 4;
  inline const ::std::string& header() const;
  inline void set_header(const ::std::string& value);
  inline void set_header(const char* value);
  inline void set_header(const char* value, size_t size);
  inline ::std::string* mutable_header();
  inline ::std::string* release_header();
  inline void set_allocated_header(::std::string* header);

  // required string message = 5;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 5;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // required .DS3_Frpg2PlayerData.DateTime datetime = 6;
  inline bool has_datetime() const;
  inline void clear_datetime();
  static const int kDatetimeFieldNumber = 6;
  inline const ::DS3_Frpg2PlayerData::DateTime& datetime() const;
  inline ::DS3_Frpg2PlayerData::DateTime* mutable_datetime();
  inline ::DS3_Frpg2PlayerData::DateTime* release_datetime();
  inline void set_allocated_datetime(::DS3_Frpg2PlayerData::DateTime* datetime);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.AnnounceMessageData)
 private:
  inline void set_has_unknown_1();
  inline void clear_has_unknown_1();
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_unknown_2();
  inline void clear_has_unknown_2();
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_message();
  inline void clear_has_message();
  inline void set_has_datetime();
  inline void clear_has_datetime();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 unknown_1_;
  ::google::protobuf::uint32 index_;
  ::std::string* header_;
  ::std::string* message_;
  ::DS3_Frpg2PlayerData::DateTime* datetime_;
  ::google::protobuf::uint32 unknown_2_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static AnnounceMessageData* default_instance_;
};
// -------------------------------------------------------------------

class AnnounceMessageDataList : public ::google::protobuf::MessageLite {
 public:
  AnnounceMessageDataList();
  virtual ~AnnounceMessageDataList();

  AnnounceMessageDataList(const AnnounceMessageDataList& from);

  inline AnnounceMessageDataList& operator=(const AnnounceMessageDataList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const AnnounceMessageDataList& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AnnounceMessageDataList* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AnnounceMessageDataList* other);

  // implements Message ----------------------------------------------

  AnnounceMessageDataList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AnnounceMessageDataList& from);
  void MergeFrom(const AnnounceMessageDataList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .DS3_Frpg2RequestMessage.AnnounceMessageData items = 1;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 1;
  inline const ::DS3_Frpg2RequestMessage::AnnounceMessageData& items(int index) const;
  inline ::DS3_Frpg2RequestMessage::AnnounceMessageData* mutable_items(int index);
  inline ::DS3_Frpg2RequestMessage::AnnounceMessageData* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::AnnounceMessageData >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::AnnounceMessageData >*
      mutable_items();

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.AnnounceMessageDataList)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::AnnounceMessageData > items_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static AnnounceMessageDataList* default_instance_;
};
// -------------------------------------------------------------------

class RequestGetAnnounceMessageList : public ::google::protobuf::MessageLite {
 public:
  RequestGetAnnounceMessageList();
  virtual ~RequestGetAnnounceMessageList();

  RequestGetAnnounceMessageList(const RequestGetAnnounceMessageList& from);

  inline RequestGetAnnounceMessageList& operator=(const RequestGetAnnounceMessageList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestGetAnnounceMessageList& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestGetAnnounceMessageList* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestGetAnnounceMessageList* other);

  // implements Message ----------------------------------------------

  RequestGetAnnounceMessageList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestGetAnnounceMessageList& from);
  void MergeFrom(const RequestGetAnnounceMessageList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 max_entries = 1;
  inline bool has_max_entries() const;
  inline void clear_max_entries();
  static const int kMaxEntriesFieldNumber = 1;
  inline ::google::protobuf::uint32 max_entries() const;
  inline void set_max_entries(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestGetAnnounceMessageList)
 private:
  inline void set_has_max_entries();
  inline void clear_has_max_entries();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 max_entries_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestGetAnnounceMessageList* default_instance_;
};
// -------------------------------------------------------------------

class RequestGetAnnounceMessageListResponse : public ::google::protobuf::MessageLite {
 public:
  RequestGetAnnounceMessageListResponse();
  virtual ~RequestGetAnnounceMessageListResponse();

  RequestGetAnnounceMessageListResponse(const RequestGetAnnounceMessageListResponse& from);

  inline RequestGetAnnounceMessageListResponse& operator=(const RequestGetAnnounceMessageListResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestGetAnnounceMessageListResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestGetAnnounceMessageListResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestGetAnnounceMessageListResponse* other);

  // implements Message ----------------------------------------------

  RequestGetAnnounceMessageListResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestGetAnnounceMessageListResponse& from);
  void MergeFrom(const RequestGetAnnounceMessageListResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .DS3_Frpg2RequestMessage.AnnounceMessageDataList changes = 1;
  inline bool has_changes() const;
  inline void clear_changes();
  static const int kChangesFieldNumber = 1;
  inline const ::DS3_Frpg2RequestMessage::AnnounceMessageDataList& changes() const;
  inline ::DS3_Frpg2RequestMessage::AnnounceMessageDataList* mutable_changes();
  inline ::DS3_Frpg2RequestMessage::AnnounceMessageDataList* release_changes();
  inline void set_allocated_changes(::DS3_Frpg2RequestMessage::AnnounceMessageDataList* changes);

  // required .DS3_Frpg2RequestMessage.AnnounceMessageDataList notices = 2;
  inline bool has_notices() const;
  inline void clear_notices();
  static const int kNoticesFieldNumber = 2;
  inline const ::DS3_Frpg2RequestMessage::AnnounceMessageDataList& notices() const;
  inline ::DS3_Frpg2RequestMessage::AnnounceMessageDataList* mutable_notices();
  inline ::DS3_Frpg2RequestMessage::AnnounceMessageDataList* release_notices();
  inline void set_allocated_notices(::DS3_Frpg2RequestMessage::AnnounceMessageDataList* notices);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestGetAnnounceMessageListResponse)
 private:
  inline void set_has_changes();
  inline void clear_has_changes();
  inline void set_has_notices();
  inline void clear_has_notices();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::DS3_Frpg2RequestMessage::AnnounceMessageDataList* changes_;
  ::DS3_Frpg2RequestMessage::AnnounceMessageDataList* notices_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestGetAnnounceMessageListResponse* default_instance_;
};
// -------------------------------------------------------------------

class PlayerCharacterData : public ::google::protobuf::MessageLite {
 public:
  PlayerCharacterData();
  virtual ~PlayerCharacterData();

  PlayerCharacterData(const PlayerCharacterData& from);

  inline PlayerCharacterData& operator=(const PlayerCharacterData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const PlayerCharacterData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PlayerCharacterData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PlayerCharacterData* other);

  // implements Message ----------------------------------------------

  PlayerCharacterData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PlayerCharacterData& from);
  void MergeFrom(const PlayerCharacterData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.PlayerCharacterData)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static PlayerCharacterData* default_instance_;
};
// -------------------------------------------------------------------

class PlayerCharacterID : public ::google::protobuf::MessageLite {
 public:
  PlayerCharacterID();
  virtual ~PlayerCharacterID();

  PlayerCharacterID(const PlayerCharacterID& from);

  inline PlayerCharacterID& operator=(const PlayerCharacterID& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const PlayerCharacterID& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PlayerCharacterID* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PlayerCharacterID* other);

  // implements Message ----------------------------------------------

  PlayerCharacterID* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PlayerCharacterID& from);
  void MergeFrom(const PlayerCharacterID& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.PlayerCharacterID)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static PlayerCharacterID* default_instance_;
};
// -------------------------------------------------------------------

class PlayerInfoUploadConfigPushMessage : public ::google::protobuf::MessageLite {
 public:
  PlayerInfoUploadConfigPushMessage();
  virtual ~PlayerInfoUploadConfigPushMessage();

  PlayerInfoUploadConfigPushMessage(const PlayerInfoUploadConfigPushMessage& from);

  inline PlayerInfoUploadConfigPushMessage& operator=(const PlayerInfoUploadConfigPushMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const PlayerInfoUploadConfigPushMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PlayerInfoUploadConfigPushMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PlayerInfoUploadConfigPushMessage* other);

  // implements Message ----------------------------------------------

  PlayerInfoUploadConfigPushMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PlayerInfoUploadConfigPushMessage& from);
  void MergeFrom(const PlayerInfoUploadConfigPushMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
  inline bool has_push_message_id() const;
  inline void clear_push_message_id();
  static const int kPushMessageIdFieldNumber = 1;
  inline ::DS3_Frpg2RequestMessage::PushMessageId push_message_id() const;
  inline void set_push_message_id(::DS3_Frpg2RequestMessage::PushMessageId value);

  // required .DS3_Frpg2RequestMessage.PlayerStatusUploadConfig config = 2;
  inline bool has_config() const;
  inline void clear_config();
  static const int kConfigFieldNumber = 2;
  inline const ::DS3_Frpg2RequestMessage::PlayerStatusUploadConfig& config() const;
  inline ::DS3_Frpg2RequestMessage::PlayerStatusUploadConfig* mutable_config();
  inline ::DS3_Frpg2RequestMessage::PlayerStatusUploadConfig* release_config();
  inline void set_allocated_config(::DS3_Frpg2RequestMessage::PlayerStatusUploadConfig* config);

  // required uint32 player_character_update_send_delay = 3;
  inline bool has_player_character_update_send_delay() const;
  inline void clear_player_character_update_send_delay();
  static const int kPlayerCharacterUpdateSendDelayFieldNumber = 3;
  inline ::google::protobuf::uint32 player_character_update_send_delay() const;
  inline void set_player_character_update_send_delay(::google::protobuf::uint32 value);

  // required uint32 player_status_send_delay = 4;
  inline bool has_player_status_send_delay() const;
  inline void clear_player_status_send_delay();
  static const int kPlayerStatusSendDelayFieldNumber = 4;
  inline ::google::protobuf::uint32 player_status_send_delay() const;
  inline void set_player_status_send_delay(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.PlayerInfoUploadConfigPushMessage)
 private:
  inline void set_has_push_message_id();
  inline void clear_has_push_message_id();
  inline void set_has_config();
  inline void clear_has_config();
  inline void set_has_player_character_update_send_delay();
  inline void clear_has_player_character_update_send_delay();
  inline void set_has_player_status_send_delay();
  inline void clear_has_player_status_send_delay();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::DS3_Frpg2RequestMessage::PlayerStatusUploadConfig* config_;
  int push_message_id_;
  ::google::protobuf::uint32 player_character_update_send_delay_;
  ::google::protobuf::uint32 player_status_send_delay_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static PlayerInfoUploadConfigPushMessage* default_instance_;
};
// -------------------------------------------------------------------

class RequestUpdateLoginPlayerCharacter : public ::google::protobuf::MessageLite {
 public:
  RequestUpdateLoginPlayerCharacter();
  virtual ~RequestUpdateLoginPlayerCharacter();

  RequestUpdateLoginPlayerCharacter(const RequestUpdateLoginPlayerCharacter& from);

  inline RequestUpdateLoginPlayerCharacter& operator=(const RequestUpdateLoginPlayerCharacter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestUpdateLoginPlayerCharacter& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestUpdateLoginPlayerCharacter* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestUpdateLoginPlayerCharacter* other);

  // implements Message ----------------------------------------------

  RequestUpdateLoginPlayerCharacter* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestUpdateLoginPlayerCharacter& from);
  void MergeFrom(const RequestUpdateLoginPlayerCharacter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 character_id = 1;
  inline bool has_character_id() const;
  inline void clear_character_id();
  static const int kCharacterIdFieldNumber = 1;
  inline ::google::protobuf::uint32 character_id() const;
  inline void set_character_id(::google::protobuf::uint32 value);

  // repeated uint32 unknown_2 = 2;
  inline int unknown_2_size() const;
  inline void clear_unknown_2();
  static const int kUnknown2FieldNumber = 2;
  inline ::google::protobuf::uint32 unknown_2(int index) const;
  inline void set_unknown_2(int index, ::google::protobuf::uint32 value);
  inline void add_unknown_2(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      unknown_2() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_unknown_2();

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestUpdateLoginPlayerCharacter)
 private:
  inline void set_has_character_id();
  inline void clear_has_character_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > unknown_2_;
  ::google::protobuf::uint32 character_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestUpdateLoginPlayerCharacter* default_instance_;
};
// -------------------------------------------------------------------

class RequestUpdateLoginPlayerCharacterResponse : public ::google::protobuf::MessageLite {
 public:
  RequestUpdateLoginPlayerCharacterResponse();
  virtual ~RequestUpdateLoginPlayerCharacterResponse();

  RequestUpdateLoginPlayerCharacterResponse(const RequestUpdateLoginPlayerCharacterResponse& from);

  inline RequestUpdateLoginPlayerCharacterResponse& operator=(const RequestUpdateLoginPlayerCharacterResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestUpdateLoginPlayerCharacterResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestUpdateLoginPlayerCharacterResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestUpdateLoginPlayerCharacterResponse* other);

  // implements Message ----------------------------------------------

  RequestUpdateLoginPlayerCharacterResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestUpdateLoginPlayerCharacterResponse& from);
  void MergeFrom(const RequestUpdateLoginPlayerCharacterResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 character_id = 1;
  inline bool has_character_id() const;
  inline void clear_character_id();
  static const int kCharacterIdFieldNumber = 1;
  inline ::google::protobuf::uint32 character_id() const;
  inline void set_character_id(::google::protobuf::uint32 value);

  // required .DS3_Frpg2RequestMessage.QuickMatchRank quickmatch_brawl_rank = 2;
  inline bool has_quickmatch_brawl_rank() const;
  inline void clear_quickmatch_brawl_rank();
  static const int kQuickmatchBrawlRankFieldNumber = 2;
  inline const ::DS3_Frpg2RequestMessage::QuickMatchRank& quickmatch_brawl_rank() const;
  inline ::DS3_Frpg2RequestMessage::QuickMatchRank* mutable_quickmatch_brawl_rank();
  inline ::DS3_Frpg2RequestMessage::QuickMatchRank* release_quickmatch_brawl_rank();
  inline void set_allocated_quickmatch_brawl_rank(::DS3_Frpg2RequestMessage::QuickMatchRank* quickmatch_brawl_rank);

  // required .DS3_Frpg2RequestMessage.QuickMatchRank quickmatch_dual_rank = 3;
  inline bool has_quickmatch_dual_rank() const;
  inline void clear_quickmatch_dual_rank();
  static const int kQuickmatchDualRankFieldNumber = 3;
  inline const ::DS3_Frpg2RequestMessage::QuickMatchRank& quickmatch_dual_rank() const;
  inline ::DS3_Frpg2RequestMessage::QuickMatchRank* mutable_quickmatch_dual_rank();
  inline ::DS3_Frpg2RequestMessage::QuickMatchRank* release_quickmatch_dual_rank();
  inline void set_allocated_quickmatch_dual_rank(::DS3_Frpg2RequestMessage::QuickMatchRank* quickmatch_dual_rank);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestUpdateLoginPlayerCharacterResponse)
 private:
  inline void set_has_character_id();
  inline void clear_has_character_id();
  inline void set_has_quickmatch_brawl_rank();
  inline void clear_has_quickmatch_brawl_rank();
  inline void set_has_quickmatch_dual_rank();
  inline void clear_has_quickmatch_dual_rank();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::DS3_Frpg2RequestMessage::QuickMatchRank* quickmatch_brawl_rank_;
  ::DS3_Frpg2RequestMessage::QuickMatchRank* quickmatch_dual_rank_;
  ::google::protobuf::uint32 character_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestUpdateLoginPlayerCharacterResponse* default_instance_;
};
// -------------------------------------------------------------------

class RequestUpdatePlayerStatus : public ::google::protobuf::MessageLite {
 public:
  RequestUpdatePlayerStatus();
  virtual ~RequestUpdatePlayerStatus();

  RequestUpdatePlayerStatus(const RequestUpdatePlayerStatus& from);

  inline RequestUpdatePlayerStatus& operator=(const RequestUpdatePlayerStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestUpdatePlayerStatus& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestUpdatePlayerStatus* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestUpdatePlayerStatus* other);

  // implements Message ----------------------------------------------

  RequestUpdatePlayerStatus* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestUpdatePlayerStatus& from);
  void MergeFrom(const RequestUpdatePlayerStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline const ::std::string& status() const;
  inline void set_status(const ::std::string& value);
  inline void set_status(const char* value);
  inline void set_status(const void* value, size_t size);
  inline ::std::string* mutable_status();
  inline ::std::string* release_status();
  inline void set_allocated_status(::std::string* status);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestUpdatePlayerStatus)
 private:
  inline void set_has_status();
  inline void clear_has_status();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* status_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestUpdatePlayerStatus* default_instance_;
};
// -------------------------------------------------------------------

class RequestUpdatePlayerStatusResponse : public ::google::protobuf::MessageLite {
 public:
  RequestUpdatePlayerStatusResponse();
  virtual ~RequestUpdatePlayerStatusResponse();

  RequestUpdatePlayerStatusResponse(const RequestUpdatePlayerStatusResponse& from);

  inline RequestUpdatePlayerStatusResponse& operator=(const RequestUpdatePlayerStatusResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestUpdatePlayerStatusResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestUpdatePlayerStatusResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestUpdatePlayerStatusResponse* other);

  // implements Message ----------------------------------------------

  RequestUpdatePlayerStatusResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestUpdatePlayerStatusResponse& from);
  void MergeFrom(const RequestUpdatePlayerStatusResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestUpdatePlayerStatusResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestUpdatePlayerStatusResponse* default_instance_;
};
// -------------------------------------------------------------------

class RequestUpdatePlayerCharacter : public ::google::protobuf::MessageLite {
 public:
  RequestUpdatePlayerCharacter();
  virtual ~RequestUpdatePlayerCharacter();

  RequestUpdatePlayerCharacter(const RequestUpdatePlayerCharacter& from);

  inline RequestUpdatePlayerCharacter& operator=(const RequestUpdatePlayerCharacter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestUpdatePlayerCharacter& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestUpdatePlayerCharacter* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestUpdatePlayerCharacter* other);

  // implements Message ----------------------------------------------

  RequestUpdatePlayerCharacter* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestUpdatePlayerCharacter& from);
  void MergeFrom(const RequestUpdatePlayerCharacter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 character_id = 1;
  inline bool has_character_id() const;
  inline void clear_character_id();
  static const int kCharacterIdFieldNumber = 1;
  inline ::google::protobuf::uint32 character_id() const;
  inline void set_character_id(::google::protobuf::uint32 value);

  // required bytes character_data = 2;
  inline bool has_character_data() const;
  inline void clear_character_data();
  static const int kCharacterDataFieldNumber = 2;
  inline const ::std::string& character_data() const;
  inline void set_character_data(const ::std::string& value);
  inline void set_character_data(const char* value);
  inline void set_character_data(const void* value, size_t size);
  inline ::std::string* mutable_character_data();
  inline ::std::string* release_character_data();
  inline void set_allocated_character_data(::std::string* character_data);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestUpdatePlayerCharacter)
 private:
  inline void set_has_character_id();
  inline void clear_has_character_id();
  inline void set_has_character_data();
  inline void clear_has_character_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* character_data_;
  ::google::protobuf::uint32 character_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestUpdatePlayerCharacter* default_instance_;
};
// -------------------------------------------------------------------

class RequestUpdatePlayerCharacterResponse : public ::google::protobuf::MessageLite {
 public:
  RequestUpdatePlayerCharacterResponse();
  virtual ~RequestUpdatePlayerCharacterResponse();

  RequestUpdatePlayerCharacterResponse(const RequestUpdatePlayerCharacterResponse& from);

  inline RequestUpdatePlayerCharacterResponse& operator=(const RequestUpdatePlayerCharacterResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestUpdatePlayerCharacterResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestUpdatePlayerCharacterResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestUpdatePlayerCharacterResponse* other);

  // implements Message ----------------------------------------------

  RequestUpdatePlayerCharacterResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestUpdatePlayerCharacterResponse& from);
  void MergeFrom(const RequestUpdatePlayerCharacterResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestUpdatePlayerCharacterResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestUpdatePlayerCharacterResponse* default_instance_;
};
// -------------------------------------------------------------------

class RequestGetPlayerCharacter : public ::google::protobuf::MessageLite {
 public:
  RequestGetPlayerCharacter();
  virtual ~RequestGetPlayerCharacter();

  RequestGetPlayerCharacter(const RequestGetPlayerCharacter& from);

  inline RequestGetPlayerCharacter& operator=(const RequestGetPlayerCharacter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestGetPlayerCharacter& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestGetPlayerCharacter* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestGetPlayerCharacter* other);

  // implements Message ----------------------------------------------

  RequestGetPlayerCharacter* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestGetPlayerCharacter& from);
  void MergeFrom(const RequestGetPlayerCharacter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 player_id = 1;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 1;
  inline ::google::protobuf::uint32 player_id() const;
  inline void set_player_id(::google::protobuf::uint32 value);

  // required uint32 character_id = 2;
  inline bool has_character_id() const;
  inline void clear_character_id();
  static const int kCharacterIdFieldNumber = 2;
  inline ::google::protobuf::uint32 character_id() const;
  inline void set_character_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestGetPlayerCharacter)
 private:
  inline void set_has_player_id();
  inline void clear_has_player_id();
  inline void set_has_character_id();
  inline void clear_has_character_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 player_id_;
  ::google::protobuf::uint32 character_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestGetPlayerCharacter* default_instance_;
};
// -------------------------------------------------------------------

class RequestGetPlayerCharacterResponse : public ::google::protobuf::MessageLite {
 public:
  RequestGetPlayerCharacterResponse();
  virtual ~RequestGetPlayerCharacterResponse();

  RequestGetPlayerCharacterResponse(const RequestGetPlayerCharacterResponse& from);

  inline RequestGetPlayerCharacterResponse& operator=(const RequestGetPlayerCharacterResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestGetPlayerCharacterResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestGetPlayerCharacterResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestGetPlayerCharacterResponse* other);

  // implements Message ----------------------------------------------

  RequestGetPlayerCharacterResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestGetPlayerCharacterResponse& from);
  void MergeFrom(const RequestGetPlayerCharacterResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 player_id = 1;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 1;
  inline ::google::protobuf::uint32 player_id() const;
  inline void set_player_id(::google::protobuf::uint32 value);

  // required uint32 character_id = 2;
  inline bool has_character_id() const;
  inline void clear_character_id();
  static const int kCharacterIdFieldNumber = 2;
  inline ::google::protobuf::uint32 character_id() const;
  inline void set_character_id(::google::protobuf::uint32 value);

  // required bytes character_data = 3;
  inline bool has_character_data() const;
  inline void clear_character_data();
  static const int kCharacterDataFieldNumber = 3;
  inline const ::std::string& character_data() const;
  inline void set_character_data(const ::std::string& value);
  inline void set_character_data(const char* value);
  inline void set_character_data(const void* value, size_t size);
  inline ::std::string* mutable_character_data();
  inline ::std::string* release_character_data();
  inline void set_allocated_character_data(::std::string* character_data);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestGetPlayerCharacterResponse)
 private:
  inline void set_has_player_id();
  inline void clear_has_player_id();
  inline void set_has_character_id();
  inline void clear_has_character_id();
  inline void set_has_character_data();
  inline void clear_has_character_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 player_id_;
  ::google::protobuf::uint32 character_id_;
  ::std::string* character_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestGetPlayerCharacterResponse* default_instance_;
};
// -------------------------------------------------------------------

class BloodMessageData : public ::google::protobuf::MessageLite {
 public:
  BloodMessageData();
  virtual ~BloodMessageData();

  BloodMessageData(const BloodMessageData& from);

  inline BloodMessageData& operator=(const BloodMessageData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const BloodMessageData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BloodMessageData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BloodMessageData* other);

  // implements Message ----------------------------------------------

  BloodMessageData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BloodMessageData& from);
  void MergeFrom(const BloodMessageData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 player_id = 1;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 1;
  inline ::google::protobuf::uint32 player_id() const;
  inline void set_player_id(::google::protobuf::uint32 value);

  // required uint32 character_id = 2;
  inline bool has_character_id() const;
  inline void clear_character_id();
  static const int kCharacterIdFieldNumber = 2;
  inline ::google::protobuf::uint32 character_id() const;
  inline void set_character_id(::google::protobuf::uint32 value);

  // required uint32 message_id = 3;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 3;
  inline ::google::protobuf::uint32 message_id() const;
  inline void set_message_id(::google::protobuf::uint32 value);

  // required uint32 good = 4;
  inline bool has_good() const;
  inline void clear_good();
  static const int kGoodFieldNumber = 4;
  inline ::google::protobuf::uint32 good() const;
  inline void set_good(::google::protobuf::uint32 value);

  // required bytes message_data = 5;
  inline bool has_message_data() const;
  inline void clear_message_data();
  static const int kMessageDataFieldNumber = 5;
  inline const ::std::string& message_data() const;
  inline void set_message_data(const ::std::string& value);
  inline void set_message_data(const char* value);
  inline void set_message_data(const void* value, size_t size);
  inline ::std::string* mutable_message_data();
  inline ::std::string* release_message_data();
  inline void set_allocated_message_data(::std::string* message_data);

  // required string player_steam_id = 6;
  inline bool has_player_steam_id() const;
  inline void clear_player_steam_id();
  static const int kPlayerSteamIdFieldNumber = 6;
  inline const ::std::string& player_steam_id() const;
  inline void set_player_steam_id(const ::std::string& value);
  inline void set_player_steam_id(const char* value);
  inline void set_player_steam_id(const char* value, size_t size);
  inline ::std::string* mutable_player_steam_id();
  inline ::std::string* release_player_steam_id();
  inline void set_allocated_player_steam_id(::std::string* player_steam_id);

  // required uint32 online_area_id = 7;
  inline bool has_online_area_id() const;
  inline void clear_online_area_id();
  static const int kOnlineAreaIdFieldNumber = 7;
  inline ::google::protobuf::uint32 online_area_id() const;
  inline void set_online_area_id(::google::protobuf::uint32 value);

  // required uint32 poor = 8;
  inline bool has_poor() const;
  inline void clear_poor();
  static const int kPoorFieldNumber = 8;
  inline ::google::protobuf::uint32 poor() const;
  inline void set_poor(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.BloodMessageData)
 private:
  inline void set_has_player_id();
  inline void clear_has_player_id();
  inline void set_has_character_id();
  inline void clear_has_character_id();
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_good();
  inline void clear_has_good();
  inline void set_has_message_data();
  inline void clear_has_message_data();
  inline void set_has_player_steam_id();
  inline void clear_has_player_steam_id();
  inline void set_has_online_area_id();
  inline void clear_has_online_area_id();
  inline void set_has_poor();
  inline void clear_has_poor();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 player_id_;
  ::google::protobuf::uint32 character_id_;
  ::google::protobuf::uint32 message_id_;
  ::google::protobuf::uint32 good_;
  ::std::string* message_data_;
  ::std::string* player_steam_id_;
  ::google::protobuf::uint32 online_area_id_;
  ::google::protobuf::uint32 poor_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static BloodMessageData* default_instance_;
};
// -------------------------------------------------------------------

class LocatedBloodMessage : public ::google::protobuf::MessageLite {
 public:
  LocatedBloodMessage();
  virtual ~LocatedBloodMessage();

  LocatedBloodMessage(const LocatedBloodMessage& from);

  inline LocatedBloodMessage& operator=(const LocatedBloodMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const LocatedBloodMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LocatedBloodMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LocatedBloodMessage* other);

  // implements Message ----------------------------------------------

  LocatedBloodMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LocatedBloodMessage& from);
  void MergeFrom(const LocatedBloodMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 online_area_id = 1;
  inline bool has_online_area_id() const;
  inline void clear_online_area_id();
  static const int kOnlineAreaIdFieldNumber = 1;
  inline ::google::protobuf::uint32 online_area_id() const;
  inline void set_online_area_id(::google::protobuf::uint32 value);

  // required uint32 message_id = 2;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 2;
  inline ::google::protobuf::uint32 message_id() const;
  inline void set_message_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.LocatedBloodMessage)
 private:
  inline void set_has_online_area_id();
  inline void clear_has_online_area_id();
  inline void set_has_message_id();
  inline void clear_has_message_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 online_area_id_;
  ::google::protobuf::uint32 message_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static LocatedBloodMessage* default_instance_;
};
// -------------------------------------------------------------------

class BloodMessageDomainLimitData : public ::google::protobuf::MessageLite {
 public:
  BloodMessageDomainLimitData();
  virtual ~BloodMessageDomainLimitData();

  BloodMessageDomainLimitData(const BloodMessageDomainLimitData& from);

  inline BloodMessageDomainLimitData& operator=(const BloodMessageDomainLimitData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const BloodMessageDomainLimitData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BloodMessageDomainLimitData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BloodMessageDomainLimitData* other);

  // implements Message ----------------------------------------------

  BloodMessageDomainLimitData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BloodMessageDomainLimitData& from);
  void MergeFrom(const BloodMessageDomainLimitData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 online_area_id = 1;
  inline bool has_online_area_id() const;
  inline void clear_online_area_id();
  static const int kOnlineAreaIdFieldNumber = 1;
  inline ::google::protobuf::uint32 online_area_id() const;
  inline void set_online_area_id(::google::protobuf::uint32 value);

  // required uint32 max_type_1 = 2;
  inline bool has_max_type_1() const;
  inline void clear_max_type_1();
  static const int kMaxType1FieldNumber = 2;
  inline ::google::protobuf::uint32 max_type_1() const;
  inline void set_max_type_1(::google::protobuf::uint32 value);

  // required uint32 max_type_2 = 3;
  inline bool has_max_type_2() const;
  inline void clear_max_type_2();
  static const int kMaxType2FieldNumber = 3;
  inline ::google::protobuf::uint32 max_type_2() const;
  inline void set_max_type_2(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.BloodMessageDomainLimitData)
 private:
  inline void set_has_online_area_id();
  inline void clear_has_online_area_id();
  inline void set_has_max_type_1();
  inline void clear_has_max_type_1();
  inline void set_has_max_type_2();
  inline void clear_has_max_type_2();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 online_area_id_;
  ::google::protobuf::uint32 max_type_1_;
  ::google::protobuf::uint32 max_type_2_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static BloodMessageDomainLimitData* default_instance_;
};
// -------------------------------------------------------------------

class RequestReentryBloodMessage : public ::google::protobuf::MessageLite {
 public:
  RequestReentryBloodMessage();
  virtual ~RequestReentryBloodMessage();

  RequestReentryBloodMessage(const RequestReentryBloodMessage& from);

  inline RequestReentryBloodMessage& operator=(const RequestReentryBloodMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestReentryBloodMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestReentryBloodMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestReentryBloodMessage* other);

  // implements Message ----------------------------------------------

  RequestReentryBloodMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestReentryBloodMessage& from);
  void MergeFrom(const RequestReentryBloodMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .DS3_Frpg2RequestMessage.LocatedBloodMessage messages = 1;
  inline int messages_size() const;
  inline void clear_messages();
  static const int kMessagesFieldNumber = 1;
  inline const ::DS3_Frpg2RequestMessage::LocatedBloodMessage& messages(int index) const;
  inline ::DS3_Frpg2RequestMessage::LocatedBloodMessage* mutable_messages(int index);
  inline ::DS3_Frpg2RequestMessage::LocatedBloodMessage* add_messages();
  inline const ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::LocatedBloodMessage >&
      messages() const;
  inline ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::LocatedBloodMessage >*
      mutable_messages();

  // required uint32 character_id = 2;
  inline bool has_character_id() const;
  inline void clear_character_id();
  static const int kCharacterIdFieldNumber = 2;
  inline ::google::protobuf::uint32 character_id() const;
  inline void set_character_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestReentryBloodMessage)
 private:
  inline void set_has_character_id();
  inline void clear_has_character_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::LocatedBloodMessage > messages_;
  ::google::protobuf::uint32 character_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestReentryBloodMessage* default_instance_;
};
// -------------------------------------------------------------------

class RequestReentryBloodMessageResponse : public ::google::protobuf::MessageLite {
 public:
  RequestReentryBloodMessageResponse();
  virtual ~RequestReentryBloodMessageResponse();

  RequestReentryBloodMessageResponse(const RequestReentryBloodMessageResponse& from);

  inline RequestReentryBloodMessageResponse& operator=(const RequestReentryBloodMessageResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestReentryBloodMessageResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestReentryBloodMessageResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestReentryBloodMessageResponse* other);

  // implements Message ----------------------------------------------

  RequestReentryBloodMessageResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestReentryBloodMessageResponse& from);
  void MergeFrom(const RequestReentryBloodMessageResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 recreate_message_ids = 1;
  inline int recreate_message_ids_size() const;
  inline void clear_recreate_message_ids();
  static const int kRecreateMessageIdsFieldNumber = 1;
  inline ::google::protobuf::uint32 recreate_message_ids(int index) const;
  inline void set_recreate_message_ids(int index, ::google::protobuf::uint32 value);
  inline void add_recreate_message_ids(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      recreate_message_ids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_recreate_message_ids();

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestReentryBloodMessageResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > recreate_message_ids_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestReentryBloodMessageResponse* default_instance_;
};
// -------------------------------------------------------------------

class RequestCreateBloodMessage : public ::google::protobuf::MessageLite {
 public:
  RequestCreateBloodMessage();
  virtual ~RequestCreateBloodMessage();

  RequestCreateBloodMessage(const RequestCreateBloodMessage& from);

  inline RequestCreateBloodMessage& operator=(const RequestCreateBloodMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestCreateBloodMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestCreateBloodMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestCreateBloodMessage* other);

  // implements Message ----------------------------------------------

  RequestCreateBloodMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestCreateBloodMessage& from);
  void MergeFrom(const RequestCreateBloodMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 online_area_id = 1;
  inline bool has_online_area_id() const;
  inline void clear_online_area_id();
  static const int kOnlineAreaIdFieldNumber = 1;
  inline ::google::protobuf::uint32 online_area_id() const;
  inline void set_online_area_id(::google::protobuf::uint32 value);

  // required uint32 character_id = 2;
  inline bool has_character_id() const;
  inline void clear_character_id();
  static const int kCharacterIdFieldNumber = 2;
  inline ::google::protobuf::uint32 character_id() const;
  inline void set_character_id(::google::protobuf::uint32 value);

  // required bytes message_data = 3;
  inline bool has_message_data() const;
  inline void clear_message_data();
  static const int kMessageDataFieldNumber = 3;
  inline const ::std::string& message_data() const;
  inline void set_message_data(const ::std::string& value);
  inline void set_message_data(const char* value);
  inline void set_message_data(const void* value, size_t size);
  inline ::std::string* mutable_message_data();
  inline ::std::string* release_message_data();
  inline void set_allocated_message_data(::std::string* message_data);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestCreateBloodMessage)
 private:
  inline void set_has_online_area_id();
  inline void clear_has_online_area_id();
  inline void set_has_character_id();
  inline void clear_has_character_id();
  inline void set_has_message_data();
  inline void clear_has_message_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 online_area_id_;
  ::google::protobuf::uint32 character_id_;
  ::std::string* message_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestCreateBloodMessage* default_instance_;
};
// -------------------------------------------------------------------

class RequestCreateBloodMessageResponse : public ::google::protobuf::MessageLite {
 public:
  RequestCreateBloodMessageResponse();
  virtual ~RequestCreateBloodMessageResponse();

  RequestCreateBloodMessageResponse(const RequestCreateBloodMessageResponse& from);

  inline RequestCreateBloodMessageResponse& operator=(const RequestCreateBloodMessageResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestCreateBloodMessageResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestCreateBloodMessageResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestCreateBloodMessageResponse* other);

  // implements Message ----------------------------------------------

  RequestCreateBloodMessageResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestCreateBloodMessageResponse& from);
  void MergeFrom(const RequestCreateBloodMessageResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::uint32 message_id() const;
  inline void set_message_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestCreateBloodMessageResponse)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 message_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestCreateBloodMessageResponse* default_instance_;
};
// -------------------------------------------------------------------

class RequestReCreateBloodMessageList_Blood_message_info_list : public ::google::protobuf::MessageLite {
 public:
  RequestReCreateBloodMessageList_Blood_message_info_list();
  virtual ~RequestReCreateBloodMessageList_Blood_message_info_list();

  RequestReCreateBloodMessageList_Blood_message_info_list(const RequestReCreateBloodMessageList_Blood_message_info_list& from);

  inline RequestReCreateBloodMessageList_Blood_message_info_list& operator=(const RequestReCreateBloodMessageList_Blood_message_info_list& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestReCreateBloodMessageList_Blood_message_info_list& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestReCreateBloodMessageList_Blood_message_info_list* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestReCreateBloodMessageList_Blood_message_info_list* other);

  // implements Message ----------------------------------------------

  RequestReCreateBloodMessageList_Blood_message_info_list* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestReCreateBloodMessageList_Blood_message_info_list& from);
  void MergeFrom(const RequestReCreateBloodMessageList_Blood_message_info_list& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 online_area_id = 1;
  inline bool has_online_area_id() const;
  inline void clear_online_area_id();
  static const int kOnlineAreaIdFieldNumber = 1;
  inline ::google::protobuf::uint32 online_area_id() const;
  inline void set_online_area_id(::google::protobuf::uint32 value);

  // required bytes message_data = 2;
  inline bool has_message_data() const;
  inline void clear_message_data();
  static const int kMessageDataFieldNumber = 2;
  inline const ::std::string& message_data() const;
  inline void set_message_data(const ::std::string& value);
  inline void set_message_data(const char* value);
  inline void set_message_data(const void* value, size_t size);
  inline ::std::string* mutable_message_data();
  inline ::std::string* release_message_data();
  inline void set_allocated_message_data(::std::string* message_data);

  // required uint32 unknown_1 = 3;
  inline bool has_unknown_1() const;
  inline void clear_unknown_1();
  static const int kUnknown1FieldNumber = 3;
  inline ::google::protobuf::uint32 unknown_1() const;
  inline void set_unknown_1(::google::protobuf::uint32 value);

  // required uint32 unknown_2 = 4;
  inline bool has_unknown_2() const;
  inline void clear_unknown_2();
  static const int kUnknown2FieldNumber = 4;
  inline ::google::protobuf::uint32 unknown_2() const;
  inline void set_unknown_2(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestReCreateBloodMessageList.Blood_message_info_list)
 private:
  inline void set_has_online_area_id();
  inline void clear_has_online_area_id();
  inline void set_has_message_data();
  inline void clear_has_message_data();
  inline void set_has_unknown_1();
  inline void clear_has_unknown_1();
  inline void set_has_unknown_2();
  inline void clear_has_unknown_2();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* message_data_;
  ::google::protobuf::uint32 online_area_id_;
  ::google::protobuf::uint32 unknown_1_;
  ::google::protobuf::uint32 unknown_2_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestReCreateBloodMessageList_Blood_message_info_list* default_instance_;
};
// -------------------------------------------------------------------

class RequestReCreateBloodMessageList : public ::google::protobuf::MessageLite {
 public:
  RequestReCreateBloodMessageList();
  virtual ~RequestReCreateBloodMessageList();

  RequestReCreateBloodMessageList(const RequestReCreateBloodMessageList& from);

  inline RequestReCreateBloodMessageList& operator=(const RequestReCreateBloodMessageList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestReCreateBloodMessageList& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestReCreateBloodMessageList* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestReCreateBloodMessageList* other);

  // implements Message ----------------------------------------------

  RequestReCreateBloodMessageList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestReCreateBloodMessageList& from);
  void MergeFrom(const RequestReCreateBloodMessageList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef RequestReCreateBloodMessageList_Blood_message_info_list Blood_message_info_list;

  // accessors -------------------------------------------------------

  // required uint32 character_id = 2;
  inline bool has_character_id() const;
  inline void clear_character_id();
  static const int kCharacterIdFieldNumber = 2;
  inline ::google::protobuf::uint32 character_id() const;
  inline void set_character_id(::google::protobuf::uint32 value);

  // repeated group Blood_message_info_list = 3 {
  inline int blood_message_info_list_size() const;
  inline void clear_blood_message_info_list();
  static const int kBloodMessageInfoListFieldNumber = 3;
  inline const ::DS3_Frpg2RequestMessage::RequestReCreateBloodMessageList_Blood_message_info_list& blood_message_info_list(int index) const;
  inline ::DS3_Frpg2RequestMessage::RequestReCreateBloodMessageList_Blood_message_info_list* mutable_blood_message_info_list(int index);
  inline ::DS3_Frpg2RequestMessage::RequestReCreateBloodMessageList_Blood_message_info_list* add_blood_message_info_list();
  inline const ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::RequestReCreateBloodMessageList_Blood_message_info_list >&
      blood_message_info_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::RequestReCreateBloodMessageList_Blood_message_info_list >*
      mutable_blood_message_info_list();

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestReCreateBloodMessageList)
 private:
  inline void set_has_character_id();
  inline void clear_has_character_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::RequestReCreateBloodMessageList_Blood_message_info_list > blood_message_info_list_;
  ::google::protobuf::uint32 character_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestReCreateBloodMessageList* default_instance_;
};
// -------------------------------------------------------------------

class RequestReCreateBloodMessageListResponse : public ::google::protobuf::MessageLite {
 public:
  RequestReCreateBloodMessageListResponse();
  virtual ~RequestReCreateBloodMessageListResponse();

  RequestReCreateBloodMessageListResponse(const RequestReCreateBloodMessageListResponse& from);

  inline RequestReCreateBloodMessageListResponse& operator=(const RequestReCreateBloodMessageListResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestReCreateBloodMessageListResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestReCreateBloodMessageListResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestReCreateBloodMessageListResponse* other);

  // implements Message ----------------------------------------------

  RequestReCreateBloodMessageListResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestReCreateBloodMessageListResponse& from);
  void MergeFrom(const RequestReCreateBloodMessageListResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 message_ids = 1;
  inline int message_ids_size() const;
  inline void clear_message_ids();
  static const int kMessageIdsFieldNumber = 1;
  inline ::google::protobuf::uint32 message_ids(int index) const;
  inline void set_message_ids(int index, ::google::protobuf::uint32 value);
  inline void add_message_ids(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      message_ids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_message_ids();

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestReCreateBloodMessageListResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > message_ids_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestReCreateBloodMessageListResponse* default_instance_;
};
// -------------------------------------------------------------------

class RequestRemoveBloodMessage : public ::google::protobuf::MessageLite {
 public:
  RequestRemoveBloodMessage();
  virtual ~RequestRemoveBloodMessage();

  RequestRemoveBloodMessage(const RequestRemoveBloodMessage& from);

  inline RequestRemoveBloodMessage& operator=(const RequestRemoveBloodMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestRemoveBloodMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestRemoveBloodMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestRemoveBloodMessage* other);

  // implements Message ----------------------------------------------

  RequestRemoveBloodMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestRemoveBloodMessage& from);
  void MergeFrom(const RequestRemoveBloodMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 online_area_id = 1;
  inline bool has_online_area_id() const;
  inline void clear_online_area_id();
  static const int kOnlineAreaIdFieldNumber = 1;
  inline ::google::protobuf::uint32 online_area_id() const;
  inline void set_online_area_id(::google::protobuf::uint32 value);

  // required uint32 message_id = 2;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 2;
  inline ::google::protobuf::uint32 message_id() const;
  inline void set_message_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestRemoveBloodMessage)
 private:
  inline void set_has_online_area_id();
  inline void clear_has_online_area_id();
  inline void set_has_message_id();
  inline void clear_has_message_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 online_area_id_;
  ::google::protobuf::uint32 message_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestRemoveBloodMessage* default_instance_;
};
// -------------------------------------------------------------------

class RequestRemoveBloodMessageResponse : public ::google::protobuf::MessageLite {
 public:
  RequestRemoveBloodMessageResponse();
  virtual ~RequestRemoveBloodMessageResponse();

  RequestRemoveBloodMessageResponse(const RequestRemoveBloodMessageResponse& from);

  inline RequestRemoveBloodMessageResponse& operator=(const RequestRemoveBloodMessageResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestRemoveBloodMessageResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestRemoveBloodMessageResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestRemoveBloodMessageResponse* other);

  // implements Message ----------------------------------------------

  RequestRemoveBloodMessageResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestRemoveBloodMessageResponse& from);
  void MergeFrom(const RequestRemoveBloodMessageResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestRemoveBloodMessageResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestRemoveBloodMessageResponse* default_instance_;
};
// -------------------------------------------------------------------

class RequestGetBloodMessageList : public ::google::protobuf::MessageLite {
 public:
  RequestGetBloodMessageList();
  virtual ~RequestGetBloodMessageList();

  RequestGetBloodMessageList(const RequestGetBloodMessageList& from);

  inline RequestGetBloodMessageList& operator=(const RequestGetBloodMessageList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestGetBloodMessageList& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestGetBloodMessageList* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestGetBloodMessageList* other);

  // implements Message ----------------------------------------------

  RequestGetBloodMessageList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestGetBloodMessageList& from);
  void MergeFrom(const RequestGetBloodMessageList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 max_messages = 1;
  inline bool has_max_messages() const;
  inline void clear_max_messages();
  static const int kMaxMessagesFieldNumber = 1;
  inline ::google::protobuf::uint32 max_messages() const;
  inline void set_max_messages(::google::protobuf::uint32 value);

  // repeated .DS3_Frpg2RequestMessage.BloodMessageDomainLimitData search_areas = 2;
  inline int search_areas_size() const;
  inline void clear_search_areas();
  static const int kSearchAreasFieldNumber = 2;
  inline const ::DS3_Frpg2RequestMessage::BloodMessageDomainLimitData& search_areas(int index) const;
  inline ::DS3_Frpg2RequestMessage::BloodMessageDomainLimitData* mutable_search_areas(int index);
  inline ::DS3_Frpg2RequestMessage::BloodMessageDomainLimitData* add_search_areas();
  inline const ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::BloodMessageDomainLimitData >&
      search_areas() const;
  inline ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::BloodMessageDomainLimitData >*
      mutable_search_areas();

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestGetBloodMessageList)
 private:
  inline void set_has_max_messages();
  inline void clear_has_max_messages();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::BloodMessageDomainLimitData > search_areas_;
  ::google::protobuf::uint32 max_messages_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestGetBloodMessageList* default_instance_;
};
// -------------------------------------------------------------------

class RequestGetBloodMessageListResponse : public ::google::protobuf::MessageLite {
 public:
  RequestGetBloodMessageListResponse();
  virtual ~RequestGetBloodMessageListResponse();

  RequestGetBloodMessageListResponse(const RequestGetBloodMessageListResponse& from);

  inline RequestGetBloodMessageListResponse& operator=(const RequestGetBloodMessageListResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestGetBloodMessageListResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestGetBloodMessageListResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestGetBloodMessageListResponse* other);

  // implements Message ----------------------------------------------

  RequestGetBloodMessageListResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestGetBloodMessageListResponse& from);
  void MergeFrom(const RequestGetBloodMessageListResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .DS3_Frpg2RequestMessage.BloodMessageData messages = 1;
  inline int messages_size() const;
  inline void clear_messages();
  static const int kMessagesFieldNumber = 1;
  inline const ::DS3_Frpg2RequestMessage::BloodMessageData& messages(int index) const;
  inline ::DS3_Frpg2RequestMessage::BloodMessageData* mutable_messages(int index);
  inline ::DS3_Frpg2RequestMessage::BloodMessageData* add_messages();
  inline const ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::BloodMessageData >&
      messages() const;
  inline ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::BloodMessageData >*
      mutable_messages();

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestGetBloodMessageListResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::BloodMessageData > messages_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestGetBloodMessageListResponse* default_instance_;
};
// -------------------------------------------------------------------

class RequestEvaluateBloodMessage : public ::google::protobuf::MessageLite {
 public:
  RequestEvaluateBloodMessage();
  virtual ~RequestEvaluateBloodMessage();

  RequestEvaluateBloodMessage(const RequestEvaluateBloodMessage& from);

  inline RequestEvaluateBloodMessage& operator=(const RequestEvaluateBloodMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestEvaluateBloodMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestEvaluateBloodMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestEvaluateBloodMessage* other);

  // implements Message ----------------------------------------------

  RequestEvaluateBloodMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestEvaluateBloodMessage& from);
  void MergeFrom(const RequestEvaluateBloodMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 online_area_id = 1;
  inline bool has_online_area_id() const;
  inline void clear_online_area_id();
  static const int kOnlineAreaIdFieldNumber = 1;
  inline ::google::protobuf::uint32 online_area_id() const;
  inline void set_online_area_id(::google::protobuf::uint32 value);

  // required uint32 message_id = 2;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 2;
  inline ::google::protobuf::uint32 message_id() const;
  inline void set_message_id(::google::protobuf::uint32 value);

  // required bool was_poor = 3;
  inline bool has_was_poor() const;
  inline void clear_was_poor();
  static const int kWasPoorFieldNumber = 3;
  inline bool was_poor() const;
  inline void set_was_poor(bool value);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestEvaluateBloodMessage)
 private:
  inline void set_has_online_area_id();
  inline void clear_has_online_area_id();
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_was_poor();
  inline void clear_has_was_poor();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 online_area_id_;
  ::google::protobuf::uint32 message_id_;
  bool was_poor_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestEvaluateBloodMessage* default_instance_;
};
// -------------------------------------------------------------------

class RequestEvaluateBloodMessageResponse : public ::google::protobuf::MessageLite {
 public:
  RequestEvaluateBloodMessageResponse();
  virtual ~RequestEvaluateBloodMessageResponse();

  RequestEvaluateBloodMessageResponse(const RequestEvaluateBloodMessageResponse& from);

  inline RequestEvaluateBloodMessageResponse& operator=(const RequestEvaluateBloodMessageResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestEvaluateBloodMessageResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestEvaluateBloodMessageResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestEvaluateBloodMessageResponse* other);

  // implements Message ----------------------------------------------

  RequestEvaluateBloodMessageResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestEvaluateBloodMessageResponse& from);
  void MergeFrom(const RequestEvaluateBloodMessageResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestEvaluateBloodMessageResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestEvaluateBloodMessageResponse* default_instance_;
};
// -------------------------------------------------------------------

class RequestGetBloodMessageEvaluation : public ::google::protobuf::MessageLite {
 public:
  RequestGetBloodMessageEvaluation();
  virtual ~RequestGetBloodMessageEvaluation();

  RequestGetBloodMessageEvaluation(const RequestGetBloodMessageEvaluation& from);

  inline RequestGetBloodMessageEvaluation& operator=(const RequestGetBloodMessageEvaluation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestGetBloodMessageEvaluation& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestGetBloodMessageEvaluation* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestGetBloodMessageEvaluation* other);

  // implements Message ----------------------------------------------

  RequestGetBloodMessageEvaluation* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestGetBloodMessageEvaluation& from);
  void MergeFrom(const RequestGetBloodMessageEvaluation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .DS3_Frpg2RequestMessage.LocatedBloodMessage messages = 1;
  inline int messages_size() const;
  inline void clear_messages();
  static const int kMessagesFieldNumber = 1;
  inline const ::DS3_Frpg2RequestMessage::LocatedBloodMessage& messages(int index) const;
  inline ::DS3_Frpg2RequestMessage::LocatedBloodMessage* mutable_messages(int index);
  inline ::DS3_Frpg2RequestMessage::LocatedBloodMessage* add_messages();
  inline const ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::LocatedBloodMessage >&
      messages() const;
  inline ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::LocatedBloodMessage >*
      mutable_messages();

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestGetBloodMessageEvaluation)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::LocatedBloodMessage > messages_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestGetBloodMessageEvaluation* default_instance_;
};
// -------------------------------------------------------------------

class BloodMessageEvaluationData : public ::google::protobuf::MessageLite {
 public:
  BloodMessageEvaluationData();
  virtual ~BloodMessageEvaluationData();

  BloodMessageEvaluationData(const BloodMessageEvaluationData& from);

  inline BloodMessageEvaluationData& operator=(const BloodMessageEvaluationData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const BloodMessageEvaluationData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BloodMessageEvaluationData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BloodMessageEvaluationData* other);

  // implements Message ----------------------------------------------

  BloodMessageEvaluationData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BloodMessageEvaluationData& from);
  void MergeFrom(const BloodMessageEvaluationData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::uint32 message_id() const;
  inline void set_message_id(::google::protobuf::uint32 value);

  // required uint32 good = 2;
  inline bool has_good() const;
  inline void clear_good();
  static const int kGoodFieldNumber = 2;
  inline ::google::protobuf::uint32 good() const;
  inline void set_good(::google::protobuf::uint32 value);

  // required uint32 poor = 3;
  inline bool has_poor() const;
  inline void clear_poor();
  static const int kPoorFieldNumber = 3;
  inline ::google::protobuf::uint32 poor() const;
  inline void set_poor(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.BloodMessageEvaluationData)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_good();
  inline void clear_has_good();
  inline void set_has_poor();
  inline void clear_has_poor();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 message_id_;
  ::google::protobuf::uint32 good_;
  ::google::protobuf::uint32 poor_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static BloodMessageEvaluationData* default_instance_;
};
// -------------------------------------------------------------------

class RequestGetBloodMessageEvaluationResponse : public ::google::protobuf::MessageLite {
 public:
  RequestGetBloodMessageEvaluationResponse();
  virtual ~RequestGetBloodMessageEvaluationResponse();

  RequestGetBloodMessageEvaluationResponse(const RequestGetBloodMessageEvaluationResponse& from);

  inline RequestGetBloodMessageEvaluationResponse& operator=(const RequestGetBloodMessageEvaluationResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestGetBloodMessageEvaluationResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestGetBloodMessageEvaluationResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestGetBloodMessageEvaluationResponse* other);

  // implements Message ----------------------------------------------

  RequestGetBloodMessageEvaluationResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestGetBloodMessageEvaluationResponse& from);
  void MergeFrom(const RequestGetBloodMessageEvaluationResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .DS3_Frpg2RequestMessage.BloodMessageEvaluationData messages = 1;
  inline int messages_size() const;
  inline void clear_messages();
  static const int kMessagesFieldNumber = 1;
  inline const ::DS3_Frpg2RequestMessage::BloodMessageEvaluationData& messages(int index) const;
  inline ::DS3_Frpg2RequestMessage::BloodMessageEvaluationData* mutable_messages(int index);
  inline ::DS3_Frpg2RequestMessage::BloodMessageEvaluationData* add_messages();
  inline const ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::BloodMessageEvaluationData >&
      messages() const;
  inline ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::BloodMessageEvaluationData >*
      mutable_messages();

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestGetBloodMessageEvaluationResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::BloodMessageEvaluationData > messages_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestGetBloodMessageEvaluationResponse* default_instance_;
};
// -------------------------------------------------------------------

class PushRequestEvaluateBloodMessage : public ::google::protobuf::MessageLite {
 public:
  PushRequestEvaluateBloodMessage();
  virtual ~PushRequestEvaluateBloodMessage();

  PushRequestEvaluateBloodMessage(const PushRequestEvaluateBloodMessage& from);

  inline PushRequestEvaluateBloodMessage& operator=(const PushRequestEvaluateBloodMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const PushRequestEvaluateBloodMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PushRequestEvaluateBloodMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PushRequestEvaluateBloodMessage* other);

  // implements Message ----------------------------------------------

  PushRequestEvaluateBloodMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PushRequestEvaluateBloodMessage& from);
  void MergeFrom(const PushRequestEvaluateBloodMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
  inline bool has_push_message_id() const;
  inline void clear_push_message_id();
  static const int kPushMessageIdFieldNumber = 1;
  inline ::DS3_Frpg2RequestMessage::PushMessageId push_message_id() const;
  inline void set_push_message_id(::DS3_Frpg2RequestMessage::PushMessageId value);

  // required uint32 player_id = 2;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 2;
  inline ::google::protobuf::uint32 player_id() const;
  inline void set_player_id(::google::protobuf::uint32 value);

  // required uint32 message_id = 3;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 3;
  inline ::google::protobuf::uint32 message_id() const;
  inline void set_message_id(::google::protobuf::uint32 value);

  // required string player_steam_id = 4;
  inline bool has_player_steam_id() const;
  inline void clear_player_steam_id();
  static const int kPlayerSteamIdFieldNumber = 4;
  inline const ::std::string& player_steam_id() const;
  inline void set_player_steam_id(const ::std::string& value);
  inline void set_player_steam_id(const char* value);
  inline void set_player_steam_id(const char* value, size_t size);
  inline ::std::string* mutable_player_steam_id();
  inline ::std::string* release_player_steam_id();
  inline void set_allocated_player_steam_id(::std::string* player_steam_id);

  // required bool was_poor = 5;
  inline bool has_was_poor() const;
  inline void clear_was_poor();
  static const int kWasPoorFieldNumber = 5;
  inline bool was_poor() const;
  inline void set_was_poor(bool value);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.PushRequestEvaluateBloodMessage)
 private:
  inline void set_has_push_message_id();
  inline void clear_has_push_message_id();
  inline void set_has_player_id();
  inline void clear_has_player_id();
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_player_steam_id();
  inline void clear_has_player_steam_id();
  inline void set_has_was_poor();
  inline void clear_has_was_poor();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int push_message_id_;
  ::google::protobuf::uint32 player_id_;
  ::std::string* player_steam_id_;
  ::google::protobuf::uint32 message_id_;
  bool was_poor_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static PushRequestEvaluateBloodMessage* default_instance_;
};
// -------------------------------------------------------------------

class BloodstainInfo : public ::google::protobuf::MessageLite {
 public:
  BloodstainInfo();
  virtual ~BloodstainInfo();

  BloodstainInfo(const BloodstainInfo& from);

  inline BloodstainInfo& operator=(const BloodstainInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const BloodstainInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BloodstainInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BloodstainInfo* other);

  // implements Message ----------------------------------------------

  BloodstainInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BloodstainInfo& from);
  void MergeFrom(const BloodstainInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 online_area_id = 1;
  inline bool has_online_area_id() const;
  inline void clear_online_area_id();
  static const int kOnlineAreaIdFieldNumber = 1;
  inline ::google::protobuf::uint32 online_area_id() const;
  inline void set_online_area_id(::google::protobuf::uint32 value);

  // required uint32 bloodstain_id = 2;
  inline bool has_bloodstain_id() const;
  inline void clear_bloodstain_id();
  static const int kBloodstainIdFieldNumber = 2;
  inline ::google::protobuf::uint32 bloodstain_id() const;
  inline void set_bloodstain_id(::google::protobuf::uint32 value);

  // required bytes data = 3;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 3;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.BloodstainInfo)
 private:
  inline void set_has_online_area_id();
  inline void clear_has_online_area_id();
  inline void set_has_bloodstain_id();
  inline void clear_has_bloodstain_id();
  inline void set_has_data();
  inline void clear_has_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 online_area_id_;
  ::google::protobuf::uint32 bloodstain_id_;
  ::std::string* data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static BloodstainInfo* default_instance_;
};
// -------------------------------------------------------------------

class RequestCreateBloodstain : public ::google::protobuf::MessageLite {
 public:
  RequestCreateBloodstain();
  virtual ~RequestCreateBloodstain();

  RequestCreateBloodstain(const RequestCreateBloodstain& from);

  inline RequestCreateBloodstain& operator=(const RequestCreateBloodstain& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestCreateBloodstain& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestCreateBloodstain* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestCreateBloodstain* other);

  // implements Message ----------------------------------------------

  RequestCreateBloodstain* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestCreateBloodstain& from);
  void MergeFrom(const RequestCreateBloodstain& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 online_area_id = 1;
  inline bool has_online_area_id() const;
  inline void clear_online_area_id();
  static const int kOnlineAreaIdFieldNumber = 1;
  inline ::google::protobuf::uint32 online_area_id() const;
  inline void set_online_area_id(::google::protobuf::uint32 value);

  // required bytes data = 2;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // required bytes ghost_data = 3;
  inline bool has_ghost_data() const;
  inline void clear_ghost_data();
  static const int kGhostDataFieldNumber = 3;
  inline const ::std::string& ghost_data() const;
  inline void set_ghost_data(const ::std::string& value);
  inline void set_ghost_data(const char* value);
  inline void set_ghost_data(const void* value, size_t size);
  inline ::std::string* mutable_ghost_data();
  inline ::std::string* release_ghost_data();
  inline void set_allocated_ghost_data(::std::string* ghost_data);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestCreateBloodstain)
 private:
  inline void set_has_online_area_id();
  inline void clear_has_online_area_id();
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_ghost_data();
  inline void clear_has_ghost_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* data_;
  ::std::string* ghost_data_;
  ::google::protobuf::uint32 online_area_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestCreateBloodstain* default_instance_;
};
// -------------------------------------------------------------------

class RequestGetBloodstainList : public ::google::protobuf::MessageLite {
 public:
  RequestGetBloodstainList();
  virtual ~RequestGetBloodstainList();

  RequestGetBloodstainList(const RequestGetBloodstainList& from);

  inline RequestGetBloodstainList& operator=(const RequestGetBloodstainList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestGetBloodstainList& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestGetBloodstainList* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestGetBloodstainList* other);

  // implements Message ----------------------------------------------

  RequestGetBloodstainList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestGetBloodstainList& from);
  void MergeFrom(const RequestGetBloodstainList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 max_stains = 1;
  inline bool has_max_stains() const;
  inline void clear_max_stains();
  static const int kMaxStainsFieldNumber = 1;
  inline ::google::protobuf::uint32 max_stains() const;
  inline void set_max_stains(::google::protobuf::uint32 value);

  // repeated .DS3_Frpg2RequestMessage.DomainLimitData search_areas = 2;
  inline int search_areas_size() const;
  inline void clear_search_areas();
  static const int kSearchAreasFieldNumber = 2;
  inline const ::DS3_Frpg2RequestMessage::DomainLimitData& search_areas(int index) const;
  inline ::DS3_Frpg2RequestMessage::DomainLimitData* mutable_search_areas(int index);
  inline ::DS3_Frpg2RequestMessage::DomainLimitData* add_search_areas();
  inline const ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::DomainLimitData >&
      search_areas() const;
  inline ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::DomainLimitData >*
      mutable_search_areas();

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestGetBloodstainList)
 private:
  inline void set_has_max_stains();
  inline void clear_has_max_stains();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::DomainLimitData > search_areas_;
  ::google::protobuf::uint32 max_stains_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestGetBloodstainList* default_instance_;
};
// -------------------------------------------------------------------

class RequestGetBloodstainListResponse : public ::google::protobuf::MessageLite {
 public:
  RequestGetBloodstainListResponse();
  virtual ~RequestGetBloodstainListResponse();

  RequestGetBloodstainListResponse(const RequestGetBloodstainListResponse& from);

  inline RequestGetBloodstainListResponse& operator=(const RequestGetBloodstainListResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestGetBloodstainListResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestGetBloodstainListResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestGetBloodstainListResponse* other);

  // implements Message ----------------------------------------------

  RequestGetBloodstainListResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestGetBloodstainListResponse& from);
  void MergeFrom(const RequestGetBloodstainListResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .DS3_Frpg2RequestMessage.BloodstainInfo bloodstains = 1;
  inline int bloodstains_size() const;
  inline void clear_bloodstains();
  static const int kBloodstainsFieldNumber = 1;
  inline const ::DS3_Frpg2RequestMessage::BloodstainInfo& bloodstains(int index) const;
  inline ::DS3_Frpg2RequestMessage::BloodstainInfo* mutable_bloodstains(int index);
  inline ::DS3_Frpg2RequestMessage::BloodstainInfo* add_bloodstains();
  inline const ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::BloodstainInfo >&
      bloodstains() const;
  inline ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::BloodstainInfo >*
      mutable_bloodstains();

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestGetBloodstainListResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::BloodstainInfo > bloodstains_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestGetBloodstainListResponse* default_instance_;
};
// -------------------------------------------------------------------

class RequestGetDeadingGhost : public ::google::protobuf::MessageLite {
 public:
  RequestGetDeadingGhost();
  virtual ~RequestGetDeadingGhost();

  RequestGetDeadingGhost(const RequestGetDeadingGhost& from);

  inline RequestGetDeadingGhost& operator=(const RequestGetDeadingGhost& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestGetDeadingGhost& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestGetDeadingGhost* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestGetDeadingGhost* other);

  // implements Message ----------------------------------------------

  RequestGetDeadingGhost* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestGetDeadingGhost& from);
  void MergeFrom(const RequestGetDeadingGhost& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 online_area_id = 1;
  inline bool has_online_area_id() const;
  inline void clear_online_area_id();
  static const int kOnlineAreaIdFieldNumber = 1;
  inline ::google::protobuf::uint32 online_area_id() const;
  inline void set_online_area_id(::google::protobuf::uint32 value);

  // required uint32 bloodstain_id = 2;
  inline bool has_bloodstain_id() const;
  inline void clear_bloodstain_id();
  static const int kBloodstainIdFieldNumber = 2;
  inline ::google::protobuf::uint32 bloodstain_id() const;
  inline void set_bloodstain_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestGetDeadingGhost)
 private:
  inline void set_has_online_area_id();
  inline void clear_has_online_area_id();
  inline void set_has_bloodstain_id();
  inline void clear_has_bloodstain_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 online_area_id_;
  ::google::protobuf::uint32 bloodstain_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestGetDeadingGhost* default_instance_;
};
// -------------------------------------------------------------------

class RequestGetDeadingGhostResponse : public ::google::protobuf::MessageLite {
 public:
  RequestGetDeadingGhostResponse();
  virtual ~RequestGetDeadingGhostResponse();

  RequestGetDeadingGhostResponse(const RequestGetDeadingGhostResponse& from);

  inline RequestGetDeadingGhostResponse& operator=(const RequestGetDeadingGhostResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestGetDeadingGhostResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestGetDeadingGhostResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestGetDeadingGhostResponse* other);

  // implements Message ----------------------------------------------

  RequestGetDeadingGhostResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestGetDeadingGhostResponse& from);
  void MergeFrom(const RequestGetDeadingGhostResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 online_area_id = 1;
  inline bool has_online_area_id() const;
  inline void clear_online_area_id();
  static const int kOnlineAreaIdFieldNumber = 1;
  inline ::google::protobuf::uint32 online_area_id() const;
  inline void set_online_area_id(::google::protobuf::uint32 value);

  // required uint32 bloodstain_id = 2;
  inline bool has_bloodstain_id() const;
  inline void clear_bloodstain_id();
  static const int kBloodstainIdFieldNumber = 2;
  inline ::google::protobuf::uint32 bloodstain_id() const;
  inline void set_bloodstain_id(::google::protobuf::uint32 value);

  // required bytes data = 3;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 3;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestGetDeadingGhostResponse)
 private:
  inline void set_has_online_area_id();
  inline void clear_has_online_area_id();
  inline void set_has_bloodstain_id();
  inline void clear_has_bloodstain_id();
  inline void set_has_data();
  inline void clear_has_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 online_area_id_;
  ::google::protobuf::uint32 bloodstain_id_;
  ::std::string* data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestGetDeadingGhostResponse* default_instance_;
};
// -------------------------------------------------------------------

class LogCommonInfo_1 : public ::google::protobuf::MessageLite {
 public:
  LogCommonInfo_1();
  virtual ~LogCommonInfo_1();

  LogCommonInfo_1(const LogCommonInfo_1& from);

  inline LogCommonInfo_1& operator=(const LogCommonInfo_1& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const LogCommonInfo_1& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LogCommonInfo_1* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LogCommonInfo_1* other);

  // implements Message ----------------------------------------------

  LogCommonInfo_1* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LogCommonInfo_1& from);
  void MergeFrom(const LogCommonInfo_1& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 unknown_1 = 34;
  inline bool has_unknown_1() const;
  inline void clear_unknown_1();
  static const int kUnknown1FieldNumber = 34;
  inline ::google::protobuf::uint32 unknown_1() const;
  inline void set_unknown_1(::google::protobuf::uint32 value);

  // required uint32 unknown_2 = 37;
  inline bool has_unknown_2() const;
  inline void clear_unknown_2();
  static const int kUnknown2FieldNumber = 37;
  inline ::google::protobuf::uint32 unknown_2() const;
  inline void set_unknown_2(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.LogCommonInfo_1)
 private:
  inline void set_has_unknown_1();
  inline void clear_has_unknown_1();
  inline void set_has_unknown_2();
  inline void clear_has_unknown_2();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 unknown_1_;
  ::google::protobuf::uint32 unknown_2_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static LogCommonInfo_1* default_instance_;
};
// -------------------------------------------------------------------

class LogCommonInfo : public ::google::protobuf::MessageLite {
 public:
  LogCommonInfo();
  virtual ~LogCommonInfo();

  LogCommonInfo(const LogCommonInfo& from);

  inline LogCommonInfo& operator=(const LogCommonInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const LogCommonInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LogCommonInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LogCommonInfo* other);

  // implements Message ----------------------------------------------

  LogCommonInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LogCommonInfo& from);
  void MergeFrom(const LogCommonInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .DS3_Frpg2RequestMessage.LogCommonInfo_1 unknown_1 = 3;
  inline bool has_unknown_1() const;
  inline void clear_unknown_1();
  static const int kUnknown1FieldNumber = 3;
  inline const ::DS3_Frpg2RequestMessage::LogCommonInfo_1& unknown_1() const;
  inline ::DS3_Frpg2RequestMessage::LogCommonInfo_1* mutable_unknown_1();
  inline ::DS3_Frpg2RequestMessage::LogCommonInfo_1* release_unknown_1();
  inline void set_allocated_unknown_1(::DS3_Frpg2RequestMessage::LogCommonInfo_1* unknown_1);

  // required .DS3_Frpg2PlayerData.UnknownStruct1 unknown_2 = 7;
  inline bool has_unknown_2() const;
  inline void clear_unknown_2();
  static const int kUnknown2FieldNumber = 7;
  inline const ::DS3_Frpg2PlayerData::UnknownStruct1& unknown_2() const;
  inline ::DS3_Frpg2PlayerData::UnknownStruct1* mutable_unknown_2();
  inline ::DS3_Frpg2PlayerData::UnknownStruct1* release_unknown_2();
  inline void set_allocated_unknown_2(::DS3_Frpg2PlayerData::UnknownStruct1* unknown_2);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.LogCommonInfo)
 private:
  inline void set_has_unknown_1();
  inline void clear_has_unknown_1();
  inline void set_has_unknown_2();
  inline void clear_has_unknown_2();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::DS3_Frpg2RequestMessage::LogCommonInfo_1* unknown_1_;
  ::DS3_Frpg2PlayerData::UnknownStruct1* unknown_2_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static LogCommonInfo* default_instance_;
};
// -------------------------------------------------------------------

class DomainLimitData : public ::google::protobuf::MessageLite {
 public:
  DomainLimitData();
  virtual ~DomainLimitData();

  DomainLimitData(const DomainLimitData& from);

  inline DomainLimitData& operator=(const DomainLimitData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const DomainLimitData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DomainLimitData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DomainLimitData* other);

  // implements Message ----------------------------------------------

  DomainLimitData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DomainLimitData& from);
  void MergeFrom(const DomainLimitData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 online_area_id = 1;
  inline bool has_online_area_id() const;
  inline void clear_online_area_id();
  static const int kOnlineAreaIdFieldNumber = 1;
  inline ::google::protobuf::uint32 online_area_id() const;
  inline void set_online_area_id(::google::protobuf::uint32 value);

  // required uint32 max_items = 2;
  inline bool has_max_items() const;
  inline void clear_max_items();
  static const int kMaxItemsFieldNumber = 2;
  inline ::google::protobuf::uint32 max_items() const;
  inline void set_max_items(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.DomainLimitData)
 private:
  inline void set_has_online_area_id();
  inline void clear_has_online_area_id();
  inline void set_has_max_items();
  inline void clear_has_max_items();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 online_area_id_;
  ::google::protobuf::uint32 max_items_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static DomainLimitData* default_instance_;
};
// -------------------------------------------------------------------

class KillerInfo : public ::google::protobuf::MessageLite {
 public:
  KillerInfo();
  virtual ~KillerInfo();

  KillerInfo(const KillerInfo& from);

  inline KillerInfo& operator=(const KillerInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const KillerInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const KillerInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(KillerInfo* other);

  // implements Message ----------------------------------------------

  KillerInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const KillerInfo& from);
  void MergeFrom(const KillerInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 killer_player_id = 1;
  inline bool has_killer_player_id() const;
  inline void clear_killer_player_id();
  static const int kKillerPlayerIdFieldNumber = 1;
  inline ::google::protobuf::uint32 killer_player_id() const;
  inline void set_killer_player_id(::google::protobuf::uint32 value);

  // required uint32 unknown_2 = 2;
  inline bool has_unknown_2() const;
  inline void clear_unknown_2();
  static const int kUnknown2FieldNumber = 2;
  inline ::google::protobuf::uint32 unknown_2() const;
  inline void set_unknown_2(::google::protobuf::uint32 value);

  // required uint32 unknown_3 = 3;
  inline bool has_unknown_3() const;
  inline void clear_unknown_3();
  static const int kUnknown3FieldNumber = 3;
  inline ::google::protobuf::uint32 unknown_3() const;
  inline void set_unknown_3(::google::protobuf::uint32 value);

  // required uint32 unknown_4 = 4;
  inline bool has_unknown_4() const;
  inline void clear_unknown_4();
  static const int kUnknown4FieldNumber = 4;
  inline ::google::protobuf::uint32 unknown_4() const;
  inline void set_unknown_4(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.KillerInfo)
 private:
  inline void set_has_killer_player_id();
  inline void clear_has_killer_player_id();
  inline void set_has_unknown_2();
  inline void clear_has_unknown_2();
  inline void set_has_unknown_3();
  inline void clear_has_unknown_3();
  inline void set_has_unknown_4();
  inline void clear_has_unknown_4();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 killer_player_id_;
  ::google::protobuf::uint32 unknown_2_;
  ::google::protobuf::uint32 unknown_3_;
  ::google::protobuf::uint32 unknown_4_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static KillerInfo* default_instance_;
};
// -------------------------------------------------------------------

class KillEnemyInfo : public ::google::protobuf::MessageLite {
 public:
  KillEnemyInfo();
  virtual ~KillEnemyInfo();

  KillEnemyInfo(const KillEnemyInfo& from);

  inline KillEnemyInfo& operator=(const KillEnemyInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const KillEnemyInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const KillEnemyInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(KillEnemyInfo* other);

  // implements Message ----------------------------------------------

  KillEnemyInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const KillEnemyInfo& from);
  void MergeFrom(const KillEnemyInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 enemy_type_id = 1;
  inline bool has_enemy_type_id() const;
  inline void clear_enemy_type_id();
  static const int kEnemyTypeIdFieldNumber = 1;
  inline ::google::protobuf::uint32 enemy_type_id() const;
  inline void set_enemy_type_id(::google::protobuf::uint32 value);

  // required uint32 count = 2;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 2;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.KillEnemyInfo)
 private:
  inline void set_has_enemy_type_id();
  inline void clear_has_enemy_type_id();
  inline void set_has_count();
  inline void clear_has_count();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 enemy_type_id_;
  ::google::protobuf::uint32 count_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static KillEnemyInfo* default_instance_;
};
// -------------------------------------------------------------------

class PartyMemberInfo : public ::google::protobuf::MessageLite {
 public:
  PartyMemberInfo();
  virtual ~PartyMemberInfo();

  PartyMemberInfo(const PartyMemberInfo& from);

  inline PartyMemberInfo& operator=(const PartyMemberInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const PartyMemberInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PartyMemberInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PartyMemberInfo* other);

  // implements Message ----------------------------------------------

  PartyMemberInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PartyMemberInfo& from);
  void MergeFrom(const PartyMemberInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 player_id = 1;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 1;
  inline ::google::protobuf::uint32 player_id() const;
  inline void set_player_id(::google::protobuf::uint32 value);

  // required uint32 char_id = 2;
  inline bool has_char_id() const;
  inline void clear_char_id();
  static const int kCharIdFieldNumber = 2;
  inline ::google::protobuf::uint32 char_id() const;
  inline void set_char_id(::google::protobuf::uint32 value);

  // required uint32 unknown_2 = 3;
  inline bool has_unknown_2() const;
  inline void clear_unknown_2();
  static const int kUnknown2FieldNumber = 3;
  inline ::google::protobuf::uint32 unknown_2() const;
  inline void set_unknown_2(::google::protobuf::uint32 value);

  // required uint32 unknown_4 = 4;
  inline bool has_unknown_4() const;
  inline void clear_unknown_4();
  static const int kUnknown4FieldNumber = 4;
  inline ::google::protobuf::uint32 unknown_4() const;
  inline void set_unknown_4(::google::protobuf::uint32 value);

  // required uint32 unknown_5 = 5;
  inline bool has_unknown_5() const;
  inline void clear_unknown_5();
  static const int kUnknown5FieldNumber = 5;
  inline ::google::protobuf::uint32 unknown_5() const;
  inline void set_unknown_5(::google::protobuf::uint32 value);

  // required uint32 unknown_6 = 6;
  inline bool has_unknown_6() const;
  inline void clear_unknown_6();
  static const int kUnknown6FieldNumber = 6;
  inline ::google::protobuf::uint32 unknown_6() const;
  inline void set_unknown_6(::google::protobuf::uint32 value);

  // optional uint32 unknown_7 = 7;
  inline bool has_unknown_7() const;
  inline void clear_unknown_7();
  static const int kUnknown7FieldNumber = 7;
  inline ::google::protobuf::uint32 unknown_7() const;
  inline void set_unknown_7(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.PartyMemberInfo)
 private:
  inline void set_has_player_id();
  inline void clear_has_player_id();
  inline void set_has_char_id();
  inline void clear_has_char_id();
  inline void set_has_unknown_2();
  inline void clear_has_unknown_2();
  inline void set_has_unknown_4();
  inline void clear_has_unknown_4();
  inline void set_has_unknown_5();
  inline void clear_has_unknown_5();
  inline void set_has_unknown_6();
  inline void clear_has_unknown_6();
  inline void set_has_unknown_7();
  inline void clear_has_unknown_7();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 player_id_;
  ::google::protobuf::uint32 char_id_;
  ::google::protobuf::uint32 unknown_2_;
  ::google::protobuf::uint32 unknown_4_;
  ::google::protobuf::uint32 unknown_5_;
  ::google::protobuf::uint32 unknown_6_;
  ::google::protobuf::uint32 unknown_7_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static PartyMemberInfo* default_instance_;
};
// -------------------------------------------------------------------

class RequestNotifyProtoBufLog : public ::google::protobuf::MessageLite {
 public:
  RequestNotifyProtoBufLog();
  virtual ~RequestNotifyProtoBufLog();

  RequestNotifyProtoBufLog(const RequestNotifyProtoBufLog& from);

  inline RequestNotifyProtoBufLog& operator=(const RequestNotifyProtoBufLog& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestNotifyProtoBufLog& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestNotifyProtoBufLog* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestNotifyProtoBufLog* other);

  // implements Message ----------------------------------------------

  RequestNotifyProtoBufLog* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestNotifyProtoBufLog& from);
  void MergeFrom(const RequestNotifyProtoBufLog& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .DS3_Frpg2RequestMessage.LogType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::DS3_Frpg2RequestMessage::LogType type() const;
  inline void set_type(::DS3_Frpg2RequestMessage::LogType value);

  // required bytes common = 2;
  inline bool has_common() const;
  inline void clear_common();
  static const int kCommonFieldNumber = 2;
  inline const ::std::string& common() const;
  inline void set_common(const ::std::string& value);
  inline void set_common(const char* value);
  inline void set_common(const void* value, size_t size);
  inline ::std::string* mutable_common();
  inline ::std::string* release_common();
  inline void set_allocated_common(::std::string* common);

  // required bytes data = 3;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 3;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestNotifyProtoBufLog)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_common();
  inline void clear_has_common();
  inline void set_has_data();
  inline void clear_has_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* common_;
  ::std::string* data_;
  int type_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestNotifyProtoBufLog* default_instance_;
};
// -------------------------------------------------------------------

class RequestNotifyDie : public ::google::protobuf::MessageLite {
 public:
  RequestNotifyDie();
  virtual ~RequestNotifyDie();

  RequestNotifyDie(const RequestNotifyDie& from);

  inline RequestNotifyDie& operator=(const RequestNotifyDie& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestNotifyDie& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestNotifyDie* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestNotifyDie* other);

  // implements Message ----------------------------------------------

  RequestNotifyDie* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestNotifyDie& from);
  void MergeFrom(const RequestNotifyDie& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string unknown_1 = 1;
  inline bool has_unknown_1() const;
  inline void clear_unknown_1();
  static const int kUnknown1FieldNumber = 1;
  inline const ::std::string& unknown_1() const;
  inline void set_unknown_1(const ::std::string& value);
  inline void set_unknown_1(const char* value);
  inline void set_unknown_1(const char* value, size_t size);
  inline ::std::string* mutable_unknown_1();
  inline ::std::string* release_unknown_1();
  inline void set_allocated_unknown_1(::std::string* unknown_1);

  // required uint32 map_id = 2;
  inline bool has_map_id() const;
  inline void clear_map_id();
  static const int kMapIdFieldNumber = 2;
  inline ::google::protobuf::uint32 map_id() const;
  inline void set_map_id(::google::protobuf::uint32 value);

  // required .DS3_Frpg2PlayerData.Vector location = 3;
  inline bool has_location() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 3;
  inline const ::DS3_Frpg2PlayerData::Vector& location() const;
  inline ::DS3_Frpg2PlayerData::Vector* mutable_location();
  inline ::DS3_Frpg2PlayerData::Vector* release_location();
  inline void set_allocated_location(::DS3_Frpg2PlayerData::Vector* location);

  // required .DS3_Frpg2RequestMessage.CauseOfDeath cause_of_death = 4;
  inline bool has_cause_of_death() const;
  inline void clear_cause_of_death();
  static const int kCauseOfDeathFieldNumber = 4;
  inline ::DS3_Frpg2RequestMessage::CauseOfDeath cause_of_death() const;
  inline void set_cause_of_death(::DS3_Frpg2RequestMessage::CauseOfDeath value);

  // required uint32 souls_dropped = 5;
  inline bool has_souls_dropped() const;
  inline void clear_souls_dropped();
  static const int kSoulsDroppedFieldNumber = 5;
  inline ::google::protobuf::uint32 souls_dropped() const;
  inline void set_souls_dropped(::google::protobuf::uint32 value);

  // required uint32 souls_lost = 6;
  inline bool has_souls_lost() const;
  inline void clear_souls_lost();
  static const int kSoulsLostFieldNumber = 6;
  inline ::google::protobuf::uint32 souls_lost() const;
  inline void set_souls_lost(::google::protobuf::uint32 value);

  // required uint32 actor_id = 7;
  inline bool has_actor_id() const;
  inline void clear_actor_id();
  static const int kActorIdFieldNumber = 7;
  inline ::google::protobuf::uint32 actor_id() const;
  inline void set_actor_id(::google::protobuf::uint32 value);

  // required .DS3_Frpg2RequestMessage.KillerInfo killer_info = 8;
  inline bool has_killer_info() const;
  inline void clear_killer_info();
  static const int kKillerInfoFieldNumber = 8;
  inline const ::DS3_Frpg2RequestMessage::KillerInfo& killer_info() const;
  inline ::DS3_Frpg2RequestMessage::KillerInfo* mutable_killer_info();
  inline ::DS3_Frpg2RequestMessage::KillerInfo* release_killer_info();
  inline void set_allocated_killer_info(::DS3_Frpg2RequestMessage::KillerInfo* killer_info);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestNotifyDie)
 private:
  inline void set_has_unknown_1();
  inline void clear_has_unknown_1();
  inline void set_has_map_id();
  inline void clear_has_map_id();
  inline void set_has_location();
  inline void clear_has_location();
  inline void set_has_cause_of_death();
  inline void clear_has_cause_of_death();
  inline void set_has_souls_dropped();
  inline void clear_has_souls_dropped();
  inline void set_has_souls_lost();
  inline void clear_has_souls_lost();
  inline void set_has_actor_id();
  inline void clear_has_actor_id();
  inline void set_has_killer_info();
  inline void clear_has_killer_info();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* unknown_1_;
  ::DS3_Frpg2PlayerData::Vector* location_;
  ::google::protobuf::uint32 map_id_;
  int cause_of_death_;
  ::google::protobuf::uint32 souls_dropped_;
  ::google::protobuf::uint32 souls_lost_;
  ::DS3_Frpg2RequestMessage::KillerInfo* killer_info_;
  ::google::protobuf::uint32 actor_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestNotifyDie* default_instance_;
};
// -------------------------------------------------------------------

class RequestNotifyKillEnemy : public ::google::protobuf::MessageLite {
 public:
  RequestNotifyKillEnemy();
  virtual ~RequestNotifyKillEnemy();

  RequestNotifyKillEnemy(const RequestNotifyKillEnemy& from);

  inline RequestNotifyKillEnemy& operator=(const RequestNotifyKillEnemy& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestNotifyKillEnemy& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestNotifyKillEnemy* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestNotifyKillEnemy* other);

  // implements Message ----------------------------------------------

  RequestNotifyKillEnemy* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestNotifyKillEnemy& from);
  void MergeFrom(const RequestNotifyKillEnemy& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .DS3_Frpg2RequestMessage.LogCommonInfo info = 1;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 1;
  inline const ::DS3_Frpg2RequestMessage::LogCommonInfo& info() const;
  inline ::DS3_Frpg2RequestMessage::LogCommonInfo* mutable_info();
  inline ::DS3_Frpg2RequestMessage::LogCommonInfo* release_info();
  inline void set_allocated_info(::DS3_Frpg2RequestMessage::LogCommonInfo* info);

  // repeated .DS3_Frpg2RequestMessage.KillEnemyInfo enemys = 2;
  inline int enemys_size() const;
  inline void clear_enemys();
  static const int kEnemysFieldNumber = 2;
  inline const ::DS3_Frpg2RequestMessage::KillEnemyInfo& enemys(int index) const;
  inline ::DS3_Frpg2RequestMessage::KillEnemyInfo* mutable_enemys(int index);
  inline ::DS3_Frpg2RequestMessage::KillEnemyInfo* add_enemys();
  inline const ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::KillEnemyInfo >&
      enemys() const;
  inline ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::KillEnemyInfo >*
      mutable_enemys();

  // required uint32 map_id = 3;
  inline bool has_map_id() const;
  inline void clear_map_id();
  static const int kMapIdFieldNumber = 3;
  inline ::google::protobuf::uint32 map_id() const;
  inline void set_map_id(::google::protobuf::uint32 value);

  // required .DS3_Frpg2PlayerData.Vector location = 4;
  inline bool has_location() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 4;
  inline const ::DS3_Frpg2PlayerData::Vector& location() const;
  inline ::DS3_Frpg2PlayerData::Vector* mutable_location();
  inline ::DS3_Frpg2PlayerData::Vector* release_location();
  inline void set_allocated_location(::DS3_Frpg2PlayerData::Vector* location);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestNotifyKillEnemy)
 private:
  inline void set_has_info();
  inline void clear_has_info();
  inline void set_has_map_id();
  inline void clear_has_map_id();
  inline void set_has_location();
  inline void clear_has_location();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::DS3_Frpg2RequestMessage::LogCommonInfo* info_;
  ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::KillEnemyInfo > enemys_;
  ::DS3_Frpg2PlayerData::Vector* location_;
  ::google::protobuf::uint32 map_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestNotifyKillEnemy* default_instance_;
};
// -------------------------------------------------------------------

class RequestNotifyKillBoss : public ::google::protobuf::MessageLite {
 public:
  RequestNotifyKillBoss();
  virtual ~RequestNotifyKillBoss();

  RequestNotifyKillBoss(const RequestNotifyKillBoss& from);

  inline RequestNotifyKillBoss& operator=(const RequestNotifyKillBoss& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestNotifyKillBoss& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestNotifyKillBoss* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestNotifyKillBoss* other);

  // implements Message ----------------------------------------------

  RequestNotifyKillBoss* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestNotifyKillBoss& from);
  void MergeFrom(const RequestNotifyKillBoss& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string unknown_1 = 1;
  inline bool has_unknown_1() const;
  inline void clear_unknown_1();
  static const int kUnknown1FieldNumber = 1;
  inline const ::std::string& unknown_1() const;
  inline void set_unknown_1(const ::std::string& value);
  inline void set_unknown_1(const char* value);
  inline void set_unknown_1(const char* value, size_t size);
  inline ::std::string* mutable_unknown_1();
  inline ::std::string* release_unknown_1();
  inline void set_allocated_unknown_1(::std::string* unknown_1);

  // required uint32 boss_id = 2;
  inline bool has_boss_id() const;
  inline void clear_boss_id();
  static const int kBossIdFieldNumber = 2;
  inline ::google::protobuf::uint32 boss_id() const;
  inline void set_boss_id(::google::protobuf::uint32 value);

  // required uint32 in_coop = 3;
  inline bool has_in_coop() const;
  inline void clear_in_coop();
  static const int kInCoopFieldNumber = 3;
  inline ::google::protobuf::uint32 in_coop() const;
  inline void set_in_coop(::google::protobuf::uint32 value);

  // required uint32 boss_died = 4;
  inline bool has_boss_died() const;
  inline void clear_boss_died();
  static const int kBossDiedFieldNumber = 4;
  inline ::google::protobuf::uint32 boss_died() const;
  inline void set_boss_died(::google::protobuf::uint32 value);

  // required uint32 cooperator_count = 5;
  inline bool has_cooperator_count() const;
  inline void clear_cooperator_count();
  static const int kCooperatorCountFieldNumber = 5;
  inline ::google::protobuf::uint32 cooperator_count() const;
  inline void set_cooperator_count(::google::protobuf::uint32 value);

  // required uint32 fight_duration = 6;
  inline bool has_fight_duration() const;
  inline void clear_fight_duration();
  static const int kFightDurationFieldNumber = 6;
  inline ::google::protobuf::uint32 fight_duration() const;
  inline void set_fight_duration(::google::protobuf::uint32 value);

  // required uint32 map_id = 8;
  inline bool has_map_id() const;
  inline void clear_map_id();
  static const int kMapIdFieldNumber = 8;
  inline ::google::protobuf::uint32 map_id() const;
  inline void set_map_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestNotifyKillBoss)
 private:
  inline void set_has_unknown_1();
  inline void clear_has_unknown_1();
  inline void set_has_boss_id();
  inline void clear_has_boss_id();
  inline void set_has_in_coop();
  inline void clear_has_in_coop();
  inline void set_has_boss_died();
  inline void clear_has_boss_died();
  inline void set_has_cooperator_count();
  inline void clear_has_cooperator_count();
  inline void set_has_fight_duration();
  inline void clear_has_fight_duration();
  inline void set_has_map_id();
  inline void clear_has_map_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* unknown_1_;
  ::google::protobuf::uint32 boss_id_;
  ::google::protobuf::uint32 in_coop_;
  ::google::protobuf::uint32 boss_died_;
  ::google::protobuf::uint32 cooperator_count_;
  ::google::protobuf::uint32 fight_duration_;
  ::google::protobuf::uint32 map_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestNotifyKillBoss* default_instance_;
};
// -------------------------------------------------------------------

class RequestNotifyJoinMultiplay : public ::google::protobuf::MessageLite {
 public:
  RequestNotifyJoinMultiplay();
  virtual ~RequestNotifyJoinMultiplay();

  RequestNotifyJoinMultiplay(const RequestNotifyJoinMultiplay& from);

  inline RequestNotifyJoinMultiplay& operator=(const RequestNotifyJoinMultiplay& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestNotifyJoinMultiplay& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestNotifyJoinMultiplay* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestNotifyJoinMultiplay* other);

  // implements Message ----------------------------------------------

  RequestNotifyJoinMultiplay* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestNotifyJoinMultiplay& from);
  void MergeFrom(const RequestNotifyJoinMultiplay& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .DS3_Frpg2PlayerData.AllStatus all_status = 1;
  inline bool has_all_status() const;
  inline void clear_all_status();
  static const int kAllStatusFieldNumber = 1;
  inline const ::DS3_Frpg2PlayerData::AllStatus& all_status() const;
  inline ::DS3_Frpg2PlayerData::AllStatus* mutable_all_status();
  inline ::DS3_Frpg2PlayerData::AllStatus* release_all_status();
  inline void set_allocated_all_status(::DS3_Frpg2PlayerData::AllStatus* all_status);

  // required uint32 map_id = 2;
  inline bool has_map_id() const;
  inline void clear_map_id();
  static const int kMapIdFieldNumber = 2;
  inline ::google::protobuf::uint32 map_id() const;
  inline void set_map_id(::google::protobuf::uint32 value);

  // required uint32 online_area_id = 3;
  inline bool has_online_area_id() const;
  inline void clear_online_area_id();
  static const int kOnlineAreaIdFieldNumber = 3;
  inline ::google::protobuf::uint32 online_area_id() const;
  inline void set_online_area_id(::google::protobuf::uint32 value);

  // required uint32 unknown_2 = 4;
  inline bool has_unknown_2() const;
  inline void clear_unknown_2();
  static const int kUnknown2FieldNumber = 4;
  inline ::google::protobuf::uint32 unknown_2() const;
  inline void set_unknown_2(::google::protobuf::uint32 value);

  // required uint32 unknown_3 = 5;
  inline bool has_unknown_3() const;
  inline void clear_unknown_3();
  static const int kUnknown3FieldNumber = 5;
  inline ::google::protobuf::uint32 unknown_3() const;
  inline void set_unknown_3(::google::protobuf::uint32 value);

  // repeated .DS3_Frpg2RequestMessage.PartyMemberInfo party_member_info = 6;
  inline int party_member_info_size() const;
  inline void clear_party_member_info();
  static const int kPartyMemberInfoFieldNumber = 6;
  inline const ::DS3_Frpg2RequestMessage::PartyMemberInfo& party_member_info(int index) const;
  inline ::DS3_Frpg2RequestMessage::PartyMemberInfo* mutable_party_member_info(int index);
  inline ::DS3_Frpg2RequestMessage::PartyMemberInfo* add_party_member_info();
  inline const ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::PartyMemberInfo >&
      party_member_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::PartyMemberInfo >*
      mutable_party_member_info();

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestNotifyJoinMultiplay)
 private:
  inline void set_has_all_status();
  inline void clear_has_all_status();
  inline void set_has_map_id();
  inline void clear_has_map_id();
  inline void set_has_online_area_id();
  inline void clear_has_online_area_id();
  inline void set_has_unknown_2();
  inline void clear_has_unknown_2();
  inline void set_has_unknown_3();
  inline void clear_has_unknown_3();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::DS3_Frpg2PlayerData::AllStatus* all_status_;
  ::google::protobuf::uint32 map_id_;
  ::google::protobuf::uint32 online_area_id_;
  ::google::protobuf::uint32 unknown_2_;
  ::google::protobuf::uint32 unknown_3_;
  ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::PartyMemberInfo > party_member_info_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestNotifyJoinMultiplay* default_instance_;
};
// -------------------------------------------------------------------

class RequestNotifyLeaveMultiplay : public ::google::protobuf::MessageLite {
 public:
  RequestNotifyLeaveMultiplay();
  virtual ~RequestNotifyLeaveMultiplay();

  RequestNotifyLeaveMultiplay(const RequestNotifyLeaveMultiplay& from);

  inline RequestNotifyLeaveMultiplay& operator=(const RequestNotifyLeaveMultiplay& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestNotifyLeaveMultiplay& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestNotifyLeaveMultiplay* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestNotifyLeaveMultiplay* other);

  // implements Message ----------------------------------------------

  RequestNotifyLeaveMultiplay* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestNotifyLeaveMultiplay& from);
  void MergeFrom(const RequestNotifyLeaveMultiplay& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .DS3_Frpg2PlayerData.AllStatus all_status = 1;
  inline bool has_all_status() const;
  inline void clear_all_status();
  static const int kAllStatusFieldNumber = 1;
  inline const ::DS3_Frpg2PlayerData::AllStatus& all_status() const;
  inline ::DS3_Frpg2PlayerData::AllStatus* mutable_all_status();
  inline ::DS3_Frpg2PlayerData::AllStatus* release_all_status();
  inline void set_allocated_all_status(::DS3_Frpg2PlayerData::AllStatus* all_status);

  // required uint32 map_id = 2;
  inline bool has_map_id() const;
  inline void clear_map_id();
  static const int kMapIdFieldNumber = 2;
  inline ::google::protobuf::uint32 map_id() const;
  inline void set_map_id(::google::protobuf::uint32 value);

  // required uint32 online_area_id = 3;
  inline bool has_online_area_id() const;
  inline void clear_online_area_id();
  static const int kOnlineAreaIdFieldNumber = 3;
  inline ::google::protobuf::uint32 online_area_id() const;
  inline void set_online_area_id(::google::protobuf::uint32 value);

  // required uint32 unknown_2 = 4;
  inline bool has_unknown_2() const;
  inline void clear_unknown_2();
  static const int kUnknown2FieldNumber = 4;
  inline ::google::protobuf::uint32 unknown_2() const;
  inline void set_unknown_2(::google::protobuf::uint32 value);

  // required uint32 unknown_3 = 5;
  inline bool has_unknown_3() const;
  inline void clear_unknown_3();
  static const int kUnknown3FieldNumber = 5;
  inline ::google::protobuf::uint32 unknown_3() const;
  inline void set_unknown_3(::google::protobuf::uint32 value);

  // required uint32 unknown_4 = 6;
  inline bool has_unknown_4() const;
  inline void clear_unknown_4();
  static const int kUnknown4FieldNumber = 6;
  inline ::google::protobuf::uint32 unknown_4() const;
  inline void set_unknown_4(::google::protobuf::uint32 value);

  // repeated .DS3_Frpg2RequestMessage.PartyMemberInfo party_member_info = 7;
  inline int party_member_info_size() const;
  inline void clear_party_member_info();
  static const int kPartyMemberInfoFieldNumber = 7;
  inline const ::DS3_Frpg2RequestMessage::PartyMemberInfo& party_member_info(int index) const;
  inline ::DS3_Frpg2RequestMessage::PartyMemberInfo* mutable_party_member_info(int index);
  inline ::DS3_Frpg2RequestMessage::PartyMemberInfo* add_party_member_info();
  inline const ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::PartyMemberInfo >&
      party_member_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::PartyMemberInfo >*
      mutable_party_member_info();

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestNotifyLeaveMultiplay)
 private:
  inline void set_has_all_status();
  inline void clear_has_all_status();
  inline void set_has_map_id();
  inline void clear_has_map_id();
  inline void set_has_online_area_id();
  inline void clear_has_online_area_id();
  inline void set_has_unknown_2();
  inline void clear_has_unknown_2();
  inline void set_has_unknown_3();
  inline void clear_has_unknown_3();
  inline void set_has_unknown_4();
  inline void clear_has_unknown_4();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::DS3_Frpg2PlayerData::AllStatus* all_status_;
  ::google::protobuf::uint32 map_id_;
  ::google::protobuf::uint32 online_area_id_;
  ::google::protobuf::uint32 unknown_2_;
  ::google::protobuf::uint32 unknown_3_;
  ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::PartyMemberInfo > party_member_info_;
  ::google::protobuf::uint32 unknown_4_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestNotifyLeaveMultiplay* default_instance_;
};
// -------------------------------------------------------------------

class RequestNotifyCreateSignResult : public ::google::protobuf::MessageLite {
 public:
  RequestNotifyCreateSignResult();
  virtual ~RequestNotifyCreateSignResult();

  RequestNotifyCreateSignResult(const RequestNotifyCreateSignResult& from);

  inline RequestNotifyCreateSignResult& operator=(const RequestNotifyCreateSignResult& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestNotifyCreateSignResult& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestNotifyCreateSignResult* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestNotifyCreateSignResult* other);

  // implements Message ----------------------------------------------

  RequestNotifyCreateSignResult* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestNotifyCreateSignResult& from);
  void MergeFrom(const RequestNotifyCreateSignResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .DS3_Frpg2PlayerData.AllStatus all_status = 1;
  inline bool has_all_status() const;
  inline void clear_all_status();
  static const int kAllStatusFieldNumber = 1;
  inline const ::DS3_Frpg2PlayerData::AllStatus& all_status() const;
  inline ::DS3_Frpg2PlayerData::AllStatus* mutable_all_status();
  inline ::DS3_Frpg2PlayerData::AllStatus* release_all_status();
  inline void set_allocated_all_status(::DS3_Frpg2PlayerData::AllStatus* all_status);

  // required uint32 map_id = 2;
  inline bool has_map_id() const;
  inline void clear_map_id();
  static const int kMapIdFieldNumber = 2;
  inline ::google::protobuf::uint32 map_id() const;
  inline void set_map_id(::google::protobuf::uint32 value);

  // required uint32 online_area_id = 3;
  inline bool has_online_area_id() const;
  inline void clear_online_area_id();
  static const int kOnlineAreaIdFieldNumber = 3;
  inline ::google::protobuf::uint32 online_area_id() const;
  inline void set_online_area_id(::google::protobuf::uint32 value);

  // required .DS3_Frpg2PlayerData.Vector location = 4;
  inline bool has_location() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 4;
  inline const ::DS3_Frpg2PlayerData::Vector& location() const;
  inline ::DS3_Frpg2PlayerData::Vector* mutable_location();
  inline ::DS3_Frpg2PlayerData::Vector* release_location();
  inline void set_allocated_location(::DS3_Frpg2PlayerData::Vector* location);

  // required uint32 sign_unique_number = 5;
  inline bool has_sign_unique_number() const;
  inline void clear_sign_unique_number();
  static const int kSignUniqueNumberFieldNumber = 5;
  inline ::google::protobuf::uint32 sign_unique_number() const;
  inline void set_sign_unique_number(::google::protobuf::uint32 value);

  // required uint32 unknown_2 = 6;
  inline bool has_unknown_2() const;
  inline void clear_unknown_2();
  static const int kUnknown2FieldNumber = 6;
  inline ::google::protobuf::uint32 unknown_2() const;
  inline void set_unknown_2(::google::protobuf::uint32 value);

  // required uint32 unknown_3 = 7;
  inline bool has_unknown_3() const;
  inline void clear_unknown_3();
  static const int kUnknown3FieldNumber = 7;
  inline ::google::protobuf::uint32 unknown_3() const;
  inline void set_unknown_3(::google::protobuf::uint32 value);

  // required uint32 unknown_4 = 8;
  inline bool has_unknown_4() const;
  inline void clear_unknown_4();
  static const int kUnknown4FieldNumber = 8;
  inline ::google::protobuf::uint32 unknown_4() const;
  inline void set_unknown_4(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestNotifyCreateSignResult)
 private:
  inline void set_has_all_status();
  inline void clear_has_all_status();
  inline void set_has_map_id();
  inline void clear_has_map_id();
  inline void set_has_online_area_id();
  inline void clear_has_online_area_id();
  inline void set_has_location();
  inline void clear_has_location();
  inline void set_has_sign_unique_number();
  inline void clear_has_sign_unique_number();
  inline void set_has_unknown_2();
  inline void clear_has_unknown_2();
  inline void set_has_unknown_3();
  inline void clear_has_unknown_3();
  inline void set_has_unknown_4();
  inline void clear_has_unknown_4();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::DS3_Frpg2PlayerData::AllStatus* all_status_;
  ::google::protobuf::uint32 map_id_;
  ::google::protobuf::uint32 online_area_id_;
  ::DS3_Frpg2PlayerData::Vector* location_;
  ::google::protobuf::uint32 sign_unique_number_;
  ::google::protobuf::uint32 unknown_2_;
  ::google::protobuf::uint32 unknown_3_;
  ::google::protobuf::uint32 unknown_4_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestNotifyCreateSignResult* default_instance_;
};
// -------------------------------------------------------------------

class RequestNotifySummonSignResult : public ::google::protobuf::MessageLite {
 public:
  RequestNotifySummonSignResult();
  virtual ~RequestNotifySummonSignResult();

  RequestNotifySummonSignResult(const RequestNotifySummonSignResult& from);

  inline RequestNotifySummonSignResult& operator=(const RequestNotifySummonSignResult& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestNotifySummonSignResult& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestNotifySummonSignResult* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestNotifySummonSignResult* other);

  // implements Message ----------------------------------------------

  RequestNotifySummonSignResult* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestNotifySummonSignResult& from);
  void MergeFrom(const RequestNotifySummonSignResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string unknown_1 = 1;
  inline bool has_unknown_1() const;
  inline void clear_unknown_1();
  static const int kUnknown1FieldNumber = 1;
  inline const ::std::string& unknown_1() const;
  inline void set_unknown_1(const ::std::string& value);
  inline void set_unknown_1(const char* value);
  inline void set_unknown_1(const char* value, size_t size);
  inline ::std::string* mutable_unknown_1();
  inline ::std::string* release_unknown_1();
  inline void set_allocated_unknown_1(::std::string* unknown_1);

  // required uint32 map_id = 2;
  inline bool has_map_id() const;
  inline void clear_map_id();
  static const int kMapIdFieldNumber = 2;
  inline ::google::protobuf::uint32 map_id() const;
  inline void set_map_id(::google::protobuf::uint32 value);

  // required uint32 online_area_id = 3;
  inline bool has_online_area_id() const;
  inline void clear_online_area_id();
  static const int kOnlineAreaIdFieldNumber = 3;
  inline ::google::protobuf::uint32 online_area_id() const;
  inline void set_online_area_id(::google::protobuf::uint32 value);

  // required .DS3_Frpg2PlayerData.Vector location = 4;
  inline bool has_location() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 4;
  inline const ::DS3_Frpg2PlayerData::Vector& location() const;
  inline ::DS3_Frpg2PlayerData::Vector* mutable_location();
  inline ::DS3_Frpg2PlayerData::Vector* release_location();
  inline void set_allocated_location(::DS3_Frpg2PlayerData::Vector* location);

  // required .DS3_Frpg2RequestMessage.SignInfo sign_info = 5;
  inline bool has_sign_info() const;
  inline void clear_sign_info();
  static const int kSignInfoFieldNumber = 5;
  inline const ::DS3_Frpg2RequestMessage::SignInfo& sign_info() const;
  inline ::DS3_Frpg2RequestMessage::SignInfo* mutable_sign_info();
  inline ::DS3_Frpg2RequestMessage::SignInfo* release_sign_info();
  inline void set_allocated_sign_info(::DS3_Frpg2RequestMessage::SignInfo* sign_info);

  // required uint32 unknown_6 = 6;
  inline bool has_unknown_6() const;
  inline void clear_unknown_6();
  static const int kUnknown6FieldNumber = 6;
  inline ::google::protobuf::uint32 unknown_6() const;
  inline void set_unknown_6(::google::protobuf::uint32 value);

  // required uint32 unknown_7 = 7;
  inline bool has_unknown_7() const;
  inline void clear_unknown_7();
  static const int kUnknown7FieldNumber = 7;
  inline ::google::protobuf::uint32 unknown_7() const;
  inline void set_unknown_7(::google::protobuf::uint32 value);

  // required uint32 unknown_8 = 8;
  inline bool has_unknown_8() const;
  inline void clear_unknown_8();
  static const int kUnknown8FieldNumber = 8;
  inline ::google::protobuf::uint32 unknown_8() const;
  inline void set_unknown_8(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestNotifySummonSignResult)
 private:
  inline void set_has_unknown_1();
  inline void clear_has_unknown_1();
  inline void set_has_map_id();
  inline void clear_has_map_id();
  inline void set_has_online_area_id();
  inline void clear_has_online_area_id();
  inline void set_has_location();
  inline void clear_has_location();
  inline void set_has_sign_info();
  inline void clear_has_sign_info();
  inline void set_has_unknown_6();
  inline void clear_has_unknown_6();
  inline void set_has_unknown_7();
  inline void clear_has_unknown_7();
  inline void set_has_unknown_8();
  inline void clear_has_unknown_8();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* unknown_1_;
  ::google::protobuf::uint32 map_id_;
  ::google::protobuf::uint32 online_area_id_;
  ::DS3_Frpg2PlayerData::Vector* location_;
  ::DS3_Frpg2RequestMessage::SignInfo* sign_info_;
  ::google::protobuf::uint32 unknown_6_;
  ::google::protobuf::uint32 unknown_7_;
  ::google::protobuf::uint32 unknown_8_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestNotifySummonSignResult* default_instance_;
};
// -------------------------------------------------------------------

class RequestNotifyBreakInResult : public ::google::protobuf::MessageLite {
 public:
  RequestNotifyBreakInResult();
  virtual ~RequestNotifyBreakInResult();

  RequestNotifyBreakInResult(const RequestNotifyBreakInResult& from);

  inline RequestNotifyBreakInResult& operator=(const RequestNotifyBreakInResult& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestNotifyBreakInResult& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestNotifyBreakInResult* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestNotifyBreakInResult* other);

  // implements Message ----------------------------------------------

  RequestNotifyBreakInResult* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestNotifyBreakInResult& from);
  void MergeFrom(const RequestNotifyBreakInResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestNotifyBreakInResult)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestNotifyBreakInResult* default_instance_;
};
// -------------------------------------------------------------------

class RequestNotifyDisconnectSession : public ::google::protobuf::MessageLite {
 public:
  RequestNotifyDisconnectSession();
  virtual ~RequestNotifyDisconnectSession();

  RequestNotifyDisconnectSession(const RequestNotifyDisconnectSession& from);

  inline RequestNotifyDisconnectSession& operator=(const RequestNotifyDisconnectSession& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestNotifyDisconnectSession& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestNotifyDisconnectSession* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestNotifyDisconnectSession* other);

  // implements Message ----------------------------------------------

  RequestNotifyDisconnectSession* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestNotifyDisconnectSession& from);
  void MergeFrom(const RequestNotifyDisconnectSession& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestNotifyDisconnectSession)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestNotifyDisconnectSession* default_instance_;
};
// -------------------------------------------------------------------

class RequestNotifyDisconnectSessionResponse : public ::google::protobuf::MessageLite {
 public:
  RequestNotifyDisconnectSessionResponse();
  virtual ~RequestNotifyDisconnectSessionResponse();

  RequestNotifyDisconnectSessionResponse(const RequestNotifyDisconnectSessionResponse& from);

  inline RequestNotifyDisconnectSessionResponse& operator=(const RequestNotifyDisconnectSessionResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestNotifyDisconnectSessionResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestNotifyDisconnectSessionResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestNotifyDisconnectSessionResponse* other);

  // implements Message ----------------------------------------------

  RequestNotifyDisconnectSessionResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestNotifyDisconnectSessionResponse& from);
  void MergeFrom(const RequestNotifyDisconnectSessionResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestNotifyDisconnectSessionResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestNotifyDisconnectSessionResponse* default_instance_;
};
// -------------------------------------------------------------------

class RequestNotifyRegisterCharacter : public ::google::protobuf::MessageLite {
 public:
  RequestNotifyRegisterCharacter();
  virtual ~RequestNotifyRegisterCharacter();

  RequestNotifyRegisterCharacter(const RequestNotifyRegisterCharacter& from);

  inline RequestNotifyRegisterCharacter& operator=(const RequestNotifyRegisterCharacter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestNotifyRegisterCharacter& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestNotifyRegisterCharacter* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestNotifyRegisterCharacter* other);

  // implements Message ----------------------------------------------

  RequestNotifyRegisterCharacter* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestNotifyRegisterCharacter& from);
  void MergeFrom(const RequestNotifyRegisterCharacter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .DS3_Frpg2PlayerData.AllStatus status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline const ::DS3_Frpg2PlayerData::AllStatus& status() const;
  inline ::DS3_Frpg2PlayerData::AllStatus* mutable_status();
  inline ::DS3_Frpg2PlayerData::AllStatus* release_status();
  inline void set_allocated_status(::DS3_Frpg2PlayerData::AllStatus* status);

  // required uint32 unknown_2 = 2;
  inline bool has_unknown_2() const;
  inline void clear_unknown_2();
  static const int kUnknown2FieldNumber = 2;
  inline ::google::protobuf::uint32 unknown_2() const;
  inline void set_unknown_2(::google::protobuf::uint32 value);

  // required uint32 unknown_3 = 3;
  inline bool has_unknown_3() const;
  inline void clear_unknown_3();
  static const int kUnknown3FieldNumber = 3;
  inline ::google::protobuf::uint32 unknown_3() const;
  inline void set_unknown_3(::google::protobuf::uint32 value);

  // required uint32 unknown_4 = 4;
  inline bool has_unknown_4() const;
  inline void clear_unknown_4();
  static const int kUnknown4FieldNumber = 4;
  inline ::google::protobuf::uint32 unknown_4() const;
  inline void set_unknown_4(::google::protobuf::uint32 value);

  // required uint32 unknown_5 = 5;
  inline bool has_unknown_5() const;
  inline void clear_unknown_5();
  static const int kUnknown5FieldNumber = 5;
  inline ::google::protobuf::uint32 unknown_5() const;
  inline void set_unknown_5(::google::protobuf::uint32 value);

  // required uint32 unknown_6 = 6;
  inline bool has_unknown_6() const;
  inline void clear_unknown_6();
  static const int kUnknown6FieldNumber = 6;
  inline ::google::protobuf::uint32 unknown_6() const;
  inline void set_unknown_6(::google::protobuf::uint32 value);

  // required uint32 unknown_7 = 7;
  inline bool has_unknown_7() const;
  inline void clear_unknown_7();
  static const int kUnknown7FieldNumber = 7;
  inline ::google::protobuf::uint32 unknown_7() const;
  inline void set_unknown_7(::google::protobuf::uint32 value);

  // required uint32 unknown_8 = 8;
  inline bool has_unknown_8() const;
  inline void clear_unknown_8();
  static const int kUnknown8FieldNumber = 8;
  inline ::google::protobuf::uint32 unknown_8() const;
  inline void set_unknown_8(::google::protobuf::uint32 value);

  // required uint32 unknown_9 = 9;
  inline bool has_unknown_9() const;
  inline void clear_unknown_9();
  static const int kUnknown9FieldNumber = 9;
  inline ::google::protobuf::uint32 unknown_9() const;
  inline void set_unknown_9(::google::protobuf::uint32 value);

  // required uint32 unknown_10 = 10;
  inline bool has_unknown_10() const;
  inline void clear_unknown_10();
  static const int kUnknown10FieldNumber = 10;
  inline ::google::protobuf::uint32 unknown_10() const;
  inline void set_unknown_10(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestNotifyRegisterCharacter)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_unknown_2();
  inline void clear_has_unknown_2();
  inline void set_has_unknown_3();
  inline void clear_has_unknown_3();
  inline void set_has_unknown_4();
  inline void clear_has_unknown_4();
  inline void set_has_unknown_5();
  inline void clear_has_unknown_5();
  inline void set_has_unknown_6();
  inline void clear_has_unknown_6();
  inline void set_has_unknown_7();
  inline void clear_has_unknown_7();
  inline void set_has_unknown_8();
  inline void clear_has_unknown_8();
  inline void set_has_unknown_9();
  inline void clear_has_unknown_9();
  inline void set_has_unknown_10();
  inline void clear_has_unknown_10();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::DS3_Frpg2PlayerData::AllStatus* status_;
  ::google::protobuf::uint32 unknown_2_;
  ::google::protobuf::uint32 unknown_3_;
  ::google::protobuf::uint32 unknown_4_;
  ::google::protobuf::uint32 unknown_5_;
  ::google::protobuf::uint32 unknown_6_;
  ::google::protobuf::uint32 unknown_7_;
  ::google::protobuf::uint32 unknown_8_;
  ::google::protobuf::uint32 unknown_9_;
  ::google::protobuf::uint32 unknown_10_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestNotifyRegisterCharacter* default_instance_;
};
// -------------------------------------------------------------------

class SummonSignMessage : public ::google::protobuf::MessageLite {
 public:
  SummonSignMessage();
  virtual ~SummonSignMessage();

  SummonSignMessage(const SummonSignMessage& from);

  inline SummonSignMessage& operator=(const SummonSignMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const SummonSignMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SummonSignMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SummonSignMessage* other);

  // implements Message ----------------------------------------------

  SummonSignMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SummonSignMessage& from);
  void MergeFrom(const SummonSignMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 player_id = 1;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 1;
  inline ::google::protobuf::uint32 player_id() const;
  inline void set_player_id(::google::protobuf::uint32 value);

  // required string steam_id = 2;
  inline bool has_steam_id() const;
  inline void clear_steam_id();
  static const int kSteamIdFieldNumber = 2;
  inline const ::std::string& steam_id() const;
  inline void set_steam_id(const ::std::string& value);
  inline void set_steam_id(const char* value);
  inline void set_steam_id(const char* value, size_t size);
  inline ::std::string* mutable_steam_id();
  inline ::std::string* release_steam_id();
  inline void set_allocated_steam_id(::std::string* steam_id);

  // required .DS3_Frpg2RequestMessage.SignInfo sign_info = 3;
  inline bool has_sign_info() const;
  inline void clear_sign_info();
  static const int kSignInfoFieldNumber = 3;
  inline const ::DS3_Frpg2RequestMessage::SignInfo& sign_info() const;
  inline ::DS3_Frpg2RequestMessage::SignInfo* mutable_sign_info();
  inline ::DS3_Frpg2RequestMessage::SignInfo* release_sign_info();
  inline void set_allocated_sign_info(::DS3_Frpg2RequestMessage::SignInfo* sign_info);

  // required bytes player_struct = 4;
  inline bool has_player_struct() const;
  inline void clear_player_struct();
  static const int kPlayerStructFieldNumber = 4;
  inline const ::std::string& player_struct() const;
  inline void set_player_struct(const ::std::string& value);
  inline void set_player_struct(const char* value);
  inline void set_player_struct(const void* value, size_t size);
  inline ::std::string* mutable_player_struct();
  inline ::std::string* release_player_struct();
  inline void set_allocated_player_struct(::std::string* player_struct);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.SummonSignMessage)
 private:
  inline void set_has_player_id();
  inline void clear_has_player_id();
  inline void set_has_steam_id();
  inline void clear_has_steam_id();
  inline void set_has_sign_info();
  inline void clear_has_sign_info();
  inline void set_has_player_struct();
  inline void clear_has_player_struct();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* steam_id_;
  ::DS3_Frpg2RequestMessage::SignInfo* sign_info_;
  ::std::string* player_struct_;
  ::google::protobuf::uint32 player_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static SummonSignMessage* default_instance_;
};
// -------------------------------------------------------------------

class RemoveSignMessage : public ::google::protobuf::MessageLite {
 public:
  RemoveSignMessage();
  virtual ~RemoveSignMessage();

  RemoveSignMessage(const RemoveSignMessage& from);

  inline RemoveSignMessage& operator=(const RemoveSignMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RemoveSignMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RemoveSignMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RemoveSignMessage* other);

  // implements Message ----------------------------------------------

  RemoveSignMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RemoveSignMessage& from);
  void MergeFrom(const RemoveSignMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 player_id = 1;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 1;
  inline ::google::protobuf::uint32 player_id() const;
  inline void set_player_id(::google::protobuf::uint32 value);

  // required uint32 sign_id = 2;
  inline bool has_sign_id() const;
  inline void clear_sign_id();
  static const int kSignIdFieldNumber = 2;
  inline ::google::protobuf::uint32 sign_id() const;
  inline void set_sign_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RemoveSignMessage)
 private:
  inline void set_has_player_id();
  inline void clear_has_player_id();
  inline void set_has_sign_id();
  inline void clear_has_sign_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 player_id_;
  ::google::protobuf::uint32 sign_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RemoveSignMessage* default_instance_;
};
// -------------------------------------------------------------------

class RejectSignMessage : public ::google::protobuf::MessageLite {
 public:
  RejectSignMessage();
  virtual ~RejectSignMessage();

  RejectSignMessage(const RejectSignMessage& from);

  inline RejectSignMessage& operator=(const RejectSignMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RejectSignMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RejectSignMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RejectSignMessage* other);

  // implements Message ----------------------------------------------

  RejectSignMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RejectSignMessage& from);
  void MergeFrom(const RejectSignMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 sign_id = 1;
  inline bool has_sign_id() const;
  inline void clear_sign_id();
  static const int kSignIdFieldNumber = 1;
  inline ::google::protobuf::uint32 sign_id() const;
  inline void set_sign_id(::google::protobuf::uint32 value);

  // required uint32 unknown_2 = 2;
  inline bool has_unknown_2() const;
  inline void clear_unknown_2();
  static const int kUnknown2FieldNumber = 2;
  inline ::google::protobuf::uint32 unknown_2() const;
  inline void set_unknown_2(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RejectSignMessage)
 private:
  inline void set_has_sign_id();
  inline void clear_has_sign_id();
  inline void set_has_unknown_2();
  inline void clear_has_unknown_2();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 sign_id_;
  ::google::protobuf::uint32 unknown_2_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RejectSignMessage* default_instance_;
};
// -------------------------------------------------------------------

class CachedSign : public ::google::protobuf::MessageLite {
 public:
  CachedSign();
  virtual ~CachedSign();

  CachedSign(const CachedSign& from);

  inline CachedSign& operator=(const CachedSign& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CachedSign& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CachedSign* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CachedSign* other);

  // implements Message ----------------------------------------------

  CachedSign* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CachedSign& from);
  void MergeFrom(const CachedSign& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.CachedSign)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static CachedSign* default_instance_;
};
// -------------------------------------------------------------------

class GetSignResult : public ::google::protobuf::MessageLite {
 public:
  GetSignResult();
  virtual ~GetSignResult();

  GetSignResult(const GetSignResult& from);

  inline GetSignResult& operator=(const GetSignResult& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GetSignResult& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetSignResult* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetSignResult* other);

  // implements Message ----------------------------------------------

  GetSignResult* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetSignResult& from);
  void MergeFrom(const GetSignResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .DS3_Frpg2RequestMessage.SignInfo sign_info_without_data = 1;
  inline int sign_info_without_data_size() const;
  inline void clear_sign_info_without_data();
  static const int kSignInfoWithoutDataFieldNumber = 1;
  inline const ::DS3_Frpg2RequestMessage::SignInfo& sign_info_without_data(int index) const;
  inline ::DS3_Frpg2RequestMessage::SignInfo* mutable_sign_info_without_data(int index);
  inline ::DS3_Frpg2RequestMessage::SignInfo* add_sign_info_without_data();
  inline const ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::SignInfo >&
      sign_info_without_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::SignInfo >*
      mutable_sign_info_without_data();

  // repeated .DS3_Frpg2RequestMessage.SignData sign_data = 2;
  inline int sign_data_size() const;
  inline void clear_sign_data();
  static const int kSignDataFieldNumber = 2;
  inline const ::DS3_Frpg2RequestMessage::SignData& sign_data(int index) const;
  inline ::DS3_Frpg2RequestMessage::SignData* mutable_sign_data(int index);
  inline ::DS3_Frpg2RequestMessage::SignData* add_sign_data();
  inline const ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::SignData >&
      sign_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::SignData >*
      mutable_sign_data();

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.GetSignResult)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::SignInfo > sign_info_without_data_;
  ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::SignData > sign_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static GetSignResult* default_instance_;
};
// -------------------------------------------------------------------

class SignInfo : public ::google::protobuf::MessageLite {
 public:
  SignInfo();
  virtual ~SignInfo();

  SignInfo(const SignInfo& from);

  inline SignInfo& operator=(const SignInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const SignInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SignInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SignInfo* other);

  // implements Message ----------------------------------------------

  SignInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SignInfo& from);
  void MergeFrom(const SignInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 player_id = 1;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 1;
  inline ::google::protobuf::uint32 player_id() const;
  inline void set_player_id(::google::protobuf::uint32 value);

  // required uint32 sign_id = 2;
  inline bool has_sign_id() const;
  inline void clear_sign_id();
  static const int kSignIdFieldNumber = 2;
  inline ::google::protobuf::uint32 sign_id() const;
  inline void set_sign_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.SignInfo)
 private:
  inline void set_has_player_id();
  inline void clear_has_player_id();
  inline void set_has_sign_id();
  inline void clear_has_sign_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 player_id_;
  ::google::protobuf::uint32 sign_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static SignInfo* default_instance_;
};
// -------------------------------------------------------------------

class SignData : public ::google::protobuf::MessageLite {
 public:
  SignData();
  virtual ~SignData();

  SignData(const SignData& from);

  inline SignData& operator=(const SignData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const SignData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SignData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SignData* other);

  // implements Message ----------------------------------------------

  SignData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SignData& from);
  void MergeFrom(const SignData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .DS3_Frpg2RequestMessage.SignInfo sign_info = 1;
  inline bool has_sign_info() const;
  inline void clear_sign_info();
  static const int kSignInfoFieldNumber = 1;
  inline const ::DS3_Frpg2RequestMessage::SignInfo& sign_info() const;
  inline ::DS3_Frpg2RequestMessage::SignInfo* mutable_sign_info();
  inline ::DS3_Frpg2RequestMessage::SignInfo* release_sign_info();
  inline void set_allocated_sign_info(::DS3_Frpg2RequestMessage::SignInfo* sign_info);

  // required uint32 online_area_id = 2;
  inline bool has_online_area_id() const;
  inline void clear_online_area_id();
  static const int kOnlineAreaIdFieldNumber = 2;
  inline ::google::protobuf::uint32 online_area_id() const;
  inline void set_online_area_id(::google::protobuf::uint32 value);

  // required .DS3_Frpg2RequestMessage.MatchingParameter matching_parameter = 3;
  inline bool has_matching_parameter() const;
  inline void clear_matching_parameter();
  static const int kMatchingParameterFieldNumber = 3;
  inline const ::DS3_Frpg2RequestMessage::MatchingParameter& matching_parameter() const;
  inline ::DS3_Frpg2RequestMessage::MatchingParameter* mutable_matching_parameter();
  inline ::DS3_Frpg2RequestMessage::MatchingParameter* release_matching_parameter();
  inline void set_allocated_matching_parameter(::DS3_Frpg2RequestMessage::MatchingParameter* matching_parameter);

  // required bytes player_struct = 4;
  inline bool has_player_struct() const;
  inline void clear_player_struct();
  static const int kPlayerStructFieldNumber = 4;
  inline const ::std::string& player_struct() const;
  inline void set_player_struct(const ::std::string& value);
  inline void set_player_struct(const char* value);
  inline void set_player_struct(const void* value, size_t size);
  inline ::std::string* mutable_player_struct();
  inline ::std::string* release_player_struct();
  inline void set_allocated_player_struct(::std::string* player_struct);

  // required string steam_id = 5;
  inline bool has_steam_id() const;
  inline void clear_steam_id();
  static const int kSteamIdFieldNumber = 5;
  inline const ::std::string& steam_id() const;
  inline void set_steam_id(const ::std::string& value);
  inline void set_steam_id(const char* value);
  inline void set_steam_id(const char* value, size_t size);
  inline ::std::string* mutable_steam_id();
  inline ::std::string* release_steam_id();
  inline void set_allocated_steam_id(::std::string* steam_id);

  // required .DS3_Frpg2RequestMessage.SignType sign_type = 6;
  inline bool has_sign_type() const;
  inline void clear_sign_type();
  static const int kSignTypeFieldNumber = 6;
  inline ::DS3_Frpg2RequestMessage::SignType sign_type() const;
  inline void set_sign_type(::DS3_Frpg2RequestMessage::SignType value);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.SignData)
 private:
  inline void set_has_sign_info();
  inline void clear_has_sign_info();
  inline void set_has_online_area_id();
  inline void clear_has_online_area_id();
  inline void set_has_matching_parameter();
  inline void clear_has_matching_parameter();
  inline void set_has_player_struct();
  inline void clear_has_player_struct();
  inline void set_has_steam_id();
  inline void clear_has_steam_id();
  inline void set_has_sign_type();
  inline void clear_has_sign_type();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::DS3_Frpg2RequestMessage::SignInfo* sign_info_;
  ::DS3_Frpg2RequestMessage::MatchingParameter* matching_parameter_;
  ::std::string* player_struct_;
  ::google::protobuf::uint32 online_area_id_;
  int sign_type_;
  ::std::string* steam_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static SignData* default_instance_;
};
// -------------------------------------------------------------------

class MatchingParameter : public ::google::protobuf::MessageLite {
 public:
  MatchingParameter();
  virtual ~MatchingParameter();

  MatchingParameter(const MatchingParameter& from);

  inline MatchingParameter& operator=(const MatchingParameter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const MatchingParameter& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MatchingParameter* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MatchingParameter* other);

  // implements Message ----------------------------------------------

  MatchingParameter* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MatchingParameter& from);
  void MergeFrom(const MatchingParameter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 regulation_version = 1;
  inline bool has_regulation_version() const;
  inline void clear_regulation_version();
  static const int kRegulationVersionFieldNumber = 1;
  inline ::google::protobuf::uint32 regulation_version() const;
  inline void set_regulation_version(::google::protobuf::uint32 value);

  // required uint32 unknown_id_2 = 2;
  inline bool has_unknown_id_2() const;
  inline void clear_unknown_id_2();
  static const int kUnknownId2FieldNumber = 2;
  inline ::google::protobuf::uint32 unknown_id_2() const;
  inline void set_unknown_id_2(::google::protobuf::uint32 value);

  // required uint32 allow_cross_region = 3;
  inline bool has_allow_cross_region() const;
  inline void clear_allow_cross_region();
  static const int kAllowCrossRegionFieldNumber = 3;
  inline ::google::protobuf::uint32 allow_cross_region() const;
  inline void set_allow_cross_region(::google::protobuf::uint32 value);

  // required uint32 nat_type = 4;
  inline bool has_nat_type() const;
  inline void clear_nat_type();
  static const int kNatTypeFieldNumber = 4;
  inline ::google::protobuf::uint32 nat_type() const;
  inline void set_nat_type(::google::protobuf::uint32 value);

  // required uint32 unknown_id_5 = 5;
  inline bool has_unknown_id_5() const;
  inline void clear_unknown_id_5();
  static const int kUnknownId5FieldNumber = 5;
  inline ::google::protobuf::uint32 unknown_id_5() const;
  inline void set_unknown_id_5(::google::protobuf::uint32 value);

  // required uint32 soul_level = 6;
  inline bool has_soul_level() const;
  inline void clear_soul_level();
  static const int kSoulLevelFieldNumber = 6;
  inline ::google::protobuf::uint32 soul_level() const;
  inline void set_soul_level(::google::protobuf::uint32 value);

  // required uint32 soul_memory = 7;
  inline bool has_soul_memory() const;
  inline void clear_soul_memory();
  static const int kSoulMemoryFieldNumber = 7;
  inline ::google::protobuf::uint32 soul_memory() const;
  inline void set_soul_memory(::google::protobuf::uint32 value);

  // optional string unknown_string = 8;
  inline bool has_unknown_string() const;
  inline void clear_unknown_string();
  static const int kUnknownStringFieldNumber = 8;
  inline const ::std::string& unknown_string() const;
  inline void set_unknown_string(const ::std::string& value);
  inline void set_unknown_string(const char* value);
  inline void set_unknown_string(const char* value, size_t size);
  inline ::std::string* mutable_unknown_string();
  inline ::std::string* release_unknown_string();
  inline void set_allocated_unknown_string(::std::string* unknown_string);

  // required uint32 clear_count = 9;
  inline bool has_clear_count() const;
  inline void clear_clear_count();
  static const int kClearCountFieldNumber = 9;
  inline ::google::protobuf::uint32 clear_count() const;
  inline void set_clear_count(::google::protobuf::uint32 value);

  // required string password = 10;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 10;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // required .DS3_Frpg2RequestMessage.Covenant covenant = 11;
  inline bool has_covenant() const;
  inline void clear_covenant();
  static const int kCovenantFieldNumber = 11;
  inline ::DS3_Frpg2RequestMessage::Covenant covenant() const;
  inline void set_covenant(::DS3_Frpg2RequestMessage::Covenant value);

  // required uint32 weapon_level = 14;
  inline bool has_weapon_level() const;
  inline void clear_weapon_level();
  static const int kWeaponLevelFieldNumber = 14;
  inline ::google::protobuf::uint32 weapon_level() const;
  inline void set_weapon_level(::google::protobuf::uint32 value);

  // optional string unknown_id_15 = 15;
  inline bool has_unknown_id_15() const;
  inline void clear_unknown_id_15();
  static const int kUnknownId15FieldNumber = 15;
  inline const ::std::string& unknown_id_15() const;
  inline void set_unknown_id_15(const ::std::string& value);
  inline void set_unknown_id_15(const char* value);
  inline void set_unknown_id_15(const char* value, size_t size);
  inline ::std::string* mutable_unknown_id_15();
  inline ::std::string* release_unknown_id_15();
  inline void set_allocated_unknown_id_15(::std::string* unknown_id_15);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.MatchingParameter)
 private:
  inline void set_has_regulation_version();
  inline void clear_has_regulation_version();
  inline void set_has_unknown_id_2();
  inline void clear_has_unknown_id_2();
  inline void set_has_allow_cross_region();
  inline void clear_has_allow_cross_region();
  inline void set_has_nat_type();
  inline void clear_has_nat_type();
  inline void set_has_unknown_id_5();
  inline void clear_has_unknown_id_5();
  inline void set_has_soul_level();
  inline void clear_has_soul_level();
  inline void set_has_soul_memory();
  inline void clear_has_soul_memory();
  inline void set_has_unknown_string();
  inline void clear_has_unknown_string();
  inline void set_has_clear_count();
  inline void clear_has_clear_count();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_covenant();
  inline void clear_has_covenant();
  inline void set_has_weapon_level();
  inline void clear_has_weapon_level();
  inline void set_has_unknown_id_15();
  inline void clear_has_unknown_id_15();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 regulation_version_;
  ::google::protobuf::uint32 unknown_id_2_;
  ::google::protobuf::uint32 allow_cross_region_;
  ::google::protobuf::uint32 nat_type_;
  ::google::protobuf::uint32 unknown_id_5_;
  ::google::protobuf::uint32 soul_level_;
  ::std::string* unknown_string_;
  ::google::protobuf::uint32 soul_memory_;
  ::google::protobuf::uint32 clear_count_;
  ::std::string* password_;
  int covenant_;
  ::google::protobuf::uint32 weapon_level_;
  ::std::string* unknown_id_15_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static MatchingParameter* default_instance_;
};
// -------------------------------------------------------------------

class SignGetFlags : public ::google::protobuf::MessageLite {
 public:
  SignGetFlags();
  virtual ~SignGetFlags();

  SignGetFlags(const SignGetFlags& from);

  inline SignGetFlags& operator=(const SignGetFlags& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const SignGetFlags& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SignGetFlags* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SignGetFlags* other);

  // implements Message ----------------------------------------------

  SignGetFlags* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SignGetFlags& from);
  void MergeFrom(const SignGetFlags& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 unknown_id_1 = 1;
  inline bool has_unknown_id_1() const;
  inline void clear_unknown_id_1();
  static const int kUnknownId1FieldNumber = 1;
  inline ::google::protobuf::uint32 unknown_id_1() const;
  inline void set_unknown_id_1(::google::protobuf::uint32 value);

  // required uint32 unknown_id_2 = 2;
  inline bool has_unknown_id_2() const;
  inline void clear_unknown_id_2();
  static const int kUnknownId2FieldNumber = 2;
  inline ::google::protobuf::uint32 unknown_id_2() const;
  inline void set_unknown_id_2(::google::protobuf::uint32 value);

  // required uint32 unknown_id_3 = 3;
  inline bool has_unknown_id_3() const;
  inline void clear_unknown_id_3();
  static const int kUnknownId3FieldNumber = 3;
  inline ::google::protobuf::uint32 unknown_id_3() const;
  inline void set_unknown_id_3(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.SignGetFlags)
 private:
  inline void set_has_unknown_id_1();
  inline void clear_has_unknown_id_1();
  inline void set_has_unknown_id_2();
  inline void clear_has_unknown_id_2();
  inline void set_has_unknown_id_3();
  inline void clear_has_unknown_id_3();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 unknown_id_1_;
  ::google::protobuf::uint32 unknown_id_2_;
  ::google::protobuf::uint32 unknown_id_3_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static SignGetFlags* default_instance_;
};
// -------------------------------------------------------------------

class SignDomainGetInfo : public ::google::protobuf::MessageLite {
 public:
  SignDomainGetInfo();
  virtual ~SignDomainGetInfo();

  SignDomainGetInfo(const SignDomainGetInfo& from);

  inline SignDomainGetInfo& operator=(const SignDomainGetInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const SignDomainGetInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SignDomainGetInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SignDomainGetInfo* other);

  // implements Message ----------------------------------------------

  SignDomainGetInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SignDomainGetInfo& from);
  void MergeFrom(const SignDomainGetInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 online_area_id = 1;
  inline bool has_online_area_id() const;
  inline void clear_online_area_id();
  static const int kOnlineAreaIdFieldNumber = 1;
  inline ::google::protobuf::uint32 online_area_id() const;
  inline void set_online_area_id(::google::protobuf::uint32 value);

  // required uint32 max_signs = 2;
  inline bool has_max_signs() const;
  inline void clear_max_signs();
  static const int kMaxSignsFieldNumber = 2;
  inline ::google::protobuf::uint32 max_signs() const;
  inline void set_max_signs(::google::protobuf::uint32 value);

  // repeated .DS3_Frpg2RequestMessage.SignInfo already_have_signs = 3;
  inline int already_have_signs_size() const;
  inline void clear_already_have_signs();
  static const int kAlreadyHaveSignsFieldNumber = 3;
  inline const ::DS3_Frpg2RequestMessage::SignInfo& already_have_signs(int index) const;
  inline ::DS3_Frpg2RequestMessage::SignInfo* mutable_already_have_signs(int index);
  inline ::DS3_Frpg2RequestMessage::SignInfo* add_already_have_signs();
  inline const ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::SignInfo >&
      already_have_signs() const;
  inline ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::SignInfo >*
      mutable_already_have_signs();

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.SignDomainGetInfo)
 private:
  inline void set_has_online_area_id();
  inline void clear_has_online_area_id();
  inline void set_has_max_signs();
  inline void clear_has_max_signs();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 online_area_id_;
  ::google::protobuf::uint32 max_signs_;
  ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::SignInfo > already_have_signs_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static SignDomainGetInfo* default_instance_;
};
// -------------------------------------------------------------------

class RequestGetSignList : public ::google::protobuf::MessageLite {
 public:
  RequestGetSignList();
  virtual ~RequestGetSignList();

  RequestGetSignList(const RequestGetSignList& from);

  inline RequestGetSignList& operator=(const RequestGetSignList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestGetSignList& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestGetSignList* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestGetSignList* other);

  // implements Message ----------------------------------------------

  RequestGetSignList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestGetSignList& from);
  void MergeFrom(const RequestGetSignList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 unknown_id_1 = 1;
  inline bool has_unknown_id_1() const;
  inline void clear_unknown_id_1();
  static const int kUnknownId1FieldNumber = 1;
  inline ::google::protobuf::uint32 unknown_id_1() const;
  inline void set_unknown_id_1(::google::protobuf::uint32 value);

  // repeated .DS3_Frpg2RequestMessage.SignDomainGetInfo search_areas = 2;
  inline int search_areas_size() const;
  inline void clear_search_areas();
  static const int kSearchAreasFieldNumber = 2;
  inline const ::DS3_Frpg2RequestMessage::SignDomainGetInfo& search_areas(int index) const;
  inline ::DS3_Frpg2RequestMessage::SignDomainGetInfo* mutable_search_areas(int index);
  inline ::DS3_Frpg2RequestMessage::SignDomainGetInfo* add_search_areas();
  inline const ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::SignDomainGetInfo >&
      search_areas() const;
  inline ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::SignDomainGetInfo >*
      mutable_search_areas();

  // required uint32 max_signs = 3;
  inline bool has_max_signs() const;
  inline void clear_max_signs();
  static const int kMaxSignsFieldNumber = 3;
  inline ::google::protobuf::uint32 max_signs() const;
  inline void set_max_signs(::google::protobuf::uint32 value);

  // required .DS3_Frpg2RequestMessage.MatchingParameter matching_parameter = 4;
  inline bool has_matching_parameter() const;
  inline void clear_matching_parameter();
  static const int kMatchingParameterFieldNumber = 4;
  inline const ::DS3_Frpg2RequestMessage::MatchingParameter& matching_parameter() const;
  inline ::DS3_Frpg2RequestMessage::MatchingParameter* mutable_matching_parameter();
  inline ::DS3_Frpg2RequestMessage::MatchingParameter* release_matching_parameter();
  inline void set_allocated_matching_parameter(::DS3_Frpg2RequestMessage::MatchingParameter* matching_parameter);

  // required .DS3_Frpg2RequestMessage.SignGetFlags sign_get_flags = 5;
  inline bool has_sign_get_flags() const;
  inline void clear_sign_get_flags();
  static const int kSignGetFlagsFieldNumber = 5;
  inline const ::DS3_Frpg2RequestMessage::SignGetFlags& sign_get_flags() const;
  inline ::DS3_Frpg2RequestMessage::SignGetFlags* mutable_sign_get_flags();
  inline ::DS3_Frpg2RequestMessage::SignGetFlags* release_sign_get_flags();
  inline void set_allocated_sign_get_flags(::DS3_Frpg2RequestMessage::SignGetFlags* sign_get_flags);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestGetSignList)
 private:
  inline void set_has_unknown_id_1();
  inline void clear_has_unknown_id_1();
  inline void set_has_max_signs();
  inline void clear_has_max_signs();
  inline void set_has_matching_parameter();
  inline void clear_has_matching_parameter();
  inline void set_has_sign_get_flags();
  inline void clear_has_sign_get_flags();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::SignDomainGetInfo > search_areas_;
  ::google::protobuf::uint32 unknown_id_1_;
  ::google::protobuf::uint32 max_signs_;
  ::DS3_Frpg2RequestMessage::MatchingParameter* matching_parameter_;
  ::DS3_Frpg2RequestMessage::SignGetFlags* sign_get_flags_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestGetSignList* default_instance_;
};
// -------------------------------------------------------------------

class RequestGetSignListResponse : public ::google::protobuf::MessageLite {
 public:
  RequestGetSignListResponse();
  virtual ~RequestGetSignListResponse();

  RequestGetSignListResponse(const RequestGetSignListResponse& from);

  inline RequestGetSignListResponse& operator=(const RequestGetSignListResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestGetSignListResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestGetSignListResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestGetSignListResponse* other);

  // implements Message ----------------------------------------------

  RequestGetSignListResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestGetSignListResponse& from);
  void MergeFrom(const RequestGetSignListResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .DS3_Frpg2RequestMessage.GetSignResult get_sign_result = 1;
  inline bool has_get_sign_result() const;
  inline void clear_get_sign_result();
  static const int kGetSignResultFieldNumber = 1;
  inline const ::DS3_Frpg2RequestMessage::GetSignResult& get_sign_result() const;
  inline ::DS3_Frpg2RequestMessage::GetSignResult* mutable_get_sign_result();
  inline ::DS3_Frpg2RequestMessage::GetSignResult* release_get_sign_result();
  inline void set_allocated_get_sign_result(::DS3_Frpg2RequestMessage::GetSignResult* get_sign_result);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestGetSignListResponse)
 private:
  inline void set_has_get_sign_result();
  inline void clear_has_get_sign_result();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::DS3_Frpg2RequestMessage::GetSignResult* get_sign_result_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestGetSignListResponse* default_instance_;
};
// -------------------------------------------------------------------

class RequestCreateSign : public ::google::protobuf::MessageLite {
 public:
  RequestCreateSign();
  virtual ~RequestCreateSign();

  RequestCreateSign(const RequestCreateSign& from);

  inline RequestCreateSign& operator=(const RequestCreateSign& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestCreateSign& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestCreateSign* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestCreateSign* other);

  // implements Message ----------------------------------------------

  RequestCreateSign* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestCreateSign& from);
  void MergeFrom(const RequestCreateSign& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 map_id = 1;
  inline bool has_map_id() const;
  inline void clear_map_id();
  static const int kMapIdFieldNumber = 1;
  inline ::google::protobuf::uint32 map_id() const;
  inline void set_map_id(::google::protobuf::uint32 value);

  // required uint32 online_area_id = 2;
  inline bool has_online_area_id() const;
  inline void clear_online_area_id();
  static const int kOnlineAreaIdFieldNumber = 2;
  inline ::google::protobuf::uint32 online_area_id() const;
  inline void set_online_area_id(::google::protobuf::uint32 value);

  // required .DS3_Frpg2RequestMessage.MatchingParameter matching_parameter = 3;
  inline bool has_matching_parameter() const;
  inline void clear_matching_parameter();
  static const int kMatchingParameterFieldNumber = 3;
  inline const ::DS3_Frpg2RequestMessage::MatchingParameter& matching_parameter() const;
  inline ::DS3_Frpg2RequestMessage::MatchingParameter* mutable_matching_parameter();
  inline ::DS3_Frpg2RequestMessage::MatchingParameter* release_matching_parameter();
  inline void set_allocated_matching_parameter(::DS3_Frpg2RequestMessage::MatchingParameter* matching_parameter);

  // required uint32 sign_type = 4;
  inline bool has_sign_type() const;
  inline void clear_sign_type();
  static const int kSignTypeFieldNumber = 4;
  inline ::google::protobuf::uint32 sign_type() const;
  inline void set_sign_type(::google::protobuf::uint32 value);

  // required bytes player_struct = 5;
  inline bool has_player_struct() const;
  inline void clear_player_struct();
  static const int kPlayerStructFieldNumber = 5;
  inline const ::std::string& player_struct() const;
  inline void set_player_struct(const ::std::string& value);
  inline void set_player_struct(const char* value);
  inline void set_player_struct(const void* value, size_t size);
  inline ::std::string* mutable_player_struct();
  inline ::std::string* release_player_struct();
  inline void set_allocated_player_struct(::std::string* player_struct);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestCreateSign)
 private:
  inline void set_has_map_id();
  inline void clear_has_map_id();
  inline void set_has_online_area_id();
  inline void clear_has_online_area_id();
  inline void set_has_matching_parameter();
  inline void clear_has_matching_parameter();
  inline void set_has_sign_type();
  inline void clear_has_sign_type();
  inline void set_has_player_struct();
  inline void clear_has_player_struct();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 map_id_;
  ::google::protobuf::uint32 online_area_id_;
  ::DS3_Frpg2RequestMessage::MatchingParameter* matching_parameter_;
  ::std::string* player_struct_;
  ::google::protobuf::uint32 sign_type_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestCreateSign* default_instance_;
};
// -------------------------------------------------------------------

class RequestCreateSignResponse : public ::google::protobuf::MessageLite {
 public:
  RequestCreateSignResponse();
  virtual ~RequestCreateSignResponse();

  RequestCreateSignResponse(const RequestCreateSignResponse& from);

  inline RequestCreateSignResponse& operator=(const RequestCreateSignResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestCreateSignResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestCreateSignResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestCreateSignResponse* other);

  // implements Message ----------------------------------------------

  RequestCreateSignResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestCreateSignResponse& from);
  void MergeFrom(const RequestCreateSignResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 sign_id = 1;
  inline bool has_sign_id() const;
  inline void clear_sign_id();
  static const int kSignIdFieldNumber = 1;
  inline ::google::protobuf::uint32 sign_id() const;
  inline void set_sign_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestCreateSignResponse)
 private:
  inline void set_has_sign_id();
  inline void clear_has_sign_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 sign_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestCreateSignResponse* default_instance_;
};
// -------------------------------------------------------------------

class RequestSummonSign : public ::google::protobuf::MessageLite {
 public:
  RequestSummonSign();
  virtual ~RequestSummonSign();

  RequestSummonSign(const RequestSummonSign& from);

  inline RequestSummonSign& operator=(const RequestSummonSign& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestSummonSign& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestSummonSign* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestSummonSign* other);

  // implements Message ----------------------------------------------

  RequestSummonSign* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestSummonSign& from);
  void MergeFrom(const RequestSummonSign& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 map_id = 1;
  inline bool has_map_id() const;
  inline void clear_map_id();
  static const int kMapIdFieldNumber = 1;
  inline ::google::protobuf::uint32 map_id() const;
  inline void set_map_id(::google::protobuf::uint32 value);

  // required uint32 online_area_id = 2;
  inline bool has_online_area_id() const;
  inline void clear_online_area_id();
  static const int kOnlineAreaIdFieldNumber = 2;
  inline ::google::protobuf::uint32 online_area_id() const;
  inline void set_online_area_id(::google::protobuf::uint32 value);

  // required .DS3_Frpg2RequestMessage.SignInfo sign_info = 3;
  inline bool has_sign_info() const;
  inline void clear_sign_info();
  static const int kSignInfoFieldNumber = 3;
  inline const ::DS3_Frpg2RequestMessage::SignInfo& sign_info() const;
  inline ::DS3_Frpg2RequestMessage::SignInfo* mutable_sign_info();
  inline ::DS3_Frpg2RequestMessage::SignInfo* release_sign_info();
  inline void set_allocated_sign_info(::DS3_Frpg2RequestMessage::SignInfo* sign_info);

  // required bytes player_struct = 4;
  inline bool has_player_struct() const;
  inline void clear_player_struct();
  static const int kPlayerStructFieldNumber = 4;
  inline const ::std::string& player_struct() const;
  inline void set_player_struct(const ::std::string& value);
  inline void set_player_struct(const char* value);
  inline void set_player_struct(const void* value, size_t size);
  inline ::std::string* mutable_player_struct();
  inline ::std::string* release_player_struct();
  inline void set_allocated_player_struct(::std::string* player_struct);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestSummonSign)
 private:
  inline void set_has_map_id();
  inline void clear_has_map_id();
  inline void set_has_online_area_id();
  inline void clear_has_online_area_id();
  inline void set_has_sign_info();
  inline void clear_has_sign_info();
  inline void set_has_player_struct();
  inline void clear_has_player_struct();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 map_id_;
  ::google::protobuf::uint32 online_area_id_;
  ::DS3_Frpg2RequestMessage::SignInfo* sign_info_;
  ::std::string* player_struct_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestSummonSign* default_instance_;
};
// -------------------------------------------------------------------

class RequestSummonSignResponse : public ::google::protobuf::MessageLite {
 public:
  RequestSummonSignResponse();
  virtual ~RequestSummonSignResponse();

  RequestSummonSignResponse(const RequestSummonSignResponse& from);

  inline RequestSummonSignResponse& operator=(const RequestSummonSignResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestSummonSignResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestSummonSignResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestSummonSignResponse* other);

  // implements Message ----------------------------------------------

  RequestSummonSignResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestSummonSignResponse& from);
  void MergeFrom(const RequestSummonSignResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestSummonSignResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestSummonSignResponse* default_instance_;
};
// -------------------------------------------------------------------

class RequestRemoveSign : public ::google::protobuf::MessageLite {
 public:
  RequestRemoveSign();
  virtual ~RequestRemoveSign();

  RequestRemoveSign(const RequestRemoveSign& from);

  inline RequestRemoveSign& operator=(const RequestRemoveSign& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestRemoveSign& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestRemoveSign* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestRemoveSign* other);

  // implements Message ----------------------------------------------

  RequestRemoveSign* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestRemoveSign& from);
  void MergeFrom(const RequestRemoveSign& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 map_id = 1;
  inline bool has_map_id() const;
  inline void clear_map_id();
  static const int kMapIdFieldNumber = 1;
  inline ::google::protobuf::uint32 map_id() const;
  inline void set_map_id(::google::protobuf::uint32 value);

  // required uint32 online_area_id = 2;
  inline bool has_online_area_id() const;
  inline void clear_online_area_id();
  static const int kOnlineAreaIdFieldNumber = 2;
  inline ::google::protobuf::uint32 online_area_id() const;
  inline void set_online_area_id(::google::protobuf::uint32 value);

  // required uint32 sign_id = 3;
  inline bool has_sign_id() const;
  inline void clear_sign_id();
  static const int kSignIdFieldNumber = 3;
  inline ::google::protobuf::uint32 sign_id() const;
  inline void set_sign_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestRemoveSign)
 private:
  inline void set_has_map_id();
  inline void clear_has_map_id();
  inline void set_has_online_area_id();
  inline void clear_has_online_area_id();
  inline void set_has_sign_id();
  inline void clear_has_sign_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 map_id_;
  ::google::protobuf::uint32 online_area_id_;
  ::google::protobuf::uint32 sign_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestRemoveSign* default_instance_;
};
// -------------------------------------------------------------------

class RequestRemoveSignResponse : public ::google::protobuf::MessageLite {
 public:
  RequestRemoveSignResponse();
  virtual ~RequestRemoveSignResponse();

  RequestRemoveSignResponse(const RequestRemoveSignResponse& from);

  inline RequestRemoveSignResponse& operator=(const RequestRemoveSignResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestRemoveSignResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestRemoveSignResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestRemoveSignResponse* other);

  // implements Message ----------------------------------------------

  RequestRemoveSignResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestRemoveSignResponse& from);
  void MergeFrom(const RequestRemoveSignResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestRemoveSignResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestRemoveSignResponse* default_instance_;
};
// -------------------------------------------------------------------

class RequestUpdateSign : public ::google::protobuf::MessageLite {
 public:
  RequestUpdateSign();
  virtual ~RequestUpdateSign();

  RequestUpdateSign(const RequestUpdateSign& from);

  inline RequestUpdateSign& operator=(const RequestUpdateSign& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestUpdateSign& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestUpdateSign* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestUpdateSign* other);

  // implements Message ----------------------------------------------

  RequestUpdateSign* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestUpdateSign& from);
  void MergeFrom(const RequestUpdateSign& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 map_id = 1;
  inline bool has_map_id() const;
  inline void clear_map_id();
  static const int kMapIdFieldNumber = 1;
  inline ::google::protobuf::uint32 map_id() const;
  inline void set_map_id(::google::protobuf::uint32 value);

  // required uint32 online_area_id = 2;
  inline bool has_online_area_id() const;
  inline void clear_online_area_id();
  static const int kOnlineAreaIdFieldNumber = 2;
  inline ::google::protobuf::uint32 online_area_id() const;
  inline void set_online_area_id(::google::protobuf::uint32 value);

  // required uint32 sign_id = 3;
  inline bool has_sign_id() const;
  inline void clear_sign_id();
  static const int kSignIdFieldNumber = 3;
  inline ::google::protobuf::uint32 sign_id() const;
  inline void set_sign_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestUpdateSign)
 private:
  inline void set_has_map_id();
  inline void clear_has_map_id();
  inline void set_has_online_area_id();
  inline void clear_has_online_area_id();
  inline void set_has_sign_id();
  inline void clear_has_sign_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 map_id_;
  ::google::protobuf::uint32 online_area_id_;
  ::google::protobuf::uint32 sign_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestUpdateSign* default_instance_;
};
// -------------------------------------------------------------------

class RequestUpdateSignResponse : public ::google::protobuf::MessageLite {
 public:
  RequestUpdateSignResponse();
  virtual ~RequestUpdateSignResponse();

  RequestUpdateSignResponse(const RequestUpdateSignResponse& from);

  inline RequestUpdateSignResponse& operator=(const RequestUpdateSignResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestUpdateSignResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestUpdateSignResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestUpdateSignResponse* other);

  // implements Message ----------------------------------------------

  RequestUpdateSignResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestUpdateSignResponse& from);
  void MergeFrom(const RequestUpdateSignResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestUpdateSignResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestUpdateSignResponse* default_instance_;
};
// -------------------------------------------------------------------

class RequestRejectSign : public ::google::protobuf::MessageLite {
 public:
  RequestRejectSign();
  virtual ~RequestRejectSign();

  RequestRejectSign(const RequestRejectSign& from);

  inline RequestRejectSign& operator=(const RequestRejectSign& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestRejectSign& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestRejectSign* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestRejectSign* other);

  // implements Message ----------------------------------------------

  RequestRejectSign* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestRejectSign& from);
  void MergeFrom(const RequestRejectSign& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 unknown_1 = 1;
  inline bool has_unknown_1() const;
  inline void clear_unknown_1();
  static const int kUnknown1FieldNumber = 1;
  inline ::google::protobuf::uint32 unknown_1() const;
  inline void set_unknown_1(::google::protobuf::uint32 value);

  // required uint32 unknown_2 = 2;
  inline bool has_unknown_2() const;
  inline void clear_unknown_2();
  static const int kUnknown2FieldNumber = 2;
  inline ::google::protobuf::uint32 unknown_2() const;
  inline void set_unknown_2(::google::protobuf::uint32 value);

  // required uint32 sign_id = 3;
  inline bool has_sign_id() const;
  inline void clear_sign_id();
  static const int kSignIdFieldNumber = 3;
  inline ::google::protobuf::uint32 sign_id() const;
  inline void set_sign_id(::google::protobuf::uint32 value);

  // required bool unknown_4 = 4;
  inline bool has_unknown_4() const;
  inline void clear_unknown_4();
  static const int kUnknown4FieldNumber = 4;
  inline bool unknown_4() const;
  inline void set_unknown_4(bool value);

  // required bool unknown_5 = 5;
  inline bool has_unknown_5() const;
  inline void clear_unknown_5();
  static const int kUnknown5FieldNumber = 5;
  inline bool unknown_5() const;
  inline void set_unknown_5(bool value);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestRejectSign)
 private:
  inline void set_has_unknown_1();
  inline void clear_has_unknown_1();
  inline void set_has_unknown_2();
  inline void clear_has_unknown_2();
  inline void set_has_sign_id();
  inline void clear_has_sign_id();
  inline void set_has_unknown_4();
  inline void clear_has_unknown_4();
  inline void set_has_unknown_5();
  inline void clear_has_unknown_5();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 unknown_1_;
  ::google::protobuf::uint32 unknown_2_;
  ::google::protobuf::uint32 sign_id_;
  bool unknown_4_;
  bool unknown_5_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestRejectSign* default_instance_;
};
// -------------------------------------------------------------------

class RequestRejectSignResponse : public ::google::protobuf::MessageLite {
 public:
  RequestRejectSignResponse();
  virtual ~RequestRejectSignResponse();

  RequestRejectSignResponse(const RequestRejectSignResponse& from);

  inline RequestRejectSignResponse& operator=(const RequestRejectSignResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestRejectSignResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestRejectSignResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestRejectSignResponse* other);

  // implements Message ----------------------------------------------

  RequestRejectSignResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestRejectSignResponse& from);
  void MergeFrom(const RequestRejectSignResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestRejectSignResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestRejectSignResponse* default_instance_;
};
// -------------------------------------------------------------------

class RequestGetRightMatchingArea : public ::google::protobuf::MessageLite {
 public:
  RequestGetRightMatchingArea();
  virtual ~RequestGetRightMatchingArea();

  RequestGetRightMatchingArea(const RequestGetRightMatchingArea& from);

  inline RequestGetRightMatchingArea& operator=(const RequestGetRightMatchingArea& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestGetRightMatchingArea& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestGetRightMatchingArea* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestGetRightMatchingArea* other);

  // implements Message ----------------------------------------------

  RequestGetRightMatchingArea* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestGetRightMatchingArea& from);
  void MergeFrom(const RequestGetRightMatchingArea& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .DS3_Frpg2RequestMessage.MatchingParameter matching_parameter = 1;
  inline bool has_matching_parameter() const;
  inline void clear_matching_parameter();
  static const int kMatchingParameterFieldNumber = 1;
  inline const ::DS3_Frpg2RequestMessage::MatchingParameter& matching_parameter() const;
  inline ::DS3_Frpg2RequestMessage::MatchingParameter* mutable_matching_parameter();
  inline ::DS3_Frpg2RequestMessage::MatchingParameter* release_matching_parameter();
  inline void set_allocated_matching_parameter(::DS3_Frpg2RequestMessage::MatchingParameter* matching_parameter);

  // required uint32 unknown = 2;
  inline bool has_unknown() const;
  inline void clear_unknown();
  static const int kUnknownFieldNumber = 2;
  inline ::google::protobuf::uint32 unknown() const;
  inline void set_unknown(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestGetRightMatchingArea)
 private:
  inline void set_has_matching_parameter();
  inline void clear_has_matching_parameter();
  inline void set_has_unknown();
  inline void clear_has_unknown();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::DS3_Frpg2RequestMessage::MatchingParameter* matching_parameter_;
  ::google::protobuf::uint32 unknown_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestGetRightMatchingArea* default_instance_;
};
// -------------------------------------------------------------------

class RequestGetRightMatchingAreaResponse_Area_info : public ::google::protobuf::MessageLite {
 public:
  RequestGetRightMatchingAreaResponse_Area_info();
  virtual ~RequestGetRightMatchingAreaResponse_Area_info();

  RequestGetRightMatchingAreaResponse_Area_info(const RequestGetRightMatchingAreaResponse_Area_info& from);

  inline RequestGetRightMatchingAreaResponse_Area_info& operator=(const RequestGetRightMatchingAreaResponse_Area_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestGetRightMatchingAreaResponse_Area_info& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestGetRightMatchingAreaResponse_Area_info* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestGetRightMatchingAreaResponse_Area_info* other);

  // implements Message ----------------------------------------------

  RequestGetRightMatchingAreaResponse_Area_info* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestGetRightMatchingAreaResponse_Area_info& from);
  void MergeFrom(const RequestGetRightMatchingAreaResponse_Area_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 online_area_id = 1;
  inline bool has_online_area_id() const;
  inline void clear_online_area_id();
  static const int kOnlineAreaIdFieldNumber = 1;
  inline ::google::protobuf::uint32 online_area_id() const;
  inline void set_online_area_id(::google::protobuf::uint32 value);

  // required uint32 population = 2;
  inline bool has_population() const;
  inline void clear_population();
  static const int kPopulationFieldNumber = 2;
  inline ::google::protobuf::uint32 population() const;
  inline void set_population(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestGetRightMatchingAreaResponse.Area_info)
 private:
  inline void set_has_online_area_id();
  inline void clear_has_online_area_id();
  inline void set_has_population();
  inline void clear_has_population();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 online_area_id_;
  ::google::protobuf::uint32 population_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestGetRightMatchingAreaResponse_Area_info* default_instance_;
};
// -------------------------------------------------------------------

class RequestGetRightMatchingAreaResponse : public ::google::protobuf::MessageLite {
 public:
  RequestGetRightMatchingAreaResponse();
  virtual ~RequestGetRightMatchingAreaResponse();

  RequestGetRightMatchingAreaResponse(const RequestGetRightMatchingAreaResponse& from);

  inline RequestGetRightMatchingAreaResponse& operator=(const RequestGetRightMatchingAreaResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestGetRightMatchingAreaResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestGetRightMatchingAreaResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestGetRightMatchingAreaResponse* other);

  // implements Message ----------------------------------------------

  RequestGetRightMatchingAreaResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestGetRightMatchingAreaResponse& from);
  void MergeFrom(const RequestGetRightMatchingAreaResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef RequestGetRightMatchingAreaResponse_Area_info Area_info;

  // accessors -------------------------------------------------------

  // repeated group Area_info = 1 {
  inline int area_info_size() const;
  inline void clear_area_info();
  static const int kAreaInfoFieldNumber = 1;
  inline const ::DS3_Frpg2RequestMessage::RequestGetRightMatchingAreaResponse_Area_info& area_info(int index) const;
  inline ::DS3_Frpg2RequestMessage::RequestGetRightMatchingAreaResponse_Area_info* mutable_area_info(int index);
  inline ::DS3_Frpg2RequestMessage::RequestGetRightMatchingAreaResponse_Area_info* add_area_info();
  inline const ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::RequestGetRightMatchingAreaResponse_Area_info >&
      area_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::RequestGetRightMatchingAreaResponse_Area_info >*
      mutable_area_info();

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestGetRightMatchingAreaResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::RequestGetRightMatchingAreaResponse_Area_info > area_info_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestGetRightMatchingAreaResponse* default_instance_;
};
// -------------------------------------------------------------------

class PushRequestRemoveSign : public ::google::protobuf::MessageLite {
 public:
  PushRequestRemoveSign();
  virtual ~PushRequestRemoveSign();

  PushRequestRemoveSign(const PushRequestRemoveSign& from);

  inline PushRequestRemoveSign& operator=(const PushRequestRemoveSign& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const PushRequestRemoveSign& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PushRequestRemoveSign* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PushRequestRemoveSign* other);

  // implements Message ----------------------------------------------

  PushRequestRemoveSign* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PushRequestRemoveSign& from);
  void MergeFrom(const PushRequestRemoveSign& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
  inline bool has_push_message_id() const;
  inline void clear_push_message_id();
  static const int kPushMessageIdFieldNumber = 1;
  inline ::DS3_Frpg2RequestMessage::PushMessageId push_message_id() const;
  inline void set_push_message_id(::DS3_Frpg2RequestMessage::PushMessageId value);

  // required .DS3_Frpg2RequestMessage.RemoveSignMessage message = 2;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 2;
  inline const ::DS3_Frpg2RequestMessage::RemoveSignMessage& message() const;
  inline ::DS3_Frpg2RequestMessage::RemoveSignMessage* mutable_message();
  inline ::DS3_Frpg2RequestMessage::RemoveSignMessage* release_message();
  inline void set_allocated_message(::DS3_Frpg2RequestMessage::RemoveSignMessage* message);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.PushRequestRemoveSign)
 private:
  inline void set_has_push_message_id();
  inline void clear_has_push_message_id();
  inline void set_has_message();
  inline void clear_has_message();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::DS3_Frpg2RequestMessage::RemoveSignMessage* message_;
  int push_message_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static PushRequestRemoveSign* default_instance_;
};
// -------------------------------------------------------------------

class PushRequestSummonSign : public ::google::protobuf::MessageLite {
 public:
  PushRequestSummonSign();
  virtual ~PushRequestSummonSign();

  PushRequestSummonSign(const PushRequestSummonSign& from);

  inline PushRequestSummonSign& operator=(const PushRequestSummonSign& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const PushRequestSummonSign& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PushRequestSummonSign* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PushRequestSummonSign* other);

  // implements Message ----------------------------------------------

  PushRequestSummonSign* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PushRequestSummonSign& from);
  void MergeFrom(const PushRequestSummonSign& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
  inline bool has_push_message_id() const;
  inline void clear_push_message_id();
  static const int kPushMessageIdFieldNumber = 1;
  inline ::DS3_Frpg2RequestMessage::PushMessageId push_message_id() const;
  inline void set_push_message_id(::DS3_Frpg2RequestMessage::PushMessageId value);

  // required .DS3_Frpg2RequestMessage.SummonSignMessage message = 2;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 2;
  inline const ::DS3_Frpg2RequestMessage::SummonSignMessage& message() const;
  inline ::DS3_Frpg2RequestMessage::SummonSignMessage* mutable_message();
  inline ::DS3_Frpg2RequestMessage::SummonSignMessage* release_message();
  inline void set_allocated_message(::DS3_Frpg2RequestMessage::SummonSignMessage* message);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.PushRequestSummonSign)
 private:
  inline void set_has_push_message_id();
  inline void clear_has_push_message_id();
  inline void set_has_message();
  inline void clear_has_message();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::DS3_Frpg2RequestMessage::SummonSignMessage* message_;
  int push_message_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static PushRequestSummonSign* default_instance_;
};
// -------------------------------------------------------------------

class PushRequestRejectSign : public ::google::protobuf::MessageLite {
 public:
  PushRequestRejectSign();
  virtual ~PushRequestRejectSign();

  PushRequestRejectSign(const PushRequestRejectSign& from);

  inline PushRequestRejectSign& operator=(const PushRequestRejectSign& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const PushRequestRejectSign& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PushRequestRejectSign* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PushRequestRejectSign* other);

  // implements Message ----------------------------------------------

  PushRequestRejectSign* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PushRequestRejectSign& from);
  void MergeFrom(const PushRequestRejectSign& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
  inline bool has_push_message_id() const;
  inline void clear_push_message_id();
  static const int kPushMessageIdFieldNumber = 1;
  inline ::DS3_Frpg2RequestMessage::PushMessageId push_message_id() const;
  inline void set_push_message_id(::DS3_Frpg2RequestMessage::PushMessageId value);

  // required .DS3_Frpg2RequestMessage.RejectSignMessage message = 2;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 2;
  inline const ::DS3_Frpg2RequestMessage::RejectSignMessage& message() const;
  inline ::DS3_Frpg2RequestMessage::RejectSignMessage* mutable_message();
  inline ::DS3_Frpg2RequestMessage::RejectSignMessage* release_message();
  inline void set_allocated_message(::DS3_Frpg2RequestMessage::RejectSignMessage* message);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.PushRequestRejectSign)
 private:
  inline void set_has_push_message_id();
  inline void clear_has_push_message_id();
  inline void set_has_message();
  inline void clear_has_message();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::DS3_Frpg2RequestMessage::RejectSignMessage* message_;
  int push_message_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static PushRequestRejectSign* default_instance_;
};
// -------------------------------------------------------------------

class BreakInTargetData : public ::google::protobuf::MessageLite {
 public:
  BreakInTargetData();
  virtual ~BreakInTargetData();

  BreakInTargetData(const BreakInTargetData& from);

  inline BreakInTargetData& operator=(const BreakInTargetData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const BreakInTargetData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BreakInTargetData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BreakInTargetData* other);

  // implements Message ----------------------------------------------

  BreakInTargetData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BreakInTargetData& from);
  void MergeFrom(const BreakInTargetData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 player_id = 1;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 1;
  inline ::google::protobuf::uint32 player_id() const;
  inline void set_player_id(::google::protobuf::uint32 value);

  // required string steam_id = 2;
  inline bool has_steam_id() const;
  inline void clear_steam_id();
  static const int kSteamIdFieldNumber = 2;
  inline const ::std::string& steam_id() const;
  inline void set_steam_id(const ::std::string& value);
  inline void set_steam_id(const char* value);
  inline void set_steam_id(const char* value, size_t size);
  inline ::std::string* mutable_steam_id();
  inline ::std::string* release_steam_id();
  inline void set_allocated_steam_id(::std::string* steam_id);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.BreakInTargetData)
 private:
  inline void set_has_player_id();
  inline void clear_has_player_id();
  inline void set_has_steam_id();
  inline void clear_has_steam_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* steam_id_;
  ::google::protobuf::uint32 player_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static BreakInTargetData* default_instance_;
};
// -------------------------------------------------------------------

class RequestGetBreakInTargetList : public ::google::protobuf::MessageLite {
 public:
  RequestGetBreakInTargetList();
  virtual ~RequestGetBreakInTargetList();

  RequestGetBreakInTargetList(const RequestGetBreakInTargetList& from);

  inline RequestGetBreakInTargetList& operator=(const RequestGetBreakInTargetList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestGetBreakInTargetList& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestGetBreakInTargetList* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestGetBreakInTargetList* other);

  // implements Message ----------------------------------------------

  RequestGetBreakInTargetList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestGetBreakInTargetList& from);
  void MergeFrom(const RequestGetBreakInTargetList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 map_id = 1;
  inline bool has_map_id() const;
  inline void clear_map_id();
  static const int kMapIdFieldNumber = 1;
  inline ::google::protobuf::uint32 map_id() const;
  inline void set_map_id(::google::protobuf::uint32 value);

  // required uint32 online_area_id = 2;
  inline bool has_online_area_id() const;
  inline void clear_online_area_id();
  static const int kOnlineAreaIdFieldNumber = 2;
  inline ::google::protobuf::uint32 online_area_id() const;
  inline void set_online_area_id(::google::protobuf::uint32 value);

  // required uint32 max_targets = 3;
  inline bool has_max_targets() const;
  inline void clear_max_targets();
  static const int kMaxTargetsFieldNumber = 3;
  inline ::google::protobuf::uint32 max_targets() const;
  inline void set_max_targets(::google::protobuf::uint32 value);

  // required .DS3_Frpg2RequestMessage.MatchingParameter matching_parameter = 4;
  inline bool has_matching_parameter() const;
  inline void clear_matching_parameter();
  static const int kMatchingParameterFieldNumber = 4;
  inline const ::DS3_Frpg2RequestMessage::MatchingParameter& matching_parameter() const;
  inline ::DS3_Frpg2RequestMessage::MatchingParameter* mutable_matching_parameter();
  inline ::DS3_Frpg2RequestMessage::MatchingParameter* release_matching_parameter();
  inline void set_allocated_matching_parameter(::DS3_Frpg2RequestMessage::MatchingParameter* matching_parameter);

  // required uint32 unknown_5 = 5;
  inline bool has_unknown_5() const;
  inline void clear_unknown_5();
  static const int kUnknown5FieldNumber = 5;
  inline ::google::protobuf::uint32 unknown_5() const;
  inline void set_unknown_5(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestGetBreakInTargetList)
 private:
  inline void set_has_map_id();
  inline void clear_has_map_id();
  inline void set_has_online_area_id();
  inline void clear_has_online_area_id();
  inline void set_has_max_targets();
  inline void clear_has_max_targets();
  inline void set_has_matching_parameter();
  inline void clear_has_matching_parameter();
  inline void set_has_unknown_5();
  inline void clear_has_unknown_5();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 map_id_;
  ::google::protobuf::uint32 online_area_id_;
  ::DS3_Frpg2RequestMessage::MatchingParameter* matching_parameter_;
  ::google::protobuf::uint32 max_targets_;
  ::google::protobuf::uint32 unknown_5_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestGetBreakInTargetList* default_instance_;
};
// -------------------------------------------------------------------

class RequestGetBreakInTargetListResponse : public ::google::protobuf::MessageLite {
 public:
  RequestGetBreakInTargetListResponse();
  virtual ~RequestGetBreakInTargetListResponse();

  RequestGetBreakInTargetListResponse(const RequestGetBreakInTargetListResponse& from);

  inline RequestGetBreakInTargetListResponse& operator=(const RequestGetBreakInTargetListResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestGetBreakInTargetListResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestGetBreakInTargetListResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestGetBreakInTargetListResponse* other);

  // implements Message ----------------------------------------------

  RequestGetBreakInTargetListResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestGetBreakInTargetListResponse& from);
  void MergeFrom(const RequestGetBreakInTargetListResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 map_id = 1;
  inline bool has_map_id() const;
  inline void clear_map_id();
  static const int kMapIdFieldNumber = 1;
  inline ::google::protobuf::uint32 map_id() const;
  inline void set_map_id(::google::protobuf::uint32 value);

  // optional uint32 online_area_id = 2;
  inline bool has_online_area_id() const;
  inline void clear_online_area_id();
  static const int kOnlineAreaIdFieldNumber = 2;
  inline ::google::protobuf::uint32 online_area_id() const;
  inline void set_online_area_id(::google::protobuf::uint32 value);

  // repeated .DS3_Frpg2RequestMessage.BreakInTargetData target_data = 3;
  inline int target_data_size() const;
  inline void clear_target_data();
  static const int kTargetDataFieldNumber = 3;
  inline const ::DS3_Frpg2RequestMessage::BreakInTargetData& target_data(int index) const;
  inline ::DS3_Frpg2RequestMessage::BreakInTargetData* mutable_target_data(int index);
  inline ::DS3_Frpg2RequestMessage::BreakInTargetData* add_target_data();
  inline const ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::BreakInTargetData >&
      target_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::BreakInTargetData >*
      mutable_target_data();

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestGetBreakInTargetListResponse)
 private:
  inline void set_has_map_id();
  inline void clear_has_map_id();
  inline void set_has_online_area_id();
  inline void clear_has_online_area_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 map_id_;
  ::google::protobuf::uint32 online_area_id_;
  ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::BreakInTargetData > target_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestGetBreakInTargetListResponse* default_instance_;
};
// -------------------------------------------------------------------

class PushRequestAllowBreakInTarget : public ::google::protobuf::MessageLite {
 public:
  PushRequestAllowBreakInTarget();
  virtual ~PushRequestAllowBreakInTarget();

  PushRequestAllowBreakInTarget(const PushRequestAllowBreakInTarget& from);

  inline PushRequestAllowBreakInTarget& operator=(const PushRequestAllowBreakInTarget& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const PushRequestAllowBreakInTarget& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PushRequestAllowBreakInTarget* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PushRequestAllowBreakInTarget* other);

  // implements Message ----------------------------------------------

  PushRequestAllowBreakInTarget* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PushRequestAllowBreakInTarget& from);
  void MergeFrom(const PushRequestAllowBreakInTarget& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
  inline bool has_push_message_id() const;
  inline void clear_push_message_id();
  static const int kPushMessageIdFieldNumber = 1;
  inline ::DS3_Frpg2RequestMessage::PushMessageId push_message_id() const;
  inline void set_push_message_id(::DS3_Frpg2RequestMessage::PushMessageId value);

  // required uint32 player_id = 2;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 2;
  inline ::google::protobuf::uint32 player_id() const;
  inline void set_player_id(::google::protobuf::uint32 value);

  // required bytes player_struct = 3;
  inline bool has_player_struct() const;
  inline void clear_player_struct();
  static const int kPlayerStructFieldNumber = 3;
  inline const ::std::string& player_struct() const;
  inline void set_player_struct(const ::std::string& value);
  inline void set_player_struct(const char* value);
  inline void set_player_struct(const void* value, size_t size);
  inline ::std::string* mutable_player_struct();
  inline ::std::string* release_player_struct();
  inline void set_allocated_player_struct(::std::string* player_struct);

  // required uint32 unknown_4 = 4;
  inline bool has_unknown_4() const;
  inline void clear_unknown_4();
  static const int kUnknown4FieldNumber = 4;
  inline ::google::protobuf::uint32 unknown_4() const;
  inline void set_unknown_4(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.PushRequestAllowBreakInTarget)
 private:
  inline void set_has_push_message_id();
  inline void clear_has_push_message_id();
  inline void set_has_player_id();
  inline void clear_has_player_id();
  inline void set_has_player_struct();
  inline void clear_has_player_struct();
  inline void set_has_unknown_4();
  inline void clear_has_unknown_4();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int push_message_id_;
  ::google::protobuf::uint32 player_id_;
  ::std::string* player_struct_;
  ::google::protobuf::uint32 unknown_4_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static PushRequestAllowBreakInTarget* default_instance_;
};
// -------------------------------------------------------------------

class PushRequestBreakInTarget : public ::google::protobuf::MessageLite {
 public:
  PushRequestBreakInTarget();
  virtual ~PushRequestBreakInTarget();

  PushRequestBreakInTarget(const PushRequestBreakInTarget& from);

  inline PushRequestBreakInTarget& operator=(const PushRequestBreakInTarget& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const PushRequestBreakInTarget& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PushRequestBreakInTarget* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PushRequestBreakInTarget* other);

  // implements Message ----------------------------------------------

  PushRequestBreakInTarget* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PushRequestBreakInTarget& from);
  void MergeFrom(const PushRequestBreakInTarget& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
  inline bool has_push_message_id() const;
  inline void clear_push_message_id();
  static const int kPushMessageIdFieldNumber = 1;
  inline ::DS3_Frpg2RequestMessage::PushMessageId push_message_id() const;
  inline void set_push_message_id(::DS3_Frpg2RequestMessage::PushMessageId value);

  // required uint32 player_id = 2;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 2;
  inline ::google::protobuf::uint32 player_id() const;
  inline void set_player_id(::google::protobuf::uint32 value);

  // required string steam_id = 3;
  inline bool has_steam_id() const;
  inline void clear_steam_id();
  static const int kSteamIdFieldNumber = 3;
  inline const ::std::string& steam_id() const;
  inline void set_steam_id(const ::std::string& value);
  inline void set_steam_id(const char* value);
  inline void set_steam_id(const char* value, size_t size);
  inline ::std::string* mutable_steam_id();
  inline ::std::string* release_steam_id();
  inline void set_allocated_steam_id(::std::string* steam_id);

  // required uint32 unknown_4 = 4;
  inline bool has_unknown_4() const;
  inline void clear_unknown_4();
  static const int kUnknown4FieldNumber = 4;
  inline ::google::protobuf::uint32 unknown_4() const;
  inline void set_unknown_4(::google::protobuf::uint32 value);

  // required uint32 map_id = 5;
  inline bool has_map_id() const;
  inline void clear_map_id();
  static const int kMapIdFieldNumber = 5;
  inline ::google::protobuf::uint32 map_id() const;
  inline void set_map_id(::google::protobuf::uint32 value);

  // required uint32 online_area_id = 6;
  inline bool has_online_area_id() const;
  inline void clear_online_area_id();
  static const int kOnlineAreaIdFieldNumber = 6;
  inline ::google::protobuf::uint32 online_area_id() const;
  inline void set_online_area_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.PushRequestBreakInTarget)
 private:
  inline void set_has_push_message_id();
  inline void clear_has_push_message_id();
  inline void set_has_player_id();
  inline void clear_has_player_id();
  inline void set_has_steam_id();
  inline void clear_has_steam_id();
  inline void set_has_unknown_4();
  inline void clear_has_unknown_4();
  inline void set_has_map_id();
  inline void clear_has_map_id();
  inline void set_has_online_area_id();
  inline void clear_has_online_area_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int push_message_id_;
  ::google::protobuf::uint32 player_id_;
  ::std::string* steam_id_;
  ::google::protobuf::uint32 unknown_4_;
  ::google::protobuf::uint32 map_id_;
  ::google::protobuf::uint32 online_area_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static PushRequestBreakInTarget* default_instance_;
};
// -------------------------------------------------------------------

class PushRequestRemoveBreakInTarget : public ::google::protobuf::MessageLite {
 public:
  PushRequestRemoveBreakInTarget();
  virtual ~PushRequestRemoveBreakInTarget();

  PushRequestRemoveBreakInTarget(const PushRequestRemoveBreakInTarget& from);

  inline PushRequestRemoveBreakInTarget& operator=(const PushRequestRemoveBreakInTarget& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const PushRequestRemoveBreakInTarget& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PushRequestRemoveBreakInTarget* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PushRequestRemoveBreakInTarget* other);

  // implements Message ----------------------------------------------

  PushRequestRemoveBreakInTarget* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PushRequestRemoveBreakInTarget& from);
  void MergeFrom(const PushRequestRemoveBreakInTarget& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
  inline bool has_push_message_id() const;
  inline void clear_push_message_id();
  static const int kPushMessageIdFieldNumber = 1;
  inline ::DS3_Frpg2RequestMessage::PushMessageId push_message_id() const;
  inline void set_push_message_id(::DS3_Frpg2RequestMessage::PushMessageId value);

  // required uint32 unknown_2 = 2;
  inline bool has_unknown_2() const;
  inline void clear_unknown_2();
  static const int kUnknown2FieldNumber = 2;
  inline ::google::protobuf::uint32 unknown_2() const;
  inline void set_unknown_2(::google::protobuf::uint32 value);

  // required string unknown_3 = 3;
  inline bool has_unknown_3() const;
  inline void clear_unknown_3();
  static const int kUnknown3FieldNumber = 3;
  inline const ::std::string& unknown_3() const;
  inline void set_unknown_3(const ::std::string& value);
  inline void set_unknown_3(const char* value);
  inline void set_unknown_3(const char* value, size_t size);
  inline ::std::string* mutable_unknown_3();
  inline ::std::string* release_unknown_3();
  inline void set_allocated_unknown_3(::std::string* unknown_3);

  // required uint32 unknown_4 = 4;
  inline bool has_unknown_4() const;
  inline void clear_unknown_4();
  static const int kUnknown4FieldNumber = 4;
  inline ::google::protobuf::uint32 unknown_4() const;
  inline void set_unknown_4(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.PushRequestRemoveBreakInTarget)
 private:
  inline void set_has_push_message_id();
  inline void clear_has_push_message_id();
  inline void set_has_unknown_2();
  inline void clear_has_unknown_2();
  inline void set_has_unknown_3();
  inline void clear_has_unknown_3();
  inline void set_has_unknown_4();
  inline void clear_has_unknown_4();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int push_message_id_;
  ::google::protobuf::uint32 unknown_2_;
  ::std::string* unknown_3_;
  ::google::protobuf::uint32 unknown_4_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static PushRequestRemoveBreakInTarget* default_instance_;
};
// -------------------------------------------------------------------

class RequestBreakInTarget : public ::google::protobuf::MessageLite {
 public:
  RequestBreakInTarget();
  virtual ~RequestBreakInTarget();

  RequestBreakInTarget(const RequestBreakInTarget& from);

  inline RequestBreakInTarget& operator=(const RequestBreakInTarget& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestBreakInTarget& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestBreakInTarget* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestBreakInTarget* other);

  // implements Message ----------------------------------------------

  RequestBreakInTarget* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestBreakInTarget& from);
  void MergeFrom(const RequestBreakInTarget& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 map_id = 1;
  inline bool has_map_id() const;
  inline void clear_map_id();
  static const int kMapIdFieldNumber = 1;
  inline ::google::protobuf::uint32 map_id() const;
  inline void set_map_id(::google::protobuf::uint32 value);

  // required uint32 online_area_id = 2;
  inline bool has_online_area_id() const;
  inline void clear_online_area_id();
  static const int kOnlineAreaIdFieldNumber = 2;
  inline ::google::protobuf::uint32 online_area_id() const;
  inline void set_online_area_id(::google::protobuf::uint32 value);

  // required uint32 player_id = 3;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 3;
  inline ::google::protobuf::uint32 player_id() const;
  inline void set_player_id(::google::protobuf::uint32 value);

  // required uint32 unknown_4 = 4;
  inline bool has_unknown_4() const;
  inline void clear_unknown_4();
  static const int kUnknown4FieldNumber = 4;
  inline ::google::protobuf::uint32 unknown_4() const;
  inline void set_unknown_4(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestBreakInTarget)
 private:
  inline void set_has_map_id();
  inline void clear_has_map_id();
  inline void set_has_online_area_id();
  inline void clear_has_online_area_id();
  inline void set_has_player_id();
  inline void clear_has_player_id();
  inline void set_has_unknown_4();
  inline void clear_has_unknown_4();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 map_id_;
  ::google::protobuf::uint32 online_area_id_;
  ::google::protobuf::uint32 player_id_;
  ::google::protobuf::uint32 unknown_4_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestBreakInTarget* default_instance_;
};
// -------------------------------------------------------------------

class RequestRejectBreakInTarget : public ::google::protobuf::MessageLite {
 public:
  RequestRejectBreakInTarget();
  virtual ~RequestRejectBreakInTarget();

  RequestRejectBreakInTarget(const RequestRejectBreakInTarget& from);

  inline RequestRejectBreakInTarget& operator=(const RequestRejectBreakInTarget& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestRejectBreakInTarget& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestRejectBreakInTarget* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestRejectBreakInTarget* other);

  // implements Message ----------------------------------------------

  RequestRejectBreakInTarget* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestRejectBreakInTarget& from);
  void MergeFrom(const RequestRejectBreakInTarget& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 player_id = 1;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 1;
  inline ::google::protobuf::uint32 player_id() const;
  inline void set_player_id(::google::protobuf::uint32 value);

  // required uint32 unknown_2 = 2;
  inline bool has_unknown_2() const;
  inline void clear_unknown_2();
  static const int kUnknown2FieldNumber = 2;
  inline ::google::protobuf::uint32 unknown_2() const;
  inline void set_unknown_2(::google::protobuf::uint32 value);

  // required uint32 map_id = 3;
  inline bool has_map_id() const;
  inline void clear_map_id();
  static const int kMapIdFieldNumber = 3;
  inline ::google::protobuf::uint32 map_id() const;
  inline void set_map_id(::google::protobuf::uint32 value);

  // required uint32 online_area_id = 4;
  inline bool has_online_area_id() const;
  inline void clear_online_area_id();
  static const int kOnlineAreaIdFieldNumber = 4;
  inline ::google::protobuf::uint32 online_area_id() const;
  inline void set_online_area_id(::google::protobuf::uint32 value);

  // required uint32 unknown_5 = 5;
  inline bool has_unknown_5() const;
  inline void clear_unknown_5();
  static const int kUnknown5FieldNumber = 5;
  inline ::google::protobuf::uint32 unknown_5() const;
  inline void set_unknown_5(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestRejectBreakInTarget)
 private:
  inline void set_has_player_id();
  inline void clear_has_player_id();
  inline void set_has_unknown_2();
  inline void clear_has_unknown_2();
  inline void set_has_map_id();
  inline void clear_has_map_id();
  inline void set_has_online_area_id();
  inline void clear_has_online_area_id();
  inline void set_has_unknown_5();
  inline void clear_has_unknown_5();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 player_id_;
  ::google::protobuf::uint32 unknown_2_;
  ::google::protobuf::uint32 map_id_;
  ::google::protobuf::uint32 online_area_id_;
  ::google::protobuf::uint32 unknown_5_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestRejectBreakInTarget* default_instance_;
};
// -------------------------------------------------------------------

class PushRequestRejectBreakInTarget : public ::google::protobuf::MessageLite {
 public:
  PushRequestRejectBreakInTarget();
  virtual ~PushRequestRejectBreakInTarget();

  PushRequestRejectBreakInTarget(const PushRequestRejectBreakInTarget& from);

  inline PushRequestRejectBreakInTarget& operator=(const PushRequestRejectBreakInTarget& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const PushRequestRejectBreakInTarget& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PushRequestRejectBreakInTarget* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PushRequestRejectBreakInTarget* other);

  // implements Message ----------------------------------------------

  PushRequestRejectBreakInTarget* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PushRequestRejectBreakInTarget& from);
  void MergeFrom(const PushRequestRejectBreakInTarget& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
  inline bool has_push_message_id() const;
  inline void clear_push_message_id();
  static const int kPushMessageIdFieldNumber = 1;
  inline ::DS3_Frpg2RequestMessage::PushMessageId push_message_id() const;
  inline void set_push_message_id(::DS3_Frpg2RequestMessage::PushMessageId value);

  // required uint32 player_id = 2;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 2;
  inline ::google::protobuf::uint32 player_id() const;
  inline void set_player_id(::google::protobuf::uint32 value);

  // required uint32 unknown_3 = 3;
  inline bool has_unknown_3() const;
  inline void clear_unknown_3();
  static const int kUnknown3FieldNumber = 3;
  inline ::google::protobuf::uint32 unknown_3() const;
  inline void set_unknown_3(::google::protobuf::uint32 value);

  // required string steam_id = 4;
  inline bool has_steam_id() const;
  inline void clear_steam_id();
  static const int kSteamIdFieldNumber = 4;
  inline const ::std::string& steam_id() const;
  inline void set_steam_id(const ::std::string& value);
  inline void set_steam_id(const char* value);
  inline void set_steam_id(const char* value, size_t size);
  inline ::std::string* mutable_steam_id();
  inline ::std::string* release_steam_id();
  inline void set_allocated_steam_id(::std::string* steam_id);

  // required uint32 unknown_5 = 5;
  inline bool has_unknown_5() const;
  inline void clear_unknown_5();
  static const int kUnknown5FieldNumber = 5;
  inline ::google::protobuf::uint32 unknown_5() const;
  inline void set_unknown_5(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.PushRequestRejectBreakInTarget)
 private:
  inline void set_has_push_message_id();
  inline void clear_has_push_message_id();
  inline void set_has_player_id();
  inline void clear_has_player_id();
  inline void set_has_unknown_3();
  inline void clear_has_unknown_3();
  inline void set_has_steam_id();
  inline void clear_has_steam_id();
  inline void set_has_unknown_5();
  inline void clear_has_unknown_5();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int push_message_id_;
  ::google::protobuf::uint32 player_id_;
  ::std::string* steam_id_;
  ::google::protobuf::uint32 unknown_3_;
  ::google::protobuf::uint32 unknown_5_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static PushRequestRejectBreakInTarget* default_instance_;
};
// -------------------------------------------------------------------

class RequestBreakInTargetResponse : public ::google::protobuf::MessageLite {
 public:
  RequestBreakInTargetResponse();
  virtual ~RequestBreakInTargetResponse();

  RequestBreakInTargetResponse(const RequestBreakInTargetResponse& from);

  inline RequestBreakInTargetResponse& operator=(const RequestBreakInTargetResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestBreakInTargetResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestBreakInTargetResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestBreakInTargetResponse* other);

  // implements Message ----------------------------------------------

  RequestBreakInTargetResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestBreakInTargetResponse& from);
  void MergeFrom(const RequestBreakInTargetResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestBreakInTargetResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestBreakInTargetResponse* default_instance_;
};
// -------------------------------------------------------------------

class RequestRejectBreakInTargetResponse : public ::google::protobuf::MessageLite {
 public:
  RequestRejectBreakInTargetResponse();
  virtual ~RequestRejectBreakInTargetResponse();

  RequestRejectBreakInTargetResponse(const RequestRejectBreakInTargetResponse& from);

  inline RequestRejectBreakInTargetResponse& operator=(const RequestRejectBreakInTargetResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestRejectBreakInTargetResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestRejectBreakInTargetResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestRejectBreakInTargetResponse* other);

  // implements Message ----------------------------------------------

  RequestRejectBreakInTargetResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestRejectBreakInTargetResponse& from);
  void MergeFrom(const RequestRejectBreakInTargetResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestRejectBreakInTargetResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestRejectBreakInTargetResponse* default_instance_;
};
// -------------------------------------------------------------------

class RequestGetGhostDataList : public ::google::protobuf::MessageLite {
 public:
  RequestGetGhostDataList();
  virtual ~RequestGetGhostDataList();

  RequestGetGhostDataList(const RequestGetGhostDataList& from);

  inline RequestGetGhostDataList& operator=(const RequestGetGhostDataList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestGetGhostDataList& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestGetGhostDataList* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestGetGhostDataList* other);

  // implements Message ----------------------------------------------

  RequestGetGhostDataList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestGetGhostDataList& from);
  void MergeFrom(const RequestGetGhostDataList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 max_ghosts = 1;
  inline bool has_max_ghosts() const;
  inline void clear_max_ghosts();
  static const int kMaxGhostsFieldNumber = 1;
  inline ::google::protobuf::uint32 max_ghosts() const;
  inline void set_max_ghosts(::google::protobuf::uint32 value);

  // repeated .DS3_Frpg2RequestMessage.DomainLimitData search_areas = 2;
  inline int search_areas_size() const;
  inline void clear_search_areas();
  static const int kSearchAreasFieldNumber = 2;
  inline const ::DS3_Frpg2RequestMessage::DomainLimitData& search_areas(int index) const;
  inline ::DS3_Frpg2RequestMessage::DomainLimitData* mutable_search_areas(int index);
  inline ::DS3_Frpg2RequestMessage::DomainLimitData* add_search_areas();
  inline const ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::DomainLimitData >&
      search_areas() const;
  inline ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::DomainLimitData >*
      mutable_search_areas();

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestGetGhostDataList)
 private:
  inline void set_has_max_ghosts();
  inline void clear_has_max_ghosts();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::DomainLimitData > search_areas_;
  ::google::protobuf::uint32 max_ghosts_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestGetGhostDataList* default_instance_;
};
// -------------------------------------------------------------------

class GhostData : public ::google::protobuf::MessageLite {
 public:
  GhostData();
  virtual ~GhostData();

  GhostData(const GhostData& from);

  inline GhostData& operator=(const GhostData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GhostData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GhostData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GhostData* other);

  // implements Message ----------------------------------------------

  GhostData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GhostData& from);
  void MergeFrom(const GhostData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 unknown_1 = 1;
  inline bool has_unknown_1() const;
  inline void clear_unknown_1();
  static const int kUnknown1FieldNumber = 1;
  inline ::google::protobuf::uint32 unknown_1() const;
  inline void set_unknown_1(::google::protobuf::uint32 value);

  // required uint32 ghost_id = 2;
  inline bool has_ghost_id() const;
  inline void clear_ghost_id();
  static const int kGhostIdFieldNumber = 2;
  inline ::google::protobuf::uint32 ghost_id() const;
  inline void set_ghost_id(::google::protobuf::uint32 value);

  // required bytes data = 3;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 3;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.GhostData)
 private:
  inline void set_has_unknown_1();
  inline void clear_has_unknown_1();
  inline void set_has_ghost_id();
  inline void clear_has_ghost_id();
  inline void set_has_data();
  inline void clear_has_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 unknown_1_;
  ::google::protobuf::uint32 ghost_id_;
  ::std::string* data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static GhostData* default_instance_;
};
// -------------------------------------------------------------------

class RequestCreateGhostData : public ::google::protobuf::MessageLite {
 public:
  RequestCreateGhostData();
  virtual ~RequestCreateGhostData();

  RequestCreateGhostData(const RequestCreateGhostData& from);

  inline RequestCreateGhostData& operator=(const RequestCreateGhostData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestCreateGhostData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestCreateGhostData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestCreateGhostData* other);

  // implements Message ----------------------------------------------

  RequestCreateGhostData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestCreateGhostData& from);
  void MergeFrom(const RequestCreateGhostData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 online_area_id = 1;
  inline bool has_online_area_id() const;
  inline void clear_online_area_id();
  static const int kOnlineAreaIdFieldNumber = 1;
  inline ::google::protobuf::uint32 online_area_id() const;
  inline void set_online_area_id(::google::protobuf::uint32 value);

  // required bytes data = 2;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestCreateGhostData)
 private:
  inline void set_has_online_area_id();
  inline void clear_has_online_area_id();
  inline void set_has_data();
  inline void clear_has_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* data_;
  ::google::protobuf::uint32 online_area_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestCreateGhostData* default_instance_;
};
// -------------------------------------------------------------------

class RequestCreateGhostDataResponse : public ::google::protobuf::MessageLite {
 public:
  RequestCreateGhostDataResponse();
  virtual ~RequestCreateGhostDataResponse();

  RequestCreateGhostDataResponse(const RequestCreateGhostDataResponse& from);

  inline RequestCreateGhostDataResponse& operator=(const RequestCreateGhostDataResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestCreateGhostDataResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestCreateGhostDataResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestCreateGhostDataResponse* other);

  // implements Message ----------------------------------------------

  RequestCreateGhostDataResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestCreateGhostDataResponse& from);
  void MergeFrom(const RequestCreateGhostDataResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestCreateGhostDataResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestCreateGhostDataResponse* default_instance_;
};
// -------------------------------------------------------------------

class RequestGetGhostDataListResponse : public ::google::protobuf::MessageLite {
 public:
  RequestGetGhostDataListResponse();
  virtual ~RequestGetGhostDataListResponse();

  RequestGetGhostDataListResponse(const RequestGetGhostDataListResponse& from);

  inline RequestGetGhostDataListResponse& operator=(const RequestGetGhostDataListResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestGetGhostDataListResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestGetGhostDataListResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestGetGhostDataListResponse* other);

  // implements Message ----------------------------------------------

  RequestGetGhostDataListResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestGetGhostDataListResponse& from);
  void MergeFrom(const RequestGetGhostDataListResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .DS3_Frpg2RequestMessage.GhostData ghosts = 1;
  inline int ghosts_size() const;
  inline void clear_ghosts();
  static const int kGhostsFieldNumber = 1;
  inline const ::DS3_Frpg2RequestMessage::GhostData& ghosts(int index) const;
  inline ::DS3_Frpg2RequestMessage::GhostData* mutable_ghosts(int index);
  inline ::DS3_Frpg2RequestMessage::GhostData* add_ghosts();
  inline const ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::GhostData >&
      ghosts() const;
  inline ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::GhostData >*
      mutable_ghosts();

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestGetGhostDataListResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::GhostData > ghosts_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestGetGhostDataListResponse* default_instance_;
};
// -------------------------------------------------------------------

class RequestGetVisitorList : public ::google::protobuf::MessageLite {
 public:
  RequestGetVisitorList();
  virtual ~RequestGetVisitorList();

  RequestGetVisitorList(const RequestGetVisitorList& from);

  inline RequestGetVisitorList& operator=(const RequestGetVisitorList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestGetVisitorList& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestGetVisitorList* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestGetVisitorList* other);

  // implements Message ----------------------------------------------

  RequestGetVisitorList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestGetVisitorList& from);
  void MergeFrom(const RequestGetVisitorList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 map_id = 1;
  inline bool has_map_id() const;
  inline void clear_map_id();
  static const int kMapIdFieldNumber = 1;
  inline ::google::protobuf::uint32 map_id() const;
  inline void set_map_id(::google::protobuf::uint32 value);

  // required uint32 online_area_id = 2;
  inline bool has_online_area_id() const;
  inline void clear_online_area_id();
  static const int kOnlineAreaIdFieldNumber = 2;
  inline ::google::protobuf::uint32 online_area_id() const;
  inline void set_online_area_id(::google::protobuf::uint32 value);

  // required uint32 max_visitors = 3;
  inline bool has_max_visitors() const;
  inline void clear_max_visitors();
  static const int kMaxVisitorsFieldNumber = 3;
  inline ::google::protobuf::uint32 max_visitors() const;
  inline void set_max_visitors(::google::protobuf::uint32 value);

  // required .DS3_Frpg2RequestMessage.MatchingParameter matching_parameter = 4;
  inline bool has_matching_parameter() const;
  inline void clear_matching_parameter();
  static const int kMatchingParameterFieldNumber = 4;
  inline const ::DS3_Frpg2RequestMessage::MatchingParameter& matching_parameter() const;
  inline ::DS3_Frpg2RequestMessage::MatchingParameter* mutable_matching_parameter();
  inline ::DS3_Frpg2RequestMessage::MatchingParameter* release_matching_parameter();
  inline void set_allocated_matching_parameter(::DS3_Frpg2RequestMessage::MatchingParameter* matching_parameter);

  // required .DS3_Frpg2RequestMessage.VisitorPool visitor_pool = 5;
  inline bool has_visitor_pool() const;
  inline void clear_visitor_pool();
  static const int kVisitorPoolFieldNumber = 5;
  inline ::DS3_Frpg2RequestMessage::VisitorPool visitor_pool() const;
  inline void set_visitor_pool(::DS3_Frpg2RequestMessage::VisitorPool value);

  // required uint32 unknown_6 = 6;
  inline bool has_unknown_6() const;
  inline void clear_unknown_6();
  static const int kUnknown6FieldNumber = 6;
  inline ::google::protobuf::uint32 unknown_6() const;
  inline void set_unknown_6(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestGetVisitorList)
 private:
  inline void set_has_map_id();
  inline void clear_has_map_id();
  inline void set_has_online_area_id();
  inline void clear_has_online_area_id();
  inline void set_has_max_visitors();
  inline void clear_has_max_visitors();
  inline void set_has_matching_parameter();
  inline void clear_has_matching_parameter();
  inline void set_has_visitor_pool();
  inline void clear_has_visitor_pool();
  inline void set_has_unknown_6();
  inline void clear_has_unknown_6();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 map_id_;
  ::google::protobuf::uint32 online_area_id_;
  ::DS3_Frpg2RequestMessage::MatchingParameter* matching_parameter_;
  ::google::protobuf::uint32 max_visitors_;
  int visitor_pool_;
  ::google::protobuf::uint32 unknown_6_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestGetVisitorList* default_instance_;
};
// -------------------------------------------------------------------

class VisitorData : public ::google::protobuf::MessageLite {
 public:
  VisitorData();
  virtual ~VisitorData();

  VisitorData(const VisitorData& from);

  inline VisitorData& operator=(const VisitorData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const VisitorData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const VisitorData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(VisitorData* other);

  // implements Message ----------------------------------------------

  VisitorData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const VisitorData& from);
  void MergeFrom(const VisitorData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 player_id = 1;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 1;
  inline ::google::protobuf::uint32 player_id() const;
  inline void set_player_id(::google::protobuf::uint32 value);

  // required string player_steam_id = 2;
  inline bool has_player_steam_id() const;
  inline void clear_player_steam_id();
  static const int kPlayerSteamIdFieldNumber = 2;
  inline const ::std::string& player_steam_id() const;
  inline void set_player_steam_id(const ::std::string& value);
  inline void set_player_steam_id(const char* value);
  inline void set_player_steam_id(const char* value, size_t size);
  inline ::std::string* mutable_player_steam_id();
  inline ::std::string* release_player_steam_id();
  inline void set_allocated_player_steam_id(::std::string* player_steam_id);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.VisitorData)
 private:
  inline void set_has_player_id();
  inline void clear_has_player_id();
  inline void set_has_player_steam_id();
  inline void clear_has_player_steam_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* player_steam_id_;
  ::google::protobuf::uint32 player_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static VisitorData* default_instance_;
};
// -------------------------------------------------------------------

class RequestGetVisitorListResponse : public ::google::protobuf::MessageLite {
 public:
  RequestGetVisitorListResponse();
  virtual ~RequestGetVisitorListResponse();

  RequestGetVisitorListResponse(const RequestGetVisitorListResponse& from);

  inline RequestGetVisitorListResponse& operator=(const RequestGetVisitorListResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestGetVisitorListResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestGetVisitorListResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestGetVisitorListResponse* other);

  // implements Message ----------------------------------------------

  RequestGetVisitorListResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestGetVisitorListResponse& from);
  void MergeFrom(const RequestGetVisitorListResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 map_id = 1;
  inline bool has_map_id() const;
  inline void clear_map_id();
  static const int kMapIdFieldNumber = 1;
  inline ::google::protobuf::uint32 map_id() const;
  inline void set_map_id(::google::protobuf::uint32 value);

  // required uint32 online_area_id = 2;
  inline bool has_online_area_id() const;
  inline void clear_online_area_id();
  static const int kOnlineAreaIdFieldNumber = 2;
  inline ::google::protobuf::uint32 online_area_id() const;
  inline void set_online_area_id(::google::protobuf::uint32 value);

  // repeated .DS3_Frpg2RequestMessage.VisitorData visitors = 3;
  inline int visitors_size() const;
  inline void clear_visitors();
  static const int kVisitorsFieldNumber = 3;
  inline const ::DS3_Frpg2RequestMessage::VisitorData& visitors(int index) const;
  inline ::DS3_Frpg2RequestMessage::VisitorData* mutable_visitors(int index);
  inline ::DS3_Frpg2RequestMessage::VisitorData* add_visitors();
  inline const ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::VisitorData >&
      visitors() const;
  inline ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::VisitorData >*
      mutable_visitors();

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestGetVisitorListResponse)
 private:
  inline void set_has_map_id();
  inline void clear_has_map_id();
  inline void set_has_online_area_id();
  inline void clear_has_online_area_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 map_id_;
  ::google::protobuf::uint32 online_area_id_;
  ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::VisitorData > visitors_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestGetVisitorListResponse* default_instance_;
};
// -------------------------------------------------------------------

class PushRequestRemoveVisitor : public ::google::protobuf::MessageLite {
 public:
  PushRequestRemoveVisitor();
  virtual ~PushRequestRemoveVisitor();

  PushRequestRemoveVisitor(const PushRequestRemoveVisitor& from);

  inline PushRequestRemoveVisitor& operator=(const PushRequestRemoveVisitor& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const PushRequestRemoveVisitor& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PushRequestRemoveVisitor* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PushRequestRemoveVisitor* other);

  // implements Message ----------------------------------------------

  PushRequestRemoveVisitor* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PushRequestRemoveVisitor& from);
  void MergeFrom(const PushRequestRemoveVisitor& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
  inline bool has_push_message_id() const;
  inline void clear_push_message_id();
  static const int kPushMessageIdFieldNumber = 1;
  inline ::DS3_Frpg2RequestMessage::PushMessageId push_message_id() const;
  inline void set_push_message_id(::DS3_Frpg2RequestMessage::PushMessageId value);

  // required uint32 player_id = 2;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 2;
  inline ::google::protobuf::uint32 player_id() const;
  inline void set_player_id(::google::protobuf::uint32 value);

  // required string player_steam_id = 3;
  inline bool has_player_steam_id() const;
  inline void clear_player_steam_id();
  static const int kPlayerSteamIdFieldNumber = 3;
  inline const ::std::string& player_steam_id() const;
  inline void set_player_steam_id(const ::std::string& value);
  inline void set_player_steam_id(const char* value);
  inline void set_player_steam_id(const char* value, size_t size);
  inline ::std::string* mutable_player_steam_id();
  inline ::std::string* release_player_steam_id();
  inline void set_allocated_player_steam_id(::std::string* player_steam_id);

  // required .DS3_Frpg2RequestMessage.VisitorPool visitor_pool = 4;
  inline bool has_visitor_pool() const;
  inline void clear_visitor_pool();
  static const int kVisitorPoolFieldNumber = 4;
  inline ::DS3_Frpg2RequestMessage::VisitorPool visitor_pool() const;
  inline void set_visitor_pool(::DS3_Frpg2RequestMessage::VisitorPool value);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.PushRequestRemoveVisitor)
 private:
  inline void set_has_push_message_id();
  inline void clear_has_push_message_id();
  inline void set_has_player_id();
  inline void clear_has_player_id();
  inline void set_has_player_steam_id();
  inline void clear_has_player_steam_id();
  inline void set_has_visitor_pool();
  inline void clear_has_visitor_pool();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int push_message_id_;
  ::google::protobuf::uint32 player_id_;
  ::std::string* player_steam_id_;
  int visitor_pool_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static PushRequestRemoveVisitor* default_instance_;
};
// -------------------------------------------------------------------

class RequestVisit : public ::google::protobuf::MessageLite {
 public:
  RequestVisit();
  virtual ~RequestVisit();

  RequestVisit(const RequestVisit& from);

  inline RequestVisit& operator=(const RequestVisit& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestVisit& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestVisit* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestVisit* other);

  // implements Message ----------------------------------------------

  RequestVisit* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestVisit& from);
  void MergeFrom(const RequestVisit& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 map_id = 1;
  inline bool has_map_id() const;
  inline void clear_map_id();
  static const int kMapIdFieldNumber = 1;
  inline ::google::protobuf::uint32 map_id() const;
  inline void set_map_id(::google::protobuf::uint32 value);

  // required uint32 online_area_id = 2;
  inline bool has_online_area_id() const;
  inline void clear_online_area_id();
  static const int kOnlineAreaIdFieldNumber = 2;
  inline ::google::protobuf::uint32 online_area_id() const;
  inline void set_online_area_id(::google::protobuf::uint32 value);

  // required .DS3_Frpg2RequestMessage.VisitorPool visitor_pool = 3;
  inline bool has_visitor_pool() const;
  inline void clear_visitor_pool();
  static const int kVisitorPoolFieldNumber = 3;
  inline ::DS3_Frpg2RequestMessage::VisitorPool visitor_pool() const;
  inline void set_visitor_pool(::DS3_Frpg2RequestMessage::VisitorPool value);

  // required uint32 player_id = 4;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 4;
  inline ::google::protobuf::uint32 player_id() const;
  inline void set_player_id(::google::protobuf::uint32 value);

  // required bytes data = 5;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 5;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestVisit)
 private:
  inline void set_has_map_id();
  inline void clear_has_map_id();
  inline void set_has_online_area_id();
  inline void clear_has_online_area_id();
  inline void set_has_visitor_pool();
  inline void clear_has_visitor_pool();
  inline void set_has_player_id();
  inline void clear_has_player_id();
  inline void set_has_data();
  inline void clear_has_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 map_id_;
  ::google::protobuf::uint32 online_area_id_;
  int visitor_pool_;
  ::google::protobuf::uint32 player_id_;
  ::std::string* data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestVisit* default_instance_;
};
// -------------------------------------------------------------------

class PushRequestVisit : public ::google::protobuf::MessageLite {
 public:
  PushRequestVisit();
  virtual ~PushRequestVisit();

  PushRequestVisit(const PushRequestVisit& from);

  inline PushRequestVisit& operator=(const PushRequestVisit& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const PushRequestVisit& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PushRequestVisit* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PushRequestVisit* other);

  // implements Message ----------------------------------------------

  PushRequestVisit* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PushRequestVisit& from);
  void MergeFrom(const PushRequestVisit& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
  inline bool has_push_message_id() const;
  inline void clear_push_message_id();
  static const int kPushMessageIdFieldNumber = 1;
  inline ::DS3_Frpg2RequestMessage::PushMessageId push_message_id() const;
  inline void set_push_message_id(::DS3_Frpg2RequestMessage::PushMessageId value);

  // required uint32 player_id = 2;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 2;
  inline ::google::protobuf::uint32 player_id() const;
  inline void set_player_id(::google::protobuf::uint32 value);

  // required string player_steam_id = 3;
  inline bool has_player_steam_id() const;
  inline void clear_player_steam_id();
  static const int kPlayerSteamIdFieldNumber = 3;
  inline const ::std::string& player_steam_id() const;
  inline void set_player_steam_id(const ::std::string& value);
  inline void set_player_steam_id(const char* value);
  inline void set_player_steam_id(const char* value, size_t size);
  inline ::std::string* mutable_player_steam_id();
  inline ::std::string* release_player_steam_id();
  inline void set_allocated_player_steam_id(::std::string* player_steam_id);

  // required bytes data = 4;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 4;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // required .DS3_Frpg2RequestMessage.VisitorPool visitor_pool = 5;
  inline bool has_visitor_pool() const;
  inline void clear_visitor_pool();
  static const int kVisitorPoolFieldNumber = 5;
  inline ::DS3_Frpg2RequestMessage::VisitorPool visitor_pool() const;
  inline void set_visitor_pool(::DS3_Frpg2RequestMessage::VisitorPool value);

  // required uint32 map_id = 6;
  inline bool has_map_id() const;
  inline void clear_map_id();
  static const int kMapIdFieldNumber = 6;
  inline ::google::protobuf::uint32 map_id() const;
  inline void set_map_id(::google::protobuf::uint32 value);

  // required uint32 online_area_id = 7;
  inline bool has_online_area_id() const;
  inline void clear_online_area_id();
  static const int kOnlineAreaIdFieldNumber = 7;
  inline ::google::protobuf::uint32 online_area_id() const;
  inline void set_online_area_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.PushRequestVisit)
 private:
  inline void set_has_push_message_id();
  inline void clear_has_push_message_id();
  inline void set_has_player_id();
  inline void clear_has_player_id();
  inline void set_has_player_steam_id();
  inline void clear_has_player_steam_id();
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_visitor_pool();
  inline void clear_has_visitor_pool();
  inline void set_has_map_id();
  inline void clear_has_map_id();
  inline void set_has_online_area_id();
  inline void clear_has_online_area_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int push_message_id_;
  ::google::protobuf::uint32 player_id_;
  ::std::string* player_steam_id_;
  ::std::string* data_;
  int visitor_pool_;
  ::google::protobuf::uint32 map_id_;
  ::google::protobuf::uint32 online_area_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static PushRequestVisit* default_instance_;
};
// -------------------------------------------------------------------

class RequestRejectVisit : public ::google::protobuf::MessageLite {
 public:
  RequestRejectVisit();
  virtual ~RequestRejectVisit();

  RequestRejectVisit(const RequestRejectVisit& from);

  inline RequestRejectVisit& operator=(const RequestRejectVisit& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestRejectVisit& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestRejectVisit* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestRejectVisit* other);

  // implements Message ----------------------------------------------

  RequestRejectVisit* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestRejectVisit& from);
  void MergeFrom(const RequestRejectVisit& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 player_id = 1;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 1;
  inline ::google::protobuf::uint32 player_id() const;
  inline void set_player_id(::google::protobuf::uint32 value);

  // required .DS3_Frpg2RequestMessage.VisitorPool visitor_pool = 2;
  inline bool has_visitor_pool() const;
  inline void clear_visitor_pool();
  static const int kVisitorPoolFieldNumber = 2;
  inline ::DS3_Frpg2RequestMessage::VisitorPool visitor_pool() const;
  inline void set_visitor_pool(::DS3_Frpg2RequestMessage::VisitorPool value);

  // required uint32 map_id = 3;
  inline bool has_map_id() const;
  inline void clear_map_id();
  static const int kMapIdFieldNumber = 3;
  inline ::google::protobuf::uint32 map_id() const;
  inline void set_map_id(::google::protobuf::uint32 value);

  // required uint32 online_area_id = 4;
  inline bool has_online_area_id() const;
  inline void clear_online_area_id();
  static const int kOnlineAreaIdFieldNumber = 4;
  inline ::google::protobuf::uint32 online_area_id() const;
  inline void set_online_area_id(::google::protobuf::uint32 value);

  // required uint32 unknown_5 = 5;
  inline bool has_unknown_5() const;
  inline void clear_unknown_5();
  static const int kUnknown5FieldNumber = 5;
  inline ::google::protobuf::uint32 unknown_5() const;
  inline void set_unknown_5(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestRejectVisit)
 private:
  inline void set_has_player_id();
  inline void clear_has_player_id();
  inline void set_has_visitor_pool();
  inline void clear_has_visitor_pool();
  inline void set_has_map_id();
  inline void clear_has_map_id();
  inline void set_has_online_area_id();
  inline void clear_has_online_area_id();
  inline void set_has_unknown_5();
  inline void clear_has_unknown_5();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 player_id_;
  int visitor_pool_;
  ::google::protobuf::uint32 map_id_;
  ::google::protobuf::uint32 online_area_id_;
  ::google::protobuf::uint32 unknown_5_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestRejectVisit* default_instance_;
};
// -------------------------------------------------------------------

class PushRequestRejectVisit : public ::google::protobuf::MessageLite {
 public:
  PushRequestRejectVisit();
  virtual ~PushRequestRejectVisit();

  PushRequestRejectVisit(const PushRequestRejectVisit& from);

  inline PushRequestRejectVisit& operator=(const PushRequestRejectVisit& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const PushRequestRejectVisit& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PushRequestRejectVisit* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PushRequestRejectVisit* other);

  // implements Message ----------------------------------------------

  PushRequestRejectVisit* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PushRequestRejectVisit& from);
  void MergeFrom(const PushRequestRejectVisit& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
  inline bool has_push_message_id() const;
  inline void clear_push_message_id();
  static const int kPushMessageIdFieldNumber = 1;
  inline ::DS3_Frpg2RequestMessage::PushMessageId push_message_id() const;
  inline void set_push_message_id(::DS3_Frpg2RequestMessage::PushMessageId value);

  // required uint32 player_id = 2;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 2;
  inline ::google::protobuf::uint32 player_id() const;
  inline void set_player_id(::google::protobuf::uint32 value);

  // optional .DS3_Frpg2RequestMessage.VisitorPool visitor_pool = 3;
  inline bool has_visitor_pool() const;
  inline void clear_visitor_pool();
  static const int kVisitorPoolFieldNumber = 3;
  inline ::DS3_Frpg2RequestMessage::VisitorPool visitor_pool() const;
  inline void set_visitor_pool(::DS3_Frpg2RequestMessage::VisitorPool value);

  // required string steam_id = 4;
  inline bool has_steam_id() const;
  inline void clear_steam_id();
  static const int kSteamIdFieldNumber = 4;
  inline const ::std::string& steam_id() const;
  inline void set_steam_id(const ::std::string& value);
  inline void set_steam_id(const char* value);
  inline void set_steam_id(const char* value, size_t size);
  inline ::std::string* mutable_steam_id();
  inline ::std::string* release_steam_id();
  inline void set_allocated_steam_id(::std::string* steam_id);

  // required uint32 unknown_5 = 5;
  inline bool has_unknown_5() const;
  inline void clear_unknown_5();
  static const int kUnknown5FieldNumber = 5;
  inline ::google::protobuf::uint32 unknown_5() const;
  inline void set_unknown_5(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.PushRequestRejectVisit)
 private:
  inline void set_has_push_message_id();
  inline void clear_has_push_message_id();
  inline void set_has_player_id();
  inline void clear_has_player_id();
  inline void set_has_visitor_pool();
  inline void clear_has_visitor_pool();
  inline void set_has_steam_id();
  inline void clear_has_steam_id();
  inline void set_has_unknown_5();
  inline void clear_has_unknown_5();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int push_message_id_;
  ::google::protobuf::uint32 player_id_;
  ::std::string* steam_id_;
  int visitor_pool_;
  ::google::protobuf::uint32 unknown_5_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static PushRequestRejectVisit* default_instance_;
};
// -------------------------------------------------------------------

class RequestVisitResponse : public ::google::protobuf::MessageLite {
 public:
  RequestVisitResponse();
  virtual ~RequestVisitResponse();

  RequestVisitResponse(const RequestVisitResponse& from);

  inline RequestVisitResponse& operator=(const RequestVisitResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestVisitResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestVisitResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestVisitResponse* other);

  // implements Message ----------------------------------------------

  RequestVisitResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestVisitResponse& from);
  void MergeFrom(const RequestVisitResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestVisitResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestVisitResponse* default_instance_;
};
// -------------------------------------------------------------------

class RequestRejectVisitResponse : public ::google::protobuf::MessageLite {
 public:
  RequestRejectVisitResponse();
  virtual ~RequestRejectVisitResponse();

  RequestRejectVisitResponse(const RequestRejectVisitResponse& from);

  inline RequestRejectVisitResponse& operator=(const RequestRejectVisitResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestRejectVisitResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestRejectVisitResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestRejectVisitResponse* other);

  // implements Message ----------------------------------------------

  RequestRejectVisitResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestRejectVisitResponse& from);
  void MergeFrom(const RequestRejectVisitResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestRejectVisitResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestRejectVisitResponse* default_instance_;
};
// -------------------------------------------------------------------

class RequestNotifyRingBell : public ::google::protobuf::MessageLite {
 public:
  RequestNotifyRingBell();
  virtual ~RequestNotifyRingBell();

  RequestNotifyRingBell(const RequestNotifyRingBell& from);

  inline RequestNotifyRingBell& operator=(const RequestNotifyRingBell& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestNotifyRingBell& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestNotifyRingBell* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestNotifyRingBell* other);

  // implements Message ----------------------------------------------

  RequestNotifyRingBell* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestNotifyRingBell& from);
  void MergeFrom(const RequestNotifyRingBell& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 online_area_id = 1;
  inline bool has_online_area_id() const;
  inline void clear_online_area_id();
  static const int kOnlineAreaIdFieldNumber = 1;
  inline ::google::protobuf::uint32 online_area_id() const;
  inline void set_online_area_id(::google::protobuf::uint32 value);

  // required bytes data = 2;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestNotifyRingBell)
 private:
  inline void set_has_online_area_id();
  inline void clear_has_online_area_id();
  inline void set_has_data();
  inline void clear_has_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* data_;
  ::google::protobuf::uint32 online_area_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestNotifyRingBell* default_instance_;
};
// -------------------------------------------------------------------

class RequestNotifyRingBellResponse : public ::google::protobuf::MessageLite {
 public:
  RequestNotifyRingBellResponse();
  virtual ~RequestNotifyRingBellResponse();

  RequestNotifyRingBellResponse(const RequestNotifyRingBellResponse& from);

  inline RequestNotifyRingBellResponse& operator=(const RequestNotifyRingBellResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestNotifyRingBellResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestNotifyRingBellResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestNotifyRingBellResponse* other);

  // implements Message ----------------------------------------------

  RequestNotifyRingBellResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestNotifyRingBellResponse& from);
  void MergeFrom(const RequestNotifyRingBellResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestNotifyRingBellResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestNotifyRingBellResponse* default_instance_;
};
// -------------------------------------------------------------------

class PushRequestNotifyRingBell : public ::google::protobuf::MessageLite {
 public:
  PushRequestNotifyRingBell();
  virtual ~PushRequestNotifyRingBell();

  PushRequestNotifyRingBell(const PushRequestNotifyRingBell& from);

  inline PushRequestNotifyRingBell& operator=(const PushRequestNotifyRingBell& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const PushRequestNotifyRingBell& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PushRequestNotifyRingBell* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PushRequestNotifyRingBell* other);

  // implements Message ----------------------------------------------

  PushRequestNotifyRingBell* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PushRequestNotifyRingBell& from);
  void MergeFrom(const PushRequestNotifyRingBell& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
  inline bool has_push_message_id() const;
  inline void clear_push_message_id();
  static const int kPushMessageIdFieldNumber = 1;
  inline ::DS3_Frpg2RequestMessage::PushMessageId push_message_id() const;
  inline void set_push_message_id(::DS3_Frpg2RequestMessage::PushMessageId value);

  // required uint32 player_id = 2;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 2;
  inline ::google::protobuf::uint32 player_id() const;
  inline void set_player_id(::google::protobuf::uint32 value);

  // required uint32 online_area_id = 3;
  inline bool has_online_area_id() const;
  inline void clear_online_area_id();
  static const int kOnlineAreaIdFieldNumber = 3;
  inline ::google::protobuf::uint32 online_area_id() const;
  inline void set_online_area_id(::google::protobuf::uint32 value);

  // required bytes data = 4;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 4;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.PushRequestNotifyRingBell)
 private:
  inline void set_has_push_message_id();
  inline void clear_has_push_message_id();
  inline void set_has_player_id();
  inline void clear_has_player_id();
  inline void set_has_online_area_id();
  inline void clear_has_online_area_id();
  inline void set_has_data();
  inline void clear_has_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int push_message_id_;
  ::google::protobuf::uint32 player_id_;
  ::std::string* data_;
  ::google::protobuf::uint32 online_area_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static PushRequestNotifyRingBell* default_instance_;
};
// -------------------------------------------------------------------

class RequestGetRegulationFile : public ::google::protobuf::MessageLite {
 public:
  RequestGetRegulationFile();
  virtual ~RequestGetRegulationFile();

  RequestGetRegulationFile(const RequestGetRegulationFile& from);

  inline RequestGetRegulationFile& operator=(const RequestGetRegulationFile& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestGetRegulationFile& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestGetRegulationFile* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestGetRegulationFile* other);

  // implements Message ----------------------------------------------

  RequestGetRegulationFile* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestGetRegulationFile& from);
  void MergeFrom(const RequestGetRegulationFile& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestGetRegulationFile)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestGetRegulationFile* default_instance_;
};
// -------------------------------------------------------------------

class RequestGetRegulationFileResponse : public ::google::protobuf::MessageLite {
 public:
  RequestGetRegulationFileResponse();
  virtual ~RequestGetRegulationFileResponse();

  RequestGetRegulationFileResponse(const RequestGetRegulationFileResponse& from);

  inline RequestGetRegulationFileResponse& operator=(const RequestGetRegulationFileResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestGetRegulationFileResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestGetRegulationFileResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestGetRegulationFileResponse* other);

  // implements Message ----------------------------------------------

  RequestGetRegulationFileResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestGetRegulationFileResponse& from);
  void MergeFrom(const RequestGetRegulationFileResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestGetRegulationFileResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestGetRegulationFileResponse* default_instance_;
};
// -------------------------------------------------------------------

class RegulationFileMessage : public ::google::protobuf::MessageLite {
 public:
  RegulationFileMessage();
  virtual ~RegulationFileMessage();

  RegulationFileMessage(const RegulationFileMessage& from);

  inline RegulationFileMessage& operator=(const RegulationFileMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RegulationFileMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RegulationFileMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RegulationFileMessage* other);

  // implements Message ----------------------------------------------

  RegulationFileMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RegulationFileMessage& from);
  void MergeFrom(const RegulationFileMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RegulationFileMessage)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RegulationFileMessage* default_instance_;
};
// -------------------------------------------------------------------

class RegulationFileDiffData : public ::google::protobuf::MessageLite {
 public:
  RegulationFileDiffData();
  virtual ~RegulationFileDiffData();

  RegulationFileDiffData(const RegulationFileDiffData& from);

  inline RegulationFileDiffData& operator=(const RegulationFileDiffData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RegulationFileDiffData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RegulationFileDiffData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RegulationFileDiffData* other);

  // implements Message ----------------------------------------------

  RegulationFileDiffData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RegulationFileDiffData& from);
  void MergeFrom(const RegulationFileDiffData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RegulationFileDiffData)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RegulationFileDiffData* default_instance_;
};
// -------------------------------------------------------------------

class RegulationFileUpdateMessage : public ::google::protobuf::MessageLite {
 public:
  RegulationFileUpdateMessage();
  virtual ~RegulationFileUpdateMessage();

  RegulationFileUpdateMessage(const RegulationFileUpdateMessage& from);

  inline RegulationFileUpdateMessage& operator=(const RegulationFileUpdateMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RegulationFileUpdateMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RegulationFileUpdateMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RegulationFileUpdateMessage* other);

  // implements Message ----------------------------------------------

  RegulationFileUpdateMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RegulationFileUpdateMessage& from);
  void MergeFrom(const RegulationFileUpdateMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RegulationFileUpdateMessage)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RegulationFileUpdateMessage* default_instance_;
};
// -------------------------------------------------------------------

class RegulationFileUpdatePushMessage : public ::google::protobuf::MessageLite {
 public:
  RegulationFileUpdatePushMessage();
  virtual ~RegulationFileUpdatePushMessage();

  RegulationFileUpdatePushMessage(const RegulationFileUpdatePushMessage& from);

  inline RegulationFileUpdatePushMessage& operator=(const RegulationFileUpdatePushMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RegulationFileUpdatePushMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RegulationFileUpdatePushMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RegulationFileUpdatePushMessage* other);

  // implements Message ----------------------------------------------

  RegulationFileUpdatePushMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RegulationFileUpdatePushMessage& from);
  void MergeFrom(const RegulationFileUpdatePushMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
  inline bool has_push_message_id() const;
  inline void clear_push_message_id();
  static const int kPushMessageIdFieldNumber = 1;
  inline ::DS3_Frpg2RequestMessage::PushMessageId push_message_id() const;
  inline void set_push_message_id(::DS3_Frpg2RequestMessage::PushMessageId value);

  // required .DS3_Frpg2RequestMessage.RegulationFileUpdateMessage update_message = 2;
  inline bool has_update_message() const;
  inline void clear_update_message();
  static const int kUpdateMessageFieldNumber = 2;
  inline const ::DS3_Frpg2RequestMessage::RegulationFileUpdateMessage& update_message() const;
  inline ::DS3_Frpg2RequestMessage::RegulationFileUpdateMessage* mutable_update_message();
  inline ::DS3_Frpg2RequestMessage::RegulationFileUpdateMessage* release_update_message();
  inline void set_allocated_update_message(::DS3_Frpg2RequestMessage::RegulationFileUpdateMessage* update_message);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RegulationFileUpdatePushMessage)
 private:
  inline void set_has_push_message_id();
  inline void clear_has_push_message_id();
  inline void set_has_update_message();
  inline void clear_has_update_message();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::DS3_Frpg2RequestMessage::RegulationFileUpdateMessage* update_message_;
  int push_message_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RegulationFileUpdatePushMessage* default_instance_;
};
// -------------------------------------------------------------------

class RequestBenchmarkThroughput : public ::google::protobuf::MessageLite {
 public:
  RequestBenchmarkThroughput();
  virtual ~RequestBenchmarkThroughput();

  RequestBenchmarkThroughput(const RequestBenchmarkThroughput& from);

  inline RequestBenchmarkThroughput& operator=(const RequestBenchmarkThroughput& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestBenchmarkThroughput& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestBenchmarkThroughput* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestBenchmarkThroughput* other);

  // implements Message ----------------------------------------------

  RequestBenchmarkThroughput* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestBenchmarkThroughput& from);
  void MergeFrom(const RequestBenchmarkThroughput& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestBenchmarkThroughput)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestBenchmarkThroughput* default_instance_;
};
// -------------------------------------------------------------------

class RequestBenchmarkThroughputResponse : public ::google::protobuf::MessageLite {
 public:
  RequestBenchmarkThroughputResponse();
  virtual ~RequestBenchmarkThroughputResponse();

  RequestBenchmarkThroughputResponse(const RequestBenchmarkThroughputResponse& from);

  inline RequestBenchmarkThroughputResponse& operator=(const RequestBenchmarkThroughputResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestBenchmarkThroughputResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestBenchmarkThroughputResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestBenchmarkThroughputResponse* other);

  // implements Message ----------------------------------------------

  RequestBenchmarkThroughputResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestBenchmarkThroughputResponse& from);
  void MergeFrom(const RequestBenchmarkThroughputResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestBenchmarkThroughputResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestBenchmarkThroughputResponse* default_instance_;
};
// -------------------------------------------------------------------

class RequestGetLoginPlayerCharacter : public ::google::protobuf::MessageLite {
 public:
  RequestGetLoginPlayerCharacter();
  virtual ~RequestGetLoginPlayerCharacter();

  RequestGetLoginPlayerCharacter(const RequestGetLoginPlayerCharacter& from);

  inline RequestGetLoginPlayerCharacter& operator=(const RequestGetLoginPlayerCharacter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestGetLoginPlayerCharacter& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestGetLoginPlayerCharacter* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestGetLoginPlayerCharacter* other);

  // implements Message ----------------------------------------------

  RequestGetLoginPlayerCharacter* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestGetLoginPlayerCharacter& from);
  void MergeFrom(const RequestGetLoginPlayerCharacter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestGetLoginPlayerCharacter)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestGetLoginPlayerCharacter* default_instance_;
};
// -------------------------------------------------------------------

class RequestGetLoginPlayerCharacterResponse : public ::google::protobuf::MessageLite {
 public:
  RequestGetLoginPlayerCharacterResponse();
  virtual ~RequestGetLoginPlayerCharacterResponse();

  RequestGetLoginPlayerCharacterResponse(const RequestGetLoginPlayerCharacterResponse& from);

  inline RequestGetLoginPlayerCharacterResponse& operator=(const RequestGetLoginPlayerCharacterResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestGetLoginPlayerCharacterResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestGetLoginPlayerCharacterResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestGetLoginPlayerCharacterResponse* other);

  // implements Message ----------------------------------------------

  RequestGetLoginPlayerCharacterResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestGetLoginPlayerCharacterResponse& from);
  void MergeFrom(const RequestGetLoginPlayerCharacterResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestGetLoginPlayerCharacterResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestGetLoginPlayerCharacterResponse* default_instance_;
};
// -------------------------------------------------------------------

class RequestGetPlayerCharacterList : public ::google::protobuf::MessageLite {
 public:
  RequestGetPlayerCharacterList();
  virtual ~RequestGetPlayerCharacterList();

  RequestGetPlayerCharacterList(const RequestGetPlayerCharacterList& from);

  inline RequestGetPlayerCharacterList& operator=(const RequestGetPlayerCharacterList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestGetPlayerCharacterList& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestGetPlayerCharacterList* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestGetPlayerCharacterList* other);

  // implements Message ----------------------------------------------

  RequestGetPlayerCharacterList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestGetPlayerCharacterList& from);
  void MergeFrom(const RequestGetPlayerCharacterList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestGetPlayerCharacterList)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestGetPlayerCharacterList* default_instance_;
};
// -------------------------------------------------------------------

class RequestGetPlayerCharacterListResponse : public ::google::protobuf::MessageLite {
 public:
  RequestGetPlayerCharacterListResponse();
  virtual ~RequestGetPlayerCharacterListResponse();

  RequestGetPlayerCharacterListResponse(const RequestGetPlayerCharacterListResponse& from);

  inline RequestGetPlayerCharacterListResponse& operator=(const RequestGetPlayerCharacterListResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestGetPlayerCharacterListResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestGetPlayerCharacterListResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestGetPlayerCharacterListResponse* other);

  // implements Message ----------------------------------------------

  RequestGetPlayerCharacterListResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestGetPlayerCharacterListResponse& from);
  void MergeFrom(const RequestGetPlayerCharacterListResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestGetPlayerCharacterListResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestGetPlayerCharacterListResponse* default_instance_;
};
// -------------------------------------------------------------------

class RequestMeasureUploadBandwidth : public ::google::protobuf::MessageLite {
 public:
  RequestMeasureUploadBandwidth();
  virtual ~RequestMeasureUploadBandwidth();

  RequestMeasureUploadBandwidth(const RequestMeasureUploadBandwidth& from);

  inline RequestMeasureUploadBandwidth& operator=(const RequestMeasureUploadBandwidth& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestMeasureUploadBandwidth& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestMeasureUploadBandwidth* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestMeasureUploadBandwidth* other);

  // implements Message ----------------------------------------------

  RequestMeasureUploadBandwidth* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestMeasureUploadBandwidth& from);
  void MergeFrom(const RequestMeasureUploadBandwidth& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestMeasureUploadBandwidth)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestMeasureUploadBandwidth* default_instance_;
};
// -------------------------------------------------------------------

class RequestMeasureUploadBandwidthResponse : public ::google::protobuf::MessageLite {
 public:
  RequestMeasureUploadBandwidthResponse();
  virtual ~RequestMeasureUploadBandwidthResponse();

  RequestMeasureUploadBandwidthResponse(const RequestMeasureUploadBandwidthResponse& from);

  inline RequestMeasureUploadBandwidthResponse& operator=(const RequestMeasureUploadBandwidthResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestMeasureUploadBandwidthResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestMeasureUploadBandwidthResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestMeasureUploadBandwidthResponse* other);

  // implements Message ----------------------------------------------

  RequestMeasureUploadBandwidthResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestMeasureUploadBandwidthResponse& from);
  void MergeFrom(const RequestMeasureUploadBandwidthResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestMeasureUploadBandwidthResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestMeasureUploadBandwidthResponse* default_instance_;
};
// -------------------------------------------------------------------

class RequestMeasureDownloadBandwidth : public ::google::protobuf::MessageLite {
 public:
  RequestMeasureDownloadBandwidth();
  virtual ~RequestMeasureDownloadBandwidth();

  RequestMeasureDownloadBandwidth(const RequestMeasureDownloadBandwidth& from);

  inline RequestMeasureDownloadBandwidth& operator=(const RequestMeasureDownloadBandwidth& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestMeasureDownloadBandwidth& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestMeasureDownloadBandwidth* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestMeasureDownloadBandwidth* other);

  // implements Message ----------------------------------------------

  RequestMeasureDownloadBandwidth* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestMeasureDownloadBandwidth& from);
  void MergeFrom(const RequestMeasureDownloadBandwidth& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestMeasureDownloadBandwidth)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestMeasureDownloadBandwidth* default_instance_;
};
// -------------------------------------------------------------------

class RequestMeasureDownloadBandwidthResponse : public ::google::protobuf::MessageLite {
 public:
  RequestMeasureDownloadBandwidthResponse();
  virtual ~RequestMeasureDownloadBandwidthResponse();

  RequestMeasureDownloadBandwidthResponse(const RequestMeasureDownloadBandwidthResponse& from);

  inline RequestMeasureDownloadBandwidthResponse& operator=(const RequestMeasureDownloadBandwidthResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestMeasureDownloadBandwidthResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestMeasureDownloadBandwidthResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestMeasureDownloadBandwidthResponse* other);

  // implements Message ----------------------------------------------

  RequestMeasureDownloadBandwidthResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestMeasureDownloadBandwidthResponse& from);
  void MergeFrom(const RequestMeasureDownloadBandwidthResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestMeasureDownloadBandwidthResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestMeasureDownloadBandwidthResponse* default_instance_;
};
// -------------------------------------------------------------------

class RequestSendMessageToPlayers : public ::google::protobuf::MessageLite {
 public:
  RequestSendMessageToPlayers();
  virtual ~RequestSendMessageToPlayers();

  RequestSendMessageToPlayers(const RequestSendMessageToPlayers& from);

  inline RequestSendMessageToPlayers& operator=(const RequestSendMessageToPlayers& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestSendMessageToPlayers& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestSendMessageToPlayers* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestSendMessageToPlayers* other);

  // implements Message ----------------------------------------------

  RequestSendMessageToPlayers* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestSendMessageToPlayers& from);
  void MergeFrom(const RequestSendMessageToPlayers& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 player_ids = 1;
  inline int player_ids_size() const;
  inline void clear_player_ids();
  static const int kPlayerIdsFieldNumber = 1;
  inline ::google::protobuf::uint32 player_ids(int index) const;
  inline void set_player_ids(int index, ::google::protobuf::uint32 value);
  inline void add_player_ids(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      player_ids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_player_ids();

  // required bytes message = 2;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 2;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const void* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestSendMessageToPlayers)
 private:
  inline void set_has_message();
  inline void clear_has_message();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > player_ids_;
  ::std::string* message_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestSendMessageToPlayers* default_instance_;
};
// -------------------------------------------------------------------

class RequestSendMessageToPlayersResponse : public ::google::protobuf::MessageLite {
 public:
  RequestSendMessageToPlayersResponse();
  virtual ~RequestSendMessageToPlayersResponse();

  RequestSendMessageToPlayersResponse(const RequestSendMessageToPlayersResponse& from);

  inline RequestSendMessageToPlayersResponse& operator=(const RequestSendMessageToPlayersResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestSendMessageToPlayersResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestSendMessageToPlayersResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestSendMessageToPlayersResponse* other);

  // implements Message ----------------------------------------------

  RequestSendMessageToPlayersResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestSendMessageToPlayersResponse& from);
  void MergeFrom(const RequestSendMessageToPlayersResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestSendMessageToPlayersResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestSendMessageToPlayersResponse* default_instance_;
};
// -------------------------------------------------------------------

class RequestSendMessageToSelectLanguagePlayers : public ::google::protobuf::MessageLite {
 public:
  RequestSendMessageToSelectLanguagePlayers();
  virtual ~RequestSendMessageToSelectLanguagePlayers();

  RequestSendMessageToSelectLanguagePlayers(const RequestSendMessageToSelectLanguagePlayers& from);

  inline RequestSendMessageToSelectLanguagePlayers& operator=(const RequestSendMessageToSelectLanguagePlayers& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestSendMessageToSelectLanguagePlayers& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestSendMessageToSelectLanguagePlayers* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestSendMessageToSelectLanguagePlayers* other);

  // implements Message ----------------------------------------------

  RequestSendMessageToSelectLanguagePlayers* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestSendMessageToSelectLanguagePlayers& from);
  void MergeFrom(const RequestSendMessageToSelectLanguagePlayers& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestSendMessageToSelectLanguagePlayers)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestSendMessageToSelectLanguagePlayers* default_instance_;
};
// -------------------------------------------------------------------

class RequestSendMessageToSelectLanguagePlayersResponse : public ::google::protobuf::MessageLite {
 public:
  RequestSendMessageToSelectLanguagePlayersResponse();
  virtual ~RequestSendMessageToSelectLanguagePlayersResponse();

  RequestSendMessageToSelectLanguagePlayersResponse(const RequestSendMessageToSelectLanguagePlayersResponse& from);

  inline RequestSendMessageToSelectLanguagePlayersResponse& operator=(const RequestSendMessageToSelectLanguagePlayersResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestSendMessageToSelectLanguagePlayersResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestSendMessageToSelectLanguagePlayersResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestSendMessageToSelectLanguagePlayersResponse* other);

  // implements Message ----------------------------------------------

  RequestSendMessageToSelectLanguagePlayersResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestSendMessageToSelectLanguagePlayersResponse& from);
  void MergeFrom(const RequestSendMessageToSelectLanguagePlayersResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestSendMessageToSelectLanguagePlayersResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestSendMessageToSelectLanguagePlayersResponse* default_instance_;
};
// -------------------------------------------------------------------

class RequestSendMessageToAllPlayers : public ::google::protobuf::MessageLite {
 public:
  RequestSendMessageToAllPlayers();
  virtual ~RequestSendMessageToAllPlayers();

  RequestSendMessageToAllPlayers(const RequestSendMessageToAllPlayers& from);

  inline RequestSendMessageToAllPlayers& operator=(const RequestSendMessageToAllPlayers& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestSendMessageToAllPlayers& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestSendMessageToAllPlayers* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestSendMessageToAllPlayers* other);

  // implements Message ----------------------------------------------

  RequestSendMessageToAllPlayers* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestSendMessageToAllPlayers& from);
  void MergeFrom(const RequestSendMessageToAllPlayers& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestSendMessageToAllPlayers)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestSendMessageToAllPlayers* default_instance_;
};
// -------------------------------------------------------------------

class RequestSendMessageToAllPlayersResponse : public ::google::protobuf::MessageLite {
 public:
  RequestSendMessageToAllPlayersResponse();
  virtual ~RequestSendMessageToAllPlayersResponse();

  RequestSendMessageToAllPlayersResponse(const RequestSendMessageToAllPlayersResponse& from);

  inline RequestSendMessageToAllPlayersResponse& operator=(const RequestSendMessageToAllPlayersResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestSendMessageToAllPlayersResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestSendMessageToAllPlayersResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestSendMessageToAllPlayersResponse* other);

  // implements Message ----------------------------------------------

  RequestSendMessageToAllPlayersResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestSendMessageToAllPlayersResponse& from);
  void MergeFrom(const RequestSendMessageToAllPlayersResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestSendMessageToAllPlayersResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestSendMessageToAllPlayersResponse* default_instance_;
};
// -------------------------------------------------------------------

class RequestSendPlayerList : public ::google::protobuf::MessageLite {
 public:
  RequestSendPlayerList();
  virtual ~RequestSendPlayerList();

  RequestSendPlayerList(const RequestSendPlayerList& from);

  inline RequestSendPlayerList& operator=(const RequestSendPlayerList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestSendPlayerList& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestSendPlayerList* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestSendPlayerList* other);

  // implements Message ----------------------------------------------

  RequestSendPlayerList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestSendPlayerList& from);
  void MergeFrom(const RequestSendPlayerList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestSendPlayerList)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestSendPlayerList* default_instance_;
};
// -------------------------------------------------------------------

class RankingData : public ::google::protobuf::MessageLite {
 public:
  RankingData();
  virtual ~RankingData();

  RankingData(const RankingData& from);

  inline RankingData& operator=(const RankingData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RankingData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RankingData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RankingData* other);

  // implements Message ----------------------------------------------

  RankingData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RankingData& from);
  void MergeFrom(const RankingData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 player_id = 1;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 1;
  inline ::google::protobuf::uint32 player_id() const;
  inline void set_player_id(::google::protobuf::uint32 value);

  // required uint32 character_id = 2;
  inline bool has_character_id() const;
  inline void clear_character_id();
  static const int kCharacterIdFieldNumber = 2;
  inline ::google::protobuf::uint32 character_id() const;
  inline void set_character_id(::google::protobuf::uint32 value);

  // required uint32 serial_rank = 3;
  inline bool has_serial_rank() const;
  inline void clear_serial_rank();
  static const int kSerialRankFieldNumber = 3;
  inline ::google::protobuf::uint32 serial_rank() const;
  inline void set_serial_rank(::google::protobuf::uint32 value);

  // required uint32 rank = 4;
  inline bool has_rank() const;
  inline void clear_rank();
  static const int kRankFieldNumber = 4;
  inline ::google::protobuf::uint32 rank() const;
  inline void set_rank(::google::protobuf::uint32 value);

  // required uint32 score = 5;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 5;
  inline ::google::protobuf::uint32 score() const;
  inline void set_score(::google::protobuf::uint32 value);

  // required bytes data = 6;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 6;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RankingData)
 private:
  inline void set_has_player_id();
  inline void clear_has_player_id();
  inline void set_has_character_id();
  inline void clear_has_character_id();
  inline void set_has_serial_rank();
  inline void clear_has_serial_rank();
  inline void set_has_rank();
  inline void clear_has_rank();
  inline void set_has_score();
  inline void clear_has_score();
  inline void set_has_data();
  inline void clear_has_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 player_id_;
  ::google::protobuf::uint32 character_id_;
  ::google::protobuf::uint32 serial_rank_;
  ::google::protobuf::uint32 rank_;
  ::std::string* data_;
  ::google::protobuf::uint32 score_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RankingData* default_instance_;
};
// -------------------------------------------------------------------

class RankingRotationID : public ::google::protobuf::MessageLite {
 public:
  RankingRotationID();
  virtual ~RankingRotationID();

  RankingRotationID(const RankingRotationID& from);

  inline RankingRotationID& operator=(const RankingRotationID& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RankingRotationID& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RankingRotationID* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RankingRotationID* other);

  // implements Message ----------------------------------------------

  RankingRotationID* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RankingRotationID& from);
  void MergeFrom(const RankingRotationID& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RankingRotationID)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RankingRotationID* default_instance_;
};
// -------------------------------------------------------------------

class RankingRecordCount : public ::google::protobuf::MessageLite {
 public:
  RankingRecordCount();
  virtual ~RankingRecordCount();

  RankingRecordCount(const RankingRecordCount& from);

  inline RankingRecordCount& operator=(const RankingRecordCount& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RankingRecordCount& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RankingRecordCount* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RankingRecordCount* other);

  // implements Message ----------------------------------------------

  RankingRecordCount* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RankingRecordCount& from);
  void MergeFrom(const RankingRecordCount& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RankingRecordCount)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RankingRecordCount* default_instance_;
};
// -------------------------------------------------------------------

class RankingDataPack : public ::google::protobuf::MessageLite {
 public:
  RankingDataPack();
  virtual ~RankingDataPack();

  RankingDataPack(const RankingDataPack& from);

  inline RankingDataPack& operator=(const RankingDataPack& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RankingDataPack& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RankingDataPack* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RankingDataPack* other);

  // implements Message ----------------------------------------------

  RankingDataPack* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RankingDataPack& from);
  void MergeFrom(const RankingDataPack& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RankingDataPack)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RankingDataPack* default_instance_;
};
// -------------------------------------------------------------------

class RequestRegisterRankingData : public ::google::protobuf::MessageLite {
 public:
  RequestRegisterRankingData();
  virtual ~RequestRegisterRankingData();

  RequestRegisterRankingData(const RequestRegisterRankingData& from);

  inline RequestRegisterRankingData& operator=(const RequestRegisterRankingData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestRegisterRankingData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestRegisterRankingData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestRegisterRankingData* other);

  // implements Message ----------------------------------------------

  RequestRegisterRankingData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestRegisterRankingData& from);
  void MergeFrom(const RequestRegisterRankingData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 board_id = 1;
  inline bool has_board_id() const;
  inline void clear_board_id();
  static const int kBoardIdFieldNumber = 1;
  inline ::google::protobuf::uint32 board_id() const;
  inline void set_board_id(::google::protobuf::uint32 value);

  // required uint32 character_id = 2;
  inline bool has_character_id() const;
  inline void clear_character_id();
  static const int kCharacterIdFieldNumber = 2;
  inline ::google::protobuf::uint32 character_id() const;
  inline void set_character_id(::google::protobuf::uint32 value);

  // required uint32 score = 3;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 3;
  inline ::google::protobuf::uint32 score() const;
  inline void set_score(::google::protobuf::uint32 value);

  // required bytes data = 4;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 4;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestRegisterRankingData)
 private:
  inline void set_has_board_id();
  inline void clear_has_board_id();
  inline void set_has_character_id();
  inline void clear_has_character_id();
  inline void set_has_score();
  inline void clear_has_score();
  inline void set_has_data();
  inline void clear_has_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 board_id_;
  ::google::protobuf::uint32 character_id_;
  ::std::string* data_;
  ::google::protobuf::uint32 score_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestRegisterRankingData* default_instance_;
};
// -------------------------------------------------------------------

class RequestRegisterRankingDataResponse : public ::google::protobuf::MessageLite {
 public:
  RequestRegisterRankingDataResponse();
  virtual ~RequestRegisterRankingDataResponse();

  RequestRegisterRankingDataResponse(const RequestRegisterRankingDataResponse& from);

  inline RequestRegisterRankingDataResponse& operator=(const RequestRegisterRankingDataResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestRegisterRankingDataResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestRegisterRankingDataResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestRegisterRankingDataResponse* other);

  // implements Message ----------------------------------------------

  RequestRegisterRankingDataResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestRegisterRankingDataResponse& from);
  void MergeFrom(const RequestRegisterRankingDataResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestRegisterRankingDataResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestRegisterRankingDataResponse* default_instance_;
};
// -------------------------------------------------------------------

class RequestGetRankingData : public ::google::protobuf::MessageLite {
 public:
  RequestGetRankingData();
  virtual ~RequestGetRankingData();

  RequestGetRankingData(const RequestGetRankingData& from);

  inline RequestGetRankingData& operator=(const RequestGetRankingData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestGetRankingData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestGetRankingData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestGetRankingData* other);

  // implements Message ----------------------------------------------

  RequestGetRankingData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestGetRankingData& from);
  void MergeFrom(const RequestGetRankingData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 board_id = 1;
  inline bool has_board_id() const;
  inline void clear_board_id();
  static const int kBoardIdFieldNumber = 1;
  inline ::google::protobuf::uint32 board_id() const;
  inline void set_board_id(::google::protobuf::uint32 value);

  // required uint32 offset = 2;
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 2;
  inline ::google::protobuf::uint32 offset() const;
  inline void set_offset(::google::protobuf::uint32 value);

  // required uint32 count = 3;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 3;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestGetRankingData)
 private:
  inline void set_has_board_id();
  inline void clear_has_board_id();
  inline void set_has_offset();
  inline void clear_has_offset();
  inline void set_has_count();
  inline void clear_has_count();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 board_id_;
  ::google::protobuf::uint32 offset_;
  ::google::protobuf::uint32 count_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestGetRankingData* default_instance_;
};
// -------------------------------------------------------------------

class RequestGetRankingDataResponse : public ::google::protobuf::MessageLite {
 public:
  RequestGetRankingDataResponse();
  virtual ~RequestGetRankingDataResponse();

  RequestGetRankingDataResponse(const RequestGetRankingDataResponse& from);

  inline RequestGetRankingDataResponse& operator=(const RequestGetRankingDataResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestGetRankingDataResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestGetRankingDataResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestGetRankingDataResponse* other);

  // implements Message ----------------------------------------------

  RequestGetRankingDataResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestGetRankingDataResponse& from);
  void MergeFrom(const RequestGetRankingDataResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .DS3_Frpg2RequestMessage.RankingData data = 1;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 1;
  inline const ::DS3_Frpg2RequestMessage::RankingData& data(int index) const;
  inline ::DS3_Frpg2RequestMessage::RankingData* mutable_data(int index);
  inline ::DS3_Frpg2RequestMessage::RankingData* add_data();
  inline const ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::RankingData >&
      data() const;
  inline ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::RankingData >*
      mutable_data();

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestGetRankingDataResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::RankingData > data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestGetRankingDataResponse* default_instance_;
};
// -------------------------------------------------------------------

class RequestGetCharacterRankingData : public ::google::protobuf::MessageLite {
 public:
  RequestGetCharacterRankingData();
  virtual ~RequestGetCharacterRankingData();

  RequestGetCharacterRankingData(const RequestGetCharacterRankingData& from);

  inline RequestGetCharacterRankingData& operator=(const RequestGetCharacterRankingData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestGetCharacterRankingData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestGetCharacterRankingData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestGetCharacterRankingData* other);

  // implements Message ----------------------------------------------

  RequestGetCharacterRankingData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestGetCharacterRankingData& from);
  void MergeFrom(const RequestGetCharacterRankingData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 board_id = 1;
  inline bool has_board_id() const;
  inline void clear_board_id();
  static const int kBoardIdFieldNumber = 1;
  inline ::google::protobuf::uint32 board_id() const;
  inline void set_board_id(::google::protobuf::uint32 value);

  // required uint32 character_id = 2;
  inline bool has_character_id() const;
  inline void clear_character_id();
  static const int kCharacterIdFieldNumber = 2;
  inline ::google::protobuf::uint32 character_id() const;
  inline void set_character_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestGetCharacterRankingData)
 private:
  inline void set_has_board_id();
  inline void clear_has_board_id();
  inline void set_has_character_id();
  inline void clear_has_character_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 board_id_;
  ::google::protobuf::uint32 character_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestGetCharacterRankingData* default_instance_;
};
// -------------------------------------------------------------------

class RequestGetCharacterRankingDataResponse : public ::google::protobuf::MessageLite {
 public:
  RequestGetCharacterRankingDataResponse();
  virtual ~RequestGetCharacterRankingDataResponse();

  RequestGetCharacterRankingDataResponse(const RequestGetCharacterRankingDataResponse& from);

  inline RequestGetCharacterRankingDataResponse& operator=(const RequestGetCharacterRankingDataResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestGetCharacterRankingDataResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestGetCharacterRankingDataResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestGetCharacterRankingDataResponse* other);

  // implements Message ----------------------------------------------

  RequestGetCharacterRankingDataResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestGetCharacterRankingDataResponse& from);
  void MergeFrom(const RequestGetCharacterRankingDataResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .DS3_Frpg2RequestMessage.RankingData data = 1;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 1;
  inline const ::DS3_Frpg2RequestMessage::RankingData& data() const;
  inline ::DS3_Frpg2RequestMessage::RankingData* mutable_data();
  inline ::DS3_Frpg2RequestMessage::RankingData* release_data();
  inline void set_allocated_data(::DS3_Frpg2RequestMessage::RankingData* data);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestGetCharacterRankingDataResponse)
 private:
  inline void set_has_data();
  inline void clear_has_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::DS3_Frpg2RequestMessage::RankingData* data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestGetCharacterRankingDataResponse* default_instance_;
};
// -------------------------------------------------------------------

class RequestCountRankingData : public ::google::protobuf::MessageLite {
 public:
  RequestCountRankingData();
  virtual ~RequestCountRankingData();

  RequestCountRankingData(const RequestCountRankingData& from);

  inline RequestCountRankingData& operator=(const RequestCountRankingData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestCountRankingData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestCountRankingData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestCountRankingData* other);

  // implements Message ----------------------------------------------

  RequestCountRankingData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestCountRankingData& from);
  void MergeFrom(const RequestCountRankingData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 board_id = 1;
  inline bool has_board_id() const;
  inline void clear_board_id();
  static const int kBoardIdFieldNumber = 1;
  inline ::google::protobuf::uint32 board_id() const;
  inline void set_board_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestCountRankingData)
 private:
  inline void set_has_board_id();
  inline void clear_has_board_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 board_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestCountRankingData* default_instance_;
};
// -------------------------------------------------------------------

class RequestCountRankingDataResponse : public ::google::protobuf::MessageLite {
 public:
  RequestCountRankingDataResponse();
  virtual ~RequestCountRankingDataResponse();

  RequestCountRankingDataResponse(const RequestCountRankingDataResponse& from);

  inline RequestCountRankingDataResponse& operator=(const RequestCountRankingDataResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestCountRankingDataResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestCountRankingDataResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestCountRankingDataResponse* other);

  // implements Message ----------------------------------------------

  RequestCountRankingDataResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestCountRankingDataResponse& from);
  void MergeFrom(const RequestCountRankingDataResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 count = 1;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 1;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestCountRankingDataResponse)
 private:
  inline void set_has_count();
  inline void clear_has_count();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 count_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestCountRankingDataResponse* default_instance_;
};
// -------------------------------------------------------------------

class RequestGetCurrentRank : public ::google::protobuf::MessageLite {
 public:
  RequestGetCurrentRank();
  virtual ~RequestGetCurrentRank();

  RequestGetCurrentRank(const RequestGetCurrentRank& from);

  inline RequestGetCurrentRank& operator=(const RequestGetCurrentRank& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestGetCurrentRank& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestGetCurrentRank* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestGetCurrentRank* other);

  // implements Message ----------------------------------------------

  RequestGetCurrentRank* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestGetCurrentRank& from);
  void MergeFrom(const RequestGetCurrentRank& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestGetCurrentRank)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestGetCurrentRank* default_instance_;
};
// -------------------------------------------------------------------

class RequestGetCurrentRankResponse : public ::google::protobuf::MessageLite {
 public:
  RequestGetCurrentRankResponse();
  virtual ~RequestGetCurrentRankResponse();

  RequestGetCurrentRankResponse(const RequestGetCurrentRankResponse& from);

  inline RequestGetCurrentRankResponse& operator=(const RequestGetCurrentRankResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestGetCurrentRankResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestGetCurrentRankResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestGetCurrentRankResponse* other);

  // implements Message ----------------------------------------------

  RequestGetCurrentRankResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestGetCurrentRankResponse& from);
  void MergeFrom(const RequestGetCurrentRankResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestGetCurrentRankResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestGetCurrentRankResponse* default_instance_;
};
// -------------------------------------------------------------------

class QuickMatchRank : public ::google::protobuf::MessageLite {
 public:
  QuickMatchRank();
  virtual ~QuickMatchRank();

  QuickMatchRank(const QuickMatchRank& from);

  inline QuickMatchRank& operator=(const QuickMatchRank& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const QuickMatchRank& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const QuickMatchRank* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(QuickMatchRank* other);

  // implements Message ----------------------------------------------

  QuickMatchRank* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const QuickMatchRank& from);
  void MergeFrom(const QuickMatchRank& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 rank = 1;
  inline bool has_rank() const;
  inline void clear_rank();
  static const int kRankFieldNumber = 1;
  inline ::google::protobuf::uint32 rank() const;
  inline void set_rank(::google::protobuf::uint32 value);

  // optional uint32 xp = 2;
  inline bool has_xp() const;
  inline void clear_xp();
  static const int kXpFieldNumber = 2;
  inline ::google::protobuf::uint32 xp() const;
  inline void set_xp(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.QuickMatchRank)
 private:
  inline void set_has_rank();
  inline void clear_has_rank();
  inline void set_has_xp();
  inline void clear_has_xp();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 rank_;
  ::google::protobuf::uint32 xp_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static QuickMatchRank* default_instance_;
};
// -------------------------------------------------------------------

class QuickMatchRankCache : public ::google::protobuf::MessageLite {
 public:
  QuickMatchRankCache();
  virtual ~QuickMatchRankCache();

  QuickMatchRankCache(const QuickMatchRankCache& from);

  inline QuickMatchRankCache& operator=(const QuickMatchRankCache& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const QuickMatchRankCache& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const QuickMatchRankCache* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(QuickMatchRankCache* other);

  // implements Message ----------------------------------------------

  QuickMatchRankCache* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const QuickMatchRankCache& from);
  void MergeFrom(const QuickMatchRankCache& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.QuickMatchRankCache)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static QuickMatchRankCache* default_instance_;
};
// -------------------------------------------------------------------

class QuickMatchSession_Result_list : public ::google::protobuf::MessageLite {
 public:
  QuickMatchSession_Result_list();
  virtual ~QuickMatchSession_Result_list();

  QuickMatchSession_Result_list(const QuickMatchSession_Result_list& from);

  inline QuickMatchSession_Result_list& operator=(const QuickMatchSession_Result_list& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const QuickMatchSession_Result_list& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const QuickMatchSession_Result_list* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(QuickMatchSession_Result_list* other);

  // implements Message ----------------------------------------------

  QuickMatchSession_Result_list* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const QuickMatchSession_Result_list& from);
  void MergeFrom(const QuickMatchSession_Result_list& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.QuickMatchSession.Result_list)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static QuickMatchSession_Result_list* default_instance_;
};
// -------------------------------------------------------------------

class QuickMatchSession : public ::google::protobuf::MessageLite {
 public:
  QuickMatchSession();
  virtual ~QuickMatchSession();

  QuickMatchSession(const QuickMatchSession& from);

  inline QuickMatchSession& operator=(const QuickMatchSession& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const QuickMatchSession& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const QuickMatchSession* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(QuickMatchSession* other);

  // implements Message ----------------------------------------------

  QuickMatchSession* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const QuickMatchSession& from);
  void MergeFrom(const QuickMatchSession& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef QuickMatchSession_Result_list Result_list;

  // accessors -------------------------------------------------------

  // repeated group Result_list = 2 {
  inline int result_list_size() const;
  inline void clear_result_list();
  static const int kResultListFieldNumber = 2;
  inline const ::DS3_Frpg2RequestMessage::QuickMatchSession_Result_list& result_list(int index) const;
  inline ::DS3_Frpg2RequestMessage::QuickMatchSession_Result_list* mutable_result_list(int index);
  inline ::DS3_Frpg2RequestMessage::QuickMatchSession_Result_list* add_result_list();
  inline const ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::QuickMatchSession_Result_list >&
      result_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::QuickMatchSession_Result_list >*
      mutable_result_list();

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.QuickMatchSession)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::QuickMatchSession_Result_list > result_list_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static QuickMatchSession* default_instance_;
};
// -------------------------------------------------------------------

class QuickMatchApologyPoint : public ::google::protobuf::MessageLite {
 public:
  QuickMatchApologyPoint();
  virtual ~QuickMatchApologyPoint();

  QuickMatchApologyPoint(const QuickMatchApologyPoint& from);

  inline QuickMatchApologyPoint& operator=(const QuickMatchApologyPoint& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const QuickMatchApologyPoint& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const QuickMatchApologyPoint* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(QuickMatchApologyPoint* other);

  // implements Message ----------------------------------------------

  QuickMatchApologyPoint* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const QuickMatchApologyPoint& from);
  void MergeFrom(const QuickMatchApologyPoint& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.QuickMatchApologyPoint)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static QuickMatchApologyPoint* default_instance_;
};
// -------------------------------------------------------------------

class QuickMatchData : public ::google::protobuf::MessageLite {
 public:
  QuickMatchData();
  virtual ~QuickMatchData();

  QuickMatchData(const QuickMatchData& from);

  inline QuickMatchData& operator=(const QuickMatchData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const QuickMatchData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const QuickMatchData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(QuickMatchData* other);

  // implements Message ----------------------------------------------

  QuickMatchData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const QuickMatchData& from);
  void MergeFrom(const QuickMatchData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 host_player_id = 1;
  inline bool has_host_player_id() const;
  inline void clear_host_player_id();
  static const int kHostPlayerIdFieldNumber = 1;
  inline ::google::protobuf::uint32 host_player_id() const;
  inline void set_host_player_id(::google::protobuf::uint32 value);

  // required string host_player_steam_id = 2;
  inline bool has_host_player_steam_id() const;
  inline void clear_host_player_steam_id();
  static const int kHostPlayerSteamIdFieldNumber = 2;
  inline const ::std::string& host_player_steam_id() const;
  inline void set_host_player_steam_id(const ::std::string& value);
  inline void set_host_player_steam_id(const char* value);
  inline void set_host_player_steam_id(const char* value, size_t size);
  inline ::std::string* mutable_host_player_steam_id();
  inline ::std::string* release_host_player_steam_id();
  inline void set_allocated_host_player_steam_id(::std::string* host_player_steam_id);

  // required uint32 online_area_id = 3;
  inline bool has_online_area_id() const;
  inline void clear_online_area_id();
  static const int kOnlineAreaIdFieldNumber = 3;
  inline ::google::protobuf::uint32 online_area_id() const;
  inline void set_online_area_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.QuickMatchData)
 private:
  inline void set_has_host_player_id();
  inline void clear_has_host_player_id();
  inline void set_has_host_player_steam_id();
  inline void clear_has_host_player_steam_id();
  inline void set_has_online_area_id();
  inline void clear_has_online_area_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* host_player_steam_id_;
  ::google::protobuf::uint32 host_player_id_;
  ::google::protobuf::uint32 online_area_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static QuickMatchData* default_instance_;
};
// -------------------------------------------------------------------

class QuickMatchSearchResult : public ::google::protobuf::MessageLite {
 public:
  QuickMatchSearchResult();
  virtual ~QuickMatchSearchResult();

  QuickMatchSearchResult(const QuickMatchSearchResult& from);

  inline QuickMatchSearchResult& operator=(const QuickMatchSearchResult& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const QuickMatchSearchResult& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const QuickMatchSearchResult* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(QuickMatchSearchResult* other);

  // implements Message ----------------------------------------------

  QuickMatchSearchResult* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const QuickMatchSearchResult& from);
  void MergeFrom(const QuickMatchSearchResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .DS3_Frpg2RequestMessage.QuickMatchData data = 2;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline const ::DS3_Frpg2RequestMessage::QuickMatchData& data() const;
  inline ::DS3_Frpg2RequestMessage::QuickMatchData* mutable_data();
  inline ::DS3_Frpg2RequestMessage::QuickMatchData* release_data();
  inline void set_allocated_data(::DS3_Frpg2RequestMessage::QuickMatchData* data);

  // required uint32 unknown_3 = 3;
  inline bool has_unknown_3() const;
  inline void clear_unknown_3();
  static const int kUnknown3FieldNumber = 3;
  inline ::google::protobuf::uint32 unknown_3() const;
  inline void set_unknown_3(::google::protobuf::uint32 value);

  // required uint32 unknown_4 = 4;
  inline bool has_unknown_4() const;
  inline void clear_unknown_4();
  static const int kUnknown4FieldNumber = 4;
  inline ::google::protobuf::uint32 unknown_4() const;
  inline void set_unknown_4(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.QuickMatchSearchResult)
 private:
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_unknown_3();
  inline void clear_has_unknown_3();
  inline void set_has_unknown_4();
  inline void clear_has_unknown_4();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::DS3_Frpg2RequestMessage::QuickMatchData* data_;
  ::google::protobuf::uint32 unknown_3_;
  ::google::protobuf::uint32 unknown_4_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static QuickMatchSearchResult* default_instance_;
};
// -------------------------------------------------------------------

class AcceptQuickMatchMessage : public ::google::protobuf::MessageLite {
 public:
  AcceptQuickMatchMessage();
  virtual ~AcceptQuickMatchMessage();

  AcceptQuickMatchMessage(const AcceptQuickMatchMessage& from);

  inline AcceptQuickMatchMessage& operator=(const AcceptQuickMatchMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const AcceptQuickMatchMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AcceptQuickMatchMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AcceptQuickMatchMessage* other);

  // implements Message ----------------------------------------------

  AcceptQuickMatchMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AcceptQuickMatchMessage& from);
  void MergeFrom(const AcceptQuickMatchMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 host_player_id = 1;
  inline bool has_host_player_id() const;
  inline void clear_host_player_id();
  static const int kHostPlayerIdFieldNumber = 1;
  inline ::google::protobuf::uint32 host_player_id() const;
  inline void set_host_player_id(::google::protobuf::uint32 value);

  // required string host_player_steam_id = 2;
  inline bool has_host_player_steam_id() const;
  inline void clear_host_player_steam_id();
  static const int kHostPlayerSteamIdFieldNumber = 2;
  inline const ::std::string& host_player_steam_id() const;
  inline void set_host_player_steam_id(const ::std::string& value);
  inline void set_host_player_steam_id(const char* value);
  inline void set_host_player_steam_id(const char* value, size_t size);
  inline ::std::string* mutable_host_player_steam_id();
  inline ::std::string* release_host_player_steam_id();
  inline void set_allocated_host_player_steam_id(::std::string* host_player_steam_id);

  // required bytes metadata = 3;
  inline bool has_metadata() const;
  inline void clear_metadata();
  static const int kMetadataFieldNumber = 3;
  inline const ::std::string& metadata() const;
  inline void set_metadata(const ::std::string& value);
  inline void set_metadata(const char* value);
  inline void set_metadata(const void* value, size_t size);
  inline ::std::string* mutable_metadata();
  inline ::std::string* release_metadata();
  inline void set_allocated_metadata(::std::string* metadata);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.AcceptQuickMatchMessage)
 private:
  inline void set_has_host_player_id();
  inline void clear_has_host_player_id();
  inline void set_has_host_player_steam_id();
  inline void clear_has_host_player_steam_id();
  inline void set_has_metadata();
  inline void clear_has_metadata();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* host_player_steam_id_;
  ::std::string* metadata_;
  ::google::protobuf::uint32 host_player_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static AcceptQuickMatchMessage* default_instance_;
};
// -------------------------------------------------------------------

class RejectQuickMatchMessage : public ::google::protobuf::MessageLite {
 public:
  RejectQuickMatchMessage();
  virtual ~RejectQuickMatchMessage();

  RejectQuickMatchMessage(const RejectQuickMatchMessage& from);

  inline RejectQuickMatchMessage& operator=(const RejectQuickMatchMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RejectQuickMatchMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RejectQuickMatchMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RejectQuickMatchMessage* other);

  // implements Message ----------------------------------------------

  RejectQuickMatchMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RejectQuickMatchMessage& from);
  void MergeFrom(const RejectQuickMatchMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 host_player_id = 1;
  inline bool has_host_player_id() const;
  inline void clear_host_player_id();
  static const int kHostPlayerIdFieldNumber = 1;
  inline ::google::protobuf::uint32 host_player_id() const;
  inline void set_host_player_id(::google::protobuf::uint32 value);

  // required uint32 unknown_2 = 2;
  inline bool has_unknown_2() const;
  inline void clear_unknown_2();
  static const int kUnknown2FieldNumber = 2;
  inline ::google::protobuf::uint32 unknown_2() const;
  inline void set_unknown_2(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RejectQuickMatchMessage)
 private:
  inline void set_has_host_player_id();
  inline void clear_has_host_player_id();
  inline void set_has_unknown_2();
  inline void clear_has_unknown_2();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 host_player_id_;
  ::google::protobuf::uint32 unknown_2_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RejectQuickMatchMessage* default_instance_;
};
// -------------------------------------------------------------------

class RemoveQuickMatchMessage : public ::google::protobuf::MessageLite {
 public:
  RemoveQuickMatchMessage();
  virtual ~RemoveQuickMatchMessage();

  RemoveQuickMatchMessage(const RemoveQuickMatchMessage& from);

  inline RemoveQuickMatchMessage& operator=(const RemoveQuickMatchMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RemoveQuickMatchMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RemoveQuickMatchMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RemoveQuickMatchMessage* other);

  // implements Message ----------------------------------------------

  RemoveQuickMatchMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RemoveQuickMatchMessage& from);
  void MergeFrom(const RemoveQuickMatchMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RemoveQuickMatchMessage)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RemoveQuickMatchMessage* default_instance_;
};
// -------------------------------------------------------------------

class JoinQuickMatchMessage : public ::google::protobuf::MessageLite {
 public:
  JoinQuickMatchMessage();
  virtual ~JoinQuickMatchMessage();

  JoinQuickMatchMessage(const JoinQuickMatchMessage& from);

  inline JoinQuickMatchMessage& operator=(const JoinQuickMatchMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const JoinQuickMatchMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const JoinQuickMatchMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(JoinQuickMatchMessage* other);

  // implements Message ----------------------------------------------

  JoinQuickMatchMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const JoinQuickMatchMessage& from);
  void MergeFrom(const JoinQuickMatchMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 join_player_id = 1;
  inline bool has_join_player_id() const;
  inline void clear_join_player_id();
  static const int kJoinPlayerIdFieldNumber = 1;
  inline ::google::protobuf::uint32 join_player_id() const;
  inline void set_join_player_id(::google::protobuf::uint32 value);

  // required string join_player_steam_id = 2;
  inline bool has_join_player_steam_id() const;
  inline void clear_join_player_steam_id();
  static const int kJoinPlayerSteamIdFieldNumber = 2;
  inline const ::std::string& join_player_steam_id() const;
  inline void set_join_player_steam_id(const ::std::string& value);
  inline void set_join_player_steam_id(const char* value);
  inline void set_join_player_steam_id(const char* value, size_t size);
  inline ::std::string* mutable_join_player_steam_id();
  inline ::std::string* release_join_player_steam_id();
  inline void set_allocated_join_player_steam_id(::std::string* join_player_steam_id);

  // required uint32 join_character_id = 3;
  inline bool has_join_character_id() const;
  inline void clear_join_character_id();
  static const int kJoinCharacterIdFieldNumber = 3;
  inline ::google::protobuf::uint32 join_character_id() const;
  inline void set_join_character_id(::google::protobuf::uint32 value);

  // required uint32 online_area_id = 4;
  inline bool has_online_area_id() const;
  inline void clear_online_area_id();
  static const int kOnlineAreaIdFieldNumber = 4;
  inline ::google::protobuf::uint32 online_area_id() const;
  inline void set_online_area_id(::google::protobuf::uint32 value);

  // required uint32 unknown_5 = 5;
  inline bool has_unknown_5() const;
  inline void clear_unknown_5();
  static const int kUnknown5FieldNumber = 5;
  inline ::google::protobuf::uint32 unknown_5() const;
  inline void set_unknown_5(::google::protobuf::uint32 value);

  // required bytes unknown_6 = 6;
  inline bool has_unknown_6() const;
  inline void clear_unknown_6();
  static const int kUnknown6FieldNumber = 6;
  inline const ::std::string& unknown_6() const;
  inline void set_unknown_6(const ::std::string& value);
  inline void set_unknown_6(const char* value);
  inline void set_unknown_6(const void* value, size_t size);
  inline ::std::string* mutable_unknown_6();
  inline ::std::string* release_unknown_6();
  inline void set_allocated_unknown_6(::std::string* unknown_6);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.JoinQuickMatchMessage)
 private:
  inline void set_has_join_player_id();
  inline void clear_has_join_player_id();
  inline void set_has_join_player_steam_id();
  inline void clear_has_join_player_steam_id();
  inline void set_has_join_character_id();
  inline void clear_has_join_character_id();
  inline void set_has_online_area_id();
  inline void clear_has_online_area_id();
  inline void set_has_unknown_5();
  inline void clear_has_unknown_5();
  inline void set_has_unknown_6();
  inline void clear_has_unknown_6();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* join_player_steam_id_;
  ::google::protobuf::uint32 join_player_id_;
  ::google::protobuf::uint32 join_character_id_;
  ::google::protobuf::uint32 online_area_id_;
  ::google::protobuf::uint32 unknown_5_;
  ::std::string* unknown_6_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static JoinQuickMatchMessage* default_instance_;
};
// -------------------------------------------------------------------

class PushRequestJoinQuickMatch : public ::google::protobuf::MessageLite {
 public:
  PushRequestJoinQuickMatch();
  virtual ~PushRequestJoinQuickMatch();

  PushRequestJoinQuickMatch(const PushRequestJoinQuickMatch& from);

  inline PushRequestJoinQuickMatch& operator=(const PushRequestJoinQuickMatch& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const PushRequestJoinQuickMatch& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PushRequestJoinQuickMatch* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PushRequestJoinQuickMatch* other);

  // implements Message ----------------------------------------------

  PushRequestJoinQuickMatch* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PushRequestJoinQuickMatch& from);
  void MergeFrom(const PushRequestJoinQuickMatch& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
  inline bool has_push_message_id() const;
  inline void clear_push_message_id();
  static const int kPushMessageIdFieldNumber = 1;
  inline ::DS3_Frpg2RequestMessage::PushMessageId push_message_id() const;
  inline void set_push_message_id(::DS3_Frpg2RequestMessage::PushMessageId value);

  // required .DS3_Frpg2RequestMessage.JoinQuickMatchMessage message = 2;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 2;
  inline const ::DS3_Frpg2RequestMessage::JoinQuickMatchMessage& message() const;
  inline ::DS3_Frpg2RequestMessage::JoinQuickMatchMessage* mutable_message();
  inline ::DS3_Frpg2RequestMessage::JoinQuickMatchMessage* release_message();
  inline void set_allocated_message(::DS3_Frpg2RequestMessage::JoinQuickMatchMessage* message);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.PushRequestJoinQuickMatch)
 private:
  inline void set_has_push_message_id();
  inline void clear_has_push_message_id();
  inline void set_has_message();
  inline void clear_has_message();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::DS3_Frpg2RequestMessage::JoinQuickMatchMessage* message_;
  int push_message_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static PushRequestJoinQuickMatch* default_instance_;
};
// -------------------------------------------------------------------

class PushRequestAcceptQuickMatch : public ::google::protobuf::MessageLite {
 public:
  PushRequestAcceptQuickMatch();
  virtual ~PushRequestAcceptQuickMatch();

  PushRequestAcceptQuickMatch(const PushRequestAcceptQuickMatch& from);

  inline PushRequestAcceptQuickMatch& operator=(const PushRequestAcceptQuickMatch& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const PushRequestAcceptQuickMatch& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PushRequestAcceptQuickMatch* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PushRequestAcceptQuickMatch* other);

  // implements Message ----------------------------------------------

  PushRequestAcceptQuickMatch* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PushRequestAcceptQuickMatch& from);
  void MergeFrom(const PushRequestAcceptQuickMatch& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
  inline bool has_push_message_id() const;
  inline void clear_push_message_id();
  static const int kPushMessageIdFieldNumber = 1;
  inline ::DS3_Frpg2RequestMessage::PushMessageId push_message_id() const;
  inline void set_push_message_id(::DS3_Frpg2RequestMessage::PushMessageId value);

  // required .DS3_Frpg2RequestMessage.AcceptQuickMatchMessage message = 2;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 2;
  inline const ::DS3_Frpg2RequestMessage::AcceptQuickMatchMessage& message() const;
  inline ::DS3_Frpg2RequestMessage::AcceptQuickMatchMessage* mutable_message();
  inline ::DS3_Frpg2RequestMessage::AcceptQuickMatchMessage* release_message();
  inline void set_allocated_message(::DS3_Frpg2RequestMessage::AcceptQuickMatchMessage* message);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.PushRequestAcceptQuickMatch)
 private:
  inline void set_has_push_message_id();
  inline void clear_has_push_message_id();
  inline void set_has_message();
  inline void clear_has_message();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::DS3_Frpg2RequestMessage::AcceptQuickMatchMessage* message_;
  int push_message_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static PushRequestAcceptQuickMatch* default_instance_;
};
// -------------------------------------------------------------------

class PushRequestRejectQuickMatch : public ::google::protobuf::MessageLite {
 public:
  PushRequestRejectQuickMatch();
  virtual ~PushRequestRejectQuickMatch();

  PushRequestRejectQuickMatch(const PushRequestRejectQuickMatch& from);

  inline PushRequestRejectQuickMatch& operator=(const PushRequestRejectQuickMatch& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const PushRequestRejectQuickMatch& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PushRequestRejectQuickMatch* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PushRequestRejectQuickMatch* other);

  // implements Message ----------------------------------------------

  PushRequestRejectQuickMatch* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PushRequestRejectQuickMatch& from);
  void MergeFrom(const PushRequestRejectQuickMatch& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
  inline bool has_push_message_id() const;
  inline void clear_push_message_id();
  static const int kPushMessageIdFieldNumber = 1;
  inline ::DS3_Frpg2RequestMessage::PushMessageId push_message_id() const;
  inline void set_push_message_id(::DS3_Frpg2RequestMessage::PushMessageId value);

  // required .DS3_Frpg2RequestMessage.RejectQuickMatchMessage message = 2;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 2;
  inline const ::DS3_Frpg2RequestMessage::RejectQuickMatchMessage& message() const;
  inline ::DS3_Frpg2RequestMessage::RejectQuickMatchMessage* mutable_message();
  inline ::DS3_Frpg2RequestMessage::RejectQuickMatchMessage* release_message();
  inline void set_allocated_message(::DS3_Frpg2RequestMessage::RejectQuickMatchMessage* message);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.PushRequestRejectQuickMatch)
 private:
  inline void set_has_push_message_id();
  inline void clear_has_push_message_id();
  inline void set_has_message();
  inline void clear_has_message();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::DS3_Frpg2RequestMessage::RejectQuickMatchMessage* message_;
  int push_message_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static PushRequestRejectQuickMatch* default_instance_;
};
// -------------------------------------------------------------------

class RequestSearchQuickMatch_Map_id_list : public ::google::protobuf::MessageLite {
 public:
  RequestSearchQuickMatch_Map_id_list();
  virtual ~RequestSearchQuickMatch_Map_id_list();

  RequestSearchQuickMatch_Map_id_list(const RequestSearchQuickMatch_Map_id_list& from);

  inline RequestSearchQuickMatch_Map_id_list& operator=(const RequestSearchQuickMatch_Map_id_list& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestSearchQuickMatch_Map_id_list& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestSearchQuickMatch_Map_id_list* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestSearchQuickMatch_Map_id_list* other);

  // implements Message ----------------------------------------------

  RequestSearchQuickMatch_Map_id_list* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestSearchQuickMatch_Map_id_list& from);
  void MergeFrom(const RequestSearchQuickMatch_Map_id_list& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 map_id = 1;
  inline bool has_map_id() const;
  inline void clear_map_id();
  static const int kMapIdFieldNumber = 1;
  inline ::google::protobuf::uint32 map_id() const;
  inline void set_map_id(::google::protobuf::uint32 value);

  // required uint32 online_area_id = 2;
  inline bool has_online_area_id() const;
  inline void clear_online_area_id();
  static const int kOnlineAreaIdFieldNumber = 2;
  inline ::google::protobuf::uint32 online_area_id() const;
  inline void set_online_area_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestSearchQuickMatch.Map_id_list)
 private:
  inline void set_has_map_id();
  inline void clear_has_map_id();
  inline void set_has_online_area_id();
  inline void clear_has_online_area_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 map_id_;
  ::google::protobuf::uint32 online_area_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestSearchQuickMatch_Map_id_list* default_instance_;
};
// -------------------------------------------------------------------

class RequestSearchQuickMatch : public ::google::protobuf::MessageLite {
 public:
  RequestSearchQuickMatch();
  virtual ~RequestSearchQuickMatch();

  RequestSearchQuickMatch(const RequestSearchQuickMatch& from);

  inline RequestSearchQuickMatch& operator=(const RequestSearchQuickMatch& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestSearchQuickMatch& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestSearchQuickMatch* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestSearchQuickMatch* other);

  // implements Message ----------------------------------------------

  RequestSearchQuickMatch* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestSearchQuickMatch& from);
  void MergeFrom(const RequestSearchQuickMatch& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef RequestSearchQuickMatch_Map_id_list Map_id_list;

  // accessors -------------------------------------------------------

  // required .DS3_Frpg2RequestMessage.QuickMatchGameMode mode = 1;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 1;
  inline ::DS3_Frpg2RequestMessage::QuickMatchGameMode mode() const;
  inline void set_mode(::DS3_Frpg2RequestMessage::QuickMatchGameMode value);

  // repeated group Map_id_list = 2 {
  inline int map_id_list_size() const;
  inline void clear_map_id_list();
  static const int kMapIdListFieldNumber = 2;
  inline const ::DS3_Frpg2RequestMessage::RequestSearchQuickMatch_Map_id_list& map_id_list(int index) const;
  inline ::DS3_Frpg2RequestMessage::RequestSearchQuickMatch_Map_id_list* mutable_map_id_list(int index);
  inline ::DS3_Frpg2RequestMessage::RequestSearchQuickMatch_Map_id_list* add_map_id_list();
  inline const ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::RequestSearchQuickMatch_Map_id_list >&
      map_id_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::RequestSearchQuickMatch_Map_id_list >*
      mutable_map_id_list();

  // required uint32 unknown_3 = 3;
  inline bool has_unknown_3() const;
  inline void clear_unknown_3();
  static const int kUnknown3FieldNumber = 3;
  inline ::google::protobuf::uint32 unknown_3() const;
  inline void set_unknown_3(::google::protobuf::uint32 value);

  // required .DS3_Frpg2RequestMessage.MatchingParameter matching_parameter = 4;
  inline bool has_matching_parameter() const;
  inline void clear_matching_parameter();
  static const int kMatchingParameterFieldNumber = 4;
  inline const ::DS3_Frpg2RequestMessage::MatchingParameter& matching_parameter() const;
  inline ::DS3_Frpg2RequestMessage::MatchingParameter* mutable_matching_parameter();
  inline ::DS3_Frpg2RequestMessage::MatchingParameter* release_matching_parameter();
  inline void set_allocated_matching_parameter(::DS3_Frpg2RequestMessage::MatchingParameter* matching_parameter);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestSearchQuickMatch)
 private:
  inline void set_has_mode();
  inline void clear_has_mode();
  inline void set_has_unknown_3();
  inline void clear_has_unknown_3();
  inline void set_has_matching_parameter();
  inline void clear_has_matching_parameter();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::RequestSearchQuickMatch_Map_id_list > map_id_list_;
  int mode_;
  ::google::protobuf::uint32 unknown_3_;
  ::DS3_Frpg2RequestMessage::MatchingParameter* matching_parameter_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestSearchQuickMatch* default_instance_;
};
// -------------------------------------------------------------------

class RequestSearchQuickMatchResponse : public ::google::protobuf::MessageLite {
 public:
  RequestSearchQuickMatchResponse();
  virtual ~RequestSearchQuickMatchResponse();

  RequestSearchQuickMatchResponse(const RequestSearchQuickMatchResponse& from);

  inline RequestSearchQuickMatchResponse& operator=(const RequestSearchQuickMatchResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestSearchQuickMatchResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestSearchQuickMatchResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestSearchQuickMatchResponse* other);

  // implements Message ----------------------------------------------

  RequestSearchQuickMatchResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestSearchQuickMatchResponse& from);
  void MergeFrom(const RequestSearchQuickMatchResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .DS3_Frpg2RequestMessage.QuickMatchSearchResult matches = 1;
  inline int matches_size() const;
  inline void clear_matches();
  static const int kMatchesFieldNumber = 1;
  inline const ::DS3_Frpg2RequestMessage::QuickMatchSearchResult& matches(int index) const;
  inline ::DS3_Frpg2RequestMessage::QuickMatchSearchResult* mutable_matches(int index);
  inline ::DS3_Frpg2RequestMessage::QuickMatchSearchResult* add_matches();
  inline const ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::QuickMatchSearchResult >&
      matches() const;
  inline ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::QuickMatchSearchResult >*
      mutable_matches();

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestSearchQuickMatchResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::QuickMatchSearchResult > matches_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestSearchQuickMatchResponse* default_instance_;
};
// -------------------------------------------------------------------

class RequestRegisterQuickMatch : public ::google::protobuf::MessageLite {
 public:
  RequestRegisterQuickMatch();
  virtual ~RequestRegisterQuickMatch();

  RequestRegisterQuickMatch(const RequestRegisterQuickMatch& from);

  inline RequestRegisterQuickMatch& operator=(const RequestRegisterQuickMatch& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestRegisterQuickMatch& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestRegisterQuickMatch* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestRegisterQuickMatch* other);

  // implements Message ----------------------------------------------

  RequestRegisterQuickMatch* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestRegisterQuickMatch& from);
  void MergeFrom(const RequestRegisterQuickMatch& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .DS3_Frpg2RequestMessage.QuickMatchGameMode mode = 1;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 1;
  inline ::DS3_Frpg2RequestMessage::QuickMatchGameMode mode() const;
  inline void set_mode(::DS3_Frpg2RequestMessage::QuickMatchGameMode value);

  // required uint32 map_id = 2;
  inline bool has_map_id() const;
  inline void clear_map_id();
  static const int kMapIdFieldNumber = 2;
  inline ::google::protobuf::uint32 map_id() const;
  inline void set_map_id(::google::protobuf::uint32 value);

  // required uint32 online_area_id = 3;
  inline bool has_online_area_id() const;
  inline void clear_online_area_id();
  static const int kOnlineAreaIdFieldNumber = 3;
  inline ::google::protobuf::uint32 online_area_id() const;
  inline void set_online_area_id(::google::protobuf::uint32 value);

  // required .DS3_Frpg2RequestMessage.MatchingParameter matching_parameter = 4;
  inline bool has_matching_parameter() const;
  inline void clear_matching_parameter();
  static const int kMatchingParameterFieldNumber = 4;
  inline const ::DS3_Frpg2RequestMessage::MatchingParameter& matching_parameter() const;
  inline ::DS3_Frpg2RequestMessage::MatchingParameter* mutable_matching_parameter();
  inline ::DS3_Frpg2RequestMessage::MatchingParameter* release_matching_parameter();
  inline void set_allocated_matching_parameter(::DS3_Frpg2RequestMessage::MatchingParameter* matching_parameter);

  // required uint32 unknown_5 = 5;
  inline bool has_unknown_5() const;
  inline void clear_unknown_5();
  static const int kUnknown5FieldNumber = 5;
  inline ::google::protobuf::uint32 unknown_5() const;
  inline void set_unknown_5(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestRegisterQuickMatch)
 private:
  inline void set_has_mode();
  inline void clear_has_mode();
  inline void set_has_map_id();
  inline void clear_has_map_id();
  inline void set_has_online_area_id();
  inline void clear_has_online_area_id();
  inline void set_has_matching_parameter();
  inline void clear_has_matching_parameter();
  inline void set_has_unknown_5();
  inline void clear_has_unknown_5();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int mode_;
  ::google::protobuf::uint32 map_id_;
  ::DS3_Frpg2RequestMessage::MatchingParameter* matching_parameter_;
  ::google::protobuf::uint32 online_area_id_;
  ::google::protobuf::uint32 unknown_5_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestRegisterQuickMatch* default_instance_;
};
// -------------------------------------------------------------------

class RequestUnregisterQuickMatch : public ::google::protobuf::MessageLite {
 public:
  RequestUnregisterQuickMatch();
  virtual ~RequestUnregisterQuickMatch();

  RequestUnregisterQuickMatch(const RequestUnregisterQuickMatch& from);

  inline RequestUnregisterQuickMatch& operator=(const RequestUnregisterQuickMatch& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestUnregisterQuickMatch& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestUnregisterQuickMatch* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestUnregisterQuickMatch* other);

  // implements Message ----------------------------------------------

  RequestUnregisterQuickMatch* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestUnregisterQuickMatch& from);
  void MergeFrom(const RequestUnregisterQuickMatch& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .DS3_Frpg2RequestMessage.QuickMatchGameMode mode = 1;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 1;
  inline ::DS3_Frpg2RequestMessage::QuickMatchGameMode mode() const;
  inline void set_mode(::DS3_Frpg2RequestMessage::QuickMatchGameMode value);

  // required uint32 map_id = 2;
  inline bool has_map_id() const;
  inline void clear_map_id();
  static const int kMapIdFieldNumber = 2;
  inline ::google::protobuf::uint32 map_id() const;
  inline void set_map_id(::google::protobuf::uint32 value);

  // required uint32 online_area_id = 3;
  inline bool has_online_area_id() const;
  inline void clear_online_area_id();
  static const int kOnlineAreaIdFieldNumber = 3;
  inline ::google::protobuf::uint32 online_area_id() const;
  inline void set_online_area_id(::google::protobuf::uint32 value);

  // required uint32 unknown_4 = 4;
  inline bool has_unknown_4() const;
  inline void clear_unknown_4();
  static const int kUnknown4FieldNumber = 4;
  inline ::google::protobuf::uint32 unknown_4() const;
  inline void set_unknown_4(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestUnregisterQuickMatch)
 private:
  inline void set_has_mode();
  inline void clear_has_mode();
  inline void set_has_map_id();
  inline void clear_has_map_id();
  inline void set_has_online_area_id();
  inline void clear_has_online_area_id();
  inline void set_has_unknown_4();
  inline void clear_has_unknown_4();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int mode_;
  ::google::protobuf::uint32 map_id_;
  ::google::protobuf::uint32 online_area_id_;
  ::google::protobuf::uint32 unknown_4_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestUnregisterQuickMatch* default_instance_;
};
// -------------------------------------------------------------------

class RequestRegisterQuickMatchResponse : public ::google::protobuf::MessageLite {
 public:
  RequestRegisterQuickMatchResponse();
  virtual ~RequestRegisterQuickMatchResponse();

  RequestRegisterQuickMatchResponse(const RequestRegisterQuickMatchResponse& from);

  inline RequestRegisterQuickMatchResponse& operator=(const RequestRegisterQuickMatchResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestRegisterQuickMatchResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestRegisterQuickMatchResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestRegisterQuickMatchResponse* other);

  // implements Message ----------------------------------------------

  RequestRegisterQuickMatchResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestRegisterQuickMatchResponse& from);
  void MergeFrom(const RequestRegisterQuickMatchResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestRegisterQuickMatchResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestRegisterQuickMatchResponse* default_instance_;
};
// -------------------------------------------------------------------

class RequestUnregisterQuickMatchResponse : public ::google::protobuf::MessageLite {
 public:
  RequestUnregisterQuickMatchResponse();
  virtual ~RequestUnregisterQuickMatchResponse();

  RequestUnregisterQuickMatchResponse(const RequestUnregisterQuickMatchResponse& from);

  inline RequestUnregisterQuickMatchResponse& operator=(const RequestUnregisterQuickMatchResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestUnregisterQuickMatchResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestUnregisterQuickMatchResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestUnregisterQuickMatchResponse* other);

  // implements Message ----------------------------------------------

  RequestUnregisterQuickMatchResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestUnregisterQuickMatchResponse& from);
  void MergeFrom(const RequestUnregisterQuickMatchResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestUnregisterQuickMatchResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestUnregisterQuickMatchResponse* default_instance_;
};
// -------------------------------------------------------------------

class RequestUpdateQuickMatch : public ::google::protobuf::MessageLite {
 public:
  RequestUpdateQuickMatch();
  virtual ~RequestUpdateQuickMatch();

  RequestUpdateQuickMatch(const RequestUpdateQuickMatch& from);

  inline RequestUpdateQuickMatch& operator=(const RequestUpdateQuickMatch& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestUpdateQuickMatch& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestUpdateQuickMatch* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestUpdateQuickMatch* other);

  // implements Message ----------------------------------------------

  RequestUpdateQuickMatch* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestUpdateQuickMatch& from);
  void MergeFrom(const RequestUpdateQuickMatch& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .DS3_Frpg2RequestMessage.QuickMatchGameMode mode = 1;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 1;
  inline ::DS3_Frpg2RequestMessage::QuickMatchGameMode mode() const;
  inline void set_mode(::DS3_Frpg2RequestMessage::QuickMatchGameMode value);

  // required uint32 map_id = 2;
  inline bool has_map_id() const;
  inline void clear_map_id();
  static const int kMapIdFieldNumber = 2;
  inline ::google::protobuf::uint32 map_id() const;
  inline void set_map_id(::google::protobuf::uint32 value);

  // required uint32 online_area_id = 3;
  inline bool has_online_area_id() const;
  inline void clear_online_area_id();
  static const int kOnlineAreaIdFieldNumber = 3;
  inline ::google::protobuf::uint32 online_area_id() const;
  inline void set_online_area_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestUpdateQuickMatch)
 private:
  inline void set_has_mode();
  inline void clear_has_mode();
  inline void set_has_map_id();
  inline void clear_has_map_id();
  inline void set_has_online_area_id();
  inline void clear_has_online_area_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int mode_;
  ::google::protobuf::uint32 map_id_;
  ::google::protobuf::uint32 online_area_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestUpdateQuickMatch* default_instance_;
};
// -------------------------------------------------------------------

class RequestUpdateQuickMatchResponse : public ::google::protobuf::MessageLite {
 public:
  RequestUpdateQuickMatchResponse();
  virtual ~RequestUpdateQuickMatchResponse();

  RequestUpdateQuickMatchResponse(const RequestUpdateQuickMatchResponse& from);

  inline RequestUpdateQuickMatchResponse& operator=(const RequestUpdateQuickMatchResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestUpdateQuickMatchResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestUpdateQuickMatchResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestUpdateQuickMatchResponse* other);

  // implements Message ----------------------------------------------

  RequestUpdateQuickMatchResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestUpdateQuickMatchResponse& from);
  void MergeFrom(const RequestUpdateQuickMatchResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestUpdateQuickMatchResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestUpdateQuickMatchResponse* default_instance_;
};
// -------------------------------------------------------------------

class RequestJoinQuickMatch : public ::google::protobuf::MessageLite {
 public:
  RequestJoinQuickMatch();
  virtual ~RequestJoinQuickMatch();

  RequestJoinQuickMatch(const RequestJoinQuickMatch& from);

  inline RequestJoinQuickMatch& operator=(const RequestJoinQuickMatch& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestJoinQuickMatch& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestJoinQuickMatch* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestJoinQuickMatch* other);

  // implements Message ----------------------------------------------

  RequestJoinQuickMatch* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestJoinQuickMatch& from);
  void MergeFrom(const RequestJoinQuickMatch& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .DS3_Frpg2RequestMessage.QuickMatchGameMode mode = 1;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 1;
  inline ::DS3_Frpg2RequestMessage::QuickMatchGameMode mode() const;
  inline void set_mode(::DS3_Frpg2RequestMessage::QuickMatchGameMode value);

  // required uint32 character_id = 2;
  inline bool has_character_id() const;
  inline void clear_character_id();
  static const int kCharacterIdFieldNumber = 2;
  inline ::google::protobuf::uint32 character_id() const;
  inline void set_character_id(::google::protobuf::uint32 value);

  // required uint32 host_player_id = 4;
  inline bool has_host_player_id() const;
  inline void clear_host_player_id();
  static const int kHostPlayerIdFieldNumber = 4;
  inline ::google::protobuf::uint32 host_player_id() const;
  inline void set_host_player_id(::google::protobuf::uint32 value);

  // required uint32 map_id = 5;
  inline bool has_map_id() const;
  inline void clear_map_id();
  static const int kMapIdFieldNumber = 5;
  inline ::google::protobuf::uint32 map_id() const;
  inline void set_map_id(::google::protobuf::uint32 value);

  // required uint32 online_area_id = 6;
  inline bool has_online_area_id() const;
  inline void clear_online_area_id();
  static const int kOnlineAreaIdFieldNumber = 6;
  inline ::google::protobuf::uint32 online_area_id() const;
  inline void set_online_area_id(::google::protobuf::uint32 value);

  // required uint32 unknown_7 = 7;
  inline bool has_unknown_7() const;
  inline void clear_unknown_7();
  static const int kUnknown7FieldNumber = 7;
  inline ::google::protobuf::uint32 unknown_7() const;
  inline void set_unknown_7(::google::protobuf::uint32 value);

  // required string password = 8;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 8;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestJoinQuickMatch)
 private:
  inline void set_has_mode();
  inline void clear_has_mode();
  inline void set_has_character_id();
  inline void clear_has_character_id();
  inline void set_has_host_player_id();
  inline void clear_has_host_player_id();
  inline void set_has_map_id();
  inline void clear_has_map_id();
  inline void set_has_online_area_id();
  inline void clear_has_online_area_id();
  inline void set_has_unknown_7();
  inline void clear_has_unknown_7();
  inline void set_has_password();
  inline void clear_has_password();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int mode_;
  ::google::protobuf::uint32 character_id_;
  ::google::protobuf::uint32 host_player_id_;
  ::google::protobuf::uint32 map_id_;
  ::google::protobuf::uint32 online_area_id_;
  ::google::protobuf::uint32 unknown_7_;
  ::std::string* password_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestJoinQuickMatch* default_instance_;
};
// -------------------------------------------------------------------

class RequestJoinQuickMatchResponse : public ::google::protobuf::MessageLite {
 public:
  RequestJoinQuickMatchResponse();
  virtual ~RequestJoinQuickMatchResponse();

  RequestJoinQuickMatchResponse(const RequestJoinQuickMatchResponse& from);

  inline RequestJoinQuickMatchResponse& operator=(const RequestJoinQuickMatchResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestJoinQuickMatchResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestJoinQuickMatchResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestJoinQuickMatchResponse* other);

  // implements Message ----------------------------------------------

  RequestJoinQuickMatchResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestJoinQuickMatchResponse& from);
  void MergeFrom(const RequestJoinQuickMatchResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestJoinQuickMatchResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestJoinQuickMatchResponse* default_instance_;
};
// -------------------------------------------------------------------

class RequestAcceptQuickMatch : public ::google::protobuf::MessageLite {
 public:
  RequestAcceptQuickMatch();
  virtual ~RequestAcceptQuickMatch();

  RequestAcceptQuickMatch(const RequestAcceptQuickMatch& from);

  inline RequestAcceptQuickMatch& operator=(const RequestAcceptQuickMatch& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestAcceptQuickMatch& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestAcceptQuickMatch* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestAcceptQuickMatch* other);

  // implements Message ----------------------------------------------

  RequestAcceptQuickMatch* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestAcceptQuickMatch& from);
  void MergeFrom(const RequestAcceptQuickMatch& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .DS3_Frpg2RequestMessage.QuickMatchGameMode mode = 1;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 1;
  inline ::DS3_Frpg2RequestMessage::QuickMatchGameMode mode() const;
  inline void set_mode(::DS3_Frpg2RequestMessage::QuickMatchGameMode value);

  // required uint32 join_player_id = 4;
  inline bool has_join_player_id() const;
  inline void clear_join_player_id();
  static const int kJoinPlayerIdFieldNumber = 4;
  inline ::google::protobuf::uint32 join_player_id() const;
  inline void set_join_player_id(::google::protobuf::uint32 value);

  // required bytes data = 5;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 5;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestAcceptQuickMatch)
 private:
  inline void set_has_mode();
  inline void clear_has_mode();
  inline void set_has_join_player_id();
  inline void clear_has_join_player_id();
  inline void set_has_data();
  inline void clear_has_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int mode_;
  ::google::protobuf::uint32 join_player_id_;
  ::std::string* data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestAcceptQuickMatch* default_instance_;
};
// -------------------------------------------------------------------

class RequestAcceptQuickMatchResponse : public ::google::protobuf::MessageLite {
 public:
  RequestAcceptQuickMatchResponse();
  virtual ~RequestAcceptQuickMatchResponse();

  RequestAcceptQuickMatchResponse(const RequestAcceptQuickMatchResponse& from);

  inline RequestAcceptQuickMatchResponse& operator=(const RequestAcceptQuickMatchResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestAcceptQuickMatchResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestAcceptQuickMatchResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestAcceptQuickMatchResponse* other);

  // implements Message ----------------------------------------------

  RequestAcceptQuickMatchResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestAcceptQuickMatchResponse& from);
  void MergeFrom(const RequestAcceptQuickMatchResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestAcceptQuickMatchResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestAcceptQuickMatchResponse* default_instance_;
};
// -------------------------------------------------------------------

class RequestRejectQuickMatch : public ::google::protobuf::MessageLite {
 public:
  RequestRejectQuickMatch();
  virtual ~RequestRejectQuickMatch();

  RequestRejectQuickMatch(const RequestRejectQuickMatch& from);

  inline RequestRejectQuickMatch& operator=(const RequestRejectQuickMatch& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestRejectQuickMatch& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestRejectQuickMatch* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestRejectQuickMatch* other);

  // implements Message ----------------------------------------------

  RequestRejectQuickMatch* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestRejectQuickMatch& from);
  void MergeFrom(const RequestRejectQuickMatch& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .DS3_Frpg2RequestMessage.QuickMatchGameMode mode = 1;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 1;
  inline ::DS3_Frpg2RequestMessage::QuickMatchGameMode mode() const;
  inline void set_mode(::DS3_Frpg2RequestMessage::QuickMatchGameMode value);

  // required uint32 map_id = 2;
  inline bool has_map_id() const;
  inline void clear_map_id();
  static const int kMapIdFieldNumber = 2;
  inline ::google::protobuf::uint32 map_id() const;
  inline void set_map_id(::google::protobuf::uint32 value);

  // required uint32 online_area_id = 3;
  inline bool has_online_area_id() const;
  inline void clear_online_area_id();
  static const int kOnlineAreaIdFieldNumber = 3;
  inline ::google::protobuf::uint32 online_area_id() const;
  inline void set_online_area_id(::google::protobuf::uint32 value);

  // required uint32 join_player_id = 4;
  inline bool has_join_player_id() const;
  inline void clear_join_player_id();
  static const int kJoinPlayerIdFieldNumber = 4;
  inline ::google::protobuf::uint32 join_player_id() const;
  inline void set_join_player_id(::google::protobuf::uint32 value);

  // required uint32 unknown_5 = 5;
  inline bool has_unknown_5() const;
  inline void clear_unknown_5();
  static const int kUnknown5FieldNumber = 5;
  inline ::google::protobuf::uint32 unknown_5() const;
  inline void set_unknown_5(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestRejectQuickMatch)
 private:
  inline void set_has_mode();
  inline void clear_has_mode();
  inline void set_has_map_id();
  inline void clear_has_map_id();
  inline void set_has_online_area_id();
  inline void clear_has_online_area_id();
  inline void set_has_join_player_id();
  inline void clear_has_join_player_id();
  inline void set_has_unknown_5();
  inline void clear_has_unknown_5();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int mode_;
  ::google::protobuf::uint32 map_id_;
  ::google::protobuf::uint32 online_area_id_;
  ::google::protobuf::uint32 join_player_id_;
  ::google::protobuf::uint32 unknown_5_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestRejectQuickMatch* default_instance_;
};
// -------------------------------------------------------------------

class RequestRejectQuickMatchResponse : public ::google::protobuf::MessageLite {
 public:
  RequestRejectQuickMatchResponse();
  virtual ~RequestRejectQuickMatchResponse();

  RequestRejectQuickMatchResponse(const RequestRejectQuickMatchResponse& from);

  inline RequestRejectQuickMatchResponse& operator=(const RequestRejectQuickMatchResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestRejectQuickMatchResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestRejectQuickMatchResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestRejectQuickMatchResponse* other);

  // implements Message ----------------------------------------------

  RequestRejectQuickMatchResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestRejectQuickMatchResponse& from);
  void MergeFrom(const RequestRejectQuickMatchResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestRejectQuickMatchResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestRejectQuickMatchResponse* default_instance_;
};
// -------------------------------------------------------------------

class RequestSendQuickMatchStart_Session_member_list : public ::google::protobuf::MessageLite {
 public:
  RequestSendQuickMatchStart_Session_member_list();
  virtual ~RequestSendQuickMatchStart_Session_member_list();

  RequestSendQuickMatchStart_Session_member_list(const RequestSendQuickMatchStart_Session_member_list& from);

  inline RequestSendQuickMatchStart_Session_member_list& operator=(const RequestSendQuickMatchStart_Session_member_list& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestSendQuickMatchStart_Session_member_list& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestSendQuickMatchStart_Session_member_list* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestSendQuickMatchStart_Session_member_list* other);

  // implements Message ----------------------------------------------

  RequestSendQuickMatchStart_Session_member_list* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestSendQuickMatchStart_Session_member_list& from);
  void MergeFrom(const RequestSendQuickMatchStart_Session_member_list& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 player_id = 1;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 1;
  inline ::google::protobuf::uint32 player_id() const;
  inline void set_player_id(::google::protobuf::uint32 value);

  // required uint32 character_id = 2;
  inline bool has_character_id() const;
  inline void clear_character_id();
  static const int kCharacterIdFieldNumber = 2;
  inline ::google::protobuf::uint32 character_id() const;
  inline void set_character_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestSendQuickMatchStart.Session_member_list)
 private:
  inline void set_has_player_id();
  inline void clear_has_player_id();
  inline void set_has_character_id();
  inline void clear_has_character_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 player_id_;
  ::google::protobuf::uint32 character_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestSendQuickMatchStart_Session_member_list* default_instance_;
};
// -------------------------------------------------------------------

class RequestSendQuickMatchStart : public ::google::protobuf::MessageLite {
 public:
  RequestSendQuickMatchStart();
  virtual ~RequestSendQuickMatchStart();

  RequestSendQuickMatchStart(const RequestSendQuickMatchStart& from);

  inline RequestSendQuickMatchStart& operator=(const RequestSendQuickMatchStart& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestSendQuickMatchStart& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestSendQuickMatchStart* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestSendQuickMatchStart* other);

  // implements Message ----------------------------------------------

  RequestSendQuickMatchStart* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestSendQuickMatchStart& from);
  void MergeFrom(const RequestSendQuickMatchStart& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef RequestSendQuickMatchStart_Session_member_list Session_member_list;

  // accessors -------------------------------------------------------

  // required uint32 unknown_1 = 1;
  inline bool has_unknown_1() const;
  inline void clear_unknown_1();
  static const int kUnknown1FieldNumber = 1;
  inline ::google::protobuf::uint32 unknown_1() const;
  inline void set_unknown_1(::google::protobuf::uint32 value);

  // repeated group Session_member_list = 2 {
  inline int session_member_list_size() const;
  inline void clear_session_member_list();
  static const int kSessionMemberListFieldNumber = 2;
  inline const ::DS3_Frpg2RequestMessage::RequestSendQuickMatchStart_Session_member_list& session_member_list(int index) const;
  inline ::DS3_Frpg2RequestMessage::RequestSendQuickMatchStart_Session_member_list* mutable_session_member_list(int index);
  inline ::DS3_Frpg2RequestMessage::RequestSendQuickMatchStart_Session_member_list* add_session_member_list();
  inline const ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::RequestSendQuickMatchStart_Session_member_list >&
      session_member_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::RequestSendQuickMatchStart_Session_member_list >*
      mutable_session_member_list();

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestSendQuickMatchStart)
 private:
  inline void set_has_unknown_1();
  inline void clear_has_unknown_1();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::RequestSendQuickMatchStart_Session_member_list > session_member_list_;
  ::google::protobuf::uint32 unknown_1_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestSendQuickMatchStart* default_instance_;
};
// -------------------------------------------------------------------

class RequestSendQuickMatchStartResponse : public ::google::protobuf::MessageLite {
 public:
  RequestSendQuickMatchStartResponse();
  virtual ~RequestSendQuickMatchStartResponse();

  RequestSendQuickMatchStartResponse(const RequestSendQuickMatchStartResponse& from);

  inline RequestSendQuickMatchStartResponse& operator=(const RequestSendQuickMatchStartResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestSendQuickMatchStartResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestSendQuickMatchStartResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestSendQuickMatchStartResponse* other);

  // implements Message ----------------------------------------------

  RequestSendQuickMatchStartResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestSendQuickMatchStartResponse& from);
  void MergeFrom(const RequestSendQuickMatchStartResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestSendQuickMatchStartResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestSendQuickMatchStartResponse* default_instance_;
};
// -------------------------------------------------------------------

class RequestSendQuickMatchResult : public ::google::protobuf::MessageLite {
 public:
  RequestSendQuickMatchResult();
  virtual ~RequestSendQuickMatchResult();

  RequestSendQuickMatchResult(const RequestSendQuickMatchResult& from);

  inline RequestSendQuickMatchResult& operator=(const RequestSendQuickMatchResult& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestSendQuickMatchResult& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestSendQuickMatchResult* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestSendQuickMatchResult* other);

  // implements Message ----------------------------------------------

  RequestSendQuickMatchResult* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestSendQuickMatchResult& from);
  void MergeFrom(const RequestSendQuickMatchResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .DS3_Frpg2RequestMessage.QuickMatchGameMode mode = 1;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 1;
  inline ::DS3_Frpg2RequestMessage::QuickMatchGameMode mode() const;
  inline void set_mode(::DS3_Frpg2RequestMessage::QuickMatchGameMode value);

  // required uint32 unknown_2 = 2;
  inline bool has_unknown_2() const;
  inline void clear_unknown_2();
  static const int kUnknown2FieldNumber = 2;
  inline ::google::protobuf::uint32 unknown_2() const;
  inline void set_unknown_2(::google::protobuf::uint32 value);

  // required .DS3_Frpg2RequestMessage.QuickMatchResult result = 3;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 3;
  inline ::DS3_Frpg2RequestMessage::QuickMatchResult result() const;
  inline void set_result(::DS3_Frpg2RequestMessage::QuickMatchResult value);

  // required bool local_won = 4;
  inline bool has_local_won() const;
  inline void clear_local_won();
  static const int kLocalWonFieldNumber = 4;
  inline bool local_won() const;
  inline void set_local_won(bool value);

  // required .DS3_Frpg2RequestMessage.QuickMatchRank remote_rank = 5;
  inline bool has_remote_rank() const;
  inline void clear_remote_rank();
  static const int kRemoteRankFieldNumber = 5;
  inline const ::DS3_Frpg2RequestMessage::QuickMatchRank& remote_rank() const;
  inline ::DS3_Frpg2RequestMessage::QuickMatchRank* mutable_remote_rank();
  inline ::DS3_Frpg2RequestMessage::QuickMatchRank* release_remote_rank();
  inline void set_allocated_remote_rank(::DS3_Frpg2RequestMessage::QuickMatchRank* remote_rank);

  // required .DS3_Frpg2RequestMessage.QuickMatchRank local_rank = 6;
  inline bool has_local_rank() const;
  inline void clear_local_rank();
  static const int kLocalRankFieldNumber = 6;
  inline const ::DS3_Frpg2RequestMessage::QuickMatchRank& local_rank() const;
  inline ::DS3_Frpg2RequestMessage::QuickMatchRank* mutable_local_rank();
  inline ::DS3_Frpg2RequestMessage::QuickMatchRank* release_local_rank();
  inline void set_allocated_local_rank(::DS3_Frpg2RequestMessage::QuickMatchRank* local_rank);

  // optional string unknown_7 = 7;
  inline bool has_unknown_7() const;
  inline void clear_unknown_7();
  static const int kUnknown7FieldNumber = 7;
  inline const ::std::string& unknown_7() const;
  inline void set_unknown_7(const ::std::string& value);
  inline void set_unknown_7(const char* value);
  inline void set_unknown_7(const char* value, size_t size);
  inline ::std::string* mutable_unknown_7();
  inline ::std::string* release_unknown_7();
  inline void set_allocated_unknown_7(::std::string* unknown_7);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestSendQuickMatchResult)
 private:
  inline void set_has_mode();
  inline void clear_has_mode();
  inline void set_has_unknown_2();
  inline void clear_has_unknown_2();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_local_won();
  inline void clear_has_local_won();
  inline void set_has_remote_rank();
  inline void clear_has_remote_rank();
  inline void set_has_local_rank();
  inline void clear_has_local_rank();
  inline void set_has_unknown_7();
  inline void clear_has_unknown_7();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int mode_;
  ::google::protobuf::uint32 unknown_2_;
  int result_;
  bool local_won_;
  ::DS3_Frpg2RequestMessage::QuickMatchRank* remote_rank_;
  ::DS3_Frpg2RequestMessage::QuickMatchRank* local_rank_;
  ::std::string* unknown_7_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestSendQuickMatchResult* default_instance_;
};
// -------------------------------------------------------------------

class RequestSendQuickMatchResultResponse : public ::google::protobuf::MessageLite {
 public:
  RequestSendQuickMatchResultResponse();
  virtual ~RequestSendQuickMatchResultResponse();

  RequestSendQuickMatchResultResponse(const RequestSendQuickMatchResultResponse& from);

  inline RequestSendQuickMatchResultResponse& operator=(const RequestSendQuickMatchResultResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestSendQuickMatchResultResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestSendQuickMatchResultResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestSendQuickMatchResultResponse* other);

  // implements Message ----------------------------------------------

  RequestSendQuickMatchResultResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestSendQuickMatchResultResponse& from);
  void MergeFrom(const RequestSendQuickMatchResultResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 unknown_1 = 1;
  inline bool has_unknown_1() const;
  inline void clear_unknown_1();
  static const int kUnknown1FieldNumber = 1;
  inline ::google::protobuf::uint32 unknown_1() const;
  inline void set_unknown_1(::google::protobuf::uint32 value);

  // required .DS3_Frpg2RequestMessage.QuickMatchRank new_local_rank = 2;
  inline bool has_new_local_rank() const;
  inline void clear_new_local_rank();
  static const int kNewLocalRankFieldNumber = 2;
  inline const ::DS3_Frpg2RequestMessage::QuickMatchRank& new_local_rank() const;
  inline ::DS3_Frpg2RequestMessage::QuickMatchRank* mutable_new_local_rank();
  inline ::DS3_Frpg2RequestMessage::QuickMatchRank* release_new_local_rank();
  inline void set_allocated_new_local_rank(::DS3_Frpg2RequestMessage::QuickMatchRank* new_local_rank);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestSendQuickMatchResultResponse)
 private:
  inline void set_has_unknown_1();
  inline void clear_has_unknown_1();
  inline void set_has_new_local_rank();
  inline void clear_has_new_local_rank();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::DS3_Frpg2RequestMessage::QuickMatchRank* new_local_rank_;
  ::google::protobuf::uint32 unknown_1_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestSendQuickMatchResultResponse* default_instance_;
};
// -------------------------------------------------------------------

class RequestPushSendQuickMatchStart : public ::google::protobuf::MessageLite {
 public:
  RequestPushSendQuickMatchStart();
  virtual ~RequestPushSendQuickMatchStart();

  RequestPushSendQuickMatchStart(const RequestPushSendQuickMatchStart& from);

  inline RequestPushSendQuickMatchStart& operator=(const RequestPushSendQuickMatchStart& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestPushSendQuickMatchStart& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestPushSendQuickMatchStart* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestPushSendQuickMatchStart* other);

  // implements Message ----------------------------------------------

  RequestPushSendQuickMatchStart* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestPushSendQuickMatchStart& from);
  void MergeFrom(const RequestPushSendQuickMatchStart& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestPushSendQuickMatchStart)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestPushSendQuickMatchStart* default_instance_;
};
// -------------------------------------------------------------------

class RitualMarkData : public ::google::protobuf::MessageLite {
 public:
  RitualMarkData();
  virtual ~RitualMarkData();

  RitualMarkData(const RitualMarkData& from);

  inline RitualMarkData& operator=(const RitualMarkData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RitualMarkData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RitualMarkData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RitualMarkData* other);

  // implements Message ----------------------------------------------

  RitualMarkData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RitualMarkData& from);
  void MergeFrom(const RitualMarkData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RitualMarkData)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RitualMarkData* default_instance_;
};
// -------------------------------------------------------------------

class LocatedRitualMark : public ::google::protobuf::MessageLite {
 public:
  LocatedRitualMark();
  virtual ~LocatedRitualMark();

  LocatedRitualMark(const LocatedRitualMark& from);

  inline LocatedRitualMark& operator=(const LocatedRitualMark& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const LocatedRitualMark& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LocatedRitualMark* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LocatedRitualMark* other);

  // implements Message ----------------------------------------------

  LocatedRitualMark* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LocatedRitualMark& from);
  void MergeFrom(const LocatedRitualMark& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.LocatedRitualMark)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static LocatedRitualMark* default_instance_;
};
// -------------------------------------------------------------------

class RitualMarkDomainLimit : public ::google::protobuf::MessageLite {
 public:
  RitualMarkDomainLimit();
  virtual ~RitualMarkDomainLimit();

  RitualMarkDomainLimit(const RitualMarkDomainLimit& from);

  inline RitualMarkDomainLimit& operator=(const RitualMarkDomainLimit& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RitualMarkDomainLimit& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RitualMarkDomainLimit* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RitualMarkDomainLimit* other);

  // implements Message ----------------------------------------------

  RitualMarkDomainLimit* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RitualMarkDomainLimit& from);
  void MergeFrom(const RitualMarkDomainLimit& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RitualMarkDomainLimit)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RitualMarkDomainLimit* default_instance_;
};
// -------------------------------------------------------------------

class RequestCreateMark : public ::google::protobuf::MessageLite {
 public:
  RequestCreateMark();
  virtual ~RequestCreateMark();

  RequestCreateMark(const RequestCreateMark& from);

  inline RequestCreateMark& operator=(const RequestCreateMark& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestCreateMark& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestCreateMark* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestCreateMark* other);

  // implements Message ----------------------------------------------

  RequestCreateMark* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestCreateMark& from);
  void MergeFrom(const RequestCreateMark& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestCreateMark)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestCreateMark* default_instance_;
};
// -------------------------------------------------------------------

class RequestCreateMarkResponse : public ::google::protobuf::MessageLite {
 public:
  RequestCreateMarkResponse();
  virtual ~RequestCreateMarkResponse();

  RequestCreateMarkResponse(const RequestCreateMarkResponse& from);

  inline RequestCreateMarkResponse& operator=(const RequestCreateMarkResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestCreateMarkResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestCreateMarkResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestCreateMarkResponse* other);

  // implements Message ----------------------------------------------

  RequestCreateMarkResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestCreateMarkResponse& from);
  void MergeFrom(const RequestCreateMarkResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestCreateMarkResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestCreateMarkResponse* default_instance_;
};
// -------------------------------------------------------------------

class RequestRemoveMark : public ::google::protobuf::MessageLite {
 public:
  RequestRemoveMark();
  virtual ~RequestRemoveMark();

  RequestRemoveMark(const RequestRemoveMark& from);

  inline RequestRemoveMark& operator=(const RequestRemoveMark& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestRemoveMark& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestRemoveMark* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestRemoveMark* other);

  // implements Message ----------------------------------------------

  RequestRemoveMark* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestRemoveMark& from);
  void MergeFrom(const RequestRemoveMark& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestRemoveMark)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestRemoveMark* default_instance_;
};
// -------------------------------------------------------------------

class RequestRemoveMarkResponse : public ::google::protobuf::MessageLite {
 public:
  RequestRemoveMarkResponse();
  virtual ~RequestRemoveMarkResponse();

  RequestRemoveMarkResponse(const RequestRemoveMarkResponse& from);

  inline RequestRemoveMarkResponse& operator=(const RequestRemoveMarkResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestRemoveMarkResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestRemoveMarkResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestRemoveMarkResponse* other);

  // implements Message ----------------------------------------------

  RequestRemoveMarkResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestRemoveMarkResponse& from);
  void MergeFrom(const RequestRemoveMarkResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestRemoveMarkResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestRemoveMarkResponse* default_instance_;
};
// -------------------------------------------------------------------

class RequestReentryMark : public ::google::protobuf::MessageLite {
 public:
  RequestReentryMark();
  virtual ~RequestReentryMark();

  RequestReentryMark(const RequestReentryMark& from);

  inline RequestReentryMark& operator=(const RequestReentryMark& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestReentryMark& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestReentryMark* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestReentryMark* other);

  // implements Message ----------------------------------------------

  RequestReentryMark* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestReentryMark& from);
  void MergeFrom(const RequestReentryMark& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestReentryMark)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestReentryMark* default_instance_;
};
// -------------------------------------------------------------------

class RequestReentryMarkResponse : public ::google::protobuf::MessageLite {
 public:
  RequestReentryMarkResponse();
  virtual ~RequestReentryMarkResponse();

  RequestReentryMarkResponse(const RequestReentryMarkResponse& from);

  inline RequestReentryMarkResponse& operator=(const RequestReentryMarkResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestReentryMarkResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestReentryMarkResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestReentryMarkResponse* other);

  // implements Message ----------------------------------------------

  RequestReentryMarkResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestReentryMarkResponse& from);
  void MergeFrom(const RequestReentryMarkResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestReentryMarkResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestReentryMarkResponse* default_instance_;
};
// -------------------------------------------------------------------

class RequestGetMarkList : public ::google::protobuf::MessageLite {
 public:
  RequestGetMarkList();
  virtual ~RequestGetMarkList();

  RequestGetMarkList(const RequestGetMarkList& from);

  inline RequestGetMarkList& operator=(const RequestGetMarkList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestGetMarkList& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestGetMarkList* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestGetMarkList* other);

  // implements Message ----------------------------------------------

  RequestGetMarkList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestGetMarkList& from);
  void MergeFrom(const RequestGetMarkList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestGetMarkList)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestGetMarkList* default_instance_;
};
// -------------------------------------------------------------------

class RequestGetMarkListResponse : public ::google::protobuf::MessageLite {
 public:
  RequestGetMarkListResponse();
  virtual ~RequestGetMarkListResponse();

  RequestGetMarkListResponse(const RequestGetMarkListResponse& from);

  inline RequestGetMarkListResponse& operator=(const RequestGetMarkListResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestGetMarkListResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestGetMarkListResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestGetMarkListResponse* other);

  // implements Message ----------------------------------------------

  RequestGetMarkListResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestGetMarkListResponse& from);
  void MergeFrom(const RequestGetMarkListResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestGetMarkListResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestGetMarkListResponse* default_instance_;
};
// -------------------------------------------------------------------

class PushRequestHeader : public ::google::protobuf::MessageLite {
 public:
  PushRequestHeader();
  virtual ~PushRequestHeader();

  PushRequestHeader(const PushRequestHeader& from);

  inline PushRequestHeader& operator=(const PushRequestHeader& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const PushRequestHeader& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PushRequestHeader* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PushRequestHeader* other);

  // implements Message ----------------------------------------------

  PushRequestHeader* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PushRequestHeader& from);
  void MergeFrom(const PushRequestHeader& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
  inline bool has_push_message_id() const;
  inline void clear_push_message_id();
  static const int kPushMessageIdFieldNumber = 1;
  inline ::DS3_Frpg2RequestMessage::PushMessageId push_message_id() const;
  inline void set_push_message_id(::DS3_Frpg2RequestMessage::PushMessageId value);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.PushRequestHeader)
 private:
  inline void set_has_push_message_id();
  inline void clear_has_push_message_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int push_message_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static PushRequestHeader* default_instance_;
};
// -------------------------------------------------------------------

class RangedLimit : public ::google::protobuf::MessageLite {
 public:
  RangedLimit();
  virtual ~RangedLimit();

  RangedLimit(const RangedLimit& from);

  inline RangedLimit& operator=(const RangedLimit& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RangedLimit& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RangedLimit* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RangedLimit* other);

  // implements Message ----------------------------------------------

  RangedLimit* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RangedLimit& from);
  void MergeFrom(const RangedLimit& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RangedLimit)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RangedLimit* default_instance_;
};
// -------------------------------------------------------------------

class PlayerUserIDPair : public ::google::protobuf::MessageLite {
 public:
  PlayerUserIDPair();
  virtual ~PlayerUserIDPair();

  PlayerUserIDPair(const PlayerUserIDPair& from);

  inline PlayerUserIDPair& operator=(const PlayerUserIDPair& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const PlayerUserIDPair& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PlayerUserIDPair* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PlayerUserIDPair* other);

  // implements Message ----------------------------------------------

  PlayerUserIDPair* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PlayerUserIDPair& from);
  void MergeFrom(const PlayerUserIDPair& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.PlayerUserIDPair)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static PlayerUserIDPair* default_instance_;
};
// -------------------------------------------------------------------

class ManagementTextMessage : public ::google::protobuf::MessageLite {
 public:
  ManagementTextMessage();
  virtual ~ManagementTextMessage();

  ManagementTextMessage(const ManagementTextMessage& from);

  inline ManagementTextMessage& operator=(const ManagementTextMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ManagementTextMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ManagementTextMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ManagementTextMessage* other);

  // implements Message ----------------------------------------------

  ManagementTextMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ManagementTextMessage& from);
  void MergeFrom(const ManagementTextMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
  inline bool has_push_message_id() const;
  inline void clear_push_message_id();
  static const int kPushMessageIdFieldNumber = 1;
  inline ::DS3_Frpg2RequestMessage::PushMessageId push_message_id() const;
  inline void set_push_message_id(::DS3_Frpg2RequestMessage::PushMessageId value);

  // required string message = 2;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 2;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // required .DS3_Frpg2PlayerData.DateTime timestamp = 3;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 3;
  inline const ::DS3_Frpg2PlayerData::DateTime& timestamp() const;
  inline ::DS3_Frpg2PlayerData::DateTime* mutable_timestamp();
  inline ::DS3_Frpg2PlayerData::DateTime* release_timestamp();
  inline void set_allocated_timestamp(::DS3_Frpg2PlayerData::DateTime* timestamp);

  // required uint32 unknown_4 = 4;
  inline bool has_unknown_4() const;
  inline void clear_unknown_4();
  static const int kUnknown4FieldNumber = 4;
  inline ::google::protobuf::uint32 unknown_4() const;
  inline void set_unknown_4(::google::protobuf::uint32 value);

  // required uint32 unknown_5 = 5;
  inline bool has_unknown_5() const;
  inline void clear_unknown_5();
  static const int kUnknown5FieldNumber = 5;
  inline ::google::protobuf::uint32 unknown_5() const;
  inline void set_unknown_5(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.ManagementTextMessage)
 private:
  inline void set_has_push_message_id();
  inline void clear_has_push_message_id();
  inline void set_has_message();
  inline void clear_has_message();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_unknown_4();
  inline void clear_has_unknown_4();
  inline void set_has_unknown_5();
  inline void clear_has_unknown_5();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* message_;
  int push_message_id_;
  ::google::protobuf::uint32 unknown_4_;
  ::DS3_Frpg2PlayerData::DateTime* timestamp_;
  ::google::protobuf::uint32 unknown_5_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static ManagementTextMessage* default_instance_;
};
// -------------------------------------------------------------------

class NRLogUploadRequest : public ::google::protobuf::MessageLite {
 public:
  NRLogUploadRequest();
  virtual ~NRLogUploadRequest();

  NRLogUploadRequest(const NRLogUploadRequest& from);

  inline NRLogUploadRequest& operator=(const NRLogUploadRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const NRLogUploadRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NRLogUploadRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NRLogUploadRequest* other);

  // implements Message ----------------------------------------------

  NRLogUploadRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NRLogUploadRequest& from);
  void MergeFrom(const NRLogUploadRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 unknown_1 = 1;
  inline bool has_unknown_1() const;
  inline void clear_unknown_1();
  static const int kUnknown1FieldNumber = 1;
  inline ::google::protobuf::uint32 unknown_1() const;
  inline void set_unknown_1(::google::protobuf::uint32 value);

  // required uint32 unknown_2 = 2;
  inline bool has_unknown_2() const;
  inline void clear_unknown_2();
  static const int kUnknown2FieldNumber = 2;
  inline ::google::protobuf::uint32 unknown_2() const;
  inline void set_unknown_2(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.NRLogUploadRequest)
 private:
  inline void set_has_unknown_1();
  inline void clear_has_unknown_1();
  inline void set_has_unknown_2();
  inline void clear_has_unknown_2();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 unknown_1_;
  ::google::protobuf::uint32 unknown_2_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static NRLogUploadRequest* default_instance_;
};
// -------------------------------------------------------------------

class NRLoggingMessage : public ::google::protobuf::MessageLite {
 public:
  NRLoggingMessage();
  virtual ~NRLoggingMessage();

  NRLoggingMessage(const NRLoggingMessage& from);

  inline NRLoggingMessage& operator=(const NRLoggingMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const NRLoggingMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NRLoggingMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NRLoggingMessage* other);

  // implements Message ----------------------------------------------

  NRLoggingMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NRLoggingMessage& from);
  void MergeFrom(const NRLoggingMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 unknown_1 = 1;
  inline bool has_unknown_1() const;
  inline void clear_unknown_1();
  static const int kUnknown1FieldNumber = 1;
  inline ::google::protobuf::uint32 unknown_1() const;
  inline void set_unknown_1(::google::protobuf::uint32 value);

  // required bytes unknown_2 = 2;
  inline bool has_unknown_2() const;
  inline void clear_unknown_2();
  static const int kUnknown2FieldNumber = 2;
  inline const ::std::string& unknown_2() const;
  inline void set_unknown_2(const ::std::string& value);
  inline void set_unknown_2(const char* value);
  inline void set_unknown_2(const void* value, size_t size);
  inline ::std::string* mutable_unknown_2();
  inline ::std::string* release_unknown_2();
  inline void set_allocated_unknown_2(::std::string* unknown_2);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.NRLoggingMessage)
 private:
  inline void set_has_unknown_1();
  inline void clear_has_unknown_1();
  inline void set_has_unknown_2();
  inline void clear_has_unknown_2();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* unknown_2_;
  ::google::protobuf::uint32 unknown_1_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static NRLoggingMessage* default_instance_;
};
// -------------------------------------------------------------------

class ServerPing : public ::google::protobuf::MessageLite {
 public:
  ServerPing();
  virtual ~ServerPing();

  ServerPing(const ServerPing& from);

  inline ServerPing& operator=(const ServerPing& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ServerPing& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ServerPing* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ServerPing* other);

  // implements Message ----------------------------------------------

  ServerPing* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ServerPing& from);
  void MergeFrom(const ServerPing& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 unknown_1 = 1;
  inline bool has_unknown_1() const;
  inline void clear_unknown_1();
  static const int kUnknown1FieldNumber = 1;
  inline ::google::protobuf::uint32 unknown_1() const;
  inline void set_unknown_1(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.ServerPing)
 private:
  inline void set_has_unknown_1();
  inline void clear_has_unknown_1();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 unknown_1_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static ServerPing* default_instance_;
};
// -------------------------------------------------------------------

class RequestGetOnlineShopItemList : public ::google::protobuf::MessageLite {
 public:
  RequestGetOnlineShopItemList();
  virtual ~RequestGetOnlineShopItemList();

  RequestGetOnlineShopItemList(const RequestGetOnlineShopItemList& from);

  inline RequestGetOnlineShopItemList& operator=(const RequestGetOnlineShopItemList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestGetOnlineShopItemList& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestGetOnlineShopItemList* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestGetOnlineShopItemList* other);

  // implements Message ----------------------------------------------

  RequestGetOnlineShopItemList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestGetOnlineShopItemList& from);
  void MergeFrom(const RequestGetOnlineShopItemList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestGetOnlineShopItemList)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestGetOnlineShopItemList* default_instance_;
};
// -------------------------------------------------------------------

class RequestGetOnlineShopItemListResponse_Lineup : public ::google::protobuf::MessageLite {
 public:
  RequestGetOnlineShopItemListResponse_Lineup();
  virtual ~RequestGetOnlineShopItemListResponse_Lineup();

  RequestGetOnlineShopItemListResponse_Lineup(const RequestGetOnlineShopItemListResponse_Lineup& from);

  inline RequestGetOnlineShopItemListResponse_Lineup& operator=(const RequestGetOnlineShopItemListResponse_Lineup& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestGetOnlineShopItemListResponse_Lineup& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestGetOnlineShopItemListResponse_Lineup* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestGetOnlineShopItemListResponse_Lineup* other);

  // implements Message ----------------------------------------------

  RequestGetOnlineShopItemListResponse_Lineup* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestGetOnlineShopItemListResponse_Lineup& from);
  void MergeFrom(const RequestGetOnlineShopItemListResponse_Lineup& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestGetOnlineShopItemListResponse.Lineup)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestGetOnlineShopItemListResponse_Lineup* default_instance_;
};
// -------------------------------------------------------------------

class RequestGetOnlineShopItemListResponse : public ::google::protobuf::MessageLite {
 public:
  RequestGetOnlineShopItemListResponse();
  virtual ~RequestGetOnlineShopItemListResponse();

  RequestGetOnlineShopItemListResponse(const RequestGetOnlineShopItemListResponse& from);

  inline RequestGetOnlineShopItemListResponse& operator=(const RequestGetOnlineShopItemListResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestGetOnlineShopItemListResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestGetOnlineShopItemListResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestGetOnlineShopItemListResponse* other);

  // implements Message ----------------------------------------------

  RequestGetOnlineShopItemListResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestGetOnlineShopItemListResponse& from);
  void MergeFrom(const RequestGetOnlineShopItemListResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef RequestGetOnlineShopItemListResponse_Lineup Lineup;

  // accessors -------------------------------------------------------

  // repeated group Lineup = 2 {
  inline int lineup_size() const;
  inline void clear_lineup();
  static const int kLineupFieldNumber = 2;
  inline const ::DS3_Frpg2RequestMessage::RequestGetOnlineShopItemListResponse_Lineup& lineup(int index) const;
  inline ::DS3_Frpg2RequestMessage::RequestGetOnlineShopItemListResponse_Lineup* mutable_lineup(int index);
  inline ::DS3_Frpg2RequestMessage::RequestGetOnlineShopItemListResponse_Lineup* add_lineup();
  inline const ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::RequestGetOnlineShopItemListResponse_Lineup >&
      lineup() const;
  inline ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::RequestGetOnlineShopItemListResponse_Lineup >*
      mutable_lineup();

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestGetOnlineShopItemListResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::RequestGetOnlineShopItemListResponse_Lineup > lineup_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestGetOnlineShopItemListResponse* default_instance_;
};
// -------------------------------------------------------------------

class LoginForXboxOne : public ::google::protobuf::MessageLite {
 public:
  LoginForXboxOne();
  virtual ~LoginForXboxOne();

  LoginForXboxOne(const LoginForXboxOne& from);

  inline LoginForXboxOne& operator=(const LoginForXboxOne& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const LoginForXboxOne& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LoginForXboxOne* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LoginForXboxOne* other);

  // implements Message ----------------------------------------------

  LoginForXboxOne* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LoginForXboxOne& from);
  void MergeFrom(const LoginForXboxOne& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.LoginForXboxOne)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static LoginForXboxOne* default_instance_;
};
// -------------------------------------------------------------------

class SocketOptionSetting : public ::google::protobuf::MessageLite {
 public:
  SocketOptionSetting();
  virtual ~SocketOptionSetting();

  SocketOptionSetting(const SocketOptionSetting& from);

  inline SocketOptionSetting& operator=(const SocketOptionSetting& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const SocketOptionSetting& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SocketOptionSetting* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SocketOptionSetting* other);

  // implements Message ----------------------------------------------

  SocketOptionSetting* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SocketOptionSetting& from);
  void MergeFrom(const SocketOptionSetting& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.SocketOptionSetting)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static SocketOptionSetting* default_instance_;
};
// -------------------------------------------------------------------

class GetConnectGameServerPortIdResponse : public ::google::protobuf::MessageLite {
 public:
  GetConnectGameServerPortIdResponse();
  virtual ~GetConnectGameServerPortIdResponse();

  GetConnectGameServerPortIdResponse(const GetConnectGameServerPortIdResponse& from);

  inline GetConnectGameServerPortIdResponse& operator=(const GetConnectGameServerPortIdResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GetConnectGameServerPortIdResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetConnectGameServerPortIdResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetConnectGameServerPortIdResponse* other);

  // implements Message ----------------------------------------------

  GetConnectGameServerPortIdResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetConnectGameServerPortIdResponse& from);
  void MergeFrom(const GetConnectGameServerPortIdResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.GetConnectGameServerPortIdResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static GetConnectGameServerPortIdResponse* default_instance_;
};
// -------------------------------------------------------------------

class NotifyLoginToPushServer : public ::google::protobuf::MessageLite {
 public:
  NotifyLoginToPushServer();
  virtual ~NotifyLoginToPushServer();

  NotifyLoginToPushServer(const NotifyLoginToPushServer& from);

  inline NotifyLoginToPushServer& operator=(const NotifyLoginToPushServer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const NotifyLoginToPushServer& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NotifyLoginToPushServer* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NotifyLoginToPushServer* other);

  // implements Message ----------------------------------------------

  NotifyLoginToPushServer* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NotifyLoginToPushServer& from);
  void MergeFrom(const NotifyLoginToPushServer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.NotifyLoginToPushServer)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static NotifyLoginToPushServer* default_instance_;
};
// -------------------------------------------------------------------

class NotifyLogoutToPushServer : public ::google::protobuf::MessageLite {
 public:
  NotifyLogoutToPushServer();
  virtual ~NotifyLogoutToPushServer();

  NotifyLogoutToPushServer(const NotifyLogoutToPushServer& from);

  inline NotifyLogoutToPushServer& operator=(const NotifyLogoutToPushServer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const NotifyLogoutToPushServer& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NotifyLogoutToPushServer* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NotifyLogoutToPushServer* other);

  // implements Message ----------------------------------------------

  NotifyLogoutToPushServer* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NotifyLogoutToPushServer& from);
  void MergeFrom(const NotifyLogoutToPushServer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.NotifyLogoutToPushServer)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static NotifyLogoutToPushServer* default_instance_;
};
// -------------------------------------------------------------------

class UserLoginInfo : public ::google::protobuf::MessageLite {
 public:
  UserLoginInfo();
  virtual ~UserLoginInfo();

  UserLoginInfo(const UserLoginInfo& from);

  inline UserLoginInfo& operator=(const UserLoginInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const UserLoginInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UserLoginInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UserLoginInfo* other);

  // implements Message ----------------------------------------------

  UserLoginInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UserLoginInfo& from);
  void MergeFrom(const UserLoginInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.UserLoginInfo)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static UserLoginInfo* default_instance_;
};
// -------------------------------------------------------------------

class UserLogout : public ::google::protobuf::MessageLite {
 public:
  UserLogout();
  virtual ~UserLogout();

  UserLogout(const UserLogout& from);

  inline UserLogout& operator=(const UserLogout& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const UserLogout& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UserLogout* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UserLogout* other);

  // implements Message ----------------------------------------------

  UserLogout* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UserLogout& from);
  void MergeFrom(const UserLogout& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.UserLogout)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static UserLogout* default_instance_;
};
// -------------------------------------------------------------------

class LoginClientInfo : public ::google::protobuf::MessageLite {
 public:
  LoginClientInfo();
  virtual ~LoginClientInfo();

  LoginClientInfo(const LoginClientInfo& from);

  inline LoginClientInfo& operator=(const LoginClientInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const LoginClientInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LoginClientInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LoginClientInfo* other);

  // implements Message ----------------------------------------------

  LoginClientInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LoginClientInfo& from);
  void MergeFrom(const LoginClientInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.LoginClientInfo)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static LoginClientInfo* default_instance_;
};
// -------------------------------------------------------------------

class NotifyClientServerInfoToPushServer : public ::google::protobuf::MessageLite {
 public:
  NotifyClientServerInfoToPushServer();
  virtual ~NotifyClientServerInfoToPushServer();

  NotifyClientServerInfoToPushServer(const NotifyClientServerInfoToPushServer& from);

  inline NotifyClientServerInfoToPushServer& operator=(const NotifyClientServerInfoToPushServer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const NotifyClientServerInfoToPushServer& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NotifyClientServerInfoToPushServer* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NotifyClientServerInfoToPushServer* other);

  // implements Message ----------------------------------------------

  NotifyClientServerInfoToPushServer* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NotifyClientServerInfoToPushServer& from);
  void MergeFrom(const NotifyClientServerInfoToPushServer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 unknown_1 = 1;
  inline bool has_unknown_1() const;
  inline void clear_unknown_1();
  static const int kUnknown1FieldNumber = 1;
  inline ::google::protobuf::uint32 unknown_1() const;
  inline void set_unknown_1(::google::protobuf::uint32 value);

  // required uint32 unknown_2 = 2;
  inline bool has_unknown_2() const;
  inline void clear_unknown_2();
  static const int kUnknown2FieldNumber = 2;
  inline ::google::protobuf::uint32 unknown_2() const;
  inline void set_unknown_2(::google::protobuf::uint32 value);

  // required uint32 unknown_3 = 3;
  inline bool has_unknown_3() const;
  inline void clear_unknown_3();
  static const int kUnknown3FieldNumber = 3;
  inline ::google::protobuf::uint32 unknown_3() const;
  inline void set_unknown_3(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.NotifyClientServerInfoToPushServer)
 private:
  inline void set_has_unknown_1();
  inline void clear_has_unknown_1();
  inline void set_has_unknown_2();
  inline void clear_has_unknown_2();
  inline void set_has_unknown_3();
  inline void clear_has_unknown_3();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 unknown_1_;
  ::google::protobuf::uint32 unknown_2_;
  ::google::protobuf::uint32 unknown_3_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static NotifyClientServerInfoToPushServer* default_instance_;
};
// -------------------------------------------------------------------

class PushLoginUserInfo : public ::google::protobuf::MessageLite {
 public:
  PushLoginUserInfo();
  virtual ~PushLoginUserInfo();

  PushLoginUserInfo(const PushLoginUserInfo& from);

  inline PushLoginUserInfo& operator=(const PushLoginUserInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const PushLoginUserInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PushLoginUserInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PushLoginUserInfo* other);

  // implements Message ----------------------------------------------

  PushLoginUserInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PushLoginUserInfo& from);
  void MergeFrom(const PushLoginUserInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 unknown_1 = 1;
  inline bool has_unknown_1() const;
  inline void clear_unknown_1();
  static const int kUnknown1FieldNumber = 1;
  inline ::google::protobuf::uint32 unknown_1() const;
  inline void set_unknown_1(::google::protobuf::uint32 value);

  // required uint32 unknown_2 = 2;
  inline bool has_unknown_2() const;
  inline void clear_unknown_2();
  static const int kUnknown2FieldNumber = 2;
  inline ::google::protobuf::uint32 unknown_2() const;
  inline void set_unknown_2(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.PushLoginUserInfo)
 private:
  inline void set_has_unknown_1();
  inline void clear_has_unknown_1();
  inline void set_has_unknown_2();
  inline void clear_has_unknown_2();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 unknown_1_;
  ::google::protobuf::uint32 unknown_2_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static PushLoginUserInfo* default_instance_;
};
// -------------------------------------------------------------------

class RequestCheckLogin : public ::google::protobuf::MessageLite {
 public:
  RequestCheckLogin();
  virtual ~RequestCheckLogin();

  RequestCheckLogin(const RequestCheckLogin& from);

  inline RequestCheckLogin& operator=(const RequestCheckLogin& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestCheckLogin& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestCheckLogin* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestCheckLogin* other);

  // implements Message ----------------------------------------------

  RequestCheckLogin* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestCheckLogin& from);
  void MergeFrom(const RequestCheckLogin& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestCheckLogin)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestCheckLogin* default_instance_;
};
// -------------------------------------------------------------------

class RequestCheckLoginResponse : public ::google::protobuf::MessageLite {
 public:
  RequestCheckLoginResponse();
  virtual ~RequestCheckLoginResponse();

  RequestCheckLoginResponse(const RequestCheckLoginResponse& from);

  inline RequestCheckLoginResponse& operator=(const RequestCheckLoginResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestCheckLoginResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestCheckLoginResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestCheckLoginResponse* other);

  // implements Message ----------------------------------------------

  RequestCheckLoginResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestCheckLoginResponse& from);
  void MergeFrom(const RequestCheckLoginResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestCheckLoginResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestCheckLoginResponse* default_instance_;
};
// -------------------------------------------------------------------

class RequestGetPlayerConnectGameServer : public ::google::protobuf::MessageLite {
 public:
  RequestGetPlayerConnectGameServer();
  virtual ~RequestGetPlayerConnectGameServer();

  RequestGetPlayerConnectGameServer(const RequestGetPlayerConnectGameServer& from);

  inline RequestGetPlayerConnectGameServer& operator=(const RequestGetPlayerConnectGameServer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestGetPlayerConnectGameServer& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestGetPlayerConnectGameServer* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestGetPlayerConnectGameServer* other);

  // implements Message ----------------------------------------------

  RequestGetPlayerConnectGameServer* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestGetPlayerConnectGameServer& from);
  void MergeFrom(const RequestGetPlayerConnectGameServer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestGetPlayerConnectGameServer)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestGetPlayerConnectGameServer* default_instance_;
};
// -------------------------------------------------------------------

class PlayerConnectServerInfo : public ::google::protobuf::MessageLite {
 public:
  PlayerConnectServerInfo();
  virtual ~PlayerConnectServerInfo();

  PlayerConnectServerInfo(const PlayerConnectServerInfo& from);

  inline PlayerConnectServerInfo& operator=(const PlayerConnectServerInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const PlayerConnectServerInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PlayerConnectServerInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PlayerConnectServerInfo* other);

  // implements Message ----------------------------------------------

  PlayerConnectServerInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PlayerConnectServerInfo& from);
  void MergeFrom(const PlayerConnectServerInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.PlayerConnectServerInfo)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static PlayerConnectServerInfo* default_instance_;
};
// -------------------------------------------------------------------

class RequestGetPlayerConnectGameServerResponse : public ::google::protobuf::MessageLite {
 public:
  RequestGetPlayerConnectGameServerResponse();
  virtual ~RequestGetPlayerConnectGameServerResponse();

  RequestGetPlayerConnectGameServerResponse(const RequestGetPlayerConnectGameServerResponse& from);

  inline RequestGetPlayerConnectGameServerResponse& operator=(const RequestGetPlayerConnectGameServerResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestGetPlayerConnectGameServerResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestGetPlayerConnectGameServerResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestGetPlayerConnectGameServerResponse* other);

  // implements Message ----------------------------------------------

  RequestGetPlayerConnectGameServerResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestGetPlayerConnectGameServerResponse& from);
  void MergeFrom(const RequestGetPlayerConnectGameServerResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestGetPlayerConnectGameServerResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestGetPlayerConnectGameServerResponse* default_instance_;
};
// -------------------------------------------------------------------

class RequestGetServerConnectTime : public ::google::protobuf::MessageLite {
 public:
  RequestGetServerConnectTime();
  virtual ~RequestGetServerConnectTime();

  RequestGetServerConnectTime(const RequestGetServerConnectTime& from);

  inline RequestGetServerConnectTime& operator=(const RequestGetServerConnectTime& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestGetServerConnectTime& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestGetServerConnectTime* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestGetServerConnectTime* other);

  // implements Message ----------------------------------------------

  RequestGetServerConnectTime* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestGetServerConnectTime& from);
  void MergeFrom(const RequestGetServerConnectTime& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestGetServerConnectTime)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestGetServerConnectTime* default_instance_;
};
// -------------------------------------------------------------------

class RequestGetServerConnectTimeResponse : public ::google::protobuf::MessageLite {
 public:
  RequestGetServerConnectTimeResponse();
  virtual ~RequestGetServerConnectTimeResponse();

  RequestGetServerConnectTimeResponse(const RequestGetServerConnectTimeResponse& from);

  inline RequestGetServerConnectTimeResponse& operator=(const RequestGetServerConnectTimeResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestGetServerConnectTimeResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestGetServerConnectTimeResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestGetServerConnectTimeResponse* other);

  // implements Message ----------------------------------------------

  RequestGetServerConnectTimeResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestGetServerConnectTimeResponse& from);
  void MergeFrom(const RequestGetServerConnectTimeResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestGetServerConnectTimeResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestGetServerConnectTimeResponse* default_instance_;
};
// -------------------------------------------------------------------

class RequestGetConnectionCount : public ::google::protobuf::MessageLite {
 public:
  RequestGetConnectionCount();
  virtual ~RequestGetConnectionCount();

  RequestGetConnectionCount(const RequestGetConnectionCount& from);

  inline RequestGetConnectionCount& operator=(const RequestGetConnectionCount& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestGetConnectionCount& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestGetConnectionCount* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestGetConnectionCount* other);

  // implements Message ----------------------------------------------

  RequestGetConnectionCount* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestGetConnectionCount& from);
  void MergeFrom(const RequestGetConnectionCount& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestGetConnectionCount)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestGetConnectionCount* default_instance_;
};
// -------------------------------------------------------------------

class RequestGetConnectionCountResponse : public ::google::protobuf::MessageLite {
 public:
  RequestGetConnectionCountResponse();
  virtual ~RequestGetConnectionCountResponse();

  RequestGetConnectionCountResponse(const RequestGetConnectionCountResponse& from);

  inline RequestGetConnectionCountResponse& operator=(const RequestGetConnectionCountResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestGetConnectionCountResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestGetConnectionCountResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestGetConnectionCountResponse* other);

  // implements Message ----------------------------------------------

  RequestGetConnectionCountResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestGetConnectionCountResponse& from);
  void MergeFrom(const RequestGetConnectionCountResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestGetConnectionCountResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestGetConnectionCountResponse* default_instance_;
};
// -------------------------------------------------------------------

class RequestDisconnectUser : public ::google::protobuf::MessageLite {
 public:
  RequestDisconnectUser();
  virtual ~RequestDisconnectUser();

  RequestDisconnectUser(const RequestDisconnectUser& from);

  inline RequestDisconnectUser& operator=(const RequestDisconnectUser& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestDisconnectUser& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestDisconnectUser* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestDisconnectUser* other);

  // implements Message ----------------------------------------------

  RequestDisconnectUser* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestDisconnectUser& from);
  void MergeFrom(const RequestDisconnectUser& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestDisconnectUser)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestDisconnectUser* default_instance_;
};
// -------------------------------------------------------------------

class RequestDisconnectAllUser : public ::google::protobuf::MessageLite {
 public:
  RequestDisconnectAllUser();
  virtual ~RequestDisconnectAllUser();

  RequestDisconnectAllUser(const RequestDisconnectAllUser& from);

  inline RequestDisconnectAllUser& operator=(const RequestDisconnectAllUser& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestDisconnectAllUser& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestDisconnectAllUser* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestDisconnectAllUser* other);

  // implements Message ----------------------------------------------

  RequestDisconnectAllUser* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestDisconnectAllUser& from);
  void MergeFrom(const RequestDisconnectAllUser& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestDisconnectAllUser)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestDisconnectAllUser* default_instance_;
};
// -------------------------------------------------------------------

class RequestSendMessageToPushClient : public ::google::protobuf::MessageLite {
 public:
  RequestSendMessageToPushClient();
  virtual ~RequestSendMessageToPushClient();

  RequestSendMessageToPushClient(const RequestSendMessageToPushClient& from);

  inline RequestSendMessageToPushClient& operator=(const RequestSendMessageToPushClient& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestSendMessageToPushClient& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestSendMessageToPushClient* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestSendMessageToPushClient* other);

  // implements Message ----------------------------------------------

  RequestSendMessageToPushClient* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestSendMessageToPushClient& from);
  void MergeFrom(const RequestSendMessageToPushClient& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestSendMessageToPushClient)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestSendMessageToPushClient* default_instance_;
};
// -------------------------------------------------------------------

class RequestGetServerSidePlayerStatus : public ::google::protobuf::MessageLite {
 public:
  RequestGetServerSidePlayerStatus();
  virtual ~RequestGetServerSidePlayerStatus();

  RequestGetServerSidePlayerStatus(const RequestGetServerSidePlayerStatus& from);

  inline RequestGetServerSidePlayerStatus& operator=(const RequestGetServerSidePlayerStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestGetServerSidePlayerStatus& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestGetServerSidePlayerStatus* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestGetServerSidePlayerStatus* other);

  // implements Message ----------------------------------------------

  RequestGetServerSidePlayerStatus* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestGetServerSidePlayerStatus& from);
  void MergeFrom(const RequestGetServerSidePlayerStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DS3_Frpg2RequestMessage.RequestGetServerSidePlayerStatus)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_DS3_5fFrpg2RequestMessage_2eproto();
  friend void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto();

  void InitAsDefaultInstance();
  static RequestGetServerSidePlayerStatus* default_instance_;
};
// ===================================================================


// ===================================================================

// EmptyResponse

// -------------------------------------------------------------------

// RequestWaitForUserLogin

// required string steam_id = 1;
inline bool RequestWaitForUserLogin::has_steam_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestWaitForUserLogin::set_has_steam_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestWaitForUserLogin::clear_has_steam_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestWaitForUserLogin::clear_steam_id() {
  if (steam_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    steam_id_->clear();
  }
  clear_has_steam_id();
}
inline const ::std::string& RequestWaitForUserLogin::steam_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestWaitForUserLogin.steam_id)
  return *steam_id_;
}
inline void RequestWaitForUserLogin::set_steam_id(const ::std::string& value) {
  set_has_steam_id();
  if (steam_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    steam_id_ = new ::std::string;
  }
  steam_id_->assign(value);
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestWaitForUserLogin.steam_id)
}
inline void RequestWaitForUserLogin::set_steam_id(const char* value) {
  set_has_steam_id();
  if (steam_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    steam_id_ = new ::std::string;
  }
  steam_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:DS3_Frpg2RequestMessage.RequestWaitForUserLogin.steam_id)
}
inline void RequestWaitForUserLogin::set_steam_id(const char* value, size_t size) {
  set_has_steam_id();
  if (steam_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    steam_id_ = new ::std::string;
  }
  steam_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DS3_Frpg2RequestMessage.RequestWaitForUserLogin.steam_id)
}
inline ::std::string* RequestWaitForUserLogin::mutable_steam_id() {
  set_has_steam_id();
  if (steam_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    steam_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.RequestWaitForUserLogin.steam_id)
  return steam_id_;
}
inline ::std::string* RequestWaitForUserLogin::release_steam_id() {
  clear_has_steam_id();
  if (steam_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = steam_id_;
    steam_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RequestWaitForUserLogin::set_allocated_steam_id(::std::string* steam_id) {
  if (steam_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete steam_id_;
  }
  if (steam_id) {
    set_has_steam_id();
    steam_id_ = steam_id;
  } else {
    clear_has_steam_id();
    steam_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.RequestWaitForUserLogin.steam_id)
}

// required uint32 unknown_1 = 2;
inline bool RequestWaitForUserLogin::has_unknown_1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestWaitForUserLogin::set_has_unknown_1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestWaitForUserLogin::clear_has_unknown_1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestWaitForUserLogin::clear_unknown_1() {
  unknown_1_ = 0u;
  clear_has_unknown_1();
}
inline ::google::protobuf::uint32 RequestWaitForUserLogin::unknown_1() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestWaitForUserLogin.unknown_1)
  return unknown_1_;
}
inline void RequestWaitForUserLogin::set_unknown_1(::google::protobuf::uint32 value) {
  set_has_unknown_1();
  unknown_1_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestWaitForUserLogin.unknown_1)
}

// required uint32 unknown_2 = 3;
inline bool RequestWaitForUserLogin::has_unknown_2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestWaitForUserLogin::set_has_unknown_2() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestWaitForUserLogin::clear_has_unknown_2() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestWaitForUserLogin::clear_unknown_2() {
  unknown_2_ = 0u;
  clear_has_unknown_2();
}
inline ::google::protobuf::uint32 RequestWaitForUserLogin::unknown_2() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestWaitForUserLogin.unknown_2)
  return unknown_2_;
}
inline void RequestWaitForUserLogin::set_unknown_2(::google::protobuf::uint32 value) {
  set_has_unknown_2();
  unknown_2_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestWaitForUserLogin.unknown_2)
}

// required uint32 unknown_3 = 4;
inline bool RequestWaitForUserLogin::has_unknown_3() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestWaitForUserLogin::set_has_unknown_3() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestWaitForUserLogin::clear_has_unknown_3() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestWaitForUserLogin::clear_unknown_3() {
  unknown_3_ = 0u;
  clear_has_unknown_3();
}
inline ::google::protobuf::uint32 RequestWaitForUserLogin::unknown_3() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestWaitForUserLogin.unknown_3)
  return unknown_3_;
}
inline void RequestWaitForUserLogin::set_unknown_3(::google::protobuf::uint32 value) {
  set_has_unknown_3();
  unknown_3_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestWaitForUserLogin.unknown_3)
}

// required uint32 unknown_4 = 5;
inline bool RequestWaitForUserLogin::has_unknown_4() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RequestWaitForUserLogin::set_has_unknown_4() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RequestWaitForUserLogin::clear_has_unknown_4() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RequestWaitForUserLogin::clear_unknown_4() {
  unknown_4_ = 0u;
  clear_has_unknown_4();
}
inline ::google::protobuf::uint32 RequestWaitForUserLogin::unknown_4() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestWaitForUserLogin.unknown_4)
  return unknown_4_;
}
inline void RequestWaitForUserLogin::set_unknown_4(::google::protobuf::uint32 value) {
  set_has_unknown_4();
  unknown_4_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestWaitForUserLogin.unknown_4)
}

// -------------------------------------------------------------------

// RequestWaitForUserLoginResponse

// required string steam_id = 1;
inline bool RequestWaitForUserLoginResponse::has_steam_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestWaitForUserLoginResponse::set_has_steam_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestWaitForUserLoginResponse::clear_has_steam_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestWaitForUserLoginResponse::clear_steam_id() {
  if (steam_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    steam_id_->clear();
  }
  clear_has_steam_id();
}
inline const ::std::string& RequestWaitForUserLoginResponse::steam_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestWaitForUserLoginResponse.steam_id)
  return *steam_id_;
}
inline void RequestWaitForUserLoginResponse::set_steam_id(const ::std::string& value) {
  set_has_steam_id();
  if (steam_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    steam_id_ = new ::std::string;
  }
  steam_id_->assign(value);
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestWaitForUserLoginResponse.steam_id)
}
inline void RequestWaitForUserLoginResponse::set_steam_id(const char* value) {
  set_has_steam_id();
  if (steam_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    steam_id_ = new ::std::string;
  }
  steam_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:DS3_Frpg2RequestMessage.RequestWaitForUserLoginResponse.steam_id)
}
inline void RequestWaitForUserLoginResponse::set_steam_id(const char* value, size_t size) {
  set_has_steam_id();
  if (steam_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    steam_id_ = new ::std::string;
  }
  steam_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DS3_Frpg2RequestMessage.RequestWaitForUserLoginResponse.steam_id)
}
inline ::std::string* RequestWaitForUserLoginResponse::mutable_steam_id() {
  set_has_steam_id();
  if (steam_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    steam_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.RequestWaitForUserLoginResponse.steam_id)
  return steam_id_;
}
inline ::std::string* RequestWaitForUserLoginResponse::release_steam_id() {
  clear_has_steam_id();
  if (steam_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = steam_id_;
    steam_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RequestWaitForUserLoginResponse::set_allocated_steam_id(::std::string* steam_id) {
  if (steam_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete steam_id_;
  }
  if (steam_id) {
    set_has_steam_id();
    steam_id_ = steam_id;
  } else {
    clear_has_steam_id();
    steam_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.RequestWaitForUserLoginResponse.steam_id)
}

// required uint32 player_id = 2;
inline bool RequestWaitForUserLoginResponse::has_player_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestWaitForUserLoginResponse::set_has_player_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestWaitForUserLoginResponse::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestWaitForUserLoginResponse::clear_player_id() {
  player_id_ = 0u;
  clear_has_player_id();
}
inline ::google::protobuf::uint32 RequestWaitForUserLoginResponse::player_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestWaitForUserLoginResponse.player_id)
  return player_id_;
}
inline void RequestWaitForUserLoginResponse::set_player_id(::google::protobuf::uint32 value) {
  set_has_player_id();
  player_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestWaitForUserLoginResponse.player_id)
}

// -------------------------------------------------------------------

// PlayerStatusUploadConfig

// repeated uint32 player_data_mask = 1;
inline int PlayerStatusUploadConfig::player_data_mask_size() const {
  return player_data_mask_.size();
}
inline void PlayerStatusUploadConfig::clear_player_data_mask() {
  player_data_mask_.Clear();
}
inline ::google::protobuf::uint32 PlayerStatusUploadConfig::player_data_mask(int index) const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.PlayerStatusUploadConfig.player_data_mask)
  return player_data_mask_.Get(index);
}
inline void PlayerStatusUploadConfig::set_player_data_mask(int index, ::google::protobuf::uint32 value) {
  player_data_mask_.Set(index, value);
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.PlayerStatusUploadConfig.player_data_mask)
}
inline void PlayerStatusUploadConfig::add_player_data_mask(::google::protobuf::uint32 value) {
  player_data_mask_.Add(value);
  // @@protoc_insertion_point(field_add:DS3_Frpg2RequestMessage.PlayerStatusUploadConfig.player_data_mask)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
PlayerStatusUploadConfig::player_data_mask() const {
  // @@protoc_insertion_point(field_list:DS3_Frpg2RequestMessage.PlayerStatusUploadConfig.player_data_mask)
  return player_data_mask_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
PlayerStatusUploadConfig::mutable_player_data_mask() {
  // @@protoc_insertion_point(field_mutable_list:DS3_Frpg2RequestMessage.PlayerStatusUploadConfig.player_data_mask)
  return &player_data_mask_;
}

// required uint32 upload_interval = 2;
inline bool PlayerStatusUploadConfig::has_upload_interval() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerStatusUploadConfig::set_has_upload_interval() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerStatusUploadConfig::clear_has_upload_interval() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerStatusUploadConfig::clear_upload_interval() {
  upload_interval_ = 0u;
  clear_has_upload_interval();
}
inline ::google::protobuf::uint32 PlayerStatusUploadConfig::upload_interval() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.PlayerStatusUploadConfig.upload_interval)
  return upload_interval_;
}
inline void PlayerStatusUploadConfig::set_upload_interval(::google::protobuf::uint32 value) {
  set_has_upload_interval();
  upload_interval_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.PlayerStatusUploadConfig.upload_interval)
}

// -------------------------------------------------------------------

// AnnounceMessageData

// required uint32 unknown_1 = 1;
inline bool AnnounceMessageData::has_unknown_1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AnnounceMessageData::set_has_unknown_1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AnnounceMessageData::clear_has_unknown_1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AnnounceMessageData::clear_unknown_1() {
  unknown_1_ = 0u;
  clear_has_unknown_1();
}
inline ::google::protobuf::uint32 AnnounceMessageData::unknown_1() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.AnnounceMessageData.unknown_1)
  return unknown_1_;
}
inline void AnnounceMessageData::set_unknown_1(::google::protobuf::uint32 value) {
  set_has_unknown_1();
  unknown_1_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.AnnounceMessageData.unknown_1)
}

// required uint32 index = 2;
inline bool AnnounceMessageData::has_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AnnounceMessageData::set_has_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AnnounceMessageData::clear_has_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AnnounceMessageData::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 AnnounceMessageData::index() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.AnnounceMessageData.index)
  return index_;
}
inline void AnnounceMessageData::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.AnnounceMessageData.index)
}

// required uint32 unknown_2 = 3;
inline bool AnnounceMessageData::has_unknown_2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AnnounceMessageData::set_has_unknown_2() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AnnounceMessageData::clear_has_unknown_2() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AnnounceMessageData::clear_unknown_2() {
  unknown_2_ = 0u;
  clear_has_unknown_2();
}
inline ::google::protobuf::uint32 AnnounceMessageData::unknown_2() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.AnnounceMessageData.unknown_2)
  return unknown_2_;
}
inline void AnnounceMessageData::set_unknown_2(::google::protobuf::uint32 value) {
  set_has_unknown_2();
  unknown_2_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.AnnounceMessageData.unknown_2)
}

// required string header = 4;
inline bool AnnounceMessageData::has_header() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AnnounceMessageData::set_has_header() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AnnounceMessageData::clear_has_header() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AnnounceMessageData::clear_header() {
  if (header_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    header_->clear();
  }
  clear_has_header();
}
inline const ::std::string& AnnounceMessageData::header() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.AnnounceMessageData.header)
  return *header_;
}
inline void AnnounceMessageData::set_header(const ::std::string& value) {
  set_has_header();
  if (header_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    header_ = new ::std::string;
  }
  header_->assign(value);
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.AnnounceMessageData.header)
}
inline void AnnounceMessageData::set_header(const char* value) {
  set_has_header();
  if (header_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    header_ = new ::std::string;
  }
  header_->assign(value);
  // @@protoc_insertion_point(field_set_char:DS3_Frpg2RequestMessage.AnnounceMessageData.header)
}
inline void AnnounceMessageData::set_header(const char* value, size_t size) {
  set_has_header();
  if (header_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    header_ = new ::std::string;
  }
  header_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DS3_Frpg2RequestMessage.AnnounceMessageData.header)
}
inline ::std::string* AnnounceMessageData::mutable_header() {
  set_has_header();
  if (header_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    header_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.AnnounceMessageData.header)
  return header_;
}
inline ::std::string* AnnounceMessageData::release_header() {
  clear_has_header();
  if (header_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = header_;
    header_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AnnounceMessageData::set_allocated_header(::std::string* header) {
  if (header_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete header_;
  }
  if (header) {
    set_has_header();
    header_ = header;
  } else {
    clear_has_header();
    header_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.AnnounceMessageData.header)
}

// required string message = 5;
inline bool AnnounceMessageData::has_message() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AnnounceMessageData::set_has_message() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AnnounceMessageData::clear_has_message() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AnnounceMessageData::clear_message() {
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& AnnounceMessageData::message() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.AnnounceMessageData.message)
  return *message_;
}
inline void AnnounceMessageData::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(value);
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.AnnounceMessageData.message)
}
inline void AnnounceMessageData::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(value);
  // @@protoc_insertion_point(field_set_char:DS3_Frpg2RequestMessage.AnnounceMessageData.message)
}
inline void AnnounceMessageData::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DS3_Frpg2RequestMessage.AnnounceMessageData.message)
}
inline ::std::string* AnnounceMessageData::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.AnnounceMessageData.message)
  return message_;
}
inline ::std::string* AnnounceMessageData::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AnnounceMessageData::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.AnnounceMessageData.message)
}

// required .DS3_Frpg2PlayerData.DateTime datetime = 6;
inline bool AnnounceMessageData::has_datetime() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AnnounceMessageData::set_has_datetime() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AnnounceMessageData::clear_has_datetime() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AnnounceMessageData::clear_datetime() {
  if (datetime_ != NULL) datetime_->::DS3_Frpg2PlayerData::DateTime::Clear();
  clear_has_datetime();
}
inline const ::DS3_Frpg2PlayerData::DateTime& AnnounceMessageData::datetime() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.AnnounceMessageData.datetime)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return datetime_ != NULL ? *datetime_ : *default_instance().datetime_;
#else
  return datetime_ != NULL ? *datetime_ : *default_instance_->datetime_;
#endif
}
inline ::DS3_Frpg2PlayerData::DateTime* AnnounceMessageData::mutable_datetime() {
  set_has_datetime();
  if (datetime_ == NULL) datetime_ = new ::DS3_Frpg2PlayerData::DateTime;
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.AnnounceMessageData.datetime)
  return datetime_;
}
inline ::DS3_Frpg2PlayerData::DateTime* AnnounceMessageData::release_datetime() {
  clear_has_datetime();
  ::DS3_Frpg2PlayerData::DateTime* temp = datetime_;
  datetime_ = NULL;
  return temp;
}
inline void AnnounceMessageData::set_allocated_datetime(::DS3_Frpg2PlayerData::DateTime* datetime) {
  delete datetime_;
  datetime_ = datetime;
  if (datetime) {
    set_has_datetime();
  } else {
    clear_has_datetime();
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.AnnounceMessageData.datetime)
}

// -------------------------------------------------------------------

// AnnounceMessageDataList

// repeated .DS3_Frpg2RequestMessage.AnnounceMessageData items = 1;
inline int AnnounceMessageDataList::items_size() const {
  return items_.size();
}
inline void AnnounceMessageDataList::clear_items() {
  items_.Clear();
}
inline const ::DS3_Frpg2RequestMessage::AnnounceMessageData& AnnounceMessageDataList::items(int index) const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.AnnounceMessageDataList.items)
  return items_.Get(index);
}
inline ::DS3_Frpg2RequestMessage::AnnounceMessageData* AnnounceMessageDataList::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.AnnounceMessageDataList.items)
  return items_.Mutable(index);
}
inline ::DS3_Frpg2RequestMessage::AnnounceMessageData* AnnounceMessageDataList::add_items() {
  // @@protoc_insertion_point(field_add:DS3_Frpg2RequestMessage.AnnounceMessageDataList.items)
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::AnnounceMessageData >&
AnnounceMessageDataList::items() const {
  // @@protoc_insertion_point(field_list:DS3_Frpg2RequestMessage.AnnounceMessageDataList.items)
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::AnnounceMessageData >*
AnnounceMessageDataList::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:DS3_Frpg2RequestMessage.AnnounceMessageDataList.items)
  return &items_;
}

// -------------------------------------------------------------------

// RequestGetAnnounceMessageList

// required uint32 max_entries = 1;
inline bool RequestGetAnnounceMessageList::has_max_entries() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestGetAnnounceMessageList::set_has_max_entries() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestGetAnnounceMessageList::clear_has_max_entries() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestGetAnnounceMessageList::clear_max_entries() {
  max_entries_ = 0u;
  clear_has_max_entries();
}
inline ::google::protobuf::uint32 RequestGetAnnounceMessageList::max_entries() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestGetAnnounceMessageList.max_entries)
  return max_entries_;
}
inline void RequestGetAnnounceMessageList::set_max_entries(::google::protobuf::uint32 value) {
  set_has_max_entries();
  max_entries_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestGetAnnounceMessageList.max_entries)
}

// -------------------------------------------------------------------

// RequestGetAnnounceMessageListResponse

// required .DS3_Frpg2RequestMessage.AnnounceMessageDataList changes = 1;
inline bool RequestGetAnnounceMessageListResponse::has_changes() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestGetAnnounceMessageListResponse::set_has_changes() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestGetAnnounceMessageListResponse::clear_has_changes() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestGetAnnounceMessageListResponse::clear_changes() {
  if (changes_ != NULL) changes_->::DS3_Frpg2RequestMessage::AnnounceMessageDataList::Clear();
  clear_has_changes();
}
inline const ::DS3_Frpg2RequestMessage::AnnounceMessageDataList& RequestGetAnnounceMessageListResponse::changes() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestGetAnnounceMessageListResponse.changes)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return changes_ != NULL ? *changes_ : *default_instance().changes_;
#else
  return changes_ != NULL ? *changes_ : *default_instance_->changes_;
#endif
}
inline ::DS3_Frpg2RequestMessage::AnnounceMessageDataList* RequestGetAnnounceMessageListResponse::mutable_changes() {
  set_has_changes();
  if (changes_ == NULL) changes_ = new ::DS3_Frpg2RequestMessage::AnnounceMessageDataList;
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.RequestGetAnnounceMessageListResponse.changes)
  return changes_;
}
inline ::DS3_Frpg2RequestMessage::AnnounceMessageDataList* RequestGetAnnounceMessageListResponse::release_changes() {
  clear_has_changes();
  ::DS3_Frpg2RequestMessage::AnnounceMessageDataList* temp = changes_;
  changes_ = NULL;
  return temp;
}
inline void RequestGetAnnounceMessageListResponse::set_allocated_changes(::DS3_Frpg2RequestMessage::AnnounceMessageDataList* changes) {
  delete changes_;
  changes_ = changes;
  if (changes) {
    set_has_changes();
  } else {
    clear_has_changes();
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.RequestGetAnnounceMessageListResponse.changes)
}

// required .DS3_Frpg2RequestMessage.AnnounceMessageDataList notices = 2;
inline bool RequestGetAnnounceMessageListResponse::has_notices() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestGetAnnounceMessageListResponse::set_has_notices() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestGetAnnounceMessageListResponse::clear_has_notices() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestGetAnnounceMessageListResponse::clear_notices() {
  if (notices_ != NULL) notices_->::DS3_Frpg2RequestMessage::AnnounceMessageDataList::Clear();
  clear_has_notices();
}
inline const ::DS3_Frpg2RequestMessage::AnnounceMessageDataList& RequestGetAnnounceMessageListResponse::notices() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestGetAnnounceMessageListResponse.notices)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return notices_ != NULL ? *notices_ : *default_instance().notices_;
#else
  return notices_ != NULL ? *notices_ : *default_instance_->notices_;
#endif
}
inline ::DS3_Frpg2RequestMessage::AnnounceMessageDataList* RequestGetAnnounceMessageListResponse::mutable_notices() {
  set_has_notices();
  if (notices_ == NULL) notices_ = new ::DS3_Frpg2RequestMessage::AnnounceMessageDataList;
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.RequestGetAnnounceMessageListResponse.notices)
  return notices_;
}
inline ::DS3_Frpg2RequestMessage::AnnounceMessageDataList* RequestGetAnnounceMessageListResponse::release_notices() {
  clear_has_notices();
  ::DS3_Frpg2RequestMessage::AnnounceMessageDataList* temp = notices_;
  notices_ = NULL;
  return temp;
}
inline void RequestGetAnnounceMessageListResponse::set_allocated_notices(::DS3_Frpg2RequestMessage::AnnounceMessageDataList* notices) {
  delete notices_;
  notices_ = notices;
  if (notices) {
    set_has_notices();
  } else {
    clear_has_notices();
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.RequestGetAnnounceMessageListResponse.notices)
}

// -------------------------------------------------------------------

// PlayerCharacterData

// -------------------------------------------------------------------

// PlayerCharacterID

// -------------------------------------------------------------------

// PlayerInfoUploadConfigPushMessage

// required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
inline bool PlayerInfoUploadConfigPushMessage::has_push_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerInfoUploadConfigPushMessage::set_has_push_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerInfoUploadConfigPushMessage::clear_has_push_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerInfoUploadConfigPushMessage::clear_push_message_id() {
  push_message_id_ = 829;
  clear_has_push_message_id();
}
inline ::DS3_Frpg2RequestMessage::PushMessageId PlayerInfoUploadConfigPushMessage::push_message_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.PlayerInfoUploadConfigPushMessage.push_message_id)
  return static_cast< ::DS3_Frpg2RequestMessage::PushMessageId >(push_message_id_);
}
inline void PlayerInfoUploadConfigPushMessage::set_push_message_id(::DS3_Frpg2RequestMessage::PushMessageId value) {
  assert(::DS3_Frpg2RequestMessage::PushMessageId_IsValid(value));
  set_has_push_message_id();
  push_message_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.PlayerInfoUploadConfigPushMessage.push_message_id)
}

// required .DS3_Frpg2RequestMessage.PlayerStatusUploadConfig config = 2;
inline bool PlayerInfoUploadConfigPushMessage::has_config() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerInfoUploadConfigPushMessage::set_has_config() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerInfoUploadConfigPushMessage::clear_has_config() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerInfoUploadConfigPushMessage::clear_config() {
  if (config_ != NULL) config_->::DS3_Frpg2RequestMessage::PlayerStatusUploadConfig::Clear();
  clear_has_config();
}
inline const ::DS3_Frpg2RequestMessage::PlayerStatusUploadConfig& PlayerInfoUploadConfigPushMessage::config() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.PlayerInfoUploadConfigPushMessage.config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return config_ != NULL ? *config_ : *default_instance().config_;
#else
  return config_ != NULL ? *config_ : *default_instance_->config_;
#endif
}
inline ::DS3_Frpg2RequestMessage::PlayerStatusUploadConfig* PlayerInfoUploadConfigPushMessage::mutable_config() {
  set_has_config();
  if (config_ == NULL) config_ = new ::DS3_Frpg2RequestMessage::PlayerStatusUploadConfig;
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.PlayerInfoUploadConfigPushMessage.config)
  return config_;
}
inline ::DS3_Frpg2RequestMessage::PlayerStatusUploadConfig* PlayerInfoUploadConfigPushMessage::release_config() {
  clear_has_config();
  ::DS3_Frpg2RequestMessage::PlayerStatusUploadConfig* temp = config_;
  config_ = NULL;
  return temp;
}
inline void PlayerInfoUploadConfigPushMessage::set_allocated_config(::DS3_Frpg2RequestMessage::PlayerStatusUploadConfig* config) {
  delete config_;
  config_ = config;
  if (config) {
    set_has_config();
  } else {
    clear_has_config();
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.PlayerInfoUploadConfigPushMessage.config)
}

// required uint32 player_character_update_send_delay = 3;
inline bool PlayerInfoUploadConfigPushMessage::has_player_character_update_send_delay() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerInfoUploadConfigPushMessage::set_has_player_character_update_send_delay() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerInfoUploadConfigPushMessage::clear_has_player_character_update_send_delay() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerInfoUploadConfigPushMessage::clear_player_character_update_send_delay() {
  player_character_update_send_delay_ = 0u;
  clear_has_player_character_update_send_delay();
}
inline ::google::protobuf::uint32 PlayerInfoUploadConfigPushMessage::player_character_update_send_delay() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.PlayerInfoUploadConfigPushMessage.player_character_update_send_delay)
  return player_character_update_send_delay_;
}
inline void PlayerInfoUploadConfigPushMessage::set_player_character_update_send_delay(::google::protobuf::uint32 value) {
  set_has_player_character_update_send_delay();
  player_character_update_send_delay_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.PlayerInfoUploadConfigPushMessage.player_character_update_send_delay)
}

// required uint32 player_status_send_delay = 4;
inline bool PlayerInfoUploadConfigPushMessage::has_player_status_send_delay() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlayerInfoUploadConfigPushMessage::set_has_player_status_send_delay() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PlayerInfoUploadConfigPushMessage::clear_has_player_status_send_delay() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PlayerInfoUploadConfigPushMessage::clear_player_status_send_delay() {
  player_status_send_delay_ = 0u;
  clear_has_player_status_send_delay();
}
inline ::google::protobuf::uint32 PlayerInfoUploadConfigPushMessage::player_status_send_delay() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.PlayerInfoUploadConfigPushMessage.player_status_send_delay)
  return player_status_send_delay_;
}
inline void PlayerInfoUploadConfigPushMessage::set_player_status_send_delay(::google::protobuf::uint32 value) {
  set_has_player_status_send_delay();
  player_status_send_delay_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.PlayerInfoUploadConfigPushMessage.player_status_send_delay)
}

// -------------------------------------------------------------------

// RequestUpdateLoginPlayerCharacter

// required uint32 character_id = 1;
inline bool RequestUpdateLoginPlayerCharacter::has_character_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestUpdateLoginPlayerCharacter::set_has_character_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestUpdateLoginPlayerCharacter::clear_has_character_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestUpdateLoginPlayerCharacter::clear_character_id() {
  character_id_ = 0u;
  clear_has_character_id();
}
inline ::google::protobuf::uint32 RequestUpdateLoginPlayerCharacter::character_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestUpdateLoginPlayerCharacter.character_id)
  return character_id_;
}
inline void RequestUpdateLoginPlayerCharacter::set_character_id(::google::protobuf::uint32 value) {
  set_has_character_id();
  character_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestUpdateLoginPlayerCharacter.character_id)
}

// repeated uint32 unknown_2 = 2;
inline int RequestUpdateLoginPlayerCharacter::unknown_2_size() const {
  return unknown_2_.size();
}
inline void RequestUpdateLoginPlayerCharacter::clear_unknown_2() {
  unknown_2_.Clear();
}
inline ::google::protobuf::uint32 RequestUpdateLoginPlayerCharacter::unknown_2(int index) const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestUpdateLoginPlayerCharacter.unknown_2)
  return unknown_2_.Get(index);
}
inline void RequestUpdateLoginPlayerCharacter::set_unknown_2(int index, ::google::protobuf::uint32 value) {
  unknown_2_.Set(index, value);
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestUpdateLoginPlayerCharacter.unknown_2)
}
inline void RequestUpdateLoginPlayerCharacter::add_unknown_2(::google::protobuf::uint32 value) {
  unknown_2_.Add(value);
  // @@protoc_insertion_point(field_add:DS3_Frpg2RequestMessage.RequestUpdateLoginPlayerCharacter.unknown_2)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
RequestUpdateLoginPlayerCharacter::unknown_2() const {
  // @@protoc_insertion_point(field_list:DS3_Frpg2RequestMessage.RequestUpdateLoginPlayerCharacter.unknown_2)
  return unknown_2_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
RequestUpdateLoginPlayerCharacter::mutable_unknown_2() {
  // @@protoc_insertion_point(field_mutable_list:DS3_Frpg2RequestMessage.RequestUpdateLoginPlayerCharacter.unknown_2)
  return &unknown_2_;
}

// -------------------------------------------------------------------

// RequestUpdateLoginPlayerCharacterResponse

// required uint32 character_id = 1;
inline bool RequestUpdateLoginPlayerCharacterResponse::has_character_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestUpdateLoginPlayerCharacterResponse::set_has_character_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestUpdateLoginPlayerCharacterResponse::clear_has_character_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestUpdateLoginPlayerCharacterResponse::clear_character_id() {
  character_id_ = 0u;
  clear_has_character_id();
}
inline ::google::protobuf::uint32 RequestUpdateLoginPlayerCharacterResponse::character_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestUpdateLoginPlayerCharacterResponse.character_id)
  return character_id_;
}
inline void RequestUpdateLoginPlayerCharacterResponse::set_character_id(::google::protobuf::uint32 value) {
  set_has_character_id();
  character_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestUpdateLoginPlayerCharacterResponse.character_id)
}

// required .DS3_Frpg2RequestMessage.QuickMatchRank quickmatch_brawl_rank = 2;
inline bool RequestUpdateLoginPlayerCharacterResponse::has_quickmatch_brawl_rank() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestUpdateLoginPlayerCharacterResponse::set_has_quickmatch_brawl_rank() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestUpdateLoginPlayerCharacterResponse::clear_has_quickmatch_brawl_rank() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestUpdateLoginPlayerCharacterResponse::clear_quickmatch_brawl_rank() {
  if (quickmatch_brawl_rank_ != NULL) quickmatch_brawl_rank_->::DS3_Frpg2RequestMessage::QuickMatchRank::Clear();
  clear_has_quickmatch_brawl_rank();
}
inline const ::DS3_Frpg2RequestMessage::QuickMatchRank& RequestUpdateLoginPlayerCharacterResponse::quickmatch_brawl_rank() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestUpdateLoginPlayerCharacterResponse.quickmatch_brawl_rank)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return quickmatch_brawl_rank_ != NULL ? *quickmatch_brawl_rank_ : *default_instance().quickmatch_brawl_rank_;
#else
  return quickmatch_brawl_rank_ != NULL ? *quickmatch_brawl_rank_ : *default_instance_->quickmatch_brawl_rank_;
#endif
}
inline ::DS3_Frpg2RequestMessage::QuickMatchRank* RequestUpdateLoginPlayerCharacterResponse::mutable_quickmatch_brawl_rank() {
  set_has_quickmatch_brawl_rank();
  if (quickmatch_brawl_rank_ == NULL) quickmatch_brawl_rank_ = new ::DS3_Frpg2RequestMessage::QuickMatchRank;
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.RequestUpdateLoginPlayerCharacterResponse.quickmatch_brawl_rank)
  return quickmatch_brawl_rank_;
}
inline ::DS3_Frpg2RequestMessage::QuickMatchRank* RequestUpdateLoginPlayerCharacterResponse::release_quickmatch_brawl_rank() {
  clear_has_quickmatch_brawl_rank();
  ::DS3_Frpg2RequestMessage::QuickMatchRank* temp = quickmatch_brawl_rank_;
  quickmatch_brawl_rank_ = NULL;
  return temp;
}
inline void RequestUpdateLoginPlayerCharacterResponse::set_allocated_quickmatch_brawl_rank(::DS3_Frpg2RequestMessage::QuickMatchRank* quickmatch_brawl_rank) {
  delete quickmatch_brawl_rank_;
  quickmatch_brawl_rank_ = quickmatch_brawl_rank;
  if (quickmatch_brawl_rank) {
    set_has_quickmatch_brawl_rank();
  } else {
    clear_has_quickmatch_brawl_rank();
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.RequestUpdateLoginPlayerCharacterResponse.quickmatch_brawl_rank)
}

// required .DS3_Frpg2RequestMessage.QuickMatchRank quickmatch_dual_rank = 3;
inline bool RequestUpdateLoginPlayerCharacterResponse::has_quickmatch_dual_rank() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestUpdateLoginPlayerCharacterResponse::set_has_quickmatch_dual_rank() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestUpdateLoginPlayerCharacterResponse::clear_has_quickmatch_dual_rank() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestUpdateLoginPlayerCharacterResponse::clear_quickmatch_dual_rank() {
  if (quickmatch_dual_rank_ != NULL) quickmatch_dual_rank_->::DS3_Frpg2RequestMessage::QuickMatchRank::Clear();
  clear_has_quickmatch_dual_rank();
}
inline const ::DS3_Frpg2RequestMessage::QuickMatchRank& RequestUpdateLoginPlayerCharacterResponse::quickmatch_dual_rank() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestUpdateLoginPlayerCharacterResponse.quickmatch_dual_rank)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return quickmatch_dual_rank_ != NULL ? *quickmatch_dual_rank_ : *default_instance().quickmatch_dual_rank_;
#else
  return quickmatch_dual_rank_ != NULL ? *quickmatch_dual_rank_ : *default_instance_->quickmatch_dual_rank_;
#endif
}
inline ::DS3_Frpg2RequestMessage::QuickMatchRank* RequestUpdateLoginPlayerCharacterResponse::mutable_quickmatch_dual_rank() {
  set_has_quickmatch_dual_rank();
  if (quickmatch_dual_rank_ == NULL) quickmatch_dual_rank_ = new ::DS3_Frpg2RequestMessage::QuickMatchRank;
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.RequestUpdateLoginPlayerCharacterResponse.quickmatch_dual_rank)
  return quickmatch_dual_rank_;
}
inline ::DS3_Frpg2RequestMessage::QuickMatchRank* RequestUpdateLoginPlayerCharacterResponse::release_quickmatch_dual_rank() {
  clear_has_quickmatch_dual_rank();
  ::DS3_Frpg2RequestMessage::QuickMatchRank* temp = quickmatch_dual_rank_;
  quickmatch_dual_rank_ = NULL;
  return temp;
}
inline void RequestUpdateLoginPlayerCharacterResponse::set_allocated_quickmatch_dual_rank(::DS3_Frpg2RequestMessage::QuickMatchRank* quickmatch_dual_rank) {
  delete quickmatch_dual_rank_;
  quickmatch_dual_rank_ = quickmatch_dual_rank;
  if (quickmatch_dual_rank) {
    set_has_quickmatch_dual_rank();
  } else {
    clear_has_quickmatch_dual_rank();
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.RequestUpdateLoginPlayerCharacterResponse.quickmatch_dual_rank)
}

// -------------------------------------------------------------------

// RequestUpdatePlayerStatus

// required bytes status = 1;
inline bool RequestUpdatePlayerStatus::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestUpdatePlayerStatus::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestUpdatePlayerStatus::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestUpdatePlayerStatus::clear_status() {
  if (status_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    status_->clear();
  }
  clear_has_status();
}
inline const ::std::string& RequestUpdatePlayerStatus::status() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestUpdatePlayerStatus.status)
  return *status_;
}
inline void RequestUpdatePlayerStatus::set_status(const ::std::string& value) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    status_ = new ::std::string;
  }
  status_->assign(value);
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestUpdatePlayerStatus.status)
}
inline void RequestUpdatePlayerStatus::set_status(const char* value) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    status_ = new ::std::string;
  }
  status_->assign(value);
  // @@protoc_insertion_point(field_set_char:DS3_Frpg2RequestMessage.RequestUpdatePlayerStatus.status)
}
inline void RequestUpdatePlayerStatus::set_status(const void* value, size_t size) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    status_ = new ::std::string;
  }
  status_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DS3_Frpg2RequestMessage.RequestUpdatePlayerStatus.status)
}
inline ::std::string* RequestUpdatePlayerStatus::mutable_status() {
  set_has_status();
  if (status_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    status_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.RequestUpdatePlayerStatus.status)
  return status_;
}
inline ::std::string* RequestUpdatePlayerStatus::release_status() {
  clear_has_status();
  if (status_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = status_;
    status_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RequestUpdatePlayerStatus::set_allocated_status(::std::string* status) {
  if (status_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete status_;
  }
  if (status) {
    set_has_status();
    status_ = status;
  } else {
    clear_has_status();
    status_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.RequestUpdatePlayerStatus.status)
}

// -------------------------------------------------------------------

// RequestUpdatePlayerStatusResponse

// -------------------------------------------------------------------

// RequestUpdatePlayerCharacter

// required uint32 character_id = 1;
inline bool RequestUpdatePlayerCharacter::has_character_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestUpdatePlayerCharacter::set_has_character_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestUpdatePlayerCharacter::clear_has_character_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestUpdatePlayerCharacter::clear_character_id() {
  character_id_ = 0u;
  clear_has_character_id();
}
inline ::google::protobuf::uint32 RequestUpdatePlayerCharacter::character_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestUpdatePlayerCharacter.character_id)
  return character_id_;
}
inline void RequestUpdatePlayerCharacter::set_character_id(::google::protobuf::uint32 value) {
  set_has_character_id();
  character_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestUpdatePlayerCharacter.character_id)
}

// required bytes character_data = 2;
inline bool RequestUpdatePlayerCharacter::has_character_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestUpdatePlayerCharacter::set_has_character_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestUpdatePlayerCharacter::clear_has_character_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestUpdatePlayerCharacter::clear_character_data() {
  if (character_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    character_data_->clear();
  }
  clear_has_character_data();
}
inline const ::std::string& RequestUpdatePlayerCharacter::character_data() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestUpdatePlayerCharacter.character_data)
  return *character_data_;
}
inline void RequestUpdatePlayerCharacter::set_character_data(const ::std::string& value) {
  set_has_character_data();
  if (character_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    character_data_ = new ::std::string;
  }
  character_data_->assign(value);
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestUpdatePlayerCharacter.character_data)
}
inline void RequestUpdatePlayerCharacter::set_character_data(const char* value) {
  set_has_character_data();
  if (character_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    character_data_ = new ::std::string;
  }
  character_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:DS3_Frpg2RequestMessage.RequestUpdatePlayerCharacter.character_data)
}
inline void RequestUpdatePlayerCharacter::set_character_data(const void* value, size_t size) {
  set_has_character_data();
  if (character_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    character_data_ = new ::std::string;
  }
  character_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DS3_Frpg2RequestMessage.RequestUpdatePlayerCharacter.character_data)
}
inline ::std::string* RequestUpdatePlayerCharacter::mutable_character_data() {
  set_has_character_data();
  if (character_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    character_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.RequestUpdatePlayerCharacter.character_data)
  return character_data_;
}
inline ::std::string* RequestUpdatePlayerCharacter::release_character_data() {
  clear_has_character_data();
  if (character_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = character_data_;
    character_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RequestUpdatePlayerCharacter::set_allocated_character_data(::std::string* character_data) {
  if (character_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete character_data_;
  }
  if (character_data) {
    set_has_character_data();
    character_data_ = character_data;
  } else {
    clear_has_character_data();
    character_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.RequestUpdatePlayerCharacter.character_data)
}

// -------------------------------------------------------------------

// RequestUpdatePlayerCharacterResponse

// -------------------------------------------------------------------

// RequestGetPlayerCharacter

// required uint32 player_id = 1;
inline bool RequestGetPlayerCharacter::has_player_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestGetPlayerCharacter::set_has_player_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestGetPlayerCharacter::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestGetPlayerCharacter::clear_player_id() {
  player_id_ = 0u;
  clear_has_player_id();
}
inline ::google::protobuf::uint32 RequestGetPlayerCharacter::player_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestGetPlayerCharacter.player_id)
  return player_id_;
}
inline void RequestGetPlayerCharacter::set_player_id(::google::protobuf::uint32 value) {
  set_has_player_id();
  player_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestGetPlayerCharacter.player_id)
}

// required uint32 character_id = 2;
inline bool RequestGetPlayerCharacter::has_character_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestGetPlayerCharacter::set_has_character_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestGetPlayerCharacter::clear_has_character_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestGetPlayerCharacter::clear_character_id() {
  character_id_ = 0u;
  clear_has_character_id();
}
inline ::google::protobuf::uint32 RequestGetPlayerCharacter::character_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestGetPlayerCharacter.character_id)
  return character_id_;
}
inline void RequestGetPlayerCharacter::set_character_id(::google::protobuf::uint32 value) {
  set_has_character_id();
  character_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestGetPlayerCharacter.character_id)
}

// -------------------------------------------------------------------

// RequestGetPlayerCharacterResponse

// required uint32 player_id = 1;
inline bool RequestGetPlayerCharacterResponse::has_player_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestGetPlayerCharacterResponse::set_has_player_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestGetPlayerCharacterResponse::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestGetPlayerCharacterResponse::clear_player_id() {
  player_id_ = 0u;
  clear_has_player_id();
}
inline ::google::protobuf::uint32 RequestGetPlayerCharacterResponse::player_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestGetPlayerCharacterResponse.player_id)
  return player_id_;
}
inline void RequestGetPlayerCharacterResponse::set_player_id(::google::protobuf::uint32 value) {
  set_has_player_id();
  player_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestGetPlayerCharacterResponse.player_id)
}

// required uint32 character_id = 2;
inline bool RequestGetPlayerCharacterResponse::has_character_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestGetPlayerCharacterResponse::set_has_character_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestGetPlayerCharacterResponse::clear_has_character_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestGetPlayerCharacterResponse::clear_character_id() {
  character_id_ = 0u;
  clear_has_character_id();
}
inline ::google::protobuf::uint32 RequestGetPlayerCharacterResponse::character_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestGetPlayerCharacterResponse.character_id)
  return character_id_;
}
inline void RequestGetPlayerCharacterResponse::set_character_id(::google::protobuf::uint32 value) {
  set_has_character_id();
  character_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestGetPlayerCharacterResponse.character_id)
}

// required bytes character_data = 3;
inline bool RequestGetPlayerCharacterResponse::has_character_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestGetPlayerCharacterResponse::set_has_character_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestGetPlayerCharacterResponse::clear_has_character_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestGetPlayerCharacterResponse::clear_character_data() {
  if (character_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    character_data_->clear();
  }
  clear_has_character_data();
}
inline const ::std::string& RequestGetPlayerCharacterResponse::character_data() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestGetPlayerCharacterResponse.character_data)
  return *character_data_;
}
inline void RequestGetPlayerCharacterResponse::set_character_data(const ::std::string& value) {
  set_has_character_data();
  if (character_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    character_data_ = new ::std::string;
  }
  character_data_->assign(value);
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestGetPlayerCharacterResponse.character_data)
}
inline void RequestGetPlayerCharacterResponse::set_character_data(const char* value) {
  set_has_character_data();
  if (character_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    character_data_ = new ::std::string;
  }
  character_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:DS3_Frpg2RequestMessage.RequestGetPlayerCharacterResponse.character_data)
}
inline void RequestGetPlayerCharacterResponse::set_character_data(const void* value, size_t size) {
  set_has_character_data();
  if (character_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    character_data_ = new ::std::string;
  }
  character_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DS3_Frpg2RequestMessage.RequestGetPlayerCharacterResponse.character_data)
}
inline ::std::string* RequestGetPlayerCharacterResponse::mutable_character_data() {
  set_has_character_data();
  if (character_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    character_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.RequestGetPlayerCharacterResponse.character_data)
  return character_data_;
}
inline ::std::string* RequestGetPlayerCharacterResponse::release_character_data() {
  clear_has_character_data();
  if (character_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = character_data_;
    character_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RequestGetPlayerCharacterResponse::set_allocated_character_data(::std::string* character_data) {
  if (character_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete character_data_;
  }
  if (character_data) {
    set_has_character_data();
    character_data_ = character_data;
  } else {
    clear_has_character_data();
    character_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.RequestGetPlayerCharacterResponse.character_data)
}

// -------------------------------------------------------------------

// BloodMessageData

// required uint32 player_id = 1;
inline bool BloodMessageData::has_player_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BloodMessageData::set_has_player_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BloodMessageData::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BloodMessageData::clear_player_id() {
  player_id_ = 0u;
  clear_has_player_id();
}
inline ::google::protobuf::uint32 BloodMessageData::player_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.BloodMessageData.player_id)
  return player_id_;
}
inline void BloodMessageData::set_player_id(::google::protobuf::uint32 value) {
  set_has_player_id();
  player_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.BloodMessageData.player_id)
}

// required uint32 character_id = 2;
inline bool BloodMessageData::has_character_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BloodMessageData::set_has_character_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BloodMessageData::clear_has_character_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BloodMessageData::clear_character_id() {
  character_id_ = 0u;
  clear_has_character_id();
}
inline ::google::protobuf::uint32 BloodMessageData::character_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.BloodMessageData.character_id)
  return character_id_;
}
inline void BloodMessageData::set_character_id(::google::protobuf::uint32 value) {
  set_has_character_id();
  character_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.BloodMessageData.character_id)
}

// required uint32 message_id = 3;
inline bool BloodMessageData::has_message_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BloodMessageData::set_has_message_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BloodMessageData::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BloodMessageData::clear_message_id() {
  message_id_ = 0u;
  clear_has_message_id();
}
inline ::google::protobuf::uint32 BloodMessageData::message_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.BloodMessageData.message_id)
  return message_id_;
}
inline void BloodMessageData::set_message_id(::google::protobuf::uint32 value) {
  set_has_message_id();
  message_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.BloodMessageData.message_id)
}

// required uint32 good = 4;
inline bool BloodMessageData::has_good() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BloodMessageData::set_has_good() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BloodMessageData::clear_has_good() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BloodMessageData::clear_good() {
  good_ = 0u;
  clear_has_good();
}
inline ::google::protobuf::uint32 BloodMessageData::good() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.BloodMessageData.good)
  return good_;
}
inline void BloodMessageData::set_good(::google::protobuf::uint32 value) {
  set_has_good();
  good_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.BloodMessageData.good)
}

// required bytes message_data = 5;
inline bool BloodMessageData::has_message_data() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BloodMessageData::set_has_message_data() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BloodMessageData::clear_has_message_data() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BloodMessageData::clear_message_data() {
  if (message_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_data_->clear();
  }
  clear_has_message_data();
}
inline const ::std::string& BloodMessageData::message_data() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.BloodMessageData.message_data)
  return *message_data_;
}
inline void BloodMessageData::set_message_data(const ::std::string& value) {
  set_has_message_data();
  if (message_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_data_ = new ::std::string;
  }
  message_data_->assign(value);
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.BloodMessageData.message_data)
}
inline void BloodMessageData::set_message_data(const char* value) {
  set_has_message_data();
  if (message_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_data_ = new ::std::string;
  }
  message_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:DS3_Frpg2RequestMessage.BloodMessageData.message_data)
}
inline void BloodMessageData::set_message_data(const void* value, size_t size) {
  set_has_message_data();
  if (message_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_data_ = new ::std::string;
  }
  message_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DS3_Frpg2RequestMessage.BloodMessageData.message_data)
}
inline ::std::string* BloodMessageData::mutable_message_data() {
  set_has_message_data();
  if (message_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.BloodMessageData.message_data)
  return message_data_;
}
inline ::std::string* BloodMessageData::release_message_data() {
  clear_has_message_data();
  if (message_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = message_data_;
    message_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void BloodMessageData::set_allocated_message_data(::std::string* message_data) {
  if (message_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete message_data_;
  }
  if (message_data) {
    set_has_message_data();
    message_data_ = message_data;
  } else {
    clear_has_message_data();
    message_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.BloodMessageData.message_data)
}

// required string player_steam_id = 6;
inline bool BloodMessageData::has_player_steam_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BloodMessageData::set_has_player_steam_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BloodMessageData::clear_has_player_steam_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BloodMessageData::clear_player_steam_id() {
  if (player_steam_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    player_steam_id_->clear();
  }
  clear_has_player_steam_id();
}
inline const ::std::string& BloodMessageData::player_steam_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.BloodMessageData.player_steam_id)
  return *player_steam_id_;
}
inline void BloodMessageData::set_player_steam_id(const ::std::string& value) {
  set_has_player_steam_id();
  if (player_steam_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    player_steam_id_ = new ::std::string;
  }
  player_steam_id_->assign(value);
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.BloodMessageData.player_steam_id)
}
inline void BloodMessageData::set_player_steam_id(const char* value) {
  set_has_player_steam_id();
  if (player_steam_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    player_steam_id_ = new ::std::string;
  }
  player_steam_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:DS3_Frpg2RequestMessage.BloodMessageData.player_steam_id)
}
inline void BloodMessageData::set_player_steam_id(const char* value, size_t size) {
  set_has_player_steam_id();
  if (player_steam_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    player_steam_id_ = new ::std::string;
  }
  player_steam_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DS3_Frpg2RequestMessage.BloodMessageData.player_steam_id)
}
inline ::std::string* BloodMessageData::mutable_player_steam_id() {
  set_has_player_steam_id();
  if (player_steam_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    player_steam_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.BloodMessageData.player_steam_id)
  return player_steam_id_;
}
inline ::std::string* BloodMessageData::release_player_steam_id() {
  clear_has_player_steam_id();
  if (player_steam_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = player_steam_id_;
    player_steam_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void BloodMessageData::set_allocated_player_steam_id(::std::string* player_steam_id) {
  if (player_steam_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete player_steam_id_;
  }
  if (player_steam_id) {
    set_has_player_steam_id();
    player_steam_id_ = player_steam_id;
  } else {
    clear_has_player_steam_id();
    player_steam_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.BloodMessageData.player_steam_id)
}

// required uint32 online_area_id = 7;
inline bool BloodMessageData::has_online_area_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BloodMessageData::set_has_online_area_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BloodMessageData::clear_has_online_area_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BloodMessageData::clear_online_area_id() {
  online_area_id_ = 0u;
  clear_has_online_area_id();
}
inline ::google::protobuf::uint32 BloodMessageData::online_area_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.BloodMessageData.online_area_id)
  return online_area_id_;
}
inline void BloodMessageData::set_online_area_id(::google::protobuf::uint32 value) {
  set_has_online_area_id();
  online_area_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.BloodMessageData.online_area_id)
}

// required uint32 poor = 8;
inline bool BloodMessageData::has_poor() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BloodMessageData::set_has_poor() {
  _has_bits_[0] |= 0x00000080u;
}
inline void BloodMessageData::clear_has_poor() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void BloodMessageData::clear_poor() {
  poor_ = 0u;
  clear_has_poor();
}
inline ::google::protobuf::uint32 BloodMessageData::poor() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.BloodMessageData.poor)
  return poor_;
}
inline void BloodMessageData::set_poor(::google::protobuf::uint32 value) {
  set_has_poor();
  poor_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.BloodMessageData.poor)
}

// -------------------------------------------------------------------

// LocatedBloodMessage

// required uint32 online_area_id = 1;
inline bool LocatedBloodMessage::has_online_area_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LocatedBloodMessage::set_has_online_area_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LocatedBloodMessage::clear_has_online_area_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LocatedBloodMessage::clear_online_area_id() {
  online_area_id_ = 0u;
  clear_has_online_area_id();
}
inline ::google::protobuf::uint32 LocatedBloodMessage::online_area_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.LocatedBloodMessage.online_area_id)
  return online_area_id_;
}
inline void LocatedBloodMessage::set_online_area_id(::google::protobuf::uint32 value) {
  set_has_online_area_id();
  online_area_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.LocatedBloodMessage.online_area_id)
}

// required uint32 message_id = 2;
inline bool LocatedBloodMessage::has_message_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LocatedBloodMessage::set_has_message_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LocatedBloodMessage::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LocatedBloodMessage::clear_message_id() {
  message_id_ = 0u;
  clear_has_message_id();
}
inline ::google::protobuf::uint32 LocatedBloodMessage::message_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.LocatedBloodMessage.message_id)
  return message_id_;
}
inline void LocatedBloodMessage::set_message_id(::google::protobuf::uint32 value) {
  set_has_message_id();
  message_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.LocatedBloodMessage.message_id)
}

// -------------------------------------------------------------------

// BloodMessageDomainLimitData

// required uint32 online_area_id = 1;
inline bool BloodMessageDomainLimitData::has_online_area_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BloodMessageDomainLimitData::set_has_online_area_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BloodMessageDomainLimitData::clear_has_online_area_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BloodMessageDomainLimitData::clear_online_area_id() {
  online_area_id_ = 0u;
  clear_has_online_area_id();
}
inline ::google::protobuf::uint32 BloodMessageDomainLimitData::online_area_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.BloodMessageDomainLimitData.online_area_id)
  return online_area_id_;
}
inline void BloodMessageDomainLimitData::set_online_area_id(::google::protobuf::uint32 value) {
  set_has_online_area_id();
  online_area_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.BloodMessageDomainLimitData.online_area_id)
}

// required uint32 max_type_1 = 2;
inline bool BloodMessageDomainLimitData::has_max_type_1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BloodMessageDomainLimitData::set_has_max_type_1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BloodMessageDomainLimitData::clear_has_max_type_1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BloodMessageDomainLimitData::clear_max_type_1() {
  max_type_1_ = 0u;
  clear_has_max_type_1();
}
inline ::google::protobuf::uint32 BloodMessageDomainLimitData::max_type_1() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.BloodMessageDomainLimitData.max_type_1)
  return max_type_1_;
}
inline void BloodMessageDomainLimitData::set_max_type_1(::google::protobuf::uint32 value) {
  set_has_max_type_1();
  max_type_1_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.BloodMessageDomainLimitData.max_type_1)
}

// required uint32 max_type_2 = 3;
inline bool BloodMessageDomainLimitData::has_max_type_2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BloodMessageDomainLimitData::set_has_max_type_2() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BloodMessageDomainLimitData::clear_has_max_type_2() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BloodMessageDomainLimitData::clear_max_type_2() {
  max_type_2_ = 0u;
  clear_has_max_type_2();
}
inline ::google::protobuf::uint32 BloodMessageDomainLimitData::max_type_2() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.BloodMessageDomainLimitData.max_type_2)
  return max_type_2_;
}
inline void BloodMessageDomainLimitData::set_max_type_2(::google::protobuf::uint32 value) {
  set_has_max_type_2();
  max_type_2_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.BloodMessageDomainLimitData.max_type_2)
}

// -------------------------------------------------------------------

// RequestReentryBloodMessage

// repeated .DS3_Frpg2RequestMessage.LocatedBloodMessage messages = 1;
inline int RequestReentryBloodMessage::messages_size() const {
  return messages_.size();
}
inline void RequestReentryBloodMessage::clear_messages() {
  messages_.Clear();
}
inline const ::DS3_Frpg2RequestMessage::LocatedBloodMessage& RequestReentryBloodMessage::messages(int index) const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestReentryBloodMessage.messages)
  return messages_.Get(index);
}
inline ::DS3_Frpg2RequestMessage::LocatedBloodMessage* RequestReentryBloodMessage::mutable_messages(int index) {
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.RequestReentryBloodMessage.messages)
  return messages_.Mutable(index);
}
inline ::DS3_Frpg2RequestMessage::LocatedBloodMessage* RequestReentryBloodMessage::add_messages() {
  // @@protoc_insertion_point(field_add:DS3_Frpg2RequestMessage.RequestReentryBloodMessage.messages)
  return messages_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::LocatedBloodMessage >&
RequestReentryBloodMessage::messages() const {
  // @@protoc_insertion_point(field_list:DS3_Frpg2RequestMessage.RequestReentryBloodMessage.messages)
  return messages_;
}
inline ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::LocatedBloodMessage >*
RequestReentryBloodMessage::mutable_messages() {
  // @@protoc_insertion_point(field_mutable_list:DS3_Frpg2RequestMessage.RequestReentryBloodMessage.messages)
  return &messages_;
}

// required uint32 character_id = 2;
inline bool RequestReentryBloodMessage::has_character_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestReentryBloodMessage::set_has_character_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestReentryBloodMessage::clear_has_character_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestReentryBloodMessage::clear_character_id() {
  character_id_ = 0u;
  clear_has_character_id();
}
inline ::google::protobuf::uint32 RequestReentryBloodMessage::character_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestReentryBloodMessage.character_id)
  return character_id_;
}
inline void RequestReentryBloodMessage::set_character_id(::google::protobuf::uint32 value) {
  set_has_character_id();
  character_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestReentryBloodMessage.character_id)
}

// -------------------------------------------------------------------

// RequestReentryBloodMessageResponse

// repeated uint32 recreate_message_ids = 1;
inline int RequestReentryBloodMessageResponse::recreate_message_ids_size() const {
  return recreate_message_ids_.size();
}
inline void RequestReentryBloodMessageResponse::clear_recreate_message_ids() {
  recreate_message_ids_.Clear();
}
inline ::google::protobuf::uint32 RequestReentryBloodMessageResponse::recreate_message_ids(int index) const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestReentryBloodMessageResponse.recreate_message_ids)
  return recreate_message_ids_.Get(index);
}
inline void RequestReentryBloodMessageResponse::set_recreate_message_ids(int index, ::google::protobuf::uint32 value) {
  recreate_message_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestReentryBloodMessageResponse.recreate_message_ids)
}
inline void RequestReentryBloodMessageResponse::add_recreate_message_ids(::google::protobuf::uint32 value) {
  recreate_message_ids_.Add(value);
  // @@protoc_insertion_point(field_add:DS3_Frpg2RequestMessage.RequestReentryBloodMessageResponse.recreate_message_ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
RequestReentryBloodMessageResponse::recreate_message_ids() const {
  // @@protoc_insertion_point(field_list:DS3_Frpg2RequestMessage.RequestReentryBloodMessageResponse.recreate_message_ids)
  return recreate_message_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
RequestReentryBloodMessageResponse::mutable_recreate_message_ids() {
  // @@protoc_insertion_point(field_mutable_list:DS3_Frpg2RequestMessage.RequestReentryBloodMessageResponse.recreate_message_ids)
  return &recreate_message_ids_;
}

// -------------------------------------------------------------------

// RequestCreateBloodMessage

// required uint32 online_area_id = 1;
inline bool RequestCreateBloodMessage::has_online_area_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestCreateBloodMessage::set_has_online_area_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestCreateBloodMessage::clear_has_online_area_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestCreateBloodMessage::clear_online_area_id() {
  online_area_id_ = 0u;
  clear_has_online_area_id();
}
inline ::google::protobuf::uint32 RequestCreateBloodMessage::online_area_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestCreateBloodMessage.online_area_id)
  return online_area_id_;
}
inline void RequestCreateBloodMessage::set_online_area_id(::google::protobuf::uint32 value) {
  set_has_online_area_id();
  online_area_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestCreateBloodMessage.online_area_id)
}

// required uint32 character_id = 2;
inline bool RequestCreateBloodMessage::has_character_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestCreateBloodMessage::set_has_character_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestCreateBloodMessage::clear_has_character_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestCreateBloodMessage::clear_character_id() {
  character_id_ = 0u;
  clear_has_character_id();
}
inline ::google::protobuf::uint32 RequestCreateBloodMessage::character_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestCreateBloodMessage.character_id)
  return character_id_;
}
inline void RequestCreateBloodMessage::set_character_id(::google::protobuf::uint32 value) {
  set_has_character_id();
  character_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestCreateBloodMessage.character_id)
}

// required bytes message_data = 3;
inline bool RequestCreateBloodMessage::has_message_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestCreateBloodMessage::set_has_message_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestCreateBloodMessage::clear_has_message_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestCreateBloodMessage::clear_message_data() {
  if (message_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_data_->clear();
  }
  clear_has_message_data();
}
inline const ::std::string& RequestCreateBloodMessage::message_data() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestCreateBloodMessage.message_data)
  return *message_data_;
}
inline void RequestCreateBloodMessage::set_message_data(const ::std::string& value) {
  set_has_message_data();
  if (message_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_data_ = new ::std::string;
  }
  message_data_->assign(value);
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestCreateBloodMessage.message_data)
}
inline void RequestCreateBloodMessage::set_message_data(const char* value) {
  set_has_message_data();
  if (message_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_data_ = new ::std::string;
  }
  message_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:DS3_Frpg2RequestMessage.RequestCreateBloodMessage.message_data)
}
inline void RequestCreateBloodMessage::set_message_data(const void* value, size_t size) {
  set_has_message_data();
  if (message_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_data_ = new ::std::string;
  }
  message_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DS3_Frpg2RequestMessage.RequestCreateBloodMessage.message_data)
}
inline ::std::string* RequestCreateBloodMessage::mutable_message_data() {
  set_has_message_data();
  if (message_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.RequestCreateBloodMessage.message_data)
  return message_data_;
}
inline ::std::string* RequestCreateBloodMessage::release_message_data() {
  clear_has_message_data();
  if (message_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = message_data_;
    message_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RequestCreateBloodMessage::set_allocated_message_data(::std::string* message_data) {
  if (message_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete message_data_;
  }
  if (message_data) {
    set_has_message_data();
    message_data_ = message_data;
  } else {
    clear_has_message_data();
    message_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.RequestCreateBloodMessage.message_data)
}

// -------------------------------------------------------------------

// RequestCreateBloodMessageResponse

// required uint32 message_id = 1;
inline bool RequestCreateBloodMessageResponse::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestCreateBloodMessageResponse::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestCreateBloodMessageResponse::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestCreateBloodMessageResponse::clear_message_id() {
  message_id_ = 0u;
  clear_has_message_id();
}
inline ::google::protobuf::uint32 RequestCreateBloodMessageResponse::message_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestCreateBloodMessageResponse.message_id)
  return message_id_;
}
inline void RequestCreateBloodMessageResponse::set_message_id(::google::protobuf::uint32 value) {
  set_has_message_id();
  message_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestCreateBloodMessageResponse.message_id)
}

// -------------------------------------------------------------------

// RequestReCreateBloodMessageList_Blood_message_info_list

// required uint32 online_area_id = 1;
inline bool RequestReCreateBloodMessageList_Blood_message_info_list::has_online_area_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestReCreateBloodMessageList_Blood_message_info_list::set_has_online_area_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestReCreateBloodMessageList_Blood_message_info_list::clear_has_online_area_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestReCreateBloodMessageList_Blood_message_info_list::clear_online_area_id() {
  online_area_id_ = 0u;
  clear_has_online_area_id();
}
inline ::google::protobuf::uint32 RequestReCreateBloodMessageList_Blood_message_info_list::online_area_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestReCreateBloodMessageList.Blood_message_info_list.online_area_id)
  return online_area_id_;
}
inline void RequestReCreateBloodMessageList_Blood_message_info_list::set_online_area_id(::google::protobuf::uint32 value) {
  set_has_online_area_id();
  online_area_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestReCreateBloodMessageList.Blood_message_info_list.online_area_id)
}

// required bytes message_data = 2;
inline bool RequestReCreateBloodMessageList_Blood_message_info_list::has_message_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestReCreateBloodMessageList_Blood_message_info_list::set_has_message_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestReCreateBloodMessageList_Blood_message_info_list::clear_has_message_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestReCreateBloodMessageList_Blood_message_info_list::clear_message_data() {
  if (message_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_data_->clear();
  }
  clear_has_message_data();
}
inline const ::std::string& RequestReCreateBloodMessageList_Blood_message_info_list::message_data() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestReCreateBloodMessageList.Blood_message_info_list.message_data)
  return *message_data_;
}
inline void RequestReCreateBloodMessageList_Blood_message_info_list::set_message_data(const ::std::string& value) {
  set_has_message_data();
  if (message_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_data_ = new ::std::string;
  }
  message_data_->assign(value);
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestReCreateBloodMessageList.Blood_message_info_list.message_data)
}
inline void RequestReCreateBloodMessageList_Blood_message_info_list::set_message_data(const char* value) {
  set_has_message_data();
  if (message_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_data_ = new ::std::string;
  }
  message_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:DS3_Frpg2RequestMessage.RequestReCreateBloodMessageList.Blood_message_info_list.message_data)
}
inline void RequestReCreateBloodMessageList_Blood_message_info_list::set_message_data(const void* value, size_t size) {
  set_has_message_data();
  if (message_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_data_ = new ::std::string;
  }
  message_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DS3_Frpg2RequestMessage.RequestReCreateBloodMessageList.Blood_message_info_list.message_data)
}
inline ::std::string* RequestReCreateBloodMessageList_Blood_message_info_list::mutable_message_data() {
  set_has_message_data();
  if (message_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.RequestReCreateBloodMessageList.Blood_message_info_list.message_data)
  return message_data_;
}
inline ::std::string* RequestReCreateBloodMessageList_Blood_message_info_list::release_message_data() {
  clear_has_message_data();
  if (message_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = message_data_;
    message_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RequestReCreateBloodMessageList_Blood_message_info_list::set_allocated_message_data(::std::string* message_data) {
  if (message_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete message_data_;
  }
  if (message_data) {
    set_has_message_data();
    message_data_ = message_data;
  } else {
    clear_has_message_data();
    message_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.RequestReCreateBloodMessageList.Blood_message_info_list.message_data)
}

// required uint32 unknown_1 = 3;
inline bool RequestReCreateBloodMessageList_Blood_message_info_list::has_unknown_1() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestReCreateBloodMessageList_Blood_message_info_list::set_has_unknown_1() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestReCreateBloodMessageList_Blood_message_info_list::clear_has_unknown_1() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestReCreateBloodMessageList_Blood_message_info_list::clear_unknown_1() {
  unknown_1_ = 0u;
  clear_has_unknown_1();
}
inline ::google::protobuf::uint32 RequestReCreateBloodMessageList_Blood_message_info_list::unknown_1() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestReCreateBloodMessageList.Blood_message_info_list.unknown_1)
  return unknown_1_;
}
inline void RequestReCreateBloodMessageList_Blood_message_info_list::set_unknown_1(::google::protobuf::uint32 value) {
  set_has_unknown_1();
  unknown_1_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestReCreateBloodMessageList.Blood_message_info_list.unknown_1)
}

// required uint32 unknown_2 = 4;
inline bool RequestReCreateBloodMessageList_Blood_message_info_list::has_unknown_2() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestReCreateBloodMessageList_Blood_message_info_list::set_has_unknown_2() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestReCreateBloodMessageList_Blood_message_info_list::clear_has_unknown_2() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestReCreateBloodMessageList_Blood_message_info_list::clear_unknown_2() {
  unknown_2_ = 0u;
  clear_has_unknown_2();
}
inline ::google::protobuf::uint32 RequestReCreateBloodMessageList_Blood_message_info_list::unknown_2() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestReCreateBloodMessageList.Blood_message_info_list.unknown_2)
  return unknown_2_;
}
inline void RequestReCreateBloodMessageList_Blood_message_info_list::set_unknown_2(::google::protobuf::uint32 value) {
  set_has_unknown_2();
  unknown_2_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestReCreateBloodMessageList.Blood_message_info_list.unknown_2)
}

// -------------------------------------------------------------------

// RequestReCreateBloodMessageList

// required uint32 character_id = 2;
inline bool RequestReCreateBloodMessageList::has_character_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestReCreateBloodMessageList::set_has_character_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestReCreateBloodMessageList::clear_has_character_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestReCreateBloodMessageList::clear_character_id() {
  character_id_ = 0u;
  clear_has_character_id();
}
inline ::google::protobuf::uint32 RequestReCreateBloodMessageList::character_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestReCreateBloodMessageList.character_id)
  return character_id_;
}
inline void RequestReCreateBloodMessageList::set_character_id(::google::protobuf::uint32 value) {
  set_has_character_id();
  character_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestReCreateBloodMessageList.character_id)
}

// repeated group Blood_message_info_list = 3 {
inline int RequestReCreateBloodMessageList::blood_message_info_list_size() const {
  return blood_message_info_list_.size();
}
inline void RequestReCreateBloodMessageList::clear_blood_message_info_list() {
  blood_message_info_list_.Clear();
}
inline const ::DS3_Frpg2RequestMessage::RequestReCreateBloodMessageList_Blood_message_info_list& RequestReCreateBloodMessageList::blood_message_info_list(int index) const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestReCreateBloodMessageList.blood_message_info_list)
  return blood_message_info_list_.Get(index);
}
inline ::DS3_Frpg2RequestMessage::RequestReCreateBloodMessageList_Blood_message_info_list* RequestReCreateBloodMessageList::mutable_blood_message_info_list(int index) {
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.RequestReCreateBloodMessageList.blood_message_info_list)
  return blood_message_info_list_.Mutable(index);
}
inline ::DS3_Frpg2RequestMessage::RequestReCreateBloodMessageList_Blood_message_info_list* RequestReCreateBloodMessageList::add_blood_message_info_list() {
  // @@protoc_insertion_point(field_add:DS3_Frpg2RequestMessage.RequestReCreateBloodMessageList.blood_message_info_list)
  return blood_message_info_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::RequestReCreateBloodMessageList_Blood_message_info_list >&
RequestReCreateBloodMessageList::blood_message_info_list() const {
  // @@protoc_insertion_point(field_list:DS3_Frpg2RequestMessage.RequestReCreateBloodMessageList.blood_message_info_list)
  return blood_message_info_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::RequestReCreateBloodMessageList_Blood_message_info_list >*
RequestReCreateBloodMessageList::mutable_blood_message_info_list() {
  // @@protoc_insertion_point(field_mutable_list:DS3_Frpg2RequestMessage.RequestReCreateBloodMessageList.blood_message_info_list)
  return &blood_message_info_list_;
}

// -------------------------------------------------------------------

// RequestReCreateBloodMessageListResponse

// repeated uint32 message_ids = 1;
inline int RequestReCreateBloodMessageListResponse::message_ids_size() const {
  return message_ids_.size();
}
inline void RequestReCreateBloodMessageListResponse::clear_message_ids() {
  message_ids_.Clear();
}
inline ::google::protobuf::uint32 RequestReCreateBloodMessageListResponse::message_ids(int index) const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestReCreateBloodMessageListResponse.message_ids)
  return message_ids_.Get(index);
}
inline void RequestReCreateBloodMessageListResponse::set_message_ids(int index, ::google::protobuf::uint32 value) {
  message_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestReCreateBloodMessageListResponse.message_ids)
}
inline void RequestReCreateBloodMessageListResponse::add_message_ids(::google::protobuf::uint32 value) {
  message_ids_.Add(value);
  // @@protoc_insertion_point(field_add:DS3_Frpg2RequestMessage.RequestReCreateBloodMessageListResponse.message_ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
RequestReCreateBloodMessageListResponse::message_ids() const {
  // @@protoc_insertion_point(field_list:DS3_Frpg2RequestMessage.RequestReCreateBloodMessageListResponse.message_ids)
  return message_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
RequestReCreateBloodMessageListResponse::mutable_message_ids() {
  // @@protoc_insertion_point(field_mutable_list:DS3_Frpg2RequestMessage.RequestReCreateBloodMessageListResponse.message_ids)
  return &message_ids_;
}

// -------------------------------------------------------------------

// RequestRemoveBloodMessage

// required uint32 online_area_id = 1;
inline bool RequestRemoveBloodMessage::has_online_area_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestRemoveBloodMessage::set_has_online_area_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestRemoveBloodMessage::clear_has_online_area_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestRemoveBloodMessage::clear_online_area_id() {
  online_area_id_ = 0u;
  clear_has_online_area_id();
}
inline ::google::protobuf::uint32 RequestRemoveBloodMessage::online_area_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestRemoveBloodMessage.online_area_id)
  return online_area_id_;
}
inline void RequestRemoveBloodMessage::set_online_area_id(::google::protobuf::uint32 value) {
  set_has_online_area_id();
  online_area_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestRemoveBloodMessage.online_area_id)
}

// required uint32 message_id = 2;
inline bool RequestRemoveBloodMessage::has_message_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestRemoveBloodMessage::set_has_message_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestRemoveBloodMessage::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestRemoveBloodMessage::clear_message_id() {
  message_id_ = 0u;
  clear_has_message_id();
}
inline ::google::protobuf::uint32 RequestRemoveBloodMessage::message_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestRemoveBloodMessage.message_id)
  return message_id_;
}
inline void RequestRemoveBloodMessage::set_message_id(::google::protobuf::uint32 value) {
  set_has_message_id();
  message_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestRemoveBloodMessage.message_id)
}

// -------------------------------------------------------------------

// RequestRemoveBloodMessageResponse

// -------------------------------------------------------------------

// RequestGetBloodMessageList

// required uint32 max_messages = 1;
inline bool RequestGetBloodMessageList::has_max_messages() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestGetBloodMessageList::set_has_max_messages() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestGetBloodMessageList::clear_has_max_messages() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestGetBloodMessageList::clear_max_messages() {
  max_messages_ = 0u;
  clear_has_max_messages();
}
inline ::google::protobuf::uint32 RequestGetBloodMessageList::max_messages() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestGetBloodMessageList.max_messages)
  return max_messages_;
}
inline void RequestGetBloodMessageList::set_max_messages(::google::protobuf::uint32 value) {
  set_has_max_messages();
  max_messages_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestGetBloodMessageList.max_messages)
}

// repeated .DS3_Frpg2RequestMessage.BloodMessageDomainLimitData search_areas = 2;
inline int RequestGetBloodMessageList::search_areas_size() const {
  return search_areas_.size();
}
inline void RequestGetBloodMessageList::clear_search_areas() {
  search_areas_.Clear();
}
inline const ::DS3_Frpg2RequestMessage::BloodMessageDomainLimitData& RequestGetBloodMessageList::search_areas(int index) const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestGetBloodMessageList.search_areas)
  return search_areas_.Get(index);
}
inline ::DS3_Frpg2RequestMessage::BloodMessageDomainLimitData* RequestGetBloodMessageList::mutable_search_areas(int index) {
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.RequestGetBloodMessageList.search_areas)
  return search_areas_.Mutable(index);
}
inline ::DS3_Frpg2RequestMessage::BloodMessageDomainLimitData* RequestGetBloodMessageList::add_search_areas() {
  // @@protoc_insertion_point(field_add:DS3_Frpg2RequestMessage.RequestGetBloodMessageList.search_areas)
  return search_areas_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::BloodMessageDomainLimitData >&
RequestGetBloodMessageList::search_areas() const {
  // @@protoc_insertion_point(field_list:DS3_Frpg2RequestMessage.RequestGetBloodMessageList.search_areas)
  return search_areas_;
}
inline ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::BloodMessageDomainLimitData >*
RequestGetBloodMessageList::mutable_search_areas() {
  // @@protoc_insertion_point(field_mutable_list:DS3_Frpg2RequestMessage.RequestGetBloodMessageList.search_areas)
  return &search_areas_;
}

// -------------------------------------------------------------------

// RequestGetBloodMessageListResponse

// repeated .DS3_Frpg2RequestMessage.BloodMessageData messages = 1;
inline int RequestGetBloodMessageListResponse::messages_size() const {
  return messages_.size();
}
inline void RequestGetBloodMessageListResponse::clear_messages() {
  messages_.Clear();
}
inline const ::DS3_Frpg2RequestMessage::BloodMessageData& RequestGetBloodMessageListResponse::messages(int index) const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestGetBloodMessageListResponse.messages)
  return messages_.Get(index);
}
inline ::DS3_Frpg2RequestMessage::BloodMessageData* RequestGetBloodMessageListResponse::mutable_messages(int index) {
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.RequestGetBloodMessageListResponse.messages)
  return messages_.Mutable(index);
}
inline ::DS3_Frpg2RequestMessage::BloodMessageData* RequestGetBloodMessageListResponse::add_messages() {
  // @@protoc_insertion_point(field_add:DS3_Frpg2RequestMessage.RequestGetBloodMessageListResponse.messages)
  return messages_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::BloodMessageData >&
RequestGetBloodMessageListResponse::messages() const {
  // @@protoc_insertion_point(field_list:DS3_Frpg2RequestMessage.RequestGetBloodMessageListResponse.messages)
  return messages_;
}
inline ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::BloodMessageData >*
RequestGetBloodMessageListResponse::mutable_messages() {
  // @@protoc_insertion_point(field_mutable_list:DS3_Frpg2RequestMessage.RequestGetBloodMessageListResponse.messages)
  return &messages_;
}

// -------------------------------------------------------------------

// RequestEvaluateBloodMessage

// required uint32 online_area_id = 1;
inline bool RequestEvaluateBloodMessage::has_online_area_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestEvaluateBloodMessage::set_has_online_area_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestEvaluateBloodMessage::clear_has_online_area_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestEvaluateBloodMessage::clear_online_area_id() {
  online_area_id_ = 0u;
  clear_has_online_area_id();
}
inline ::google::protobuf::uint32 RequestEvaluateBloodMessage::online_area_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestEvaluateBloodMessage.online_area_id)
  return online_area_id_;
}
inline void RequestEvaluateBloodMessage::set_online_area_id(::google::protobuf::uint32 value) {
  set_has_online_area_id();
  online_area_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestEvaluateBloodMessage.online_area_id)
}

// required uint32 message_id = 2;
inline bool RequestEvaluateBloodMessage::has_message_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestEvaluateBloodMessage::set_has_message_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestEvaluateBloodMessage::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestEvaluateBloodMessage::clear_message_id() {
  message_id_ = 0u;
  clear_has_message_id();
}
inline ::google::protobuf::uint32 RequestEvaluateBloodMessage::message_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestEvaluateBloodMessage.message_id)
  return message_id_;
}
inline void RequestEvaluateBloodMessage::set_message_id(::google::protobuf::uint32 value) {
  set_has_message_id();
  message_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestEvaluateBloodMessage.message_id)
}

// required bool was_poor = 3;
inline bool RequestEvaluateBloodMessage::has_was_poor() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestEvaluateBloodMessage::set_has_was_poor() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestEvaluateBloodMessage::clear_has_was_poor() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestEvaluateBloodMessage::clear_was_poor() {
  was_poor_ = false;
  clear_has_was_poor();
}
inline bool RequestEvaluateBloodMessage::was_poor() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestEvaluateBloodMessage.was_poor)
  return was_poor_;
}
inline void RequestEvaluateBloodMessage::set_was_poor(bool value) {
  set_has_was_poor();
  was_poor_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestEvaluateBloodMessage.was_poor)
}

// -------------------------------------------------------------------

// RequestEvaluateBloodMessageResponse

// -------------------------------------------------------------------

// RequestGetBloodMessageEvaluation

// repeated .DS3_Frpg2RequestMessage.LocatedBloodMessage messages = 1;
inline int RequestGetBloodMessageEvaluation::messages_size() const {
  return messages_.size();
}
inline void RequestGetBloodMessageEvaluation::clear_messages() {
  messages_.Clear();
}
inline const ::DS3_Frpg2RequestMessage::LocatedBloodMessage& RequestGetBloodMessageEvaluation::messages(int index) const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestGetBloodMessageEvaluation.messages)
  return messages_.Get(index);
}
inline ::DS3_Frpg2RequestMessage::LocatedBloodMessage* RequestGetBloodMessageEvaluation::mutable_messages(int index) {
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.RequestGetBloodMessageEvaluation.messages)
  return messages_.Mutable(index);
}
inline ::DS3_Frpg2RequestMessage::LocatedBloodMessage* RequestGetBloodMessageEvaluation::add_messages() {
  // @@protoc_insertion_point(field_add:DS3_Frpg2RequestMessage.RequestGetBloodMessageEvaluation.messages)
  return messages_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::LocatedBloodMessage >&
RequestGetBloodMessageEvaluation::messages() const {
  // @@protoc_insertion_point(field_list:DS3_Frpg2RequestMessage.RequestGetBloodMessageEvaluation.messages)
  return messages_;
}
inline ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::LocatedBloodMessage >*
RequestGetBloodMessageEvaluation::mutable_messages() {
  // @@protoc_insertion_point(field_mutable_list:DS3_Frpg2RequestMessage.RequestGetBloodMessageEvaluation.messages)
  return &messages_;
}

// -------------------------------------------------------------------

// BloodMessageEvaluationData

// required uint32 message_id = 1;
inline bool BloodMessageEvaluationData::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BloodMessageEvaluationData::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BloodMessageEvaluationData::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BloodMessageEvaluationData::clear_message_id() {
  message_id_ = 0u;
  clear_has_message_id();
}
inline ::google::protobuf::uint32 BloodMessageEvaluationData::message_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.BloodMessageEvaluationData.message_id)
  return message_id_;
}
inline void BloodMessageEvaluationData::set_message_id(::google::protobuf::uint32 value) {
  set_has_message_id();
  message_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.BloodMessageEvaluationData.message_id)
}

// required uint32 good = 2;
inline bool BloodMessageEvaluationData::has_good() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BloodMessageEvaluationData::set_has_good() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BloodMessageEvaluationData::clear_has_good() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BloodMessageEvaluationData::clear_good() {
  good_ = 0u;
  clear_has_good();
}
inline ::google::protobuf::uint32 BloodMessageEvaluationData::good() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.BloodMessageEvaluationData.good)
  return good_;
}
inline void BloodMessageEvaluationData::set_good(::google::protobuf::uint32 value) {
  set_has_good();
  good_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.BloodMessageEvaluationData.good)
}

// required uint32 poor = 3;
inline bool BloodMessageEvaluationData::has_poor() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BloodMessageEvaluationData::set_has_poor() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BloodMessageEvaluationData::clear_has_poor() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BloodMessageEvaluationData::clear_poor() {
  poor_ = 0u;
  clear_has_poor();
}
inline ::google::protobuf::uint32 BloodMessageEvaluationData::poor() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.BloodMessageEvaluationData.poor)
  return poor_;
}
inline void BloodMessageEvaluationData::set_poor(::google::protobuf::uint32 value) {
  set_has_poor();
  poor_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.BloodMessageEvaluationData.poor)
}

// -------------------------------------------------------------------

// RequestGetBloodMessageEvaluationResponse

// repeated .DS3_Frpg2RequestMessage.BloodMessageEvaluationData messages = 1;
inline int RequestGetBloodMessageEvaluationResponse::messages_size() const {
  return messages_.size();
}
inline void RequestGetBloodMessageEvaluationResponse::clear_messages() {
  messages_.Clear();
}
inline const ::DS3_Frpg2RequestMessage::BloodMessageEvaluationData& RequestGetBloodMessageEvaluationResponse::messages(int index) const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestGetBloodMessageEvaluationResponse.messages)
  return messages_.Get(index);
}
inline ::DS3_Frpg2RequestMessage::BloodMessageEvaluationData* RequestGetBloodMessageEvaluationResponse::mutable_messages(int index) {
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.RequestGetBloodMessageEvaluationResponse.messages)
  return messages_.Mutable(index);
}
inline ::DS3_Frpg2RequestMessage::BloodMessageEvaluationData* RequestGetBloodMessageEvaluationResponse::add_messages() {
  // @@protoc_insertion_point(field_add:DS3_Frpg2RequestMessage.RequestGetBloodMessageEvaluationResponse.messages)
  return messages_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::BloodMessageEvaluationData >&
RequestGetBloodMessageEvaluationResponse::messages() const {
  // @@protoc_insertion_point(field_list:DS3_Frpg2RequestMessage.RequestGetBloodMessageEvaluationResponse.messages)
  return messages_;
}
inline ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::BloodMessageEvaluationData >*
RequestGetBloodMessageEvaluationResponse::mutable_messages() {
  // @@protoc_insertion_point(field_mutable_list:DS3_Frpg2RequestMessage.RequestGetBloodMessageEvaluationResponse.messages)
  return &messages_;
}

// -------------------------------------------------------------------

// PushRequestEvaluateBloodMessage

// required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
inline bool PushRequestEvaluateBloodMessage::has_push_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PushRequestEvaluateBloodMessage::set_has_push_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PushRequestEvaluateBloodMessage::clear_has_push_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PushRequestEvaluateBloodMessage::clear_push_message_id() {
  push_message_id_ = 829;
  clear_has_push_message_id();
}
inline ::DS3_Frpg2RequestMessage::PushMessageId PushRequestEvaluateBloodMessage::push_message_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.PushRequestEvaluateBloodMessage.push_message_id)
  return static_cast< ::DS3_Frpg2RequestMessage::PushMessageId >(push_message_id_);
}
inline void PushRequestEvaluateBloodMessage::set_push_message_id(::DS3_Frpg2RequestMessage::PushMessageId value) {
  assert(::DS3_Frpg2RequestMessage::PushMessageId_IsValid(value));
  set_has_push_message_id();
  push_message_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.PushRequestEvaluateBloodMessage.push_message_id)
}

// required uint32 player_id = 2;
inline bool PushRequestEvaluateBloodMessage::has_player_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PushRequestEvaluateBloodMessage::set_has_player_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PushRequestEvaluateBloodMessage::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PushRequestEvaluateBloodMessage::clear_player_id() {
  player_id_ = 0u;
  clear_has_player_id();
}
inline ::google::protobuf::uint32 PushRequestEvaluateBloodMessage::player_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.PushRequestEvaluateBloodMessage.player_id)
  return player_id_;
}
inline void PushRequestEvaluateBloodMessage::set_player_id(::google::protobuf::uint32 value) {
  set_has_player_id();
  player_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.PushRequestEvaluateBloodMessage.player_id)
}

// required uint32 message_id = 3;
inline bool PushRequestEvaluateBloodMessage::has_message_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PushRequestEvaluateBloodMessage::set_has_message_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PushRequestEvaluateBloodMessage::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PushRequestEvaluateBloodMessage::clear_message_id() {
  message_id_ = 0u;
  clear_has_message_id();
}
inline ::google::protobuf::uint32 PushRequestEvaluateBloodMessage::message_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.PushRequestEvaluateBloodMessage.message_id)
  return message_id_;
}
inline void PushRequestEvaluateBloodMessage::set_message_id(::google::protobuf::uint32 value) {
  set_has_message_id();
  message_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.PushRequestEvaluateBloodMessage.message_id)
}

// required string player_steam_id = 4;
inline bool PushRequestEvaluateBloodMessage::has_player_steam_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PushRequestEvaluateBloodMessage::set_has_player_steam_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PushRequestEvaluateBloodMessage::clear_has_player_steam_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PushRequestEvaluateBloodMessage::clear_player_steam_id() {
  if (player_steam_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    player_steam_id_->clear();
  }
  clear_has_player_steam_id();
}
inline const ::std::string& PushRequestEvaluateBloodMessage::player_steam_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.PushRequestEvaluateBloodMessage.player_steam_id)
  return *player_steam_id_;
}
inline void PushRequestEvaluateBloodMessage::set_player_steam_id(const ::std::string& value) {
  set_has_player_steam_id();
  if (player_steam_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    player_steam_id_ = new ::std::string;
  }
  player_steam_id_->assign(value);
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.PushRequestEvaluateBloodMessage.player_steam_id)
}
inline void PushRequestEvaluateBloodMessage::set_player_steam_id(const char* value) {
  set_has_player_steam_id();
  if (player_steam_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    player_steam_id_ = new ::std::string;
  }
  player_steam_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:DS3_Frpg2RequestMessage.PushRequestEvaluateBloodMessage.player_steam_id)
}
inline void PushRequestEvaluateBloodMessage::set_player_steam_id(const char* value, size_t size) {
  set_has_player_steam_id();
  if (player_steam_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    player_steam_id_ = new ::std::string;
  }
  player_steam_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DS3_Frpg2RequestMessage.PushRequestEvaluateBloodMessage.player_steam_id)
}
inline ::std::string* PushRequestEvaluateBloodMessage::mutable_player_steam_id() {
  set_has_player_steam_id();
  if (player_steam_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    player_steam_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.PushRequestEvaluateBloodMessage.player_steam_id)
  return player_steam_id_;
}
inline ::std::string* PushRequestEvaluateBloodMessage::release_player_steam_id() {
  clear_has_player_steam_id();
  if (player_steam_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = player_steam_id_;
    player_steam_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PushRequestEvaluateBloodMessage::set_allocated_player_steam_id(::std::string* player_steam_id) {
  if (player_steam_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete player_steam_id_;
  }
  if (player_steam_id) {
    set_has_player_steam_id();
    player_steam_id_ = player_steam_id;
  } else {
    clear_has_player_steam_id();
    player_steam_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.PushRequestEvaluateBloodMessage.player_steam_id)
}

// required bool was_poor = 5;
inline bool PushRequestEvaluateBloodMessage::has_was_poor() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PushRequestEvaluateBloodMessage::set_has_was_poor() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PushRequestEvaluateBloodMessage::clear_has_was_poor() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PushRequestEvaluateBloodMessage::clear_was_poor() {
  was_poor_ = false;
  clear_has_was_poor();
}
inline bool PushRequestEvaluateBloodMessage::was_poor() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.PushRequestEvaluateBloodMessage.was_poor)
  return was_poor_;
}
inline void PushRequestEvaluateBloodMessage::set_was_poor(bool value) {
  set_has_was_poor();
  was_poor_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.PushRequestEvaluateBloodMessage.was_poor)
}

// -------------------------------------------------------------------

// BloodstainInfo

// required uint32 online_area_id = 1;
inline bool BloodstainInfo::has_online_area_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BloodstainInfo::set_has_online_area_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BloodstainInfo::clear_has_online_area_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BloodstainInfo::clear_online_area_id() {
  online_area_id_ = 0u;
  clear_has_online_area_id();
}
inline ::google::protobuf::uint32 BloodstainInfo::online_area_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.BloodstainInfo.online_area_id)
  return online_area_id_;
}
inline void BloodstainInfo::set_online_area_id(::google::protobuf::uint32 value) {
  set_has_online_area_id();
  online_area_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.BloodstainInfo.online_area_id)
}

// required uint32 bloodstain_id = 2;
inline bool BloodstainInfo::has_bloodstain_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BloodstainInfo::set_has_bloodstain_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BloodstainInfo::clear_has_bloodstain_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BloodstainInfo::clear_bloodstain_id() {
  bloodstain_id_ = 0u;
  clear_has_bloodstain_id();
}
inline ::google::protobuf::uint32 BloodstainInfo::bloodstain_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.BloodstainInfo.bloodstain_id)
  return bloodstain_id_;
}
inline void BloodstainInfo::set_bloodstain_id(::google::protobuf::uint32 value) {
  set_has_bloodstain_id();
  bloodstain_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.BloodstainInfo.bloodstain_id)
}

// required bytes data = 3;
inline bool BloodstainInfo::has_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BloodstainInfo::set_has_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BloodstainInfo::clear_has_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BloodstainInfo::clear_data() {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& BloodstainInfo::data() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.BloodstainInfo.data)
  return *data_;
}
inline void BloodstainInfo::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.BloodstainInfo.data)
}
inline void BloodstainInfo::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set_char:DS3_Frpg2RequestMessage.BloodstainInfo.data)
}
inline void BloodstainInfo::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DS3_Frpg2RequestMessage.BloodstainInfo.data)
}
inline ::std::string* BloodstainInfo::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.BloodstainInfo.data)
  return data_;
}
inline ::std::string* BloodstainInfo::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void BloodstainInfo::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.BloodstainInfo.data)
}

// -------------------------------------------------------------------

// RequestCreateBloodstain

// required uint32 online_area_id = 1;
inline bool RequestCreateBloodstain::has_online_area_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestCreateBloodstain::set_has_online_area_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestCreateBloodstain::clear_has_online_area_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestCreateBloodstain::clear_online_area_id() {
  online_area_id_ = 0u;
  clear_has_online_area_id();
}
inline ::google::protobuf::uint32 RequestCreateBloodstain::online_area_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestCreateBloodstain.online_area_id)
  return online_area_id_;
}
inline void RequestCreateBloodstain::set_online_area_id(::google::protobuf::uint32 value) {
  set_has_online_area_id();
  online_area_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestCreateBloodstain.online_area_id)
}

// required bytes data = 2;
inline bool RequestCreateBloodstain::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestCreateBloodstain::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestCreateBloodstain::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestCreateBloodstain::clear_data() {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& RequestCreateBloodstain::data() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestCreateBloodstain.data)
  return *data_;
}
inline void RequestCreateBloodstain::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestCreateBloodstain.data)
}
inline void RequestCreateBloodstain::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set_char:DS3_Frpg2RequestMessage.RequestCreateBloodstain.data)
}
inline void RequestCreateBloodstain::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DS3_Frpg2RequestMessage.RequestCreateBloodstain.data)
}
inline ::std::string* RequestCreateBloodstain::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.RequestCreateBloodstain.data)
  return data_;
}
inline ::std::string* RequestCreateBloodstain::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RequestCreateBloodstain::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.RequestCreateBloodstain.data)
}

// required bytes ghost_data = 3;
inline bool RequestCreateBloodstain::has_ghost_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestCreateBloodstain::set_has_ghost_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestCreateBloodstain::clear_has_ghost_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestCreateBloodstain::clear_ghost_data() {
  if (ghost_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ghost_data_->clear();
  }
  clear_has_ghost_data();
}
inline const ::std::string& RequestCreateBloodstain::ghost_data() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestCreateBloodstain.ghost_data)
  return *ghost_data_;
}
inline void RequestCreateBloodstain::set_ghost_data(const ::std::string& value) {
  set_has_ghost_data();
  if (ghost_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ghost_data_ = new ::std::string;
  }
  ghost_data_->assign(value);
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestCreateBloodstain.ghost_data)
}
inline void RequestCreateBloodstain::set_ghost_data(const char* value) {
  set_has_ghost_data();
  if (ghost_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ghost_data_ = new ::std::string;
  }
  ghost_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:DS3_Frpg2RequestMessage.RequestCreateBloodstain.ghost_data)
}
inline void RequestCreateBloodstain::set_ghost_data(const void* value, size_t size) {
  set_has_ghost_data();
  if (ghost_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ghost_data_ = new ::std::string;
  }
  ghost_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DS3_Frpg2RequestMessage.RequestCreateBloodstain.ghost_data)
}
inline ::std::string* RequestCreateBloodstain::mutable_ghost_data() {
  set_has_ghost_data();
  if (ghost_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ghost_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.RequestCreateBloodstain.ghost_data)
  return ghost_data_;
}
inline ::std::string* RequestCreateBloodstain::release_ghost_data() {
  clear_has_ghost_data();
  if (ghost_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ghost_data_;
    ghost_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RequestCreateBloodstain::set_allocated_ghost_data(::std::string* ghost_data) {
  if (ghost_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ghost_data_;
  }
  if (ghost_data) {
    set_has_ghost_data();
    ghost_data_ = ghost_data;
  } else {
    clear_has_ghost_data();
    ghost_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.RequestCreateBloodstain.ghost_data)
}

// -------------------------------------------------------------------

// RequestGetBloodstainList

// required uint32 max_stains = 1;
inline bool RequestGetBloodstainList::has_max_stains() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestGetBloodstainList::set_has_max_stains() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestGetBloodstainList::clear_has_max_stains() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestGetBloodstainList::clear_max_stains() {
  max_stains_ = 0u;
  clear_has_max_stains();
}
inline ::google::protobuf::uint32 RequestGetBloodstainList::max_stains() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestGetBloodstainList.max_stains)
  return max_stains_;
}
inline void RequestGetBloodstainList::set_max_stains(::google::protobuf::uint32 value) {
  set_has_max_stains();
  max_stains_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestGetBloodstainList.max_stains)
}

// repeated .DS3_Frpg2RequestMessage.DomainLimitData search_areas = 2;
inline int RequestGetBloodstainList::search_areas_size() const {
  return search_areas_.size();
}
inline void RequestGetBloodstainList::clear_search_areas() {
  search_areas_.Clear();
}
inline const ::DS3_Frpg2RequestMessage::DomainLimitData& RequestGetBloodstainList::search_areas(int index) const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestGetBloodstainList.search_areas)
  return search_areas_.Get(index);
}
inline ::DS3_Frpg2RequestMessage::DomainLimitData* RequestGetBloodstainList::mutable_search_areas(int index) {
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.RequestGetBloodstainList.search_areas)
  return search_areas_.Mutable(index);
}
inline ::DS3_Frpg2RequestMessage::DomainLimitData* RequestGetBloodstainList::add_search_areas() {
  // @@protoc_insertion_point(field_add:DS3_Frpg2RequestMessage.RequestGetBloodstainList.search_areas)
  return search_areas_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::DomainLimitData >&
RequestGetBloodstainList::search_areas() const {
  // @@protoc_insertion_point(field_list:DS3_Frpg2RequestMessage.RequestGetBloodstainList.search_areas)
  return search_areas_;
}
inline ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::DomainLimitData >*
RequestGetBloodstainList::mutable_search_areas() {
  // @@protoc_insertion_point(field_mutable_list:DS3_Frpg2RequestMessage.RequestGetBloodstainList.search_areas)
  return &search_areas_;
}

// -------------------------------------------------------------------

// RequestGetBloodstainListResponse

// repeated .DS3_Frpg2RequestMessage.BloodstainInfo bloodstains = 1;
inline int RequestGetBloodstainListResponse::bloodstains_size() const {
  return bloodstains_.size();
}
inline void RequestGetBloodstainListResponse::clear_bloodstains() {
  bloodstains_.Clear();
}
inline const ::DS3_Frpg2RequestMessage::BloodstainInfo& RequestGetBloodstainListResponse::bloodstains(int index) const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestGetBloodstainListResponse.bloodstains)
  return bloodstains_.Get(index);
}
inline ::DS3_Frpg2RequestMessage::BloodstainInfo* RequestGetBloodstainListResponse::mutable_bloodstains(int index) {
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.RequestGetBloodstainListResponse.bloodstains)
  return bloodstains_.Mutable(index);
}
inline ::DS3_Frpg2RequestMessage::BloodstainInfo* RequestGetBloodstainListResponse::add_bloodstains() {
  // @@protoc_insertion_point(field_add:DS3_Frpg2RequestMessage.RequestGetBloodstainListResponse.bloodstains)
  return bloodstains_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::BloodstainInfo >&
RequestGetBloodstainListResponse::bloodstains() const {
  // @@protoc_insertion_point(field_list:DS3_Frpg2RequestMessage.RequestGetBloodstainListResponse.bloodstains)
  return bloodstains_;
}
inline ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::BloodstainInfo >*
RequestGetBloodstainListResponse::mutable_bloodstains() {
  // @@protoc_insertion_point(field_mutable_list:DS3_Frpg2RequestMessage.RequestGetBloodstainListResponse.bloodstains)
  return &bloodstains_;
}

// -------------------------------------------------------------------

// RequestGetDeadingGhost

// required uint32 online_area_id = 1;
inline bool RequestGetDeadingGhost::has_online_area_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestGetDeadingGhost::set_has_online_area_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestGetDeadingGhost::clear_has_online_area_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestGetDeadingGhost::clear_online_area_id() {
  online_area_id_ = 0u;
  clear_has_online_area_id();
}
inline ::google::protobuf::uint32 RequestGetDeadingGhost::online_area_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestGetDeadingGhost.online_area_id)
  return online_area_id_;
}
inline void RequestGetDeadingGhost::set_online_area_id(::google::protobuf::uint32 value) {
  set_has_online_area_id();
  online_area_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestGetDeadingGhost.online_area_id)
}

// required uint32 bloodstain_id = 2;
inline bool RequestGetDeadingGhost::has_bloodstain_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestGetDeadingGhost::set_has_bloodstain_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestGetDeadingGhost::clear_has_bloodstain_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestGetDeadingGhost::clear_bloodstain_id() {
  bloodstain_id_ = 0u;
  clear_has_bloodstain_id();
}
inline ::google::protobuf::uint32 RequestGetDeadingGhost::bloodstain_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestGetDeadingGhost.bloodstain_id)
  return bloodstain_id_;
}
inline void RequestGetDeadingGhost::set_bloodstain_id(::google::protobuf::uint32 value) {
  set_has_bloodstain_id();
  bloodstain_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestGetDeadingGhost.bloodstain_id)
}

// -------------------------------------------------------------------

// RequestGetDeadingGhostResponse

// required uint32 online_area_id = 1;
inline bool RequestGetDeadingGhostResponse::has_online_area_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestGetDeadingGhostResponse::set_has_online_area_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestGetDeadingGhostResponse::clear_has_online_area_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestGetDeadingGhostResponse::clear_online_area_id() {
  online_area_id_ = 0u;
  clear_has_online_area_id();
}
inline ::google::protobuf::uint32 RequestGetDeadingGhostResponse::online_area_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestGetDeadingGhostResponse.online_area_id)
  return online_area_id_;
}
inline void RequestGetDeadingGhostResponse::set_online_area_id(::google::protobuf::uint32 value) {
  set_has_online_area_id();
  online_area_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestGetDeadingGhostResponse.online_area_id)
}

// required uint32 bloodstain_id = 2;
inline bool RequestGetDeadingGhostResponse::has_bloodstain_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestGetDeadingGhostResponse::set_has_bloodstain_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestGetDeadingGhostResponse::clear_has_bloodstain_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestGetDeadingGhostResponse::clear_bloodstain_id() {
  bloodstain_id_ = 0u;
  clear_has_bloodstain_id();
}
inline ::google::protobuf::uint32 RequestGetDeadingGhostResponse::bloodstain_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestGetDeadingGhostResponse.bloodstain_id)
  return bloodstain_id_;
}
inline void RequestGetDeadingGhostResponse::set_bloodstain_id(::google::protobuf::uint32 value) {
  set_has_bloodstain_id();
  bloodstain_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestGetDeadingGhostResponse.bloodstain_id)
}

// required bytes data = 3;
inline bool RequestGetDeadingGhostResponse::has_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestGetDeadingGhostResponse::set_has_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestGetDeadingGhostResponse::clear_has_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestGetDeadingGhostResponse::clear_data() {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& RequestGetDeadingGhostResponse::data() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestGetDeadingGhostResponse.data)
  return *data_;
}
inline void RequestGetDeadingGhostResponse::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestGetDeadingGhostResponse.data)
}
inline void RequestGetDeadingGhostResponse::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set_char:DS3_Frpg2RequestMessage.RequestGetDeadingGhostResponse.data)
}
inline void RequestGetDeadingGhostResponse::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DS3_Frpg2RequestMessage.RequestGetDeadingGhostResponse.data)
}
inline ::std::string* RequestGetDeadingGhostResponse::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.RequestGetDeadingGhostResponse.data)
  return data_;
}
inline ::std::string* RequestGetDeadingGhostResponse::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RequestGetDeadingGhostResponse::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.RequestGetDeadingGhostResponse.data)
}

// -------------------------------------------------------------------

// LogCommonInfo_1

// required uint32 unknown_1 = 34;
inline bool LogCommonInfo_1::has_unknown_1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogCommonInfo_1::set_has_unknown_1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LogCommonInfo_1::clear_has_unknown_1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LogCommonInfo_1::clear_unknown_1() {
  unknown_1_ = 0u;
  clear_has_unknown_1();
}
inline ::google::protobuf::uint32 LogCommonInfo_1::unknown_1() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.LogCommonInfo_1.unknown_1)
  return unknown_1_;
}
inline void LogCommonInfo_1::set_unknown_1(::google::protobuf::uint32 value) {
  set_has_unknown_1();
  unknown_1_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.LogCommonInfo_1.unknown_1)
}

// required uint32 unknown_2 = 37;
inline bool LogCommonInfo_1::has_unknown_2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LogCommonInfo_1::set_has_unknown_2() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LogCommonInfo_1::clear_has_unknown_2() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LogCommonInfo_1::clear_unknown_2() {
  unknown_2_ = 0u;
  clear_has_unknown_2();
}
inline ::google::protobuf::uint32 LogCommonInfo_1::unknown_2() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.LogCommonInfo_1.unknown_2)
  return unknown_2_;
}
inline void LogCommonInfo_1::set_unknown_2(::google::protobuf::uint32 value) {
  set_has_unknown_2();
  unknown_2_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.LogCommonInfo_1.unknown_2)
}

// -------------------------------------------------------------------

// LogCommonInfo

// required .DS3_Frpg2RequestMessage.LogCommonInfo_1 unknown_1 = 3;
inline bool LogCommonInfo::has_unknown_1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogCommonInfo::set_has_unknown_1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LogCommonInfo::clear_has_unknown_1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LogCommonInfo::clear_unknown_1() {
  if (unknown_1_ != NULL) unknown_1_->::DS3_Frpg2RequestMessage::LogCommonInfo_1::Clear();
  clear_has_unknown_1();
}
inline const ::DS3_Frpg2RequestMessage::LogCommonInfo_1& LogCommonInfo::unknown_1() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.LogCommonInfo.unknown_1)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return unknown_1_ != NULL ? *unknown_1_ : *default_instance().unknown_1_;
#else
  return unknown_1_ != NULL ? *unknown_1_ : *default_instance_->unknown_1_;
#endif
}
inline ::DS3_Frpg2RequestMessage::LogCommonInfo_1* LogCommonInfo::mutable_unknown_1() {
  set_has_unknown_1();
  if (unknown_1_ == NULL) unknown_1_ = new ::DS3_Frpg2RequestMessage::LogCommonInfo_1;
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.LogCommonInfo.unknown_1)
  return unknown_1_;
}
inline ::DS3_Frpg2RequestMessage::LogCommonInfo_1* LogCommonInfo::release_unknown_1() {
  clear_has_unknown_1();
  ::DS3_Frpg2RequestMessage::LogCommonInfo_1* temp = unknown_1_;
  unknown_1_ = NULL;
  return temp;
}
inline void LogCommonInfo::set_allocated_unknown_1(::DS3_Frpg2RequestMessage::LogCommonInfo_1* unknown_1) {
  delete unknown_1_;
  unknown_1_ = unknown_1;
  if (unknown_1) {
    set_has_unknown_1();
  } else {
    clear_has_unknown_1();
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.LogCommonInfo.unknown_1)
}

// required .DS3_Frpg2PlayerData.UnknownStruct1 unknown_2 = 7;
inline bool LogCommonInfo::has_unknown_2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LogCommonInfo::set_has_unknown_2() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LogCommonInfo::clear_has_unknown_2() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LogCommonInfo::clear_unknown_2() {
  if (unknown_2_ != NULL) unknown_2_->::DS3_Frpg2PlayerData::UnknownStruct1::Clear();
  clear_has_unknown_2();
}
inline const ::DS3_Frpg2PlayerData::UnknownStruct1& LogCommonInfo::unknown_2() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.LogCommonInfo.unknown_2)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return unknown_2_ != NULL ? *unknown_2_ : *default_instance().unknown_2_;
#else
  return unknown_2_ != NULL ? *unknown_2_ : *default_instance_->unknown_2_;
#endif
}
inline ::DS3_Frpg2PlayerData::UnknownStruct1* LogCommonInfo::mutable_unknown_2() {
  set_has_unknown_2();
  if (unknown_2_ == NULL) unknown_2_ = new ::DS3_Frpg2PlayerData::UnknownStruct1;
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.LogCommonInfo.unknown_2)
  return unknown_2_;
}
inline ::DS3_Frpg2PlayerData::UnknownStruct1* LogCommonInfo::release_unknown_2() {
  clear_has_unknown_2();
  ::DS3_Frpg2PlayerData::UnknownStruct1* temp = unknown_2_;
  unknown_2_ = NULL;
  return temp;
}
inline void LogCommonInfo::set_allocated_unknown_2(::DS3_Frpg2PlayerData::UnknownStruct1* unknown_2) {
  delete unknown_2_;
  unknown_2_ = unknown_2;
  if (unknown_2) {
    set_has_unknown_2();
  } else {
    clear_has_unknown_2();
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.LogCommonInfo.unknown_2)
}

// -------------------------------------------------------------------

// DomainLimitData

// required uint32 online_area_id = 1;
inline bool DomainLimitData::has_online_area_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DomainLimitData::set_has_online_area_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DomainLimitData::clear_has_online_area_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DomainLimitData::clear_online_area_id() {
  online_area_id_ = 0u;
  clear_has_online_area_id();
}
inline ::google::protobuf::uint32 DomainLimitData::online_area_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.DomainLimitData.online_area_id)
  return online_area_id_;
}
inline void DomainLimitData::set_online_area_id(::google::protobuf::uint32 value) {
  set_has_online_area_id();
  online_area_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.DomainLimitData.online_area_id)
}

// required uint32 max_items = 2;
inline bool DomainLimitData::has_max_items() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DomainLimitData::set_has_max_items() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DomainLimitData::clear_has_max_items() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DomainLimitData::clear_max_items() {
  max_items_ = 0u;
  clear_has_max_items();
}
inline ::google::protobuf::uint32 DomainLimitData::max_items() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.DomainLimitData.max_items)
  return max_items_;
}
inline void DomainLimitData::set_max_items(::google::protobuf::uint32 value) {
  set_has_max_items();
  max_items_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.DomainLimitData.max_items)
}

// -------------------------------------------------------------------

// KillerInfo

// required uint32 killer_player_id = 1;
inline bool KillerInfo::has_killer_player_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KillerInfo::set_has_killer_player_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KillerInfo::clear_has_killer_player_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KillerInfo::clear_killer_player_id() {
  killer_player_id_ = 0u;
  clear_has_killer_player_id();
}
inline ::google::protobuf::uint32 KillerInfo::killer_player_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.KillerInfo.killer_player_id)
  return killer_player_id_;
}
inline void KillerInfo::set_killer_player_id(::google::protobuf::uint32 value) {
  set_has_killer_player_id();
  killer_player_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.KillerInfo.killer_player_id)
}

// required uint32 unknown_2 = 2;
inline bool KillerInfo::has_unknown_2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KillerInfo::set_has_unknown_2() {
  _has_bits_[0] |= 0x00000002u;
}
inline void KillerInfo::clear_has_unknown_2() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void KillerInfo::clear_unknown_2() {
  unknown_2_ = 0u;
  clear_has_unknown_2();
}
inline ::google::protobuf::uint32 KillerInfo::unknown_2() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.KillerInfo.unknown_2)
  return unknown_2_;
}
inline void KillerInfo::set_unknown_2(::google::protobuf::uint32 value) {
  set_has_unknown_2();
  unknown_2_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.KillerInfo.unknown_2)
}

// required uint32 unknown_3 = 3;
inline bool KillerInfo::has_unknown_3() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void KillerInfo::set_has_unknown_3() {
  _has_bits_[0] |= 0x00000004u;
}
inline void KillerInfo::clear_has_unknown_3() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void KillerInfo::clear_unknown_3() {
  unknown_3_ = 0u;
  clear_has_unknown_3();
}
inline ::google::protobuf::uint32 KillerInfo::unknown_3() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.KillerInfo.unknown_3)
  return unknown_3_;
}
inline void KillerInfo::set_unknown_3(::google::protobuf::uint32 value) {
  set_has_unknown_3();
  unknown_3_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.KillerInfo.unknown_3)
}

// required uint32 unknown_4 = 4;
inline bool KillerInfo::has_unknown_4() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void KillerInfo::set_has_unknown_4() {
  _has_bits_[0] |= 0x00000008u;
}
inline void KillerInfo::clear_has_unknown_4() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void KillerInfo::clear_unknown_4() {
  unknown_4_ = 0u;
  clear_has_unknown_4();
}
inline ::google::protobuf::uint32 KillerInfo::unknown_4() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.KillerInfo.unknown_4)
  return unknown_4_;
}
inline void KillerInfo::set_unknown_4(::google::protobuf::uint32 value) {
  set_has_unknown_4();
  unknown_4_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.KillerInfo.unknown_4)
}

// -------------------------------------------------------------------

// KillEnemyInfo

// required uint32 enemy_type_id = 1;
inline bool KillEnemyInfo::has_enemy_type_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KillEnemyInfo::set_has_enemy_type_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KillEnemyInfo::clear_has_enemy_type_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KillEnemyInfo::clear_enemy_type_id() {
  enemy_type_id_ = 0u;
  clear_has_enemy_type_id();
}
inline ::google::protobuf::uint32 KillEnemyInfo::enemy_type_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.KillEnemyInfo.enemy_type_id)
  return enemy_type_id_;
}
inline void KillEnemyInfo::set_enemy_type_id(::google::protobuf::uint32 value) {
  set_has_enemy_type_id();
  enemy_type_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.KillEnemyInfo.enemy_type_id)
}

// required uint32 count = 2;
inline bool KillEnemyInfo::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KillEnemyInfo::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void KillEnemyInfo::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void KillEnemyInfo::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 KillEnemyInfo::count() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.KillEnemyInfo.count)
  return count_;
}
inline void KillEnemyInfo::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.KillEnemyInfo.count)
}

// -------------------------------------------------------------------

// PartyMemberInfo

// required uint32 player_id = 1;
inline bool PartyMemberInfo::has_player_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PartyMemberInfo::set_has_player_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PartyMemberInfo::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PartyMemberInfo::clear_player_id() {
  player_id_ = 0u;
  clear_has_player_id();
}
inline ::google::protobuf::uint32 PartyMemberInfo::player_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.PartyMemberInfo.player_id)
  return player_id_;
}
inline void PartyMemberInfo::set_player_id(::google::protobuf::uint32 value) {
  set_has_player_id();
  player_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.PartyMemberInfo.player_id)
}

// required uint32 char_id = 2;
inline bool PartyMemberInfo::has_char_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PartyMemberInfo::set_has_char_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PartyMemberInfo::clear_has_char_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PartyMemberInfo::clear_char_id() {
  char_id_ = 0u;
  clear_has_char_id();
}
inline ::google::protobuf::uint32 PartyMemberInfo::char_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.PartyMemberInfo.char_id)
  return char_id_;
}
inline void PartyMemberInfo::set_char_id(::google::protobuf::uint32 value) {
  set_has_char_id();
  char_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.PartyMemberInfo.char_id)
}

// required uint32 unknown_2 = 3;
inline bool PartyMemberInfo::has_unknown_2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PartyMemberInfo::set_has_unknown_2() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PartyMemberInfo::clear_has_unknown_2() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PartyMemberInfo::clear_unknown_2() {
  unknown_2_ = 0u;
  clear_has_unknown_2();
}
inline ::google::protobuf::uint32 PartyMemberInfo::unknown_2() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.PartyMemberInfo.unknown_2)
  return unknown_2_;
}
inline void PartyMemberInfo::set_unknown_2(::google::protobuf::uint32 value) {
  set_has_unknown_2();
  unknown_2_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.PartyMemberInfo.unknown_2)
}

// required uint32 unknown_4 = 4;
inline bool PartyMemberInfo::has_unknown_4() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PartyMemberInfo::set_has_unknown_4() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PartyMemberInfo::clear_has_unknown_4() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PartyMemberInfo::clear_unknown_4() {
  unknown_4_ = 0u;
  clear_has_unknown_4();
}
inline ::google::protobuf::uint32 PartyMemberInfo::unknown_4() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.PartyMemberInfo.unknown_4)
  return unknown_4_;
}
inline void PartyMemberInfo::set_unknown_4(::google::protobuf::uint32 value) {
  set_has_unknown_4();
  unknown_4_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.PartyMemberInfo.unknown_4)
}

// required uint32 unknown_5 = 5;
inline bool PartyMemberInfo::has_unknown_5() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PartyMemberInfo::set_has_unknown_5() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PartyMemberInfo::clear_has_unknown_5() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PartyMemberInfo::clear_unknown_5() {
  unknown_5_ = 0u;
  clear_has_unknown_5();
}
inline ::google::protobuf::uint32 PartyMemberInfo::unknown_5() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.PartyMemberInfo.unknown_5)
  return unknown_5_;
}
inline void PartyMemberInfo::set_unknown_5(::google::protobuf::uint32 value) {
  set_has_unknown_5();
  unknown_5_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.PartyMemberInfo.unknown_5)
}

// required uint32 unknown_6 = 6;
inline bool PartyMemberInfo::has_unknown_6() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PartyMemberInfo::set_has_unknown_6() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PartyMemberInfo::clear_has_unknown_6() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PartyMemberInfo::clear_unknown_6() {
  unknown_6_ = 0u;
  clear_has_unknown_6();
}
inline ::google::protobuf::uint32 PartyMemberInfo::unknown_6() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.PartyMemberInfo.unknown_6)
  return unknown_6_;
}
inline void PartyMemberInfo::set_unknown_6(::google::protobuf::uint32 value) {
  set_has_unknown_6();
  unknown_6_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.PartyMemberInfo.unknown_6)
}

// optional uint32 unknown_7 = 7;
inline bool PartyMemberInfo::has_unknown_7() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PartyMemberInfo::set_has_unknown_7() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PartyMemberInfo::clear_has_unknown_7() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PartyMemberInfo::clear_unknown_7() {
  unknown_7_ = 0u;
  clear_has_unknown_7();
}
inline ::google::protobuf::uint32 PartyMemberInfo::unknown_7() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.PartyMemberInfo.unknown_7)
  return unknown_7_;
}
inline void PartyMemberInfo::set_unknown_7(::google::protobuf::uint32 value) {
  set_has_unknown_7();
  unknown_7_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.PartyMemberInfo.unknown_7)
}

// -------------------------------------------------------------------

// RequestNotifyProtoBufLog

// required .DS3_Frpg2RequestMessage.LogType type = 1;
inline bool RequestNotifyProtoBufLog::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestNotifyProtoBufLog::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestNotifyProtoBufLog::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestNotifyProtoBufLog::clear_type() {
  type_ = 2020;
  clear_has_type();
}
inline ::DS3_Frpg2RequestMessage::LogType RequestNotifyProtoBufLog::type() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestNotifyProtoBufLog.type)
  return static_cast< ::DS3_Frpg2RequestMessage::LogType >(type_);
}
inline void RequestNotifyProtoBufLog::set_type(::DS3_Frpg2RequestMessage::LogType value) {
  assert(::DS3_Frpg2RequestMessage::LogType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestNotifyProtoBufLog.type)
}

// required bytes common = 2;
inline bool RequestNotifyProtoBufLog::has_common() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestNotifyProtoBufLog::set_has_common() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestNotifyProtoBufLog::clear_has_common() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestNotifyProtoBufLog::clear_common() {
  if (common_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    common_->clear();
  }
  clear_has_common();
}
inline const ::std::string& RequestNotifyProtoBufLog::common() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestNotifyProtoBufLog.common)
  return *common_;
}
inline void RequestNotifyProtoBufLog::set_common(const ::std::string& value) {
  set_has_common();
  if (common_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    common_ = new ::std::string;
  }
  common_->assign(value);
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestNotifyProtoBufLog.common)
}
inline void RequestNotifyProtoBufLog::set_common(const char* value) {
  set_has_common();
  if (common_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    common_ = new ::std::string;
  }
  common_->assign(value);
  // @@protoc_insertion_point(field_set_char:DS3_Frpg2RequestMessage.RequestNotifyProtoBufLog.common)
}
inline void RequestNotifyProtoBufLog::set_common(const void* value, size_t size) {
  set_has_common();
  if (common_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    common_ = new ::std::string;
  }
  common_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DS3_Frpg2RequestMessage.RequestNotifyProtoBufLog.common)
}
inline ::std::string* RequestNotifyProtoBufLog::mutable_common() {
  set_has_common();
  if (common_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    common_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.RequestNotifyProtoBufLog.common)
  return common_;
}
inline ::std::string* RequestNotifyProtoBufLog::release_common() {
  clear_has_common();
  if (common_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = common_;
    common_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RequestNotifyProtoBufLog::set_allocated_common(::std::string* common) {
  if (common_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete common_;
  }
  if (common) {
    set_has_common();
    common_ = common;
  } else {
    clear_has_common();
    common_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.RequestNotifyProtoBufLog.common)
}

// required bytes data = 3;
inline bool RequestNotifyProtoBufLog::has_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestNotifyProtoBufLog::set_has_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestNotifyProtoBufLog::clear_has_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestNotifyProtoBufLog::clear_data() {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& RequestNotifyProtoBufLog::data() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestNotifyProtoBufLog.data)
  return *data_;
}
inline void RequestNotifyProtoBufLog::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestNotifyProtoBufLog.data)
}
inline void RequestNotifyProtoBufLog::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set_char:DS3_Frpg2RequestMessage.RequestNotifyProtoBufLog.data)
}
inline void RequestNotifyProtoBufLog::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DS3_Frpg2RequestMessage.RequestNotifyProtoBufLog.data)
}
inline ::std::string* RequestNotifyProtoBufLog::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.RequestNotifyProtoBufLog.data)
  return data_;
}
inline ::std::string* RequestNotifyProtoBufLog::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RequestNotifyProtoBufLog::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.RequestNotifyProtoBufLog.data)
}

// -------------------------------------------------------------------

// RequestNotifyDie

// required string unknown_1 = 1;
inline bool RequestNotifyDie::has_unknown_1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestNotifyDie::set_has_unknown_1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestNotifyDie::clear_has_unknown_1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestNotifyDie::clear_unknown_1() {
  if (unknown_1_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unknown_1_->clear();
  }
  clear_has_unknown_1();
}
inline const ::std::string& RequestNotifyDie::unknown_1() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestNotifyDie.unknown_1)
  return *unknown_1_;
}
inline void RequestNotifyDie::set_unknown_1(const ::std::string& value) {
  set_has_unknown_1();
  if (unknown_1_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unknown_1_ = new ::std::string;
  }
  unknown_1_->assign(value);
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestNotifyDie.unknown_1)
}
inline void RequestNotifyDie::set_unknown_1(const char* value) {
  set_has_unknown_1();
  if (unknown_1_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unknown_1_ = new ::std::string;
  }
  unknown_1_->assign(value);
  // @@protoc_insertion_point(field_set_char:DS3_Frpg2RequestMessage.RequestNotifyDie.unknown_1)
}
inline void RequestNotifyDie::set_unknown_1(const char* value, size_t size) {
  set_has_unknown_1();
  if (unknown_1_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unknown_1_ = new ::std::string;
  }
  unknown_1_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DS3_Frpg2RequestMessage.RequestNotifyDie.unknown_1)
}
inline ::std::string* RequestNotifyDie::mutable_unknown_1() {
  set_has_unknown_1();
  if (unknown_1_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unknown_1_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.RequestNotifyDie.unknown_1)
  return unknown_1_;
}
inline ::std::string* RequestNotifyDie::release_unknown_1() {
  clear_has_unknown_1();
  if (unknown_1_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = unknown_1_;
    unknown_1_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RequestNotifyDie::set_allocated_unknown_1(::std::string* unknown_1) {
  if (unknown_1_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete unknown_1_;
  }
  if (unknown_1) {
    set_has_unknown_1();
    unknown_1_ = unknown_1;
  } else {
    clear_has_unknown_1();
    unknown_1_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.RequestNotifyDie.unknown_1)
}

// required uint32 map_id = 2;
inline bool RequestNotifyDie::has_map_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestNotifyDie::set_has_map_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestNotifyDie::clear_has_map_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestNotifyDie::clear_map_id() {
  map_id_ = 0u;
  clear_has_map_id();
}
inline ::google::protobuf::uint32 RequestNotifyDie::map_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestNotifyDie.map_id)
  return map_id_;
}
inline void RequestNotifyDie::set_map_id(::google::protobuf::uint32 value) {
  set_has_map_id();
  map_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestNotifyDie.map_id)
}

// required .DS3_Frpg2PlayerData.Vector location = 3;
inline bool RequestNotifyDie::has_location() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestNotifyDie::set_has_location() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestNotifyDie::clear_has_location() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestNotifyDie::clear_location() {
  if (location_ != NULL) location_->::DS3_Frpg2PlayerData::Vector::Clear();
  clear_has_location();
}
inline const ::DS3_Frpg2PlayerData::Vector& RequestNotifyDie::location() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestNotifyDie.location)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return location_ != NULL ? *location_ : *default_instance().location_;
#else
  return location_ != NULL ? *location_ : *default_instance_->location_;
#endif
}
inline ::DS3_Frpg2PlayerData::Vector* RequestNotifyDie::mutable_location() {
  set_has_location();
  if (location_ == NULL) location_ = new ::DS3_Frpg2PlayerData::Vector;
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.RequestNotifyDie.location)
  return location_;
}
inline ::DS3_Frpg2PlayerData::Vector* RequestNotifyDie::release_location() {
  clear_has_location();
  ::DS3_Frpg2PlayerData::Vector* temp = location_;
  location_ = NULL;
  return temp;
}
inline void RequestNotifyDie::set_allocated_location(::DS3_Frpg2PlayerData::Vector* location) {
  delete location_;
  location_ = location;
  if (location) {
    set_has_location();
  } else {
    clear_has_location();
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.RequestNotifyDie.location)
}

// required .DS3_Frpg2RequestMessage.CauseOfDeath cause_of_death = 4;
inline bool RequestNotifyDie::has_cause_of_death() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestNotifyDie::set_has_cause_of_death() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestNotifyDie::clear_has_cause_of_death() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestNotifyDie::clear_cause_of_death() {
  cause_of_death_ = 0;
  clear_has_cause_of_death();
}
inline ::DS3_Frpg2RequestMessage::CauseOfDeath RequestNotifyDie::cause_of_death() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestNotifyDie.cause_of_death)
  return static_cast< ::DS3_Frpg2RequestMessage::CauseOfDeath >(cause_of_death_);
}
inline void RequestNotifyDie::set_cause_of_death(::DS3_Frpg2RequestMessage::CauseOfDeath value) {
  assert(::DS3_Frpg2RequestMessage::CauseOfDeath_IsValid(value));
  set_has_cause_of_death();
  cause_of_death_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestNotifyDie.cause_of_death)
}

// required uint32 souls_dropped = 5;
inline bool RequestNotifyDie::has_souls_dropped() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RequestNotifyDie::set_has_souls_dropped() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RequestNotifyDie::clear_has_souls_dropped() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RequestNotifyDie::clear_souls_dropped() {
  souls_dropped_ = 0u;
  clear_has_souls_dropped();
}
inline ::google::protobuf::uint32 RequestNotifyDie::souls_dropped() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestNotifyDie.souls_dropped)
  return souls_dropped_;
}
inline void RequestNotifyDie::set_souls_dropped(::google::protobuf::uint32 value) {
  set_has_souls_dropped();
  souls_dropped_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestNotifyDie.souls_dropped)
}

// required uint32 souls_lost = 6;
inline bool RequestNotifyDie::has_souls_lost() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RequestNotifyDie::set_has_souls_lost() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RequestNotifyDie::clear_has_souls_lost() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RequestNotifyDie::clear_souls_lost() {
  souls_lost_ = 0u;
  clear_has_souls_lost();
}
inline ::google::protobuf::uint32 RequestNotifyDie::souls_lost() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestNotifyDie.souls_lost)
  return souls_lost_;
}
inline void RequestNotifyDie::set_souls_lost(::google::protobuf::uint32 value) {
  set_has_souls_lost();
  souls_lost_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestNotifyDie.souls_lost)
}

// required uint32 actor_id = 7;
inline bool RequestNotifyDie::has_actor_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RequestNotifyDie::set_has_actor_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RequestNotifyDie::clear_has_actor_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RequestNotifyDie::clear_actor_id() {
  actor_id_ = 0u;
  clear_has_actor_id();
}
inline ::google::protobuf::uint32 RequestNotifyDie::actor_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestNotifyDie.actor_id)
  return actor_id_;
}
inline void RequestNotifyDie::set_actor_id(::google::protobuf::uint32 value) {
  set_has_actor_id();
  actor_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestNotifyDie.actor_id)
}

// required .DS3_Frpg2RequestMessage.KillerInfo killer_info = 8;
inline bool RequestNotifyDie::has_killer_info() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RequestNotifyDie::set_has_killer_info() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RequestNotifyDie::clear_has_killer_info() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RequestNotifyDie::clear_killer_info() {
  if (killer_info_ != NULL) killer_info_->::DS3_Frpg2RequestMessage::KillerInfo::Clear();
  clear_has_killer_info();
}
inline const ::DS3_Frpg2RequestMessage::KillerInfo& RequestNotifyDie::killer_info() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestNotifyDie.killer_info)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return killer_info_ != NULL ? *killer_info_ : *default_instance().killer_info_;
#else
  return killer_info_ != NULL ? *killer_info_ : *default_instance_->killer_info_;
#endif
}
inline ::DS3_Frpg2RequestMessage::KillerInfo* RequestNotifyDie::mutable_killer_info() {
  set_has_killer_info();
  if (killer_info_ == NULL) killer_info_ = new ::DS3_Frpg2RequestMessage::KillerInfo;
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.RequestNotifyDie.killer_info)
  return killer_info_;
}
inline ::DS3_Frpg2RequestMessage::KillerInfo* RequestNotifyDie::release_killer_info() {
  clear_has_killer_info();
  ::DS3_Frpg2RequestMessage::KillerInfo* temp = killer_info_;
  killer_info_ = NULL;
  return temp;
}
inline void RequestNotifyDie::set_allocated_killer_info(::DS3_Frpg2RequestMessage::KillerInfo* killer_info) {
  delete killer_info_;
  killer_info_ = killer_info;
  if (killer_info) {
    set_has_killer_info();
  } else {
    clear_has_killer_info();
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.RequestNotifyDie.killer_info)
}

// -------------------------------------------------------------------

// RequestNotifyKillEnemy

// required .DS3_Frpg2RequestMessage.LogCommonInfo info = 1;
inline bool RequestNotifyKillEnemy::has_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestNotifyKillEnemy::set_has_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestNotifyKillEnemy::clear_has_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestNotifyKillEnemy::clear_info() {
  if (info_ != NULL) info_->::DS3_Frpg2RequestMessage::LogCommonInfo::Clear();
  clear_has_info();
}
inline const ::DS3_Frpg2RequestMessage::LogCommonInfo& RequestNotifyKillEnemy::info() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestNotifyKillEnemy.info)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return info_ != NULL ? *info_ : *default_instance().info_;
#else
  return info_ != NULL ? *info_ : *default_instance_->info_;
#endif
}
inline ::DS3_Frpg2RequestMessage::LogCommonInfo* RequestNotifyKillEnemy::mutable_info() {
  set_has_info();
  if (info_ == NULL) info_ = new ::DS3_Frpg2RequestMessage::LogCommonInfo;
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.RequestNotifyKillEnemy.info)
  return info_;
}
inline ::DS3_Frpg2RequestMessage::LogCommonInfo* RequestNotifyKillEnemy::release_info() {
  clear_has_info();
  ::DS3_Frpg2RequestMessage::LogCommonInfo* temp = info_;
  info_ = NULL;
  return temp;
}
inline void RequestNotifyKillEnemy::set_allocated_info(::DS3_Frpg2RequestMessage::LogCommonInfo* info) {
  delete info_;
  info_ = info;
  if (info) {
    set_has_info();
  } else {
    clear_has_info();
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.RequestNotifyKillEnemy.info)
}

// repeated .DS3_Frpg2RequestMessage.KillEnemyInfo enemys = 2;
inline int RequestNotifyKillEnemy::enemys_size() const {
  return enemys_.size();
}
inline void RequestNotifyKillEnemy::clear_enemys() {
  enemys_.Clear();
}
inline const ::DS3_Frpg2RequestMessage::KillEnemyInfo& RequestNotifyKillEnemy::enemys(int index) const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestNotifyKillEnemy.enemys)
  return enemys_.Get(index);
}
inline ::DS3_Frpg2RequestMessage::KillEnemyInfo* RequestNotifyKillEnemy::mutable_enemys(int index) {
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.RequestNotifyKillEnemy.enemys)
  return enemys_.Mutable(index);
}
inline ::DS3_Frpg2RequestMessage::KillEnemyInfo* RequestNotifyKillEnemy::add_enemys() {
  // @@protoc_insertion_point(field_add:DS3_Frpg2RequestMessage.RequestNotifyKillEnemy.enemys)
  return enemys_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::KillEnemyInfo >&
RequestNotifyKillEnemy::enemys() const {
  // @@protoc_insertion_point(field_list:DS3_Frpg2RequestMessage.RequestNotifyKillEnemy.enemys)
  return enemys_;
}
inline ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::KillEnemyInfo >*
RequestNotifyKillEnemy::mutable_enemys() {
  // @@protoc_insertion_point(field_mutable_list:DS3_Frpg2RequestMessage.RequestNotifyKillEnemy.enemys)
  return &enemys_;
}

// required uint32 map_id = 3;
inline bool RequestNotifyKillEnemy::has_map_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestNotifyKillEnemy::set_has_map_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestNotifyKillEnemy::clear_has_map_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestNotifyKillEnemy::clear_map_id() {
  map_id_ = 0u;
  clear_has_map_id();
}
inline ::google::protobuf::uint32 RequestNotifyKillEnemy::map_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestNotifyKillEnemy.map_id)
  return map_id_;
}
inline void RequestNotifyKillEnemy::set_map_id(::google::protobuf::uint32 value) {
  set_has_map_id();
  map_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestNotifyKillEnemy.map_id)
}

// required .DS3_Frpg2PlayerData.Vector location = 4;
inline bool RequestNotifyKillEnemy::has_location() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestNotifyKillEnemy::set_has_location() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestNotifyKillEnemy::clear_has_location() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestNotifyKillEnemy::clear_location() {
  if (location_ != NULL) location_->::DS3_Frpg2PlayerData::Vector::Clear();
  clear_has_location();
}
inline const ::DS3_Frpg2PlayerData::Vector& RequestNotifyKillEnemy::location() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestNotifyKillEnemy.location)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return location_ != NULL ? *location_ : *default_instance().location_;
#else
  return location_ != NULL ? *location_ : *default_instance_->location_;
#endif
}
inline ::DS3_Frpg2PlayerData::Vector* RequestNotifyKillEnemy::mutable_location() {
  set_has_location();
  if (location_ == NULL) location_ = new ::DS3_Frpg2PlayerData::Vector;
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.RequestNotifyKillEnemy.location)
  return location_;
}
inline ::DS3_Frpg2PlayerData::Vector* RequestNotifyKillEnemy::release_location() {
  clear_has_location();
  ::DS3_Frpg2PlayerData::Vector* temp = location_;
  location_ = NULL;
  return temp;
}
inline void RequestNotifyKillEnemy::set_allocated_location(::DS3_Frpg2PlayerData::Vector* location) {
  delete location_;
  location_ = location;
  if (location) {
    set_has_location();
  } else {
    clear_has_location();
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.RequestNotifyKillEnemy.location)
}

// -------------------------------------------------------------------

// RequestNotifyKillBoss

// required string unknown_1 = 1;
inline bool RequestNotifyKillBoss::has_unknown_1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestNotifyKillBoss::set_has_unknown_1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestNotifyKillBoss::clear_has_unknown_1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestNotifyKillBoss::clear_unknown_1() {
  if (unknown_1_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unknown_1_->clear();
  }
  clear_has_unknown_1();
}
inline const ::std::string& RequestNotifyKillBoss::unknown_1() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestNotifyKillBoss.unknown_1)
  return *unknown_1_;
}
inline void RequestNotifyKillBoss::set_unknown_1(const ::std::string& value) {
  set_has_unknown_1();
  if (unknown_1_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unknown_1_ = new ::std::string;
  }
  unknown_1_->assign(value);
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestNotifyKillBoss.unknown_1)
}
inline void RequestNotifyKillBoss::set_unknown_1(const char* value) {
  set_has_unknown_1();
  if (unknown_1_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unknown_1_ = new ::std::string;
  }
  unknown_1_->assign(value);
  // @@protoc_insertion_point(field_set_char:DS3_Frpg2RequestMessage.RequestNotifyKillBoss.unknown_1)
}
inline void RequestNotifyKillBoss::set_unknown_1(const char* value, size_t size) {
  set_has_unknown_1();
  if (unknown_1_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unknown_1_ = new ::std::string;
  }
  unknown_1_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DS3_Frpg2RequestMessage.RequestNotifyKillBoss.unknown_1)
}
inline ::std::string* RequestNotifyKillBoss::mutable_unknown_1() {
  set_has_unknown_1();
  if (unknown_1_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unknown_1_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.RequestNotifyKillBoss.unknown_1)
  return unknown_1_;
}
inline ::std::string* RequestNotifyKillBoss::release_unknown_1() {
  clear_has_unknown_1();
  if (unknown_1_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = unknown_1_;
    unknown_1_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RequestNotifyKillBoss::set_allocated_unknown_1(::std::string* unknown_1) {
  if (unknown_1_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete unknown_1_;
  }
  if (unknown_1) {
    set_has_unknown_1();
    unknown_1_ = unknown_1;
  } else {
    clear_has_unknown_1();
    unknown_1_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.RequestNotifyKillBoss.unknown_1)
}

// required uint32 boss_id = 2;
inline bool RequestNotifyKillBoss::has_boss_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestNotifyKillBoss::set_has_boss_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestNotifyKillBoss::clear_has_boss_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestNotifyKillBoss::clear_boss_id() {
  boss_id_ = 0u;
  clear_has_boss_id();
}
inline ::google::protobuf::uint32 RequestNotifyKillBoss::boss_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestNotifyKillBoss.boss_id)
  return boss_id_;
}
inline void RequestNotifyKillBoss::set_boss_id(::google::protobuf::uint32 value) {
  set_has_boss_id();
  boss_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestNotifyKillBoss.boss_id)
}

// required uint32 in_coop = 3;
inline bool RequestNotifyKillBoss::has_in_coop() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestNotifyKillBoss::set_has_in_coop() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestNotifyKillBoss::clear_has_in_coop() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestNotifyKillBoss::clear_in_coop() {
  in_coop_ = 0u;
  clear_has_in_coop();
}
inline ::google::protobuf::uint32 RequestNotifyKillBoss::in_coop() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestNotifyKillBoss.in_coop)
  return in_coop_;
}
inline void RequestNotifyKillBoss::set_in_coop(::google::protobuf::uint32 value) {
  set_has_in_coop();
  in_coop_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestNotifyKillBoss.in_coop)
}

// required uint32 boss_died = 4;
inline bool RequestNotifyKillBoss::has_boss_died() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestNotifyKillBoss::set_has_boss_died() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestNotifyKillBoss::clear_has_boss_died() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestNotifyKillBoss::clear_boss_died() {
  boss_died_ = 0u;
  clear_has_boss_died();
}
inline ::google::protobuf::uint32 RequestNotifyKillBoss::boss_died() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestNotifyKillBoss.boss_died)
  return boss_died_;
}
inline void RequestNotifyKillBoss::set_boss_died(::google::protobuf::uint32 value) {
  set_has_boss_died();
  boss_died_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestNotifyKillBoss.boss_died)
}

// required uint32 cooperator_count = 5;
inline bool RequestNotifyKillBoss::has_cooperator_count() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RequestNotifyKillBoss::set_has_cooperator_count() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RequestNotifyKillBoss::clear_has_cooperator_count() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RequestNotifyKillBoss::clear_cooperator_count() {
  cooperator_count_ = 0u;
  clear_has_cooperator_count();
}
inline ::google::protobuf::uint32 RequestNotifyKillBoss::cooperator_count() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestNotifyKillBoss.cooperator_count)
  return cooperator_count_;
}
inline void RequestNotifyKillBoss::set_cooperator_count(::google::protobuf::uint32 value) {
  set_has_cooperator_count();
  cooperator_count_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestNotifyKillBoss.cooperator_count)
}

// required uint32 fight_duration = 6;
inline bool RequestNotifyKillBoss::has_fight_duration() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RequestNotifyKillBoss::set_has_fight_duration() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RequestNotifyKillBoss::clear_has_fight_duration() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RequestNotifyKillBoss::clear_fight_duration() {
  fight_duration_ = 0u;
  clear_has_fight_duration();
}
inline ::google::protobuf::uint32 RequestNotifyKillBoss::fight_duration() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestNotifyKillBoss.fight_duration)
  return fight_duration_;
}
inline void RequestNotifyKillBoss::set_fight_duration(::google::protobuf::uint32 value) {
  set_has_fight_duration();
  fight_duration_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestNotifyKillBoss.fight_duration)
}

// required uint32 map_id = 8;
inline bool RequestNotifyKillBoss::has_map_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RequestNotifyKillBoss::set_has_map_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RequestNotifyKillBoss::clear_has_map_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RequestNotifyKillBoss::clear_map_id() {
  map_id_ = 0u;
  clear_has_map_id();
}
inline ::google::protobuf::uint32 RequestNotifyKillBoss::map_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestNotifyKillBoss.map_id)
  return map_id_;
}
inline void RequestNotifyKillBoss::set_map_id(::google::protobuf::uint32 value) {
  set_has_map_id();
  map_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestNotifyKillBoss.map_id)
}

// -------------------------------------------------------------------

// RequestNotifyJoinMultiplay

// required .DS3_Frpg2PlayerData.AllStatus all_status = 1;
inline bool RequestNotifyJoinMultiplay::has_all_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestNotifyJoinMultiplay::set_has_all_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestNotifyJoinMultiplay::clear_has_all_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestNotifyJoinMultiplay::clear_all_status() {
  if (all_status_ != NULL) all_status_->::DS3_Frpg2PlayerData::AllStatus::Clear();
  clear_has_all_status();
}
inline const ::DS3_Frpg2PlayerData::AllStatus& RequestNotifyJoinMultiplay::all_status() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestNotifyJoinMultiplay.all_status)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return all_status_ != NULL ? *all_status_ : *default_instance().all_status_;
#else
  return all_status_ != NULL ? *all_status_ : *default_instance_->all_status_;
#endif
}
inline ::DS3_Frpg2PlayerData::AllStatus* RequestNotifyJoinMultiplay::mutable_all_status() {
  set_has_all_status();
  if (all_status_ == NULL) all_status_ = new ::DS3_Frpg2PlayerData::AllStatus;
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.RequestNotifyJoinMultiplay.all_status)
  return all_status_;
}
inline ::DS3_Frpg2PlayerData::AllStatus* RequestNotifyJoinMultiplay::release_all_status() {
  clear_has_all_status();
  ::DS3_Frpg2PlayerData::AllStatus* temp = all_status_;
  all_status_ = NULL;
  return temp;
}
inline void RequestNotifyJoinMultiplay::set_allocated_all_status(::DS3_Frpg2PlayerData::AllStatus* all_status) {
  delete all_status_;
  all_status_ = all_status;
  if (all_status) {
    set_has_all_status();
  } else {
    clear_has_all_status();
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.RequestNotifyJoinMultiplay.all_status)
}

// required uint32 map_id = 2;
inline bool RequestNotifyJoinMultiplay::has_map_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestNotifyJoinMultiplay::set_has_map_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestNotifyJoinMultiplay::clear_has_map_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestNotifyJoinMultiplay::clear_map_id() {
  map_id_ = 0u;
  clear_has_map_id();
}
inline ::google::protobuf::uint32 RequestNotifyJoinMultiplay::map_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestNotifyJoinMultiplay.map_id)
  return map_id_;
}
inline void RequestNotifyJoinMultiplay::set_map_id(::google::protobuf::uint32 value) {
  set_has_map_id();
  map_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestNotifyJoinMultiplay.map_id)
}

// required uint32 online_area_id = 3;
inline bool RequestNotifyJoinMultiplay::has_online_area_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestNotifyJoinMultiplay::set_has_online_area_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestNotifyJoinMultiplay::clear_has_online_area_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestNotifyJoinMultiplay::clear_online_area_id() {
  online_area_id_ = 0u;
  clear_has_online_area_id();
}
inline ::google::protobuf::uint32 RequestNotifyJoinMultiplay::online_area_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestNotifyJoinMultiplay.online_area_id)
  return online_area_id_;
}
inline void RequestNotifyJoinMultiplay::set_online_area_id(::google::protobuf::uint32 value) {
  set_has_online_area_id();
  online_area_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestNotifyJoinMultiplay.online_area_id)
}

// required uint32 unknown_2 = 4;
inline bool RequestNotifyJoinMultiplay::has_unknown_2() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestNotifyJoinMultiplay::set_has_unknown_2() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestNotifyJoinMultiplay::clear_has_unknown_2() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestNotifyJoinMultiplay::clear_unknown_2() {
  unknown_2_ = 0u;
  clear_has_unknown_2();
}
inline ::google::protobuf::uint32 RequestNotifyJoinMultiplay::unknown_2() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestNotifyJoinMultiplay.unknown_2)
  return unknown_2_;
}
inline void RequestNotifyJoinMultiplay::set_unknown_2(::google::protobuf::uint32 value) {
  set_has_unknown_2();
  unknown_2_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestNotifyJoinMultiplay.unknown_2)
}

// required uint32 unknown_3 = 5;
inline bool RequestNotifyJoinMultiplay::has_unknown_3() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RequestNotifyJoinMultiplay::set_has_unknown_3() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RequestNotifyJoinMultiplay::clear_has_unknown_3() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RequestNotifyJoinMultiplay::clear_unknown_3() {
  unknown_3_ = 0u;
  clear_has_unknown_3();
}
inline ::google::protobuf::uint32 RequestNotifyJoinMultiplay::unknown_3() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestNotifyJoinMultiplay.unknown_3)
  return unknown_3_;
}
inline void RequestNotifyJoinMultiplay::set_unknown_3(::google::protobuf::uint32 value) {
  set_has_unknown_3();
  unknown_3_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestNotifyJoinMultiplay.unknown_3)
}

// repeated .DS3_Frpg2RequestMessage.PartyMemberInfo party_member_info = 6;
inline int RequestNotifyJoinMultiplay::party_member_info_size() const {
  return party_member_info_.size();
}
inline void RequestNotifyJoinMultiplay::clear_party_member_info() {
  party_member_info_.Clear();
}
inline const ::DS3_Frpg2RequestMessage::PartyMemberInfo& RequestNotifyJoinMultiplay::party_member_info(int index) const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestNotifyJoinMultiplay.party_member_info)
  return party_member_info_.Get(index);
}
inline ::DS3_Frpg2RequestMessage::PartyMemberInfo* RequestNotifyJoinMultiplay::mutable_party_member_info(int index) {
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.RequestNotifyJoinMultiplay.party_member_info)
  return party_member_info_.Mutable(index);
}
inline ::DS3_Frpg2RequestMessage::PartyMemberInfo* RequestNotifyJoinMultiplay::add_party_member_info() {
  // @@protoc_insertion_point(field_add:DS3_Frpg2RequestMessage.RequestNotifyJoinMultiplay.party_member_info)
  return party_member_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::PartyMemberInfo >&
RequestNotifyJoinMultiplay::party_member_info() const {
  // @@protoc_insertion_point(field_list:DS3_Frpg2RequestMessage.RequestNotifyJoinMultiplay.party_member_info)
  return party_member_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::PartyMemberInfo >*
RequestNotifyJoinMultiplay::mutable_party_member_info() {
  // @@protoc_insertion_point(field_mutable_list:DS3_Frpg2RequestMessage.RequestNotifyJoinMultiplay.party_member_info)
  return &party_member_info_;
}

// -------------------------------------------------------------------

// RequestNotifyLeaveMultiplay

// required .DS3_Frpg2PlayerData.AllStatus all_status = 1;
inline bool RequestNotifyLeaveMultiplay::has_all_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestNotifyLeaveMultiplay::set_has_all_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestNotifyLeaveMultiplay::clear_has_all_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestNotifyLeaveMultiplay::clear_all_status() {
  if (all_status_ != NULL) all_status_->::DS3_Frpg2PlayerData::AllStatus::Clear();
  clear_has_all_status();
}
inline const ::DS3_Frpg2PlayerData::AllStatus& RequestNotifyLeaveMultiplay::all_status() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestNotifyLeaveMultiplay.all_status)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return all_status_ != NULL ? *all_status_ : *default_instance().all_status_;
#else
  return all_status_ != NULL ? *all_status_ : *default_instance_->all_status_;
#endif
}
inline ::DS3_Frpg2PlayerData::AllStatus* RequestNotifyLeaveMultiplay::mutable_all_status() {
  set_has_all_status();
  if (all_status_ == NULL) all_status_ = new ::DS3_Frpg2PlayerData::AllStatus;
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.RequestNotifyLeaveMultiplay.all_status)
  return all_status_;
}
inline ::DS3_Frpg2PlayerData::AllStatus* RequestNotifyLeaveMultiplay::release_all_status() {
  clear_has_all_status();
  ::DS3_Frpg2PlayerData::AllStatus* temp = all_status_;
  all_status_ = NULL;
  return temp;
}
inline void RequestNotifyLeaveMultiplay::set_allocated_all_status(::DS3_Frpg2PlayerData::AllStatus* all_status) {
  delete all_status_;
  all_status_ = all_status;
  if (all_status) {
    set_has_all_status();
  } else {
    clear_has_all_status();
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.RequestNotifyLeaveMultiplay.all_status)
}

// required uint32 map_id = 2;
inline bool RequestNotifyLeaveMultiplay::has_map_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestNotifyLeaveMultiplay::set_has_map_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestNotifyLeaveMultiplay::clear_has_map_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestNotifyLeaveMultiplay::clear_map_id() {
  map_id_ = 0u;
  clear_has_map_id();
}
inline ::google::protobuf::uint32 RequestNotifyLeaveMultiplay::map_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestNotifyLeaveMultiplay.map_id)
  return map_id_;
}
inline void RequestNotifyLeaveMultiplay::set_map_id(::google::protobuf::uint32 value) {
  set_has_map_id();
  map_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestNotifyLeaveMultiplay.map_id)
}

// required uint32 online_area_id = 3;
inline bool RequestNotifyLeaveMultiplay::has_online_area_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestNotifyLeaveMultiplay::set_has_online_area_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestNotifyLeaveMultiplay::clear_has_online_area_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestNotifyLeaveMultiplay::clear_online_area_id() {
  online_area_id_ = 0u;
  clear_has_online_area_id();
}
inline ::google::protobuf::uint32 RequestNotifyLeaveMultiplay::online_area_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestNotifyLeaveMultiplay.online_area_id)
  return online_area_id_;
}
inline void RequestNotifyLeaveMultiplay::set_online_area_id(::google::protobuf::uint32 value) {
  set_has_online_area_id();
  online_area_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestNotifyLeaveMultiplay.online_area_id)
}

// required uint32 unknown_2 = 4;
inline bool RequestNotifyLeaveMultiplay::has_unknown_2() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestNotifyLeaveMultiplay::set_has_unknown_2() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestNotifyLeaveMultiplay::clear_has_unknown_2() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestNotifyLeaveMultiplay::clear_unknown_2() {
  unknown_2_ = 0u;
  clear_has_unknown_2();
}
inline ::google::protobuf::uint32 RequestNotifyLeaveMultiplay::unknown_2() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestNotifyLeaveMultiplay.unknown_2)
  return unknown_2_;
}
inline void RequestNotifyLeaveMultiplay::set_unknown_2(::google::protobuf::uint32 value) {
  set_has_unknown_2();
  unknown_2_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestNotifyLeaveMultiplay.unknown_2)
}

// required uint32 unknown_3 = 5;
inline bool RequestNotifyLeaveMultiplay::has_unknown_3() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RequestNotifyLeaveMultiplay::set_has_unknown_3() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RequestNotifyLeaveMultiplay::clear_has_unknown_3() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RequestNotifyLeaveMultiplay::clear_unknown_3() {
  unknown_3_ = 0u;
  clear_has_unknown_3();
}
inline ::google::protobuf::uint32 RequestNotifyLeaveMultiplay::unknown_3() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestNotifyLeaveMultiplay.unknown_3)
  return unknown_3_;
}
inline void RequestNotifyLeaveMultiplay::set_unknown_3(::google::protobuf::uint32 value) {
  set_has_unknown_3();
  unknown_3_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestNotifyLeaveMultiplay.unknown_3)
}

// required uint32 unknown_4 = 6;
inline bool RequestNotifyLeaveMultiplay::has_unknown_4() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RequestNotifyLeaveMultiplay::set_has_unknown_4() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RequestNotifyLeaveMultiplay::clear_has_unknown_4() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RequestNotifyLeaveMultiplay::clear_unknown_4() {
  unknown_4_ = 0u;
  clear_has_unknown_4();
}
inline ::google::protobuf::uint32 RequestNotifyLeaveMultiplay::unknown_4() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestNotifyLeaveMultiplay.unknown_4)
  return unknown_4_;
}
inline void RequestNotifyLeaveMultiplay::set_unknown_4(::google::protobuf::uint32 value) {
  set_has_unknown_4();
  unknown_4_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestNotifyLeaveMultiplay.unknown_4)
}

// repeated .DS3_Frpg2RequestMessage.PartyMemberInfo party_member_info = 7;
inline int RequestNotifyLeaveMultiplay::party_member_info_size() const {
  return party_member_info_.size();
}
inline void RequestNotifyLeaveMultiplay::clear_party_member_info() {
  party_member_info_.Clear();
}
inline const ::DS3_Frpg2RequestMessage::PartyMemberInfo& RequestNotifyLeaveMultiplay::party_member_info(int index) const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestNotifyLeaveMultiplay.party_member_info)
  return party_member_info_.Get(index);
}
inline ::DS3_Frpg2RequestMessage::PartyMemberInfo* RequestNotifyLeaveMultiplay::mutable_party_member_info(int index) {
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.RequestNotifyLeaveMultiplay.party_member_info)
  return party_member_info_.Mutable(index);
}
inline ::DS3_Frpg2RequestMessage::PartyMemberInfo* RequestNotifyLeaveMultiplay::add_party_member_info() {
  // @@protoc_insertion_point(field_add:DS3_Frpg2RequestMessage.RequestNotifyLeaveMultiplay.party_member_info)
  return party_member_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::PartyMemberInfo >&
RequestNotifyLeaveMultiplay::party_member_info() const {
  // @@protoc_insertion_point(field_list:DS3_Frpg2RequestMessage.RequestNotifyLeaveMultiplay.party_member_info)
  return party_member_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::PartyMemberInfo >*
RequestNotifyLeaveMultiplay::mutable_party_member_info() {
  // @@protoc_insertion_point(field_mutable_list:DS3_Frpg2RequestMessage.RequestNotifyLeaveMultiplay.party_member_info)
  return &party_member_info_;
}

// -------------------------------------------------------------------

// RequestNotifyCreateSignResult

// required .DS3_Frpg2PlayerData.AllStatus all_status = 1;
inline bool RequestNotifyCreateSignResult::has_all_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestNotifyCreateSignResult::set_has_all_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestNotifyCreateSignResult::clear_has_all_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestNotifyCreateSignResult::clear_all_status() {
  if (all_status_ != NULL) all_status_->::DS3_Frpg2PlayerData::AllStatus::Clear();
  clear_has_all_status();
}
inline const ::DS3_Frpg2PlayerData::AllStatus& RequestNotifyCreateSignResult::all_status() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestNotifyCreateSignResult.all_status)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return all_status_ != NULL ? *all_status_ : *default_instance().all_status_;
#else
  return all_status_ != NULL ? *all_status_ : *default_instance_->all_status_;
#endif
}
inline ::DS3_Frpg2PlayerData::AllStatus* RequestNotifyCreateSignResult::mutable_all_status() {
  set_has_all_status();
  if (all_status_ == NULL) all_status_ = new ::DS3_Frpg2PlayerData::AllStatus;
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.RequestNotifyCreateSignResult.all_status)
  return all_status_;
}
inline ::DS3_Frpg2PlayerData::AllStatus* RequestNotifyCreateSignResult::release_all_status() {
  clear_has_all_status();
  ::DS3_Frpg2PlayerData::AllStatus* temp = all_status_;
  all_status_ = NULL;
  return temp;
}
inline void RequestNotifyCreateSignResult::set_allocated_all_status(::DS3_Frpg2PlayerData::AllStatus* all_status) {
  delete all_status_;
  all_status_ = all_status;
  if (all_status) {
    set_has_all_status();
  } else {
    clear_has_all_status();
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.RequestNotifyCreateSignResult.all_status)
}

// required uint32 map_id = 2;
inline bool RequestNotifyCreateSignResult::has_map_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestNotifyCreateSignResult::set_has_map_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestNotifyCreateSignResult::clear_has_map_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestNotifyCreateSignResult::clear_map_id() {
  map_id_ = 0u;
  clear_has_map_id();
}
inline ::google::protobuf::uint32 RequestNotifyCreateSignResult::map_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestNotifyCreateSignResult.map_id)
  return map_id_;
}
inline void RequestNotifyCreateSignResult::set_map_id(::google::protobuf::uint32 value) {
  set_has_map_id();
  map_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestNotifyCreateSignResult.map_id)
}

// required uint32 online_area_id = 3;
inline bool RequestNotifyCreateSignResult::has_online_area_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestNotifyCreateSignResult::set_has_online_area_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestNotifyCreateSignResult::clear_has_online_area_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestNotifyCreateSignResult::clear_online_area_id() {
  online_area_id_ = 0u;
  clear_has_online_area_id();
}
inline ::google::protobuf::uint32 RequestNotifyCreateSignResult::online_area_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestNotifyCreateSignResult.online_area_id)
  return online_area_id_;
}
inline void RequestNotifyCreateSignResult::set_online_area_id(::google::protobuf::uint32 value) {
  set_has_online_area_id();
  online_area_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestNotifyCreateSignResult.online_area_id)
}

// required .DS3_Frpg2PlayerData.Vector location = 4;
inline bool RequestNotifyCreateSignResult::has_location() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestNotifyCreateSignResult::set_has_location() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestNotifyCreateSignResult::clear_has_location() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestNotifyCreateSignResult::clear_location() {
  if (location_ != NULL) location_->::DS3_Frpg2PlayerData::Vector::Clear();
  clear_has_location();
}
inline const ::DS3_Frpg2PlayerData::Vector& RequestNotifyCreateSignResult::location() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestNotifyCreateSignResult.location)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return location_ != NULL ? *location_ : *default_instance().location_;
#else
  return location_ != NULL ? *location_ : *default_instance_->location_;
#endif
}
inline ::DS3_Frpg2PlayerData::Vector* RequestNotifyCreateSignResult::mutable_location() {
  set_has_location();
  if (location_ == NULL) location_ = new ::DS3_Frpg2PlayerData::Vector;
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.RequestNotifyCreateSignResult.location)
  return location_;
}
inline ::DS3_Frpg2PlayerData::Vector* RequestNotifyCreateSignResult::release_location() {
  clear_has_location();
  ::DS3_Frpg2PlayerData::Vector* temp = location_;
  location_ = NULL;
  return temp;
}
inline void RequestNotifyCreateSignResult::set_allocated_location(::DS3_Frpg2PlayerData::Vector* location) {
  delete location_;
  location_ = location;
  if (location) {
    set_has_location();
  } else {
    clear_has_location();
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.RequestNotifyCreateSignResult.location)
}

// required uint32 sign_unique_number = 5;
inline bool RequestNotifyCreateSignResult::has_sign_unique_number() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RequestNotifyCreateSignResult::set_has_sign_unique_number() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RequestNotifyCreateSignResult::clear_has_sign_unique_number() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RequestNotifyCreateSignResult::clear_sign_unique_number() {
  sign_unique_number_ = 0u;
  clear_has_sign_unique_number();
}
inline ::google::protobuf::uint32 RequestNotifyCreateSignResult::sign_unique_number() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestNotifyCreateSignResult.sign_unique_number)
  return sign_unique_number_;
}
inline void RequestNotifyCreateSignResult::set_sign_unique_number(::google::protobuf::uint32 value) {
  set_has_sign_unique_number();
  sign_unique_number_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestNotifyCreateSignResult.sign_unique_number)
}

// required uint32 unknown_2 = 6;
inline bool RequestNotifyCreateSignResult::has_unknown_2() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RequestNotifyCreateSignResult::set_has_unknown_2() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RequestNotifyCreateSignResult::clear_has_unknown_2() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RequestNotifyCreateSignResult::clear_unknown_2() {
  unknown_2_ = 0u;
  clear_has_unknown_2();
}
inline ::google::protobuf::uint32 RequestNotifyCreateSignResult::unknown_2() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestNotifyCreateSignResult.unknown_2)
  return unknown_2_;
}
inline void RequestNotifyCreateSignResult::set_unknown_2(::google::protobuf::uint32 value) {
  set_has_unknown_2();
  unknown_2_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestNotifyCreateSignResult.unknown_2)
}

// required uint32 unknown_3 = 7;
inline bool RequestNotifyCreateSignResult::has_unknown_3() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RequestNotifyCreateSignResult::set_has_unknown_3() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RequestNotifyCreateSignResult::clear_has_unknown_3() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RequestNotifyCreateSignResult::clear_unknown_3() {
  unknown_3_ = 0u;
  clear_has_unknown_3();
}
inline ::google::protobuf::uint32 RequestNotifyCreateSignResult::unknown_3() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestNotifyCreateSignResult.unknown_3)
  return unknown_3_;
}
inline void RequestNotifyCreateSignResult::set_unknown_3(::google::protobuf::uint32 value) {
  set_has_unknown_3();
  unknown_3_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestNotifyCreateSignResult.unknown_3)
}

// required uint32 unknown_4 = 8;
inline bool RequestNotifyCreateSignResult::has_unknown_4() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RequestNotifyCreateSignResult::set_has_unknown_4() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RequestNotifyCreateSignResult::clear_has_unknown_4() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RequestNotifyCreateSignResult::clear_unknown_4() {
  unknown_4_ = 0u;
  clear_has_unknown_4();
}
inline ::google::protobuf::uint32 RequestNotifyCreateSignResult::unknown_4() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestNotifyCreateSignResult.unknown_4)
  return unknown_4_;
}
inline void RequestNotifyCreateSignResult::set_unknown_4(::google::protobuf::uint32 value) {
  set_has_unknown_4();
  unknown_4_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestNotifyCreateSignResult.unknown_4)
}

// -------------------------------------------------------------------

// RequestNotifySummonSignResult

// required string unknown_1 = 1;
inline bool RequestNotifySummonSignResult::has_unknown_1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestNotifySummonSignResult::set_has_unknown_1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestNotifySummonSignResult::clear_has_unknown_1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestNotifySummonSignResult::clear_unknown_1() {
  if (unknown_1_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unknown_1_->clear();
  }
  clear_has_unknown_1();
}
inline const ::std::string& RequestNotifySummonSignResult::unknown_1() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestNotifySummonSignResult.unknown_1)
  return *unknown_1_;
}
inline void RequestNotifySummonSignResult::set_unknown_1(const ::std::string& value) {
  set_has_unknown_1();
  if (unknown_1_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unknown_1_ = new ::std::string;
  }
  unknown_1_->assign(value);
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestNotifySummonSignResult.unknown_1)
}
inline void RequestNotifySummonSignResult::set_unknown_1(const char* value) {
  set_has_unknown_1();
  if (unknown_1_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unknown_1_ = new ::std::string;
  }
  unknown_1_->assign(value);
  // @@protoc_insertion_point(field_set_char:DS3_Frpg2RequestMessage.RequestNotifySummonSignResult.unknown_1)
}
inline void RequestNotifySummonSignResult::set_unknown_1(const char* value, size_t size) {
  set_has_unknown_1();
  if (unknown_1_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unknown_1_ = new ::std::string;
  }
  unknown_1_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DS3_Frpg2RequestMessage.RequestNotifySummonSignResult.unknown_1)
}
inline ::std::string* RequestNotifySummonSignResult::mutable_unknown_1() {
  set_has_unknown_1();
  if (unknown_1_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unknown_1_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.RequestNotifySummonSignResult.unknown_1)
  return unknown_1_;
}
inline ::std::string* RequestNotifySummonSignResult::release_unknown_1() {
  clear_has_unknown_1();
  if (unknown_1_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = unknown_1_;
    unknown_1_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RequestNotifySummonSignResult::set_allocated_unknown_1(::std::string* unknown_1) {
  if (unknown_1_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete unknown_1_;
  }
  if (unknown_1) {
    set_has_unknown_1();
    unknown_1_ = unknown_1;
  } else {
    clear_has_unknown_1();
    unknown_1_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.RequestNotifySummonSignResult.unknown_1)
}

// required uint32 map_id = 2;
inline bool RequestNotifySummonSignResult::has_map_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestNotifySummonSignResult::set_has_map_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestNotifySummonSignResult::clear_has_map_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestNotifySummonSignResult::clear_map_id() {
  map_id_ = 0u;
  clear_has_map_id();
}
inline ::google::protobuf::uint32 RequestNotifySummonSignResult::map_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestNotifySummonSignResult.map_id)
  return map_id_;
}
inline void RequestNotifySummonSignResult::set_map_id(::google::protobuf::uint32 value) {
  set_has_map_id();
  map_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestNotifySummonSignResult.map_id)
}

// required uint32 online_area_id = 3;
inline bool RequestNotifySummonSignResult::has_online_area_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestNotifySummonSignResult::set_has_online_area_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestNotifySummonSignResult::clear_has_online_area_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestNotifySummonSignResult::clear_online_area_id() {
  online_area_id_ = 0u;
  clear_has_online_area_id();
}
inline ::google::protobuf::uint32 RequestNotifySummonSignResult::online_area_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestNotifySummonSignResult.online_area_id)
  return online_area_id_;
}
inline void RequestNotifySummonSignResult::set_online_area_id(::google::protobuf::uint32 value) {
  set_has_online_area_id();
  online_area_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestNotifySummonSignResult.online_area_id)
}

// required .DS3_Frpg2PlayerData.Vector location = 4;
inline bool RequestNotifySummonSignResult::has_location() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestNotifySummonSignResult::set_has_location() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestNotifySummonSignResult::clear_has_location() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestNotifySummonSignResult::clear_location() {
  if (location_ != NULL) location_->::DS3_Frpg2PlayerData::Vector::Clear();
  clear_has_location();
}
inline const ::DS3_Frpg2PlayerData::Vector& RequestNotifySummonSignResult::location() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestNotifySummonSignResult.location)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return location_ != NULL ? *location_ : *default_instance().location_;
#else
  return location_ != NULL ? *location_ : *default_instance_->location_;
#endif
}
inline ::DS3_Frpg2PlayerData::Vector* RequestNotifySummonSignResult::mutable_location() {
  set_has_location();
  if (location_ == NULL) location_ = new ::DS3_Frpg2PlayerData::Vector;
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.RequestNotifySummonSignResult.location)
  return location_;
}
inline ::DS3_Frpg2PlayerData::Vector* RequestNotifySummonSignResult::release_location() {
  clear_has_location();
  ::DS3_Frpg2PlayerData::Vector* temp = location_;
  location_ = NULL;
  return temp;
}
inline void RequestNotifySummonSignResult::set_allocated_location(::DS3_Frpg2PlayerData::Vector* location) {
  delete location_;
  location_ = location;
  if (location) {
    set_has_location();
  } else {
    clear_has_location();
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.RequestNotifySummonSignResult.location)
}

// required .DS3_Frpg2RequestMessage.SignInfo sign_info = 5;
inline bool RequestNotifySummonSignResult::has_sign_info() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RequestNotifySummonSignResult::set_has_sign_info() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RequestNotifySummonSignResult::clear_has_sign_info() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RequestNotifySummonSignResult::clear_sign_info() {
  if (sign_info_ != NULL) sign_info_->::DS3_Frpg2RequestMessage::SignInfo::Clear();
  clear_has_sign_info();
}
inline const ::DS3_Frpg2RequestMessage::SignInfo& RequestNotifySummonSignResult::sign_info() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestNotifySummonSignResult.sign_info)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return sign_info_ != NULL ? *sign_info_ : *default_instance().sign_info_;
#else
  return sign_info_ != NULL ? *sign_info_ : *default_instance_->sign_info_;
#endif
}
inline ::DS3_Frpg2RequestMessage::SignInfo* RequestNotifySummonSignResult::mutable_sign_info() {
  set_has_sign_info();
  if (sign_info_ == NULL) sign_info_ = new ::DS3_Frpg2RequestMessage::SignInfo;
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.RequestNotifySummonSignResult.sign_info)
  return sign_info_;
}
inline ::DS3_Frpg2RequestMessage::SignInfo* RequestNotifySummonSignResult::release_sign_info() {
  clear_has_sign_info();
  ::DS3_Frpg2RequestMessage::SignInfo* temp = sign_info_;
  sign_info_ = NULL;
  return temp;
}
inline void RequestNotifySummonSignResult::set_allocated_sign_info(::DS3_Frpg2RequestMessage::SignInfo* sign_info) {
  delete sign_info_;
  sign_info_ = sign_info;
  if (sign_info) {
    set_has_sign_info();
  } else {
    clear_has_sign_info();
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.RequestNotifySummonSignResult.sign_info)
}

// required uint32 unknown_6 = 6;
inline bool RequestNotifySummonSignResult::has_unknown_6() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RequestNotifySummonSignResult::set_has_unknown_6() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RequestNotifySummonSignResult::clear_has_unknown_6() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RequestNotifySummonSignResult::clear_unknown_6() {
  unknown_6_ = 0u;
  clear_has_unknown_6();
}
inline ::google::protobuf::uint32 RequestNotifySummonSignResult::unknown_6() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestNotifySummonSignResult.unknown_6)
  return unknown_6_;
}
inline void RequestNotifySummonSignResult::set_unknown_6(::google::protobuf::uint32 value) {
  set_has_unknown_6();
  unknown_6_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestNotifySummonSignResult.unknown_6)
}

// required uint32 unknown_7 = 7;
inline bool RequestNotifySummonSignResult::has_unknown_7() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RequestNotifySummonSignResult::set_has_unknown_7() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RequestNotifySummonSignResult::clear_has_unknown_7() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RequestNotifySummonSignResult::clear_unknown_7() {
  unknown_7_ = 0u;
  clear_has_unknown_7();
}
inline ::google::protobuf::uint32 RequestNotifySummonSignResult::unknown_7() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestNotifySummonSignResult.unknown_7)
  return unknown_7_;
}
inline void RequestNotifySummonSignResult::set_unknown_7(::google::protobuf::uint32 value) {
  set_has_unknown_7();
  unknown_7_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestNotifySummonSignResult.unknown_7)
}

// required uint32 unknown_8 = 8;
inline bool RequestNotifySummonSignResult::has_unknown_8() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RequestNotifySummonSignResult::set_has_unknown_8() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RequestNotifySummonSignResult::clear_has_unknown_8() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RequestNotifySummonSignResult::clear_unknown_8() {
  unknown_8_ = 0u;
  clear_has_unknown_8();
}
inline ::google::protobuf::uint32 RequestNotifySummonSignResult::unknown_8() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestNotifySummonSignResult.unknown_8)
  return unknown_8_;
}
inline void RequestNotifySummonSignResult::set_unknown_8(::google::protobuf::uint32 value) {
  set_has_unknown_8();
  unknown_8_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestNotifySummonSignResult.unknown_8)
}

// -------------------------------------------------------------------

// RequestNotifyBreakInResult

// -------------------------------------------------------------------

// RequestNotifyDisconnectSession

// -------------------------------------------------------------------

// RequestNotifyDisconnectSessionResponse

// -------------------------------------------------------------------

// RequestNotifyRegisterCharacter

// required .DS3_Frpg2PlayerData.AllStatus status = 1;
inline bool RequestNotifyRegisterCharacter::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestNotifyRegisterCharacter::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestNotifyRegisterCharacter::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestNotifyRegisterCharacter::clear_status() {
  if (status_ != NULL) status_->::DS3_Frpg2PlayerData::AllStatus::Clear();
  clear_has_status();
}
inline const ::DS3_Frpg2PlayerData::AllStatus& RequestNotifyRegisterCharacter::status() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestNotifyRegisterCharacter.status)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return status_ != NULL ? *status_ : *default_instance().status_;
#else
  return status_ != NULL ? *status_ : *default_instance_->status_;
#endif
}
inline ::DS3_Frpg2PlayerData::AllStatus* RequestNotifyRegisterCharacter::mutable_status() {
  set_has_status();
  if (status_ == NULL) status_ = new ::DS3_Frpg2PlayerData::AllStatus;
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.RequestNotifyRegisterCharacter.status)
  return status_;
}
inline ::DS3_Frpg2PlayerData::AllStatus* RequestNotifyRegisterCharacter::release_status() {
  clear_has_status();
  ::DS3_Frpg2PlayerData::AllStatus* temp = status_;
  status_ = NULL;
  return temp;
}
inline void RequestNotifyRegisterCharacter::set_allocated_status(::DS3_Frpg2PlayerData::AllStatus* status) {
  delete status_;
  status_ = status;
  if (status) {
    set_has_status();
  } else {
    clear_has_status();
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.RequestNotifyRegisterCharacter.status)
}

// required uint32 unknown_2 = 2;
inline bool RequestNotifyRegisterCharacter::has_unknown_2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestNotifyRegisterCharacter::set_has_unknown_2() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestNotifyRegisterCharacter::clear_has_unknown_2() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestNotifyRegisterCharacter::clear_unknown_2() {
  unknown_2_ = 0u;
  clear_has_unknown_2();
}
inline ::google::protobuf::uint32 RequestNotifyRegisterCharacter::unknown_2() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestNotifyRegisterCharacter.unknown_2)
  return unknown_2_;
}
inline void RequestNotifyRegisterCharacter::set_unknown_2(::google::protobuf::uint32 value) {
  set_has_unknown_2();
  unknown_2_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestNotifyRegisterCharacter.unknown_2)
}

// required uint32 unknown_3 = 3;
inline bool RequestNotifyRegisterCharacter::has_unknown_3() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestNotifyRegisterCharacter::set_has_unknown_3() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestNotifyRegisterCharacter::clear_has_unknown_3() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestNotifyRegisterCharacter::clear_unknown_3() {
  unknown_3_ = 0u;
  clear_has_unknown_3();
}
inline ::google::protobuf::uint32 RequestNotifyRegisterCharacter::unknown_3() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestNotifyRegisterCharacter.unknown_3)
  return unknown_3_;
}
inline void RequestNotifyRegisterCharacter::set_unknown_3(::google::protobuf::uint32 value) {
  set_has_unknown_3();
  unknown_3_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestNotifyRegisterCharacter.unknown_3)
}

// required uint32 unknown_4 = 4;
inline bool RequestNotifyRegisterCharacter::has_unknown_4() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestNotifyRegisterCharacter::set_has_unknown_4() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestNotifyRegisterCharacter::clear_has_unknown_4() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestNotifyRegisterCharacter::clear_unknown_4() {
  unknown_4_ = 0u;
  clear_has_unknown_4();
}
inline ::google::protobuf::uint32 RequestNotifyRegisterCharacter::unknown_4() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestNotifyRegisterCharacter.unknown_4)
  return unknown_4_;
}
inline void RequestNotifyRegisterCharacter::set_unknown_4(::google::protobuf::uint32 value) {
  set_has_unknown_4();
  unknown_4_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestNotifyRegisterCharacter.unknown_4)
}

// required uint32 unknown_5 = 5;
inline bool RequestNotifyRegisterCharacter::has_unknown_5() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RequestNotifyRegisterCharacter::set_has_unknown_5() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RequestNotifyRegisterCharacter::clear_has_unknown_5() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RequestNotifyRegisterCharacter::clear_unknown_5() {
  unknown_5_ = 0u;
  clear_has_unknown_5();
}
inline ::google::protobuf::uint32 RequestNotifyRegisterCharacter::unknown_5() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestNotifyRegisterCharacter.unknown_5)
  return unknown_5_;
}
inline void RequestNotifyRegisterCharacter::set_unknown_5(::google::protobuf::uint32 value) {
  set_has_unknown_5();
  unknown_5_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestNotifyRegisterCharacter.unknown_5)
}

// required uint32 unknown_6 = 6;
inline bool RequestNotifyRegisterCharacter::has_unknown_6() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RequestNotifyRegisterCharacter::set_has_unknown_6() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RequestNotifyRegisterCharacter::clear_has_unknown_6() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RequestNotifyRegisterCharacter::clear_unknown_6() {
  unknown_6_ = 0u;
  clear_has_unknown_6();
}
inline ::google::protobuf::uint32 RequestNotifyRegisterCharacter::unknown_6() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestNotifyRegisterCharacter.unknown_6)
  return unknown_6_;
}
inline void RequestNotifyRegisterCharacter::set_unknown_6(::google::protobuf::uint32 value) {
  set_has_unknown_6();
  unknown_6_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestNotifyRegisterCharacter.unknown_6)
}

// required uint32 unknown_7 = 7;
inline bool RequestNotifyRegisterCharacter::has_unknown_7() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RequestNotifyRegisterCharacter::set_has_unknown_7() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RequestNotifyRegisterCharacter::clear_has_unknown_7() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RequestNotifyRegisterCharacter::clear_unknown_7() {
  unknown_7_ = 0u;
  clear_has_unknown_7();
}
inline ::google::protobuf::uint32 RequestNotifyRegisterCharacter::unknown_7() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestNotifyRegisterCharacter.unknown_7)
  return unknown_7_;
}
inline void RequestNotifyRegisterCharacter::set_unknown_7(::google::protobuf::uint32 value) {
  set_has_unknown_7();
  unknown_7_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestNotifyRegisterCharacter.unknown_7)
}

// required uint32 unknown_8 = 8;
inline bool RequestNotifyRegisterCharacter::has_unknown_8() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RequestNotifyRegisterCharacter::set_has_unknown_8() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RequestNotifyRegisterCharacter::clear_has_unknown_8() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RequestNotifyRegisterCharacter::clear_unknown_8() {
  unknown_8_ = 0u;
  clear_has_unknown_8();
}
inline ::google::protobuf::uint32 RequestNotifyRegisterCharacter::unknown_8() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestNotifyRegisterCharacter.unknown_8)
  return unknown_8_;
}
inline void RequestNotifyRegisterCharacter::set_unknown_8(::google::protobuf::uint32 value) {
  set_has_unknown_8();
  unknown_8_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestNotifyRegisterCharacter.unknown_8)
}

// required uint32 unknown_9 = 9;
inline bool RequestNotifyRegisterCharacter::has_unknown_9() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RequestNotifyRegisterCharacter::set_has_unknown_9() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RequestNotifyRegisterCharacter::clear_has_unknown_9() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RequestNotifyRegisterCharacter::clear_unknown_9() {
  unknown_9_ = 0u;
  clear_has_unknown_9();
}
inline ::google::protobuf::uint32 RequestNotifyRegisterCharacter::unknown_9() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestNotifyRegisterCharacter.unknown_9)
  return unknown_9_;
}
inline void RequestNotifyRegisterCharacter::set_unknown_9(::google::protobuf::uint32 value) {
  set_has_unknown_9();
  unknown_9_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestNotifyRegisterCharacter.unknown_9)
}

// required uint32 unknown_10 = 10;
inline bool RequestNotifyRegisterCharacter::has_unknown_10() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RequestNotifyRegisterCharacter::set_has_unknown_10() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RequestNotifyRegisterCharacter::clear_has_unknown_10() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RequestNotifyRegisterCharacter::clear_unknown_10() {
  unknown_10_ = 0u;
  clear_has_unknown_10();
}
inline ::google::protobuf::uint32 RequestNotifyRegisterCharacter::unknown_10() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestNotifyRegisterCharacter.unknown_10)
  return unknown_10_;
}
inline void RequestNotifyRegisterCharacter::set_unknown_10(::google::protobuf::uint32 value) {
  set_has_unknown_10();
  unknown_10_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestNotifyRegisterCharacter.unknown_10)
}

// -------------------------------------------------------------------

// SummonSignMessage

// required uint32 player_id = 1;
inline bool SummonSignMessage::has_player_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SummonSignMessage::set_has_player_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SummonSignMessage::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SummonSignMessage::clear_player_id() {
  player_id_ = 0u;
  clear_has_player_id();
}
inline ::google::protobuf::uint32 SummonSignMessage::player_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.SummonSignMessage.player_id)
  return player_id_;
}
inline void SummonSignMessage::set_player_id(::google::protobuf::uint32 value) {
  set_has_player_id();
  player_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.SummonSignMessage.player_id)
}

// required string steam_id = 2;
inline bool SummonSignMessage::has_steam_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SummonSignMessage::set_has_steam_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SummonSignMessage::clear_has_steam_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SummonSignMessage::clear_steam_id() {
  if (steam_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    steam_id_->clear();
  }
  clear_has_steam_id();
}
inline const ::std::string& SummonSignMessage::steam_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.SummonSignMessage.steam_id)
  return *steam_id_;
}
inline void SummonSignMessage::set_steam_id(const ::std::string& value) {
  set_has_steam_id();
  if (steam_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    steam_id_ = new ::std::string;
  }
  steam_id_->assign(value);
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.SummonSignMessage.steam_id)
}
inline void SummonSignMessage::set_steam_id(const char* value) {
  set_has_steam_id();
  if (steam_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    steam_id_ = new ::std::string;
  }
  steam_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:DS3_Frpg2RequestMessage.SummonSignMessage.steam_id)
}
inline void SummonSignMessage::set_steam_id(const char* value, size_t size) {
  set_has_steam_id();
  if (steam_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    steam_id_ = new ::std::string;
  }
  steam_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DS3_Frpg2RequestMessage.SummonSignMessage.steam_id)
}
inline ::std::string* SummonSignMessage::mutable_steam_id() {
  set_has_steam_id();
  if (steam_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    steam_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.SummonSignMessage.steam_id)
  return steam_id_;
}
inline ::std::string* SummonSignMessage::release_steam_id() {
  clear_has_steam_id();
  if (steam_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = steam_id_;
    steam_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SummonSignMessage::set_allocated_steam_id(::std::string* steam_id) {
  if (steam_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete steam_id_;
  }
  if (steam_id) {
    set_has_steam_id();
    steam_id_ = steam_id;
  } else {
    clear_has_steam_id();
    steam_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.SummonSignMessage.steam_id)
}

// required .DS3_Frpg2RequestMessage.SignInfo sign_info = 3;
inline bool SummonSignMessage::has_sign_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SummonSignMessage::set_has_sign_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SummonSignMessage::clear_has_sign_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SummonSignMessage::clear_sign_info() {
  if (sign_info_ != NULL) sign_info_->::DS3_Frpg2RequestMessage::SignInfo::Clear();
  clear_has_sign_info();
}
inline const ::DS3_Frpg2RequestMessage::SignInfo& SummonSignMessage::sign_info() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.SummonSignMessage.sign_info)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return sign_info_ != NULL ? *sign_info_ : *default_instance().sign_info_;
#else
  return sign_info_ != NULL ? *sign_info_ : *default_instance_->sign_info_;
#endif
}
inline ::DS3_Frpg2RequestMessage::SignInfo* SummonSignMessage::mutable_sign_info() {
  set_has_sign_info();
  if (sign_info_ == NULL) sign_info_ = new ::DS3_Frpg2RequestMessage::SignInfo;
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.SummonSignMessage.sign_info)
  return sign_info_;
}
inline ::DS3_Frpg2RequestMessage::SignInfo* SummonSignMessage::release_sign_info() {
  clear_has_sign_info();
  ::DS3_Frpg2RequestMessage::SignInfo* temp = sign_info_;
  sign_info_ = NULL;
  return temp;
}
inline void SummonSignMessage::set_allocated_sign_info(::DS3_Frpg2RequestMessage::SignInfo* sign_info) {
  delete sign_info_;
  sign_info_ = sign_info;
  if (sign_info) {
    set_has_sign_info();
  } else {
    clear_has_sign_info();
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.SummonSignMessage.sign_info)
}

// required bytes player_struct = 4;
inline bool SummonSignMessage::has_player_struct() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SummonSignMessage::set_has_player_struct() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SummonSignMessage::clear_has_player_struct() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SummonSignMessage::clear_player_struct() {
  if (player_struct_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    player_struct_->clear();
  }
  clear_has_player_struct();
}
inline const ::std::string& SummonSignMessage::player_struct() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.SummonSignMessage.player_struct)
  return *player_struct_;
}
inline void SummonSignMessage::set_player_struct(const ::std::string& value) {
  set_has_player_struct();
  if (player_struct_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    player_struct_ = new ::std::string;
  }
  player_struct_->assign(value);
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.SummonSignMessage.player_struct)
}
inline void SummonSignMessage::set_player_struct(const char* value) {
  set_has_player_struct();
  if (player_struct_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    player_struct_ = new ::std::string;
  }
  player_struct_->assign(value);
  // @@protoc_insertion_point(field_set_char:DS3_Frpg2RequestMessage.SummonSignMessage.player_struct)
}
inline void SummonSignMessage::set_player_struct(const void* value, size_t size) {
  set_has_player_struct();
  if (player_struct_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    player_struct_ = new ::std::string;
  }
  player_struct_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DS3_Frpg2RequestMessage.SummonSignMessage.player_struct)
}
inline ::std::string* SummonSignMessage::mutable_player_struct() {
  set_has_player_struct();
  if (player_struct_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    player_struct_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.SummonSignMessage.player_struct)
  return player_struct_;
}
inline ::std::string* SummonSignMessage::release_player_struct() {
  clear_has_player_struct();
  if (player_struct_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = player_struct_;
    player_struct_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SummonSignMessage::set_allocated_player_struct(::std::string* player_struct) {
  if (player_struct_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete player_struct_;
  }
  if (player_struct) {
    set_has_player_struct();
    player_struct_ = player_struct;
  } else {
    clear_has_player_struct();
    player_struct_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.SummonSignMessage.player_struct)
}

// -------------------------------------------------------------------

// RemoveSignMessage

// required uint32 player_id = 1;
inline bool RemoveSignMessage::has_player_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RemoveSignMessage::set_has_player_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RemoveSignMessage::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RemoveSignMessage::clear_player_id() {
  player_id_ = 0u;
  clear_has_player_id();
}
inline ::google::protobuf::uint32 RemoveSignMessage::player_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RemoveSignMessage.player_id)
  return player_id_;
}
inline void RemoveSignMessage::set_player_id(::google::protobuf::uint32 value) {
  set_has_player_id();
  player_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RemoveSignMessage.player_id)
}

// required uint32 sign_id = 2;
inline bool RemoveSignMessage::has_sign_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RemoveSignMessage::set_has_sign_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RemoveSignMessage::clear_has_sign_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RemoveSignMessage::clear_sign_id() {
  sign_id_ = 0u;
  clear_has_sign_id();
}
inline ::google::protobuf::uint32 RemoveSignMessage::sign_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RemoveSignMessage.sign_id)
  return sign_id_;
}
inline void RemoveSignMessage::set_sign_id(::google::protobuf::uint32 value) {
  set_has_sign_id();
  sign_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RemoveSignMessage.sign_id)
}

// -------------------------------------------------------------------

// RejectSignMessage

// required uint32 sign_id = 1;
inline bool RejectSignMessage::has_sign_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RejectSignMessage::set_has_sign_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RejectSignMessage::clear_has_sign_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RejectSignMessage::clear_sign_id() {
  sign_id_ = 0u;
  clear_has_sign_id();
}
inline ::google::protobuf::uint32 RejectSignMessage::sign_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RejectSignMessage.sign_id)
  return sign_id_;
}
inline void RejectSignMessage::set_sign_id(::google::protobuf::uint32 value) {
  set_has_sign_id();
  sign_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RejectSignMessage.sign_id)
}

// required uint32 unknown_2 = 2;
inline bool RejectSignMessage::has_unknown_2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RejectSignMessage::set_has_unknown_2() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RejectSignMessage::clear_has_unknown_2() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RejectSignMessage::clear_unknown_2() {
  unknown_2_ = 0u;
  clear_has_unknown_2();
}
inline ::google::protobuf::uint32 RejectSignMessage::unknown_2() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RejectSignMessage.unknown_2)
  return unknown_2_;
}
inline void RejectSignMessage::set_unknown_2(::google::protobuf::uint32 value) {
  set_has_unknown_2();
  unknown_2_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RejectSignMessage.unknown_2)
}

// -------------------------------------------------------------------

// CachedSign

// -------------------------------------------------------------------

// GetSignResult

// repeated .DS3_Frpg2RequestMessage.SignInfo sign_info_without_data = 1;
inline int GetSignResult::sign_info_without_data_size() const {
  return sign_info_without_data_.size();
}
inline void GetSignResult::clear_sign_info_without_data() {
  sign_info_without_data_.Clear();
}
inline const ::DS3_Frpg2RequestMessage::SignInfo& GetSignResult::sign_info_without_data(int index) const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.GetSignResult.sign_info_without_data)
  return sign_info_without_data_.Get(index);
}
inline ::DS3_Frpg2RequestMessage::SignInfo* GetSignResult::mutable_sign_info_without_data(int index) {
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.GetSignResult.sign_info_without_data)
  return sign_info_without_data_.Mutable(index);
}
inline ::DS3_Frpg2RequestMessage::SignInfo* GetSignResult::add_sign_info_without_data() {
  // @@protoc_insertion_point(field_add:DS3_Frpg2RequestMessage.GetSignResult.sign_info_without_data)
  return sign_info_without_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::SignInfo >&
GetSignResult::sign_info_without_data() const {
  // @@protoc_insertion_point(field_list:DS3_Frpg2RequestMessage.GetSignResult.sign_info_without_data)
  return sign_info_without_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::SignInfo >*
GetSignResult::mutable_sign_info_without_data() {
  // @@protoc_insertion_point(field_mutable_list:DS3_Frpg2RequestMessage.GetSignResult.sign_info_without_data)
  return &sign_info_without_data_;
}

// repeated .DS3_Frpg2RequestMessage.SignData sign_data = 2;
inline int GetSignResult::sign_data_size() const {
  return sign_data_.size();
}
inline void GetSignResult::clear_sign_data() {
  sign_data_.Clear();
}
inline const ::DS3_Frpg2RequestMessage::SignData& GetSignResult::sign_data(int index) const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.GetSignResult.sign_data)
  return sign_data_.Get(index);
}
inline ::DS3_Frpg2RequestMessage::SignData* GetSignResult::mutable_sign_data(int index) {
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.GetSignResult.sign_data)
  return sign_data_.Mutable(index);
}
inline ::DS3_Frpg2RequestMessage::SignData* GetSignResult::add_sign_data() {
  // @@protoc_insertion_point(field_add:DS3_Frpg2RequestMessage.GetSignResult.sign_data)
  return sign_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::SignData >&
GetSignResult::sign_data() const {
  // @@protoc_insertion_point(field_list:DS3_Frpg2RequestMessage.GetSignResult.sign_data)
  return sign_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::SignData >*
GetSignResult::mutable_sign_data() {
  // @@protoc_insertion_point(field_mutable_list:DS3_Frpg2RequestMessage.GetSignResult.sign_data)
  return &sign_data_;
}

// -------------------------------------------------------------------

// SignInfo

// required uint32 player_id = 1;
inline bool SignInfo::has_player_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SignInfo::set_has_player_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SignInfo::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SignInfo::clear_player_id() {
  player_id_ = 0u;
  clear_has_player_id();
}
inline ::google::protobuf::uint32 SignInfo::player_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.SignInfo.player_id)
  return player_id_;
}
inline void SignInfo::set_player_id(::google::protobuf::uint32 value) {
  set_has_player_id();
  player_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.SignInfo.player_id)
}

// required uint32 sign_id = 2;
inline bool SignInfo::has_sign_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SignInfo::set_has_sign_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SignInfo::clear_has_sign_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SignInfo::clear_sign_id() {
  sign_id_ = 0u;
  clear_has_sign_id();
}
inline ::google::protobuf::uint32 SignInfo::sign_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.SignInfo.sign_id)
  return sign_id_;
}
inline void SignInfo::set_sign_id(::google::protobuf::uint32 value) {
  set_has_sign_id();
  sign_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.SignInfo.sign_id)
}

// -------------------------------------------------------------------

// SignData

// required .DS3_Frpg2RequestMessage.SignInfo sign_info = 1;
inline bool SignData::has_sign_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SignData::set_has_sign_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SignData::clear_has_sign_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SignData::clear_sign_info() {
  if (sign_info_ != NULL) sign_info_->::DS3_Frpg2RequestMessage::SignInfo::Clear();
  clear_has_sign_info();
}
inline const ::DS3_Frpg2RequestMessage::SignInfo& SignData::sign_info() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.SignData.sign_info)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return sign_info_ != NULL ? *sign_info_ : *default_instance().sign_info_;
#else
  return sign_info_ != NULL ? *sign_info_ : *default_instance_->sign_info_;
#endif
}
inline ::DS3_Frpg2RequestMessage::SignInfo* SignData::mutable_sign_info() {
  set_has_sign_info();
  if (sign_info_ == NULL) sign_info_ = new ::DS3_Frpg2RequestMessage::SignInfo;
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.SignData.sign_info)
  return sign_info_;
}
inline ::DS3_Frpg2RequestMessage::SignInfo* SignData::release_sign_info() {
  clear_has_sign_info();
  ::DS3_Frpg2RequestMessage::SignInfo* temp = sign_info_;
  sign_info_ = NULL;
  return temp;
}
inline void SignData::set_allocated_sign_info(::DS3_Frpg2RequestMessage::SignInfo* sign_info) {
  delete sign_info_;
  sign_info_ = sign_info;
  if (sign_info) {
    set_has_sign_info();
  } else {
    clear_has_sign_info();
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.SignData.sign_info)
}

// required uint32 online_area_id = 2;
inline bool SignData::has_online_area_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SignData::set_has_online_area_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SignData::clear_has_online_area_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SignData::clear_online_area_id() {
  online_area_id_ = 0u;
  clear_has_online_area_id();
}
inline ::google::protobuf::uint32 SignData::online_area_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.SignData.online_area_id)
  return online_area_id_;
}
inline void SignData::set_online_area_id(::google::protobuf::uint32 value) {
  set_has_online_area_id();
  online_area_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.SignData.online_area_id)
}

// required .DS3_Frpg2RequestMessage.MatchingParameter matching_parameter = 3;
inline bool SignData::has_matching_parameter() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SignData::set_has_matching_parameter() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SignData::clear_has_matching_parameter() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SignData::clear_matching_parameter() {
  if (matching_parameter_ != NULL) matching_parameter_->::DS3_Frpg2RequestMessage::MatchingParameter::Clear();
  clear_has_matching_parameter();
}
inline const ::DS3_Frpg2RequestMessage::MatchingParameter& SignData::matching_parameter() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.SignData.matching_parameter)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return matching_parameter_ != NULL ? *matching_parameter_ : *default_instance().matching_parameter_;
#else
  return matching_parameter_ != NULL ? *matching_parameter_ : *default_instance_->matching_parameter_;
#endif
}
inline ::DS3_Frpg2RequestMessage::MatchingParameter* SignData::mutable_matching_parameter() {
  set_has_matching_parameter();
  if (matching_parameter_ == NULL) matching_parameter_ = new ::DS3_Frpg2RequestMessage::MatchingParameter;
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.SignData.matching_parameter)
  return matching_parameter_;
}
inline ::DS3_Frpg2RequestMessage::MatchingParameter* SignData::release_matching_parameter() {
  clear_has_matching_parameter();
  ::DS3_Frpg2RequestMessage::MatchingParameter* temp = matching_parameter_;
  matching_parameter_ = NULL;
  return temp;
}
inline void SignData::set_allocated_matching_parameter(::DS3_Frpg2RequestMessage::MatchingParameter* matching_parameter) {
  delete matching_parameter_;
  matching_parameter_ = matching_parameter;
  if (matching_parameter) {
    set_has_matching_parameter();
  } else {
    clear_has_matching_parameter();
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.SignData.matching_parameter)
}

// required bytes player_struct = 4;
inline bool SignData::has_player_struct() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SignData::set_has_player_struct() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SignData::clear_has_player_struct() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SignData::clear_player_struct() {
  if (player_struct_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    player_struct_->clear();
  }
  clear_has_player_struct();
}
inline const ::std::string& SignData::player_struct() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.SignData.player_struct)
  return *player_struct_;
}
inline void SignData::set_player_struct(const ::std::string& value) {
  set_has_player_struct();
  if (player_struct_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    player_struct_ = new ::std::string;
  }
  player_struct_->assign(value);
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.SignData.player_struct)
}
inline void SignData::set_player_struct(const char* value) {
  set_has_player_struct();
  if (player_struct_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    player_struct_ = new ::std::string;
  }
  player_struct_->assign(value);
  // @@protoc_insertion_point(field_set_char:DS3_Frpg2RequestMessage.SignData.player_struct)
}
inline void SignData::set_player_struct(const void* value, size_t size) {
  set_has_player_struct();
  if (player_struct_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    player_struct_ = new ::std::string;
  }
  player_struct_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DS3_Frpg2RequestMessage.SignData.player_struct)
}
inline ::std::string* SignData::mutable_player_struct() {
  set_has_player_struct();
  if (player_struct_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    player_struct_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.SignData.player_struct)
  return player_struct_;
}
inline ::std::string* SignData::release_player_struct() {
  clear_has_player_struct();
  if (player_struct_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = player_struct_;
    player_struct_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SignData::set_allocated_player_struct(::std::string* player_struct) {
  if (player_struct_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete player_struct_;
  }
  if (player_struct) {
    set_has_player_struct();
    player_struct_ = player_struct;
  } else {
    clear_has_player_struct();
    player_struct_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.SignData.player_struct)
}

// required string steam_id = 5;
inline bool SignData::has_steam_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SignData::set_has_steam_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SignData::clear_has_steam_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SignData::clear_steam_id() {
  if (steam_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    steam_id_->clear();
  }
  clear_has_steam_id();
}
inline const ::std::string& SignData::steam_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.SignData.steam_id)
  return *steam_id_;
}
inline void SignData::set_steam_id(const ::std::string& value) {
  set_has_steam_id();
  if (steam_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    steam_id_ = new ::std::string;
  }
  steam_id_->assign(value);
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.SignData.steam_id)
}
inline void SignData::set_steam_id(const char* value) {
  set_has_steam_id();
  if (steam_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    steam_id_ = new ::std::string;
  }
  steam_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:DS3_Frpg2RequestMessage.SignData.steam_id)
}
inline void SignData::set_steam_id(const char* value, size_t size) {
  set_has_steam_id();
  if (steam_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    steam_id_ = new ::std::string;
  }
  steam_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DS3_Frpg2RequestMessage.SignData.steam_id)
}
inline ::std::string* SignData::mutable_steam_id() {
  set_has_steam_id();
  if (steam_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    steam_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.SignData.steam_id)
  return steam_id_;
}
inline ::std::string* SignData::release_steam_id() {
  clear_has_steam_id();
  if (steam_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = steam_id_;
    steam_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SignData::set_allocated_steam_id(::std::string* steam_id) {
  if (steam_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete steam_id_;
  }
  if (steam_id) {
    set_has_steam_id();
    steam_id_ = steam_id;
  } else {
    clear_has_steam_id();
    steam_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.SignData.steam_id)
}

// required .DS3_Frpg2RequestMessage.SignType sign_type = 6;
inline bool SignData::has_sign_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SignData::set_has_sign_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SignData::clear_has_sign_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SignData::clear_sign_type() {
  sign_type_ = 0;
  clear_has_sign_type();
}
inline ::DS3_Frpg2RequestMessage::SignType SignData::sign_type() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.SignData.sign_type)
  return static_cast< ::DS3_Frpg2RequestMessage::SignType >(sign_type_);
}
inline void SignData::set_sign_type(::DS3_Frpg2RequestMessage::SignType value) {
  assert(::DS3_Frpg2RequestMessage::SignType_IsValid(value));
  set_has_sign_type();
  sign_type_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.SignData.sign_type)
}

// -------------------------------------------------------------------

// MatchingParameter

// required uint32 regulation_version = 1;
inline bool MatchingParameter::has_regulation_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MatchingParameter::set_has_regulation_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MatchingParameter::clear_has_regulation_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MatchingParameter::clear_regulation_version() {
  regulation_version_ = 0u;
  clear_has_regulation_version();
}
inline ::google::protobuf::uint32 MatchingParameter::regulation_version() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.MatchingParameter.regulation_version)
  return regulation_version_;
}
inline void MatchingParameter::set_regulation_version(::google::protobuf::uint32 value) {
  set_has_regulation_version();
  regulation_version_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.MatchingParameter.regulation_version)
}

// required uint32 unknown_id_2 = 2;
inline bool MatchingParameter::has_unknown_id_2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MatchingParameter::set_has_unknown_id_2() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MatchingParameter::clear_has_unknown_id_2() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MatchingParameter::clear_unknown_id_2() {
  unknown_id_2_ = 0u;
  clear_has_unknown_id_2();
}
inline ::google::protobuf::uint32 MatchingParameter::unknown_id_2() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.MatchingParameter.unknown_id_2)
  return unknown_id_2_;
}
inline void MatchingParameter::set_unknown_id_2(::google::protobuf::uint32 value) {
  set_has_unknown_id_2();
  unknown_id_2_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.MatchingParameter.unknown_id_2)
}

// required uint32 allow_cross_region = 3;
inline bool MatchingParameter::has_allow_cross_region() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MatchingParameter::set_has_allow_cross_region() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MatchingParameter::clear_has_allow_cross_region() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MatchingParameter::clear_allow_cross_region() {
  allow_cross_region_ = 0u;
  clear_has_allow_cross_region();
}
inline ::google::protobuf::uint32 MatchingParameter::allow_cross_region() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.MatchingParameter.allow_cross_region)
  return allow_cross_region_;
}
inline void MatchingParameter::set_allow_cross_region(::google::protobuf::uint32 value) {
  set_has_allow_cross_region();
  allow_cross_region_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.MatchingParameter.allow_cross_region)
}

// required uint32 nat_type = 4;
inline bool MatchingParameter::has_nat_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MatchingParameter::set_has_nat_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MatchingParameter::clear_has_nat_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MatchingParameter::clear_nat_type() {
  nat_type_ = 0u;
  clear_has_nat_type();
}
inline ::google::protobuf::uint32 MatchingParameter::nat_type() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.MatchingParameter.nat_type)
  return nat_type_;
}
inline void MatchingParameter::set_nat_type(::google::protobuf::uint32 value) {
  set_has_nat_type();
  nat_type_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.MatchingParameter.nat_type)
}

// required uint32 unknown_id_5 = 5;
inline bool MatchingParameter::has_unknown_id_5() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MatchingParameter::set_has_unknown_id_5() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MatchingParameter::clear_has_unknown_id_5() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MatchingParameter::clear_unknown_id_5() {
  unknown_id_5_ = 0u;
  clear_has_unknown_id_5();
}
inline ::google::protobuf::uint32 MatchingParameter::unknown_id_5() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.MatchingParameter.unknown_id_5)
  return unknown_id_5_;
}
inline void MatchingParameter::set_unknown_id_5(::google::protobuf::uint32 value) {
  set_has_unknown_id_5();
  unknown_id_5_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.MatchingParameter.unknown_id_5)
}

// required uint32 soul_level = 6;
inline bool MatchingParameter::has_soul_level() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MatchingParameter::set_has_soul_level() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MatchingParameter::clear_has_soul_level() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MatchingParameter::clear_soul_level() {
  soul_level_ = 0u;
  clear_has_soul_level();
}
inline ::google::protobuf::uint32 MatchingParameter::soul_level() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.MatchingParameter.soul_level)
  return soul_level_;
}
inline void MatchingParameter::set_soul_level(::google::protobuf::uint32 value) {
  set_has_soul_level();
  soul_level_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.MatchingParameter.soul_level)
}

// required uint32 soul_memory = 7;
inline bool MatchingParameter::has_soul_memory() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MatchingParameter::set_has_soul_memory() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MatchingParameter::clear_has_soul_memory() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MatchingParameter::clear_soul_memory() {
  soul_memory_ = 0u;
  clear_has_soul_memory();
}
inline ::google::protobuf::uint32 MatchingParameter::soul_memory() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.MatchingParameter.soul_memory)
  return soul_memory_;
}
inline void MatchingParameter::set_soul_memory(::google::protobuf::uint32 value) {
  set_has_soul_memory();
  soul_memory_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.MatchingParameter.soul_memory)
}

// optional string unknown_string = 8;
inline bool MatchingParameter::has_unknown_string() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MatchingParameter::set_has_unknown_string() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MatchingParameter::clear_has_unknown_string() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MatchingParameter::clear_unknown_string() {
  if (unknown_string_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unknown_string_->clear();
  }
  clear_has_unknown_string();
}
inline const ::std::string& MatchingParameter::unknown_string() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.MatchingParameter.unknown_string)
  return *unknown_string_;
}
inline void MatchingParameter::set_unknown_string(const ::std::string& value) {
  set_has_unknown_string();
  if (unknown_string_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unknown_string_ = new ::std::string;
  }
  unknown_string_->assign(value);
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.MatchingParameter.unknown_string)
}
inline void MatchingParameter::set_unknown_string(const char* value) {
  set_has_unknown_string();
  if (unknown_string_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unknown_string_ = new ::std::string;
  }
  unknown_string_->assign(value);
  // @@protoc_insertion_point(field_set_char:DS3_Frpg2RequestMessage.MatchingParameter.unknown_string)
}
inline void MatchingParameter::set_unknown_string(const char* value, size_t size) {
  set_has_unknown_string();
  if (unknown_string_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unknown_string_ = new ::std::string;
  }
  unknown_string_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DS3_Frpg2RequestMessage.MatchingParameter.unknown_string)
}
inline ::std::string* MatchingParameter::mutable_unknown_string() {
  set_has_unknown_string();
  if (unknown_string_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unknown_string_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.MatchingParameter.unknown_string)
  return unknown_string_;
}
inline ::std::string* MatchingParameter::release_unknown_string() {
  clear_has_unknown_string();
  if (unknown_string_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = unknown_string_;
    unknown_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MatchingParameter::set_allocated_unknown_string(::std::string* unknown_string) {
  if (unknown_string_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete unknown_string_;
  }
  if (unknown_string) {
    set_has_unknown_string();
    unknown_string_ = unknown_string;
  } else {
    clear_has_unknown_string();
    unknown_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.MatchingParameter.unknown_string)
}

// required uint32 clear_count = 9;
inline bool MatchingParameter::has_clear_count() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MatchingParameter::set_has_clear_count() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MatchingParameter::clear_has_clear_count() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MatchingParameter::clear_clear_count() {
  clear_count_ = 0u;
  clear_has_clear_count();
}
inline ::google::protobuf::uint32 MatchingParameter::clear_count() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.MatchingParameter.clear_count)
  return clear_count_;
}
inline void MatchingParameter::set_clear_count(::google::protobuf::uint32 value) {
  set_has_clear_count();
  clear_count_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.MatchingParameter.clear_count)
}

// required string password = 10;
inline bool MatchingParameter::has_password() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MatchingParameter::set_has_password() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MatchingParameter::clear_has_password() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MatchingParameter::clear_password() {
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& MatchingParameter::password() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.MatchingParameter.password)
  return *password_;
}
inline void MatchingParameter::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(value);
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.MatchingParameter.password)
}
inline void MatchingParameter::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(value);
  // @@protoc_insertion_point(field_set_char:DS3_Frpg2RequestMessage.MatchingParameter.password)
}
inline void MatchingParameter::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DS3_Frpg2RequestMessage.MatchingParameter.password)
}
inline ::std::string* MatchingParameter::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.MatchingParameter.password)
  return password_;
}
inline ::std::string* MatchingParameter::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MatchingParameter::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.MatchingParameter.password)
}

// required .DS3_Frpg2RequestMessage.Covenant covenant = 11;
inline bool MatchingParameter::has_covenant() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void MatchingParameter::set_has_covenant() {
  _has_bits_[0] |= 0x00000400u;
}
inline void MatchingParameter::clear_has_covenant() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void MatchingParameter::clear_covenant() {
  covenant_ = 0;
  clear_has_covenant();
}
inline ::DS3_Frpg2RequestMessage::Covenant MatchingParameter::covenant() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.MatchingParameter.covenant)
  return static_cast< ::DS3_Frpg2RequestMessage::Covenant >(covenant_);
}
inline void MatchingParameter::set_covenant(::DS3_Frpg2RequestMessage::Covenant value) {
  assert(::DS3_Frpg2RequestMessage::Covenant_IsValid(value));
  set_has_covenant();
  covenant_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.MatchingParameter.covenant)
}

// required uint32 weapon_level = 14;
inline bool MatchingParameter::has_weapon_level() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void MatchingParameter::set_has_weapon_level() {
  _has_bits_[0] |= 0x00000800u;
}
inline void MatchingParameter::clear_has_weapon_level() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void MatchingParameter::clear_weapon_level() {
  weapon_level_ = 0u;
  clear_has_weapon_level();
}
inline ::google::protobuf::uint32 MatchingParameter::weapon_level() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.MatchingParameter.weapon_level)
  return weapon_level_;
}
inline void MatchingParameter::set_weapon_level(::google::protobuf::uint32 value) {
  set_has_weapon_level();
  weapon_level_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.MatchingParameter.weapon_level)
}

// optional string unknown_id_15 = 15;
inline bool MatchingParameter::has_unknown_id_15() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void MatchingParameter::set_has_unknown_id_15() {
  _has_bits_[0] |= 0x00001000u;
}
inline void MatchingParameter::clear_has_unknown_id_15() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void MatchingParameter::clear_unknown_id_15() {
  if (unknown_id_15_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unknown_id_15_->clear();
  }
  clear_has_unknown_id_15();
}
inline const ::std::string& MatchingParameter::unknown_id_15() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.MatchingParameter.unknown_id_15)
  return *unknown_id_15_;
}
inline void MatchingParameter::set_unknown_id_15(const ::std::string& value) {
  set_has_unknown_id_15();
  if (unknown_id_15_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unknown_id_15_ = new ::std::string;
  }
  unknown_id_15_->assign(value);
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.MatchingParameter.unknown_id_15)
}
inline void MatchingParameter::set_unknown_id_15(const char* value) {
  set_has_unknown_id_15();
  if (unknown_id_15_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unknown_id_15_ = new ::std::string;
  }
  unknown_id_15_->assign(value);
  // @@protoc_insertion_point(field_set_char:DS3_Frpg2RequestMessage.MatchingParameter.unknown_id_15)
}
inline void MatchingParameter::set_unknown_id_15(const char* value, size_t size) {
  set_has_unknown_id_15();
  if (unknown_id_15_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unknown_id_15_ = new ::std::string;
  }
  unknown_id_15_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DS3_Frpg2RequestMessage.MatchingParameter.unknown_id_15)
}
inline ::std::string* MatchingParameter::mutable_unknown_id_15() {
  set_has_unknown_id_15();
  if (unknown_id_15_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unknown_id_15_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.MatchingParameter.unknown_id_15)
  return unknown_id_15_;
}
inline ::std::string* MatchingParameter::release_unknown_id_15() {
  clear_has_unknown_id_15();
  if (unknown_id_15_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = unknown_id_15_;
    unknown_id_15_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MatchingParameter::set_allocated_unknown_id_15(::std::string* unknown_id_15) {
  if (unknown_id_15_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete unknown_id_15_;
  }
  if (unknown_id_15) {
    set_has_unknown_id_15();
    unknown_id_15_ = unknown_id_15;
  } else {
    clear_has_unknown_id_15();
    unknown_id_15_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.MatchingParameter.unknown_id_15)
}

// -------------------------------------------------------------------

// SignGetFlags

// required uint32 unknown_id_1 = 1;
inline bool SignGetFlags::has_unknown_id_1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SignGetFlags::set_has_unknown_id_1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SignGetFlags::clear_has_unknown_id_1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SignGetFlags::clear_unknown_id_1() {
  unknown_id_1_ = 0u;
  clear_has_unknown_id_1();
}
inline ::google::protobuf::uint32 SignGetFlags::unknown_id_1() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.SignGetFlags.unknown_id_1)
  return unknown_id_1_;
}
inline void SignGetFlags::set_unknown_id_1(::google::protobuf::uint32 value) {
  set_has_unknown_id_1();
  unknown_id_1_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.SignGetFlags.unknown_id_1)
}

// required uint32 unknown_id_2 = 2;
inline bool SignGetFlags::has_unknown_id_2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SignGetFlags::set_has_unknown_id_2() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SignGetFlags::clear_has_unknown_id_2() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SignGetFlags::clear_unknown_id_2() {
  unknown_id_2_ = 0u;
  clear_has_unknown_id_2();
}
inline ::google::protobuf::uint32 SignGetFlags::unknown_id_2() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.SignGetFlags.unknown_id_2)
  return unknown_id_2_;
}
inline void SignGetFlags::set_unknown_id_2(::google::protobuf::uint32 value) {
  set_has_unknown_id_2();
  unknown_id_2_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.SignGetFlags.unknown_id_2)
}

// required uint32 unknown_id_3 = 3;
inline bool SignGetFlags::has_unknown_id_3() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SignGetFlags::set_has_unknown_id_3() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SignGetFlags::clear_has_unknown_id_3() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SignGetFlags::clear_unknown_id_3() {
  unknown_id_3_ = 0u;
  clear_has_unknown_id_3();
}
inline ::google::protobuf::uint32 SignGetFlags::unknown_id_3() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.SignGetFlags.unknown_id_3)
  return unknown_id_3_;
}
inline void SignGetFlags::set_unknown_id_3(::google::protobuf::uint32 value) {
  set_has_unknown_id_3();
  unknown_id_3_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.SignGetFlags.unknown_id_3)
}

// -------------------------------------------------------------------

// SignDomainGetInfo

// required uint32 online_area_id = 1;
inline bool SignDomainGetInfo::has_online_area_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SignDomainGetInfo::set_has_online_area_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SignDomainGetInfo::clear_has_online_area_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SignDomainGetInfo::clear_online_area_id() {
  online_area_id_ = 0u;
  clear_has_online_area_id();
}
inline ::google::protobuf::uint32 SignDomainGetInfo::online_area_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.SignDomainGetInfo.online_area_id)
  return online_area_id_;
}
inline void SignDomainGetInfo::set_online_area_id(::google::protobuf::uint32 value) {
  set_has_online_area_id();
  online_area_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.SignDomainGetInfo.online_area_id)
}

// required uint32 max_signs = 2;
inline bool SignDomainGetInfo::has_max_signs() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SignDomainGetInfo::set_has_max_signs() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SignDomainGetInfo::clear_has_max_signs() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SignDomainGetInfo::clear_max_signs() {
  max_signs_ = 0u;
  clear_has_max_signs();
}
inline ::google::protobuf::uint32 SignDomainGetInfo::max_signs() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.SignDomainGetInfo.max_signs)
  return max_signs_;
}
inline void SignDomainGetInfo::set_max_signs(::google::protobuf::uint32 value) {
  set_has_max_signs();
  max_signs_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.SignDomainGetInfo.max_signs)
}

// repeated .DS3_Frpg2RequestMessage.SignInfo already_have_signs = 3;
inline int SignDomainGetInfo::already_have_signs_size() const {
  return already_have_signs_.size();
}
inline void SignDomainGetInfo::clear_already_have_signs() {
  already_have_signs_.Clear();
}
inline const ::DS3_Frpg2RequestMessage::SignInfo& SignDomainGetInfo::already_have_signs(int index) const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.SignDomainGetInfo.already_have_signs)
  return already_have_signs_.Get(index);
}
inline ::DS3_Frpg2RequestMessage::SignInfo* SignDomainGetInfo::mutable_already_have_signs(int index) {
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.SignDomainGetInfo.already_have_signs)
  return already_have_signs_.Mutable(index);
}
inline ::DS3_Frpg2RequestMessage::SignInfo* SignDomainGetInfo::add_already_have_signs() {
  // @@protoc_insertion_point(field_add:DS3_Frpg2RequestMessage.SignDomainGetInfo.already_have_signs)
  return already_have_signs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::SignInfo >&
SignDomainGetInfo::already_have_signs() const {
  // @@protoc_insertion_point(field_list:DS3_Frpg2RequestMessage.SignDomainGetInfo.already_have_signs)
  return already_have_signs_;
}
inline ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::SignInfo >*
SignDomainGetInfo::mutable_already_have_signs() {
  // @@protoc_insertion_point(field_mutable_list:DS3_Frpg2RequestMessage.SignDomainGetInfo.already_have_signs)
  return &already_have_signs_;
}

// -------------------------------------------------------------------

// RequestGetSignList

// required uint32 unknown_id_1 = 1;
inline bool RequestGetSignList::has_unknown_id_1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestGetSignList::set_has_unknown_id_1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestGetSignList::clear_has_unknown_id_1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestGetSignList::clear_unknown_id_1() {
  unknown_id_1_ = 0u;
  clear_has_unknown_id_1();
}
inline ::google::protobuf::uint32 RequestGetSignList::unknown_id_1() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestGetSignList.unknown_id_1)
  return unknown_id_1_;
}
inline void RequestGetSignList::set_unknown_id_1(::google::protobuf::uint32 value) {
  set_has_unknown_id_1();
  unknown_id_1_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestGetSignList.unknown_id_1)
}

// repeated .DS3_Frpg2RequestMessage.SignDomainGetInfo search_areas = 2;
inline int RequestGetSignList::search_areas_size() const {
  return search_areas_.size();
}
inline void RequestGetSignList::clear_search_areas() {
  search_areas_.Clear();
}
inline const ::DS3_Frpg2RequestMessage::SignDomainGetInfo& RequestGetSignList::search_areas(int index) const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestGetSignList.search_areas)
  return search_areas_.Get(index);
}
inline ::DS3_Frpg2RequestMessage::SignDomainGetInfo* RequestGetSignList::mutable_search_areas(int index) {
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.RequestGetSignList.search_areas)
  return search_areas_.Mutable(index);
}
inline ::DS3_Frpg2RequestMessage::SignDomainGetInfo* RequestGetSignList::add_search_areas() {
  // @@protoc_insertion_point(field_add:DS3_Frpg2RequestMessage.RequestGetSignList.search_areas)
  return search_areas_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::SignDomainGetInfo >&
RequestGetSignList::search_areas() const {
  // @@protoc_insertion_point(field_list:DS3_Frpg2RequestMessage.RequestGetSignList.search_areas)
  return search_areas_;
}
inline ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::SignDomainGetInfo >*
RequestGetSignList::mutable_search_areas() {
  // @@protoc_insertion_point(field_mutable_list:DS3_Frpg2RequestMessage.RequestGetSignList.search_areas)
  return &search_areas_;
}

// required uint32 max_signs = 3;
inline bool RequestGetSignList::has_max_signs() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestGetSignList::set_has_max_signs() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestGetSignList::clear_has_max_signs() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestGetSignList::clear_max_signs() {
  max_signs_ = 0u;
  clear_has_max_signs();
}
inline ::google::protobuf::uint32 RequestGetSignList::max_signs() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestGetSignList.max_signs)
  return max_signs_;
}
inline void RequestGetSignList::set_max_signs(::google::protobuf::uint32 value) {
  set_has_max_signs();
  max_signs_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestGetSignList.max_signs)
}

// required .DS3_Frpg2RequestMessage.MatchingParameter matching_parameter = 4;
inline bool RequestGetSignList::has_matching_parameter() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestGetSignList::set_has_matching_parameter() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestGetSignList::clear_has_matching_parameter() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestGetSignList::clear_matching_parameter() {
  if (matching_parameter_ != NULL) matching_parameter_->::DS3_Frpg2RequestMessage::MatchingParameter::Clear();
  clear_has_matching_parameter();
}
inline const ::DS3_Frpg2RequestMessage::MatchingParameter& RequestGetSignList::matching_parameter() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestGetSignList.matching_parameter)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return matching_parameter_ != NULL ? *matching_parameter_ : *default_instance().matching_parameter_;
#else
  return matching_parameter_ != NULL ? *matching_parameter_ : *default_instance_->matching_parameter_;
#endif
}
inline ::DS3_Frpg2RequestMessage::MatchingParameter* RequestGetSignList::mutable_matching_parameter() {
  set_has_matching_parameter();
  if (matching_parameter_ == NULL) matching_parameter_ = new ::DS3_Frpg2RequestMessage::MatchingParameter;
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.RequestGetSignList.matching_parameter)
  return matching_parameter_;
}
inline ::DS3_Frpg2RequestMessage::MatchingParameter* RequestGetSignList::release_matching_parameter() {
  clear_has_matching_parameter();
  ::DS3_Frpg2RequestMessage::MatchingParameter* temp = matching_parameter_;
  matching_parameter_ = NULL;
  return temp;
}
inline void RequestGetSignList::set_allocated_matching_parameter(::DS3_Frpg2RequestMessage::MatchingParameter* matching_parameter) {
  delete matching_parameter_;
  matching_parameter_ = matching_parameter;
  if (matching_parameter) {
    set_has_matching_parameter();
  } else {
    clear_has_matching_parameter();
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.RequestGetSignList.matching_parameter)
}

// required .DS3_Frpg2RequestMessage.SignGetFlags sign_get_flags = 5;
inline bool RequestGetSignList::has_sign_get_flags() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RequestGetSignList::set_has_sign_get_flags() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RequestGetSignList::clear_has_sign_get_flags() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RequestGetSignList::clear_sign_get_flags() {
  if (sign_get_flags_ != NULL) sign_get_flags_->::DS3_Frpg2RequestMessage::SignGetFlags::Clear();
  clear_has_sign_get_flags();
}
inline const ::DS3_Frpg2RequestMessage::SignGetFlags& RequestGetSignList::sign_get_flags() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestGetSignList.sign_get_flags)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return sign_get_flags_ != NULL ? *sign_get_flags_ : *default_instance().sign_get_flags_;
#else
  return sign_get_flags_ != NULL ? *sign_get_flags_ : *default_instance_->sign_get_flags_;
#endif
}
inline ::DS3_Frpg2RequestMessage::SignGetFlags* RequestGetSignList::mutable_sign_get_flags() {
  set_has_sign_get_flags();
  if (sign_get_flags_ == NULL) sign_get_flags_ = new ::DS3_Frpg2RequestMessage::SignGetFlags;
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.RequestGetSignList.sign_get_flags)
  return sign_get_flags_;
}
inline ::DS3_Frpg2RequestMessage::SignGetFlags* RequestGetSignList::release_sign_get_flags() {
  clear_has_sign_get_flags();
  ::DS3_Frpg2RequestMessage::SignGetFlags* temp = sign_get_flags_;
  sign_get_flags_ = NULL;
  return temp;
}
inline void RequestGetSignList::set_allocated_sign_get_flags(::DS3_Frpg2RequestMessage::SignGetFlags* sign_get_flags) {
  delete sign_get_flags_;
  sign_get_flags_ = sign_get_flags;
  if (sign_get_flags) {
    set_has_sign_get_flags();
  } else {
    clear_has_sign_get_flags();
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.RequestGetSignList.sign_get_flags)
}

// -------------------------------------------------------------------

// RequestGetSignListResponse

// required .DS3_Frpg2RequestMessage.GetSignResult get_sign_result = 1;
inline bool RequestGetSignListResponse::has_get_sign_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestGetSignListResponse::set_has_get_sign_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestGetSignListResponse::clear_has_get_sign_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestGetSignListResponse::clear_get_sign_result() {
  if (get_sign_result_ != NULL) get_sign_result_->::DS3_Frpg2RequestMessage::GetSignResult::Clear();
  clear_has_get_sign_result();
}
inline const ::DS3_Frpg2RequestMessage::GetSignResult& RequestGetSignListResponse::get_sign_result() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestGetSignListResponse.get_sign_result)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return get_sign_result_ != NULL ? *get_sign_result_ : *default_instance().get_sign_result_;
#else
  return get_sign_result_ != NULL ? *get_sign_result_ : *default_instance_->get_sign_result_;
#endif
}
inline ::DS3_Frpg2RequestMessage::GetSignResult* RequestGetSignListResponse::mutable_get_sign_result() {
  set_has_get_sign_result();
  if (get_sign_result_ == NULL) get_sign_result_ = new ::DS3_Frpg2RequestMessage::GetSignResult;
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.RequestGetSignListResponse.get_sign_result)
  return get_sign_result_;
}
inline ::DS3_Frpg2RequestMessage::GetSignResult* RequestGetSignListResponse::release_get_sign_result() {
  clear_has_get_sign_result();
  ::DS3_Frpg2RequestMessage::GetSignResult* temp = get_sign_result_;
  get_sign_result_ = NULL;
  return temp;
}
inline void RequestGetSignListResponse::set_allocated_get_sign_result(::DS3_Frpg2RequestMessage::GetSignResult* get_sign_result) {
  delete get_sign_result_;
  get_sign_result_ = get_sign_result;
  if (get_sign_result) {
    set_has_get_sign_result();
  } else {
    clear_has_get_sign_result();
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.RequestGetSignListResponse.get_sign_result)
}

// -------------------------------------------------------------------

// RequestCreateSign

// required uint32 map_id = 1;
inline bool RequestCreateSign::has_map_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestCreateSign::set_has_map_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestCreateSign::clear_has_map_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestCreateSign::clear_map_id() {
  map_id_ = 0u;
  clear_has_map_id();
}
inline ::google::protobuf::uint32 RequestCreateSign::map_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestCreateSign.map_id)
  return map_id_;
}
inline void RequestCreateSign::set_map_id(::google::protobuf::uint32 value) {
  set_has_map_id();
  map_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestCreateSign.map_id)
}

// required uint32 online_area_id = 2;
inline bool RequestCreateSign::has_online_area_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestCreateSign::set_has_online_area_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestCreateSign::clear_has_online_area_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestCreateSign::clear_online_area_id() {
  online_area_id_ = 0u;
  clear_has_online_area_id();
}
inline ::google::protobuf::uint32 RequestCreateSign::online_area_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestCreateSign.online_area_id)
  return online_area_id_;
}
inline void RequestCreateSign::set_online_area_id(::google::protobuf::uint32 value) {
  set_has_online_area_id();
  online_area_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestCreateSign.online_area_id)
}

// required .DS3_Frpg2RequestMessage.MatchingParameter matching_parameter = 3;
inline bool RequestCreateSign::has_matching_parameter() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestCreateSign::set_has_matching_parameter() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestCreateSign::clear_has_matching_parameter() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestCreateSign::clear_matching_parameter() {
  if (matching_parameter_ != NULL) matching_parameter_->::DS3_Frpg2RequestMessage::MatchingParameter::Clear();
  clear_has_matching_parameter();
}
inline const ::DS3_Frpg2RequestMessage::MatchingParameter& RequestCreateSign::matching_parameter() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestCreateSign.matching_parameter)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return matching_parameter_ != NULL ? *matching_parameter_ : *default_instance().matching_parameter_;
#else
  return matching_parameter_ != NULL ? *matching_parameter_ : *default_instance_->matching_parameter_;
#endif
}
inline ::DS3_Frpg2RequestMessage::MatchingParameter* RequestCreateSign::mutable_matching_parameter() {
  set_has_matching_parameter();
  if (matching_parameter_ == NULL) matching_parameter_ = new ::DS3_Frpg2RequestMessage::MatchingParameter;
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.RequestCreateSign.matching_parameter)
  return matching_parameter_;
}
inline ::DS3_Frpg2RequestMessage::MatchingParameter* RequestCreateSign::release_matching_parameter() {
  clear_has_matching_parameter();
  ::DS3_Frpg2RequestMessage::MatchingParameter* temp = matching_parameter_;
  matching_parameter_ = NULL;
  return temp;
}
inline void RequestCreateSign::set_allocated_matching_parameter(::DS3_Frpg2RequestMessage::MatchingParameter* matching_parameter) {
  delete matching_parameter_;
  matching_parameter_ = matching_parameter;
  if (matching_parameter) {
    set_has_matching_parameter();
  } else {
    clear_has_matching_parameter();
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.RequestCreateSign.matching_parameter)
}

// required uint32 sign_type = 4;
inline bool RequestCreateSign::has_sign_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestCreateSign::set_has_sign_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestCreateSign::clear_has_sign_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestCreateSign::clear_sign_type() {
  sign_type_ = 0u;
  clear_has_sign_type();
}
inline ::google::protobuf::uint32 RequestCreateSign::sign_type() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestCreateSign.sign_type)
  return sign_type_;
}
inline void RequestCreateSign::set_sign_type(::google::protobuf::uint32 value) {
  set_has_sign_type();
  sign_type_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestCreateSign.sign_type)
}

// required bytes player_struct = 5;
inline bool RequestCreateSign::has_player_struct() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RequestCreateSign::set_has_player_struct() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RequestCreateSign::clear_has_player_struct() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RequestCreateSign::clear_player_struct() {
  if (player_struct_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    player_struct_->clear();
  }
  clear_has_player_struct();
}
inline const ::std::string& RequestCreateSign::player_struct() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestCreateSign.player_struct)
  return *player_struct_;
}
inline void RequestCreateSign::set_player_struct(const ::std::string& value) {
  set_has_player_struct();
  if (player_struct_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    player_struct_ = new ::std::string;
  }
  player_struct_->assign(value);
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestCreateSign.player_struct)
}
inline void RequestCreateSign::set_player_struct(const char* value) {
  set_has_player_struct();
  if (player_struct_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    player_struct_ = new ::std::string;
  }
  player_struct_->assign(value);
  // @@protoc_insertion_point(field_set_char:DS3_Frpg2RequestMessage.RequestCreateSign.player_struct)
}
inline void RequestCreateSign::set_player_struct(const void* value, size_t size) {
  set_has_player_struct();
  if (player_struct_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    player_struct_ = new ::std::string;
  }
  player_struct_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DS3_Frpg2RequestMessage.RequestCreateSign.player_struct)
}
inline ::std::string* RequestCreateSign::mutable_player_struct() {
  set_has_player_struct();
  if (player_struct_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    player_struct_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.RequestCreateSign.player_struct)
  return player_struct_;
}
inline ::std::string* RequestCreateSign::release_player_struct() {
  clear_has_player_struct();
  if (player_struct_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = player_struct_;
    player_struct_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RequestCreateSign::set_allocated_player_struct(::std::string* player_struct) {
  if (player_struct_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete player_struct_;
  }
  if (player_struct) {
    set_has_player_struct();
    player_struct_ = player_struct;
  } else {
    clear_has_player_struct();
    player_struct_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.RequestCreateSign.player_struct)
}

// -------------------------------------------------------------------

// RequestCreateSignResponse

// required uint32 sign_id = 1;
inline bool RequestCreateSignResponse::has_sign_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestCreateSignResponse::set_has_sign_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestCreateSignResponse::clear_has_sign_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestCreateSignResponse::clear_sign_id() {
  sign_id_ = 0u;
  clear_has_sign_id();
}
inline ::google::protobuf::uint32 RequestCreateSignResponse::sign_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestCreateSignResponse.sign_id)
  return sign_id_;
}
inline void RequestCreateSignResponse::set_sign_id(::google::protobuf::uint32 value) {
  set_has_sign_id();
  sign_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestCreateSignResponse.sign_id)
}

// -------------------------------------------------------------------

// RequestSummonSign

// required uint32 map_id = 1;
inline bool RequestSummonSign::has_map_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestSummonSign::set_has_map_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestSummonSign::clear_has_map_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestSummonSign::clear_map_id() {
  map_id_ = 0u;
  clear_has_map_id();
}
inline ::google::protobuf::uint32 RequestSummonSign::map_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestSummonSign.map_id)
  return map_id_;
}
inline void RequestSummonSign::set_map_id(::google::protobuf::uint32 value) {
  set_has_map_id();
  map_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestSummonSign.map_id)
}

// required uint32 online_area_id = 2;
inline bool RequestSummonSign::has_online_area_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestSummonSign::set_has_online_area_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestSummonSign::clear_has_online_area_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestSummonSign::clear_online_area_id() {
  online_area_id_ = 0u;
  clear_has_online_area_id();
}
inline ::google::protobuf::uint32 RequestSummonSign::online_area_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestSummonSign.online_area_id)
  return online_area_id_;
}
inline void RequestSummonSign::set_online_area_id(::google::protobuf::uint32 value) {
  set_has_online_area_id();
  online_area_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestSummonSign.online_area_id)
}

// required .DS3_Frpg2RequestMessage.SignInfo sign_info = 3;
inline bool RequestSummonSign::has_sign_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestSummonSign::set_has_sign_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestSummonSign::clear_has_sign_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestSummonSign::clear_sign_info() {
  if (sign_info_ != NULL) sign_info_->::DS3_Frpg2RequestMessage::SignInfo::Clear();
  clear_has_sign_info();
}
inline const ::DS3_Frpg2RequestMessage::SignInfo& RequestSummonSign::sign_info() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestSummonSign.sign_info)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return sign_info_ != NULL ? *sign_info_ : *default_instance().sign_info_;
#else
  return sign_info_ != NULL ? *sign_info_ : *default_instance_->sign_info_;
#endif
}
inline ::DS3_Frpg2RequestMessage::SignInfo* RequestSummonSign::mutable_sign_info() {
  set_has_sign_info();
  if (sign_info_ == NULL) sign_info_ = new ::DS3_Frpg2RequestMessage::SignInfo;
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.RequestSummonSign.sign_info)
  return sign_info_;
}
inline ::DS3_Frpg2RequestMessage::SignInfo* RequestSummonSign::release_sign_info() {
  clear_has_sign_info();
  ::DS3_Frpg2RequestMessage::SignInfo* temp = sign_info_;
  sign_info_ = NULL;
  return temp;
}
inline void RequestSummonSign::set_allocated_sign_info(::DS3_Frpg2RequestMessage::SignInfo* sign_info) {
  delete sign_info_;
  sign_info_ = sign_info;
  if (sign_info) {
    set_has_sign_info();
  } else {
    clear_has_sign_info();
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.RequestSummonSign.sign_info)
}

// required bytes player_struct = 4;
inline bool RequestSummonSign::has_player_struct() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestSummonSign::set_has_player_struct() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestSummonSign::clear_has_player_struct() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestSummonSign::clear_player_struct() {
  if (player_struct_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    player_struct_->clear();
  }
  clear_has_player_struct();
}
inline const ::std::string& RequestSummonSign::player_struct() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestSummonSign.player_struct)
  return *player_struct_;
}
inline void RequestSummonSign::set_player_struct(const ::std::string& value) {
  set_has_player_struct();
  if (player_struct_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    player_struct_ = new ::std::string;
  }
  player_struct_->assign(value);
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestSummonSign.player_struct)
}
inline void RequestSummonSign::set_player_struct(const char* value) {
  set_has_player_struct();
  if (player_struct_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    player_struct_ = new ::std::string;
  }
  player_struct_->assign(value);
  // @@protoc_insertion_point(field_set_char:DS3_Frpg2RequestMessage.RequestSummonSign.player_struct)
}
inline void RequestSummonSign::set_player_struct(const void* value, size_t size) {
  set_has_player_struct();
  if (player_struct_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    player_struct_ = new ::std::string;
  }
  player_struct_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DS3_Frpg2RequestMessage.RequestSummonSign.player_struct)
}
inline ::std::string* RequestSummonSign::mutable_player_struct() {
  set_has_player_struct();
  if (player_struct_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    player_struct_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.RequestSummonSign.player_struct)
  return player_struct_;
}
inline ::std::string* RequestSummonSign::release_player_struct() {
  clear_has_player_struct();
  if (player_struct_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = player_struct_;
    player_struct_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RequestSummonSign::set_allocated_player_struct(::std::string* player_struct) {
  if (player_struct_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete player_struct_;
  }
  if (player_struct) {
    set_has_player_struct();
    player_struct_ = player_struct;
  } else {
    clear_has_player_struct();
    player_struct_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.RequestSummonSign.player_struct)
}

// -------------------------------------------------------------------

// RequestSummonSignResponse

// -------------------------------------------------------------------

// RequestRemoveSign

// required uint32 map_id = 1;
inline bool RequestRemoveSign::has_map_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestRemoveSign::set_has_map_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestRemoveSign::clear_has_map_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestRemoveSign::clear_map_id() {
  map_id_ = 0u;
  clear_has_map_id();
}
inline ::google::protobuf::uint32 RequestRemoveSign::map_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestRemoveSign.map_id)
  return map_id_;
}
inline void RequestRemoveSign::set_map_id(::google::protobuf::uint32 value) {
  set_has_map_id();
  map_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestRemoveSign.map_id)
}

// required uint32 online_area_id = 2;
inline bool RequestRemoveSign::has_online_area_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestRemoveSign::set_has_online_area_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestRemoveSign::clear_has_online_area_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestRemoveSign::clear_online_area_id() {
  online_area_id_ = 0u;
  clear_has_online_area_id();
}
inline ::google::protobuf::uint32 RequestRemoveSign::online_area_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestRemoveSign.online_area_id)
  return online_area_id_;
}
inline void RequestRemoveSign::set_online_area_id(::google::protobuf::uint32 value) {
  set_has_online_area_id();
  online_area_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestRemoveSign.online_area_id)
}

// required uint32 sign_id = 3;
inline bool RequestRemoveSign::has_sign_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestRemoveSign::set_has_sign_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestRemoveSign::clear_has_sign_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestRemoveSign::clear_sign_id() {
  sign_id_ = 0u;
  clear_has_sign_id();
}
inline ::google::protobuf::uint32 RequestRemoveSign::sign_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestRemoveSign.sign_id)
  return sign_id_;
}
inline void RequestRemoveSign::set_sign_id(::google::protobuf::uint32 value) {
  set_has_sign_id();
  sign_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestRemoveSign.sign_id)
}

// -------------------------------------------------------------------

// RequestRemoveSignResponse

// -------------------------------------------------------------------

// RequestUpdateSign

// required uint32 map_id = 1;
inline bool RequestUpdateSign::has_map_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestUpdateSign::set_has_map_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestUpdateSign::clear_has_map_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestUpdateSign::clear_map_id() {
  map_id_ = 0u;
  clear_has_map_id();
}
inline ::google::protobuf::uint32 RequestUpdateSign::map_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestUpdateSign.map_id)
  return map_id_;
}
inline void RequestUpdateSign::set_map_id(::google::protobuf::uint32 value) {
  set_has_map_id();
  map_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestUpdateSign.map_id)
}

// required uint32 online_area_id = 2;
inline bool RequestUpdateSign::has_online_area_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestUpdateSign::set_has_online_area_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestUpdateSign::clear_has_online_area_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestUpdateSign::clear_online_area_id() {
  online_area_id_ = 0u;
  clear_has_online_area_id();
}
inline ::google::protobuf::uint32 RequestUpdateSign::online_area_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestUpdateSign.online_area_id)
  return online_area_id_;
}
inline void RequestUpdateSign::set_online_area_id(::google::protobuf::uint32 value) {
  set_has_online_area_id();
  online_area_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestUpdateSign.online_area_id)
}

// required uint32 sign_id = 3;
inline bool RequestUpdateSign::has_sign_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestUpdateSign::set_has_sign_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestUpdateSign::clear_has_sign_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestUpdateSign::clear_sign_id() {
  sign_id_ = 0u;
  clear_has_sign_id();
}
inline ::google::protobuf::uint32 RequestUpdateSign::sign_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestUpdateSign.sign_id)
  return sign_id_;
}
inline void RequestUpdateSign::set_sign_id(::google::protobuf::uint32 value) {
  set_has_sign_id();
  sign_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestUpdateSign.sign_id)
}

// -------------------------------------------------------------------

// RequestUpdateSignResponse

// -------------------------------------------------------------------

// RequestRejectSign

// required uint32 unknown_1 = 1;
inline bool RequestRejectSign::has_unknown_1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestRejectSign::set_has_unknown_1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestRejectSign::clear_has_unknown_1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestRejectSign::clear_unknown_1() {
  unknown_1_ = 0u;
  clear_has_unknown_1();
}
inline ::google::protobuf::uint32 RequestRejectSign::unknown_1() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestRejectSign.unknown_1)
  return unknown_1_;
}
inline void RequestRejectSign::set_unknown_1(::google::protobuf::uint32 value) {
  set_has_unknown_1();
  unknown_1_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestRejectSign.unknown_1)
}

// required uint32 unknown_2 = 2;
inline bool RequestRejectSign::has_unknown_2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestRejectSign::set_has_unknown_2() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestRejectSign::clear_has_unknown_2() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestRejectSign::clear_unknown_2() {
  unknown_2_ = 0u;
  clear_has_unknown_2();
}
inline ::google::protobuf::uint32 RequestRejectSign::unknown_2() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestRejectSign.unknown_2)
  return unknown_2_;
}
inline void RequestRejectSign::set_unknown_2(::google::protobuf::uint32 value) {
  set_has_unknown_2();
  unknown_2_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestRejectSign.unknown_2)
}

// required uint32 sign_id = 3;
inline bool RequestRejectSign::has_sign_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestRejectSign::set_has_sign_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestRejectSign::clear_has_sign_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestRejectSign::clear_sign_id() {
  sign_id_ = 0u;
  clear_has_sign_id();
}
inline ::google::protobuf::uint32 RequestRejectSign::sign_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestRejectSign.sign_id)
  return sign_id_;
}
inline void RequestRejectSign::set_sign_id(::google::protobuf::uint32 value) {
  set_has_sign_id();
  sign_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestRejectSign.sign_id)
}

// required bool unknown_4 = 4;
inline bool RequestRejectSign::has_unknown_4() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestRejectSign::set_has_unknown_4() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestRejectSign::clear_has_unknown_4() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestRejectSign::clear_unknown_4() {
  unknown_4_ = false;
  clear_has_unknown_4();
}
inline bool RequestRejectSign::unknown_4() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestRejectSign.unknown_4)
  return unknown_4_;
}
inline void RequestRejectSign::set_unknown_4(bool value) {
  set_has_unknown_4();
  unknown_4_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestRejectSign.unknown_4)
}

// required bool unknown_5 = 5;
inline bool RequestRejectSign::has_unknown_5() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RequestRejectSign::set_has_unknown_5() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RequestRejectSign::clear_has_unknown_5() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RequestRejectSign::clear_unknown_5() {
  unknown_5_ = false;
  clear_has_unknown_5();
}
inline bool RequestRejectSign::unknown_5() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestRejectSign.unknown_5)
  return unknown_5_;
}
inline void RequestRejectSign::set_unknown_5(bool value) {
  set_has_unknown_5();
  unknown_5_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestRejectSign.unknown_5)
}

// -------------------------------------------------------------------

// RequestRejectSignResponse

// -------------------------------------------------------------------

// RequestGetRightMatchingArea

// required .DS3_Frpg2RequestMessage.MatchingParameter matching_parameter = 1;
inline bool RequestGetRightMatchingArea::has_matching_parameter() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestGetRightMatchingArea::set_has_matching_parameter() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestGetRightMatchingArea::clear_has_matching_parameter() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestGetRightMatchingArea::clear_matching_parameter() {
  if (matching_parameter_ != NULL) matching_parameter_->::DS3_Frpg2RequestMessage::MatchingParameter::Clear();
  clear_has_matching_parameter();
}
inline const ::DS3_Frpg2RequestMessage::MatchingParameter& RequestGetRightMatchingArea::matching_parameter() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestGetRightMatchingArea.matching_parameter)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return matching_parameter_ != NULL ? *matching_parameter_ : *default_instance().matching_parameter_;
#else
  return matching_parameter_ != NULL ? *matching_parameter_ : *default_instance_->matching_parameter_;
#endif
}
inline ::DS3_Frpg2RequestMessage::MatchingParameter* RequestGetRightMatchingArea::mutable_matching_parameter() {
  set_has_matching_parameter();
  if (matching_parameter_ == NULL) matching_parameter_ = new ::DS3_Frpg2RequestMessage::MatchingParameter;
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.RequestGetRightMatchingArea.matching_parameter)
  return matching_parameter_;
}
inline ::DS3_Frpg2RequestMessage::MatchingParameter* RequestGetRightMatchingArea::release_matching_parameter() {
  clear_has_matching_parameter();
  ::DS3_Frpg2RequestMessage::MatchingParameter* temp = matching_parameter_;
  matching_parameter_ = NULL;
  return temp;
}
inline void RequestGetRightMatchingArea::set_allocated_matching_parameter(::DS3_Frpg2RequestMessage::MatchingParameter* matching_parameter) {
  delete matching_parameter_;
  matching_parameter_ = matching_parameter;
  if (matching_parameter) {
    set_has_matching_parameter();
  } else {
    clear_has_matching_parameter();
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.RequestGetRightMatchingArea.matching_parameter)
}

// required uint32 unknown = 2;
inline bool RequestGetRightMatchingArea::has_unknown() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestGetRightMatchingArea::set_has_unknown() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestGetRightMatchingArea::clear_has_unknown() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestGetRightMatchingArea::clear_unknown() {
  unknown_ = 0u;
  clear_has_unknown();
}
inline ::google::protobuf::uint32 RequestGetRightMatchingArea::unknown() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestGetRightMatchingArea.unknown)
  return unknown_;
}
inline void RequestGetRightMatchingArea::set_unknown(::google::protobuf::uint32 value) {
  set_has_unknown();
  unknown_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestGetRightMatchingArea.unknown)
}

// -------------------------------------------------------------------

// RequestGetRightMatchingAreaResponse_Area_info

// required uint32 online_area_id = 1;
inline bool RequestGetRightMatchingAreaResponse_Area_info::has_online_area_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestGetRightMatchingAreaResponse_Area_info::set_has_online_area_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestGetRightMatchingAreaResponse_Area_info::clear_has_online_area_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestGetRightMatchingAreaResponse_Area_info::clear_online_area_id() {
  online_area_id_ = 0u;
  clear_has_online_area_id();
}
inline ::google::protobuf::uint32 RequestGetRightMatchingAreaResponse_Area_info::online_area_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestGetRightMatchingAreaResponse.Area_info.online_area_id)
  return online_area_id_;
}
inline void RequestGetRightMatchingAreaResponse_Area_info::set_online_area_id(::google::protobuf::uint32 value) {
  set_has_online_area_id();
  online_area_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestGetRightMatchingAreaResponse.Area_info.online_area_id)
}

// required uint32 population = 2;
inline bool RequestGetRightMatchingAreaResponse_Area_info::has_population() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestGetRightMatchingAreaResponse_Area_info::set_has_population() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestGetRightMatchingAreaResponse_Area_info::clear_has_population() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestGetRightMatchingAreaResponse_Area_info::clear_population() {
  population_ = 0u;
  clear_has_population();
}
inline ::google::protobuf::uint32 RequestGetRightMatchingAreaResponse_Area_info::population() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestGetRightMatchingAreaResponse.Area_info.population)
  return population_;
}
inline void RequestGetRightMatchingAreaResponse_Area_info::set_population(::google::protobuf::uint32 value) {
  set_has_population();
  population_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestGetRightMatchingAreaResponse.Area_info.population)
}

// -------------------------------------------------------------------

// RequestGetRightMatchingAreaResponse

// repeated group Area_info = 1 {
inline int RequestGetRightMatchingAreaResponse::area_info_size() const {
  return area_info_.size();
}
inline void RequestGetRightMatchingAreaResponse::clear_area_info() {
  area_info_.Clear();
}
inline const ::DS3_Frpg2RequestMessage::RequestGetRightMatchingAreaResponse_Area_info& RequestGetRightMatchingAreaResponse::area_info(int index) const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestGetRightMatchingAreaResponse.area_info)
  return area_info_.Get(index);
}
inline ::DS3_Frpg2RequestMessage::RequestGetRightMatchingAreaResponse_Area_info* RequestGetRightMatchingAreaResponse::mutable_area_info(int index) {
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.RequestGetRightMatchingAreaResponse.area_info)
  return area_info_.Mutable(index);
}
inline ::DS3_Frpg2RequestMessage::RequestGetRightMatchingAreaResponse_Area_info* RequestGetRightMatchingAreaResponse::add_area_info() {
  // @@protoc_insertion_point(field_add:DS3_Frpg2RequestMessage.RequestGetRightMatchingAreaResponse.area_info)
  return area_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::RequestGetRightMatchingAreaResponse_Area_info >&
RequestGetRightMatchingAreaResponse::area_info() const {
  // @@protoc_insertion_point(field_list:DS3_Frpg2RequestMessage.RequestGetRightMatchingAreaResponse.area_info)
  return area_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::RequestGetRightMatchingAreaResponse_Area_info >*
RequestGetRightMatchingAreaResponse::mutable_area_info() {
  // @@protoc_insertion_point(field_mutable_list:DS3_Frpg2RequestMessage.RequestGetRightMatchingAreaResponse.area_info)
  return &area_info_;
}

// -------------------------------------------------------------------

// PushRequestRemoveSign

// required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
inline bool PushRequestRemoveSign::has_push_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PushRequestRemoveSign::set_has_push_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PushRequestRemoveSign::clear_has_push_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PushRequestRemoveSign::clear_push_message_id() {
  push_message_id_ = 829;
  clear_has_push_message_id();
}
inline ::DS3_Frpg2RequestMessage::PushMessageId PushRequestRemoveSign::push_message_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.PushRequestRemoveSign.push_message_id)
  return static_cast< ::DS3_Frpg2RequestMessage::PushMessageId >(push_message_id_);
}
inline void PushRequestRemoveSign::set_push_message_id(::DS3_Frpg2RequestMessage::PushMessageId value) {
  assert(::DS3_Frpg2RequestMessage::PushMessageId_IsValid(value));
  set_has_push_message_id();
  push_message_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.PushRequestRemoveSign.push_message_id)
}

// required .DS3_Frpg2RequestMessage.RemoveSignMessage message = 2;
inline bool PushRequestRemoveSign::has_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PushRequestRemoveSign::set_has_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PushRequestRemoveSign::clear_has_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PushRequestRemoveSign::clear_message() {
  if (message_ != NULL) message_->::DS3_Frpg2RequestMessage::RemoveSignMessage::Clear();
  clear_has_message();
}
inline const ::DS3_Frpg2RequestMessage::RemoveSignMessage& PushRequestRemoveSign::message() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.PushRequestRemoveSign.message)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return message_ != NULL ? *message_ : *default_instance().message_;
#else
  return message_ != NULL ? *message_ : *default_instance_->message_;
#endif
}
inline ::DS3_Frpg2RequestMessage::RemoveSignMessage* PushRequestRemoveSign::mutable_message() {
  set_has_message();
  if (message_ == NULL) message_ = new ::DS3_Frpg2RequestMessage::RemoveSignMessage;
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.PushRequestRemoveSign.message)
  return message_;
}
inline ::DS3_Frpg2RequestMessage::RemoveSignMessage* PushRequestRemoveSign::release_message() {
  clear_has_message();
  ::DS3_Frpg2RequestMessage::RemoveSignMessage* temp = message_;
  message_ = NULL;
  return temp;
}
inline void PushRequestRemoveSign::set_allocated_message(::DS3_Frpg2RequestMessage::RemoveSignMessage* message) {
  delete message_;
  message_ = message;
  if (message) {
    set_has_message();
  } else {
    clear_has_message();
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.PushRequestRemoveSign.message)
}

// -------------------------------------------------------------------

// PushRequestSummonSign

// required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
inline bool PushRequestSummonSign::has_push_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PushRequestSummonSign::set_has_push_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PushRequestSummonSign::clear_has_push_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PushRequestSummonSign::clear_push_message_id() {
  push_message_id_ = 829;
  clear_has_push_message_id();
}
inline ::DS3_Frpg2RequestMessage::PushMessageId PushRequestSummonSign::push_message_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.PushRequestSummonSign.push_message_id)
  return static_cast< ::DS3_Frpg2RequestMessage::PushMessageId >(push_message_id_);
}
inline void PushRequestSummonSign::set_push_message_id(::DS3_Frpg2RequestMessage::PushMessageId value) {
  assert(::DS3_Frpg2RequestMessage::PushMessageId_IsValid(value));
  set_has_push_message_id();
  push_message_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.PushRequestSummonSign.push_message_id)
}

// required .DS3_Frpg2RequestMessage.SummonSignMessage message = 2;
inline bool PushRequestSummonSign::has_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PushRequestSummonSign::set_has_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PushRequestSummonSign::clear_has_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PushRequestSummonSign::clear_message() {
  if (message_ != NULL) message_->::DS3_Frpg2RequestMessage::SummonSignMessage::Clear();
  clear_has_message();
}
inline const ::DS3_Frpg2RequestMessage::SummonSignMessage& PushRequestSummonSign::message() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.PushRequestSummonSign.message)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return message_ != NULL ? *message_ : *default_instance().message_;
#else
  return message_ != NULL ? *message_ : *default_instance_->message_;
#endif
}
inline ::DS3_Frpg2RequestMessage::SummonSignMessage* PushRequestSummonSign::mutable_message() {
  set_has_message();
  if (message_ == NULL) message_ = new ::DS3_Frpg2RequestMessage::SummonSignMessage;
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.PushRequestSummonSign.message)
  return message_;
}
inline ::DS3_Frpg2RequestMessage::SummonSignMessage* PushRequestSummonSign::release_message() {
  clear_has_message();
  ::DS3_Frpg2RequestMessage::SummonSignMessage* temp = message_;
  message_ = NULL;
  return temp;
}
inline void PushRequestSummonSign::set_allocated_message(::DS3_Frpg2RequestMessage::SummonSignMessage* message) {
  delete message_;
  message_ = message;
  if (message) {
    set_has_message();
  } else {
    clear_has_message();
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.PushRequestSummonSign.message)
}

// -------------------------------------------------------------------

// PushRequestRejectSign

// required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
inline bool PushRequestRejectSign::has_push_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PushRequestRejectSign::set_has_push_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PushRequestRejectSign::clear_has_push_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PushRequestRejectSign::clear_push_message_id() {
  push_message_id_ = 829;
  clear_has_push_message_id();
}
inline ::DS3_Frpg2RequestMessage::PushMessageId PushRequestRejectSign::push_message_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.PushRequestRejectSign.push_message_id)
  return static_cast< ::DS3_Frpg2RequestMessage::PushMessageId >(push_message_id_);
}
inline void PushRequestRejectSign::set_push_message_id(::DS3_Frpg2RequestMessage::PushMessageId value) {
  assert(::DS3_Frpg2RequestMessage::PushMessageId_IsValid(value));
  set_has_push_message_id();
  push_message_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.PushRequestRejectSign.push_message_id)
}

// required .DS3_Frpg2RequestMessage.RejectSignMessage message = 2;
inline bool PushRequestRejectSign::has_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PushRequestRejectSign::set_has_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PushRequestRejectSign::clear_has_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PushRequestRejectSign::clear_message() {
  if (message_ != NULL) message_->::DS3_Frpg2RequestMessage::RejectSignMessage::Clear();
  clear_has_message();
}
inline const ::DS3_Frpg2RequestMessage::RejectSignMessage& PushRequestRejectSign::message() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.PushRequestRejectSign.message)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return message_ != NULL ? *message_ : *default_instance().message_;
#else
  return message_ != NULL ? *message_ : *default_instance_->message_;
#endif
}
inline ::DS3_Frpg2RequestMessage::RejectSignMessage* PushRequestRejectSign::mutable_message() {
  set_has_message();
  if (message_ == NULL) message_ = new ::DS3_Frpg2RequestMessage::RejectSignMessage;
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.PushRequestRejectSign.message)
  return message_;
}
inline ::DS3_Frpg2RequestMessage::RejectSignMessage* PushRequestRejectSign::release_message() {
  clear_has_message();
  ::DS3_Frpg2RequestMessage::RejectSignMessage* temp = message_;
  message_ = NULL;
  return temp;
}
inline void PushRequestRejectSign::set_allocated_message(::DS3_Frpg2RequestMessage::RejectSignMessage* message) {
  delete message_;
  message_ = message;
  if (message) {
    set_has_message();
  } else {
    clear_has_message();
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.PushRequestRejectSign.message)
}

// -------------------------------------------------------------------

// BreakInTargetData

// required uint32 player_id = 1;
inline bool BreakInTargetData::has_player_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BreakInTargetData::set_has_player_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BreakInTargetData::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BreakInTargetData::clear_player_id() {
  player_id_ = 0u;
  clear_has_player_id();
}
inline ::google::protobuf::uint32 BreakInTargetData::player_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.BreakInTargetData.player_id)
  return player_id_;
}
inline void BreakInTargetData::set_player_id(::google::protobuf::uint32 value) {
  set_has_player_id();
  player_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.BreakInTargetData.player_id)
}

// required string steam_id = 2;
inline bool BreakInTargetData::has_steam_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BreakInTargetData::set_has_steam_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BreakInTargetData::clear_has_steam_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BreakInTargetData::clear_steam_id() {
  if (steam_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    steam_id_->clear();
  }
  clear_has_steam_id();
}
inline const ::std::string& BreakInTargetData::steam_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.BreakInTargetData.steam_id)
  return *steam_id_;
}
inline void BreakInTargetData::set_steam_id(const ::std::string& value) {
  set_has_steam_id();
  if (steam_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    steam_id_ = new ::std::string;
  }
  steam_id_->assign(value);
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.BreakInTargetData.steam_id)
}
inline void BreakInTargetData::set_steam_id(const char* value) {
  set_has_steam_id();
  if (steam_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    steam_id_ = new ::std::string;
  }
  steam_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:DS3_Frpg2RequestMessage.BreakInTargetData.steam_id)
}
inline void BreakInTargetData::set_steam_id(const char* value, size_t size) {
  set_has_steam_id();
  if (steam_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    steam_id_ = new ::std::string;
  }
  steam_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DS3_Frpg2RequestMessage.BreakInTargetData.steam_id)
}
inline ::std::string* BreakInTargetData::mutable_steam_id() {
  set_has_steam_id();
  if (steam_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    steam_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.BreakInTargetData.steam_id)
  return steam_id_;
}
inline ::std::string* BreakInTargetData::release_steam_id() {
  clear_has_steam_id();
  if (steam_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = steam_id_;
    steam_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void BreakInTargetData::set_allocated_steam_id(::std::string* steam_id) {
  if (steam_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete steam_id_;
  }
  if (steam_id) {
    set_has_steam_id();
    steam_id_ = steam_id;
  } else {
    clear_has_steam_id();
    steam_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.BreakInTargetData.steam_id)
}

// -------------------------------------------------------------------

// RequestGetBreakInTargetList

// required uint32 map_id = 1;
inline bool RequestGetBreakInTargetList::has_map_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestGetBreakInTargetList::set_has_map_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestGetBreakInTargetList::clear_has_map_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestGetBreakInTargetList::clear_map_id() {
  map_id_ = 0u;
  clear_has_map_id();
}
inline ::google::protobuf::uint32 RequestGetBreakInTargetList::map_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestGetBreakInTargetList.map_id)
  return map_id_;
}
inline void RequestGetBreakInTargetList::set_map_id(::google::protobuf::uint32 value) {
  set_has_map_id();
  map_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestGetBreakInTargetList.map_id)
}

// required uint32 online_area_id = 2;
inline bool RequestGetBreakInTargetList::has_online_area_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestGetBreakInTargetList::set_has_online_area_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestGetBreakInTargetList::clear_has_online_area_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestGetBreakInTargetList::clear_online_area_id() {
  online_area_id_ = 0u;
  clear_has_online_area_id();
}
inline ::google::protobuf::uint32 RequestGetBreakInTargetList::online_area_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestGetBreakInTargetList.online_area_id)
  return online_area_id_;
}
inline void RequestGetBreakInTargetList::set_online_area_id(::google::protobuf::uint32 value) {
  set_has_online_area_id();
  online_area_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestGetBreakInTargetList.online_area_id)
}

// required uint32 max_targets = 3;
inline bool RequestGetBreakInTargetList::has_max_targets() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestGetBreakInTargetList::set_has_max_targets() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestGetBreakInTargetList::clear_has_max_targets() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestGetBreakInTargetList::clear_max_targets() {
  max_targets_ = 0u;
  clear_has_max_targets();
}
inline ::google::protobuf::uint32 RequestGetBreakInTargetList::max_targets() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestGetBreakInTargetList.max_targets)
  return max_targets_;
}
inline void RequestGetBreakInTargetList::set_max_targets(::google::protobuf::uint32 value) {
  set_has_max_targets();
  max_targets_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestGetBreakInTargetList.max_targets)
}

// required .DS3_Frpg2RequestMessage.MatchingParameter matching_parameter = 4;
inline bool RequestGetBreakInTargetList::has_matching_parameter() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestGetBreakInTargetList::set_has_matching_parameter() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestGetBreakInTargetList::clear_has_matching_parameter() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestGetBreakInTargetList::clear_matching_parameter() {
  if (matching_parameter_ != NULL) matching_parameter_->::DS3_Frpg2RequestMessage::MatchingParameter::Clear();
  clear_has_matching_parameter();
}
inline const ::DS3_Frpg2RequestMessage::MatchingParameter& RequestGetBreakInTargetList::matching_parameter() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestGetBreakInTargetList.matching_parameter)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return matching_parameter_ != NULL ? *matching_parameter_ : *default_instance().matching_parameter_;
#else
  return matching_parameter_ != NULL ? *matching_parameter_ : *default_instance_->matching_parameter_;
#endif
}
inline ::DS3_Frpg2RequestMessage::MatchingParameter* RequestGetBreakInTargetList::mutable_matching_parameter() {
  set_has_matching_parameter();
  if (matching_parameter_ == NULL) matching_parameter_ = new ::DS3_Frpg2RequestMessage::MatchingParameter;
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.RequestGetBreakInTargetList.matching_parameter)
  return matching_parameter_;
}
inline ::DS3_Frpg2RequestMessage::MatchingParameter* RequestGetBreakInTargetList::release_matching_parameter() {
  clear_has_matching_parameter();
  ::DS3_Frpg2RequestMessage::MatchingParameter* temp = matching_parameter_;
  matching_parameter_ = NULL;
  return temp;
}
inline void RequestGetBreakInTargetList::set_allocated_matching_parameter(::DS3_Frpg2RequestMessage::MatchingParameter* matching_parameter) {
  delete matching_parameter_;
  matching_parameter_ = matching_parameter;
  if (matching_parameter) {
    set_has_matching_parameter();
  } else {
    clear_has_matching_parameter();
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.RequestGetBreakInTargetList.matching_parameter)
}

// required uint32 unknown_5 = 5;
inline bool RequestGetBreakInTargetList::has_unknown_5() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RequestGetBreakInTargetList::set_has_unknown_5() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RequestGetBreakInTargetList::clear_has_unknown_5() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RequestGetBreakInTargetList::clear_unknown_5() {
  unknown_5_ = 0u;
  clear_has_unknown_5();
}
inline ::google::protobuf::uint32 RequestGetBreakInTargetList::unknown_5() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestGetBreakInTargetList.unknown_5)
  return unknown_5_;
}
inline void RequestGetBreakInTargetList::set_unknown_5(::google::protobuf::uint32 value) {
  set_has_unknown_5();
  unknown_5_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestGetBreakInTargetList.unknown_5)
}

// -------------------------------------------------------------------

// RequestGetBreakInTargetListResponse

// optional uint32 map_id = 1;
inline bool RequestGetBreakInTargetListResponse::has_map_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestGetBreakInTargetListResponse::set_has_map_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestGetBreakInTargetListResponse::clear_has_map_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestGetBreakInTargetListResponse::clear_map_id() {
  map_id_ = 0u;
  clear_has_map_id();
}
inline ::google::protobuf::uint32 RequestGetBreakInTargetListResponse::map_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestGetBreakInTargetListResponse.map_id)
  return map_id_;
}
inline void RequestGetBreakInTargetListResponse::set_map_id(::google::protobuf::uint32 value) {
  set_has_map_id();
  map_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestGetBreakInTargetListResponse.map_id)
}

// optional uint32 online_area_id = 2;
inline bool RequestGetBreakInTargetListResponse::has_online_area_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestGetBreakInTargetListResponse::set_has_online_area_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestGetBreakInTargetListResponse::clear_has_online_area_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestGetBreakInTargetListResponse::clear_online_area_id() {
  online_area_id_ = 0u;
  clear_has_online_area_id();
}
inline ::google::protobuf::uint32 RequestGetBreakInTargetListResponse::online_area_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestGetBreakInTargetListResponse.online_area_id)
  return online_area_id_;
}
inline void RequestGetBreakInTargetListResponse::set_online_area_id(::google::protobuf::uint32 value) {
  set_has_online_area_id();
  online_area_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestGetBreakInTargetListResponse.online_area_id)
}

// repeated .DS3_Frpg2RequestMessage.BreakInTargetData target_data = 3;
inline int RequestGetBreakInTargetListResponse::target_data_size() const {
  return target_data_.size();
}
inline void RequestGetBreakInTargetListResponse::clear_target_data() {
  target_data_.Clear();
}
inline const ::DS3_Frpg2RequestMessage::BreakInTargetData& RequestGetBreakInTargetListResponse::target_data(int index) const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestGetBreakInTargetListResponse.target_data)
  return target_data_.Get(index);
}
inline ::DS3_Frpg2RequestMessage::BreakInTargetData* RequestGetBreakInTargetListResponse::mutable_target_data(int index) {
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.RequestGetBreakInTargetListResponse.target_data)
  return target_data_.Mutable(index);
}
inline ::DS3_Frpg2RequestMessage::BreakInTargetData* RequestGetBreakInTargetListResponse::add_target_data() {
  // @@protoc_insertion_point(field_add:DS3_Frpg2RequestMessage.RequestGetBreakInTargetListResponse.target_data)
  return target_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::BreakInTargetData >&
RequestGetBreakInTargetListResponse::target_data() const {
  // @@protoc_insertion_point(field_list:DS3_Frpg2RequestMessage.RequestGetBreakInTargetListResponse.target_data)
  return target_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::BreakInTargetData >*
RequestGetBreakInTargetListResponse::mutable_target_data() {
  // @@protoc_insertion_point(field_mutable_list:DS3_Frpg2RequestMessage.RequestGetBreakInTargetListResponse.target_data)
  return &target_data_;
}

// -------------------------------------------------------------------

// PushRequestAllowBreakInTarget

// required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
inline bool PushRequestAllowBreakInTarget::has_push_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PushRequestAllowBreakInTarget::set_has_push_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PushRequestAllowBreakInTarget::clear_has_push_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PushRequestAllowBreakInTarget::clear_push_message_id() {
  push_message_id_ = 829;
  clear_has_push_message_id();
}
inline ::DS3_Frpg2RequestMessage::PushMessageId PushRequestAllowBreakInTarget::push_message_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.PushRequestAllowBreakInTarget.push_message_id)
  return static_cast< ::DS3_Frpg2RequestMessage::PushMessageId >(push_message_id_);
}
inline void PushRequestAllowBreakInTarget::set_push_message_id(::DS3_Frpg2RequestMessage::PushMessageId value) {
  assert(::DS3_Frpg2RequestMessage::PushMessageId_IsValid(value));
  set_has_push_message_id();
  push_message_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.PushRequestAllowBreakInTarget.push_message_id)
}

// required uint32 player_id = 2;
inline bool PushRequestAllowBreakInTarget::has_player_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PushRequestAllowBreakInTarget::set_has_player_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PushRequestAllowBreakInTarget::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PushRequestAllowBreakInTarget::clear_player_id() {
  player_id_ = 0u;
  clear_has_player_id();
}
inline ::google::protobuf::uint32 PushRequestAllowBreakInTarget::player_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.PushRequestAllowBreakInTarget.player_id)
  return player_id_;
}
inline void PushRequestAllowBreakInTarget::set_player_id(::google::protobuf::uint32 value) {
  set_has_player_id();
  player_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.PushRequestAllowBreakInTarget.player_id)
}

// required bytes player_struct = 3;
inline bool PushRequestAllowBreakInTarget::has_player_struct() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PushRequestAllowBreakInTarget::set_has_player_struct() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PushRequestAllowBreakInTarget::clear_has_player_struct() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PushRequestAllowBreakInTarget::clear_player_struct() {
  if (player_struct_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    player_struct_->clear();
  }
  clear_has_player_struct();
}
inline const ::std::string& PushRequestAllowBreakInTarget::player_struct() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.PushRequestAllowBreakInTarget.player_struct)
  return *player_struct_;
}
inline void PushRequestAllowBreakInTarget::set_player_struct(const ::std::string& value) {
  set_has_player_struct();
  if (player_struct_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    player_struct_ = new ::std::string;
  }
  player_struct_->assign(value);
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.PushRequestAllowBreakInTarget.player_struct)
}
inline void PushRequestAllowBreakInTarget::set_player_struct(const char* value) {
  set_has_player_struct();
  if (player_struct_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    player_struct_ = new ::std::string;
  }
  player_struct_->assign(value);
  // @@protoc_insertion_point(field_set_char:DS3_Frpg2RequestMessage.PushRequestAllowBreakInTarget.player_struct)
}
inline void PushRequestAllowBreakInTarget::set_player_struct(const void* value, size_t size) {
  set_has_player_struct();
  if (player_struct_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    player_struct_ = new ::std::string;
  }
  player_struct_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DS3_Frpg2RequestMessage.PushRequestAllowBreakInTarget.player_struct)
}
inline ::std::string* PushRequestAllowBreakInTarget::mutable_player_struct() {
  set_has_player_struct();
  if (player_struct_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    player_struct_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.PushRequestAllowBreakInTarget.player_struct)
  return player_struct_;
}
inline ::std::string* PushRequestAllowBreakInTarget::release_player_struct() {
  clear_has_player_struct();
  if (player_struct_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = player_struct_;
    player_struct_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PushRequestAllowBreakInTarget::set_allocated_player_struct(::std::string* player_struct) {
  if (player_struct_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete player_struct_;
  }
  if (player_struct) {
    set_has_player_struct();
    player_struct_ = player_struct;
  } else {
    clear_has_player_struct();
    player_struct_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.PushRequestAllowBreakInTarget.player_struct)
}

// required uint32 unknown_4 = 4;
inline bool PushRequestAllowBreakInTarget::has_unknown_4() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PushRequestAllowBreakInTarget::set_has_unknown_4() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PushRequestAllowBreakInTarget::clear_has_unknown_4() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PushRequestAllowBreakInTarget::clear_unknown_4() {
  unknown_4_ = 0u;
  clear_has_unknown_4();
}
inline ::google::protobuf::uint32 PushRequestAllowBreakInTarget::unknown_4() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.PushRequestAllowBreakInTarget.unknown_4)
  return unknown_4_;
}
inline void PushRequestAllowBreakInTarget::set_unknown_4(::google::protobuf::uint32 value) {
  set_has_unknown_4();
  unknown_4_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.PushRequestAllowBreakInTarget.unknown_4)
}

// -------------------------------------------------------------------

// PushRequestBreakInTarget

// required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
inline bool PushRequestBreakInTarget::has_push_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PushRequestBreakInTarget::set_has_push_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PushRequestBreakInTarget::clear_has_push_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PushRequestBreakInTarget::clear_push_message_id() {
  push_message_id_ = 829;
  clear_has_push_message_id();
}
inline ::DS3_Frpg2RequestMessage::PushMessageId PushRequestBreakInTarget::push_message_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.PushRequestBreakInTarget.push_message_id)
  return static_cast< ::DS3_Frpg2RequestMessage::PushMessageId >(push_message_id_);
}
inline void PushRequestBreakInTarget::set_push_message_id(::DS3_Frpg2RequestMessage::PushMessageId value) {
  assert(::DS3_Frpg2RequestMessage::PushMessageId_IsValid(value));
  set_has_push_message_id();
  push_message_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.PushRequestBreakInTarget.push_message_id)
}

// required uint32 player_id = 2;
inline bool PushRequestBreakInTarget::has_player_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PushRequestBreakInTarget::set_has_player_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PushRequestBreakInTarget::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PushRequestBreakInTarget::clear_player_id() {
  player_id_ = 0u;
  clear_has_player_id();
}
inline ::google::protobuf::uint32 PushRequestBreakInTarget::player_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.PushRequestBreakInTarget.player_id)
  return player_id_;
}
inline void PushRequestBreakInTarget::set_player_id(::google::protobuf::uint32 value) {
  set_has_player_id();
  player_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.PushRequestBreakInTarget.player_id)
}

// required string steam_id = 3;
inline bool PushRequestBreakInTarget::has_steam_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PushRequestBreakInTarget::set_has_steam_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PushRequestBreakInTarget::clear_has_steam_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PushRequestBreakInTarget::clear_steam_id() {
  if (steam_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    steam_id_->clear();
  }
  clear_has_steam_id();
}
inline const ::std::string& PushRequestBreakInTarget::steam_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.PushRequestBreakInTarget.steam_id)
  return *steam_id_;
}
inline void PushRequestBreakInTarget::set_steam_id(const ::std::string& value) {
  set_has_steam_id();
  if (steam_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    steam_id_ = new ::std::string;
  }
  steam_id_->assign(value);
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.PushRequestBreakInTarget.steam_id)
}
inline void PushRequestBreakInTarget::set_steam_id(const char* value) {
  set_has_steam_id();
  if (steam_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    steam_id_ = new ::std::string;
  }
  steam_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:DS3_Frpg2RequestMessage.PushRequestBreakInTarget.steam_id)
}
inline void PushRequestBreakInTarget::set_steam_id(const char* value, size_t size) {
  set_has_steam_id();
  if (steam_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    steam_id_ = new ::std::string;
  }
  steam_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DS3_Frpg2RequestMessage.PushRequestBreakInTarget.steam_id)
}
inline ::std::string* PushRequestBreakInTarget::mutable_steam_id() {
  set_has_steam_id();
  if (steam_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    steam_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.PushRequestBreakInTarget.steam_id)
  return steam_id_;
}
inline ::std::string* PushRequestBreakInTarget::release_steam_id() {
  clear_has_steam_id();
  if (steam_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = steam_id_;
    steam_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PushRequestBreakInTarget::set_allocated_steam_id(::std::string* steam_id) {
  if (steam_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete steam_id_;
  }
  if (steam_id) {
    set_has_steam_id();
    steam_id_ = steam_id;
  } else {
    clear_has_steam_id();
    steam_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.PushRequestBreakInTarget.steam_id)
}

// required uint32 unknown_4 = 4;
inline bool PushRequestBreakInTarget::has_unknown_4() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PushRequestBreakInTarget::set_has_unknown_4() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PushRequestBreakInTarget::clear_has_unknown_4() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PushRequestBreakInTarget::clear_unknown_4() {
  unknown_4_ = 0u;
  clear_has_unknown_4();
}
inline ::google::protobuf::uint32 PushRequestBreakInTarget::unknown_4() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.PushRequestBreakInTarget.unknown_4)
  return unknown_4_;
}
inline void PushRequestBreakInTarget::set_unknown_4(::google::protobuf::uint32 value) {
  set_has_unknown_4();
  unknown_4_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.PushRequestBreakInTarget.unknown_4)
}

// required uint32 map_id = 5;
inline bool PushRequestBreakInTarget::has_map_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PushRequestBreakInTarget::set_has_map_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PushRequestBreakInTarget::clear_has_map_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PushRequestBreakInTarget::clear_map_id() {
  map_id_ = 0u;
  clear_has_map_id();
}
inline ::google::protobuf::uint32 PushRequestBreakInTarget::map_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.PushRequestBreakInTarget.map_id)
  return map_id_;
}
inline void PushRequestBreakInTarget::set_map_id(::google::protobuf::uint32 value) {
  set_has_map_id();
  map_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.PushRequestBreakInTarget.map_id)
}

// required uint32 online_area_id = 6;
inline bool PushRequestBreakInTarget::has_online_area_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PushRequestBreakInTarget::set_has_online_area_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PushRequestBreakInTarget::clear_has_online_area_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PushRequestBreakInTarget::clear_online_area_id() {
  online_area_id_ = 0u;
  clear_has_online_area_id();
}
inline ::google::protobuf::uint32 PushRequestBreakInTarget::online_area_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.PushRequestBreakInTarget.online_area_id)
  return online_area_id_;
}
inline void PushRequestBreakInTarget::set_online_area_id(::google::protobuf::uint32 value) {
  set_has_online_area_id();
  online_area_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.PushRequestBreakInTarget.online_area_id)
}

// -------------------------------------------------------------------

// PushRequestRemoveBreakInTarget

// required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
inline bool PushRequestRemoveBreakInTarget::has_push_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PushRequestRemoveBreakInTarget::set_has_push_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PushRequestRemoveBreakInTarget::clear_has_push_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PushRequestRemoveBreakInTarget::clear_push_message_id() {
  push_message_id_ = 829;
  clear_has_push_message_id();
}
inline ::DS3_Frpg2RequestMessage::PushMessageId PushRequestRemoveBreakInTarget::push_message_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.PushRequestRemoveBreakInTarget.push_message_id)
  return static_cast< ::DS3_Frpg2RequestMessage::PushMessageId >(push_message_id_);
}
inline void PushRequestRemoveBreakInTarget::set_push_message_id(::DS3_Frpg2RequestMessage::PushMessageId value) {
  assert(::DS3_Frpg2RequestMessage::PushMessageId_IsValid(value));
  set_has_push_message_id();
  push_message_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.PushRequestRemoveBreakInTarget.push_message_id)
}

// required uint32 unknown_2 = 2;
inline bool PushRequestRemoveBreakInTarget::has_unknown_2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PushRequestRemoveBreakInTarget::set_has_unknown_2() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PushRequestRemoveBreakInTarget::clear_has_unknown_2() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PushRequestRemoveBreakInTarget::clear_unknown_2() {
  unknown_2_ = 0u;
  clear_has_unknown_2();
}
inline ::google::protobuf::uint32 PushRequestRemoveBreakInTarget::unknown_2() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.PushRequestRemoveBreakInTarget.unknown_2)
  return unknown_2_;
}
inline void PushRequestRemoveBreakInTarget::set_unknown_2(::google::protobuf::uint32 value) {
  set_has_unknown_2();
  unknown_2_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.PushRequestRemoveBreakInTarget.unknown_2)
}

// required string unknown_3 = 3;
inline bool PushRequestRemoveBreakInTarget::has_unknown_3() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PushRequestRemoveBreakInTarget::set_has_unknown_3() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PushRequestRemoveBreakInTarget::clear_has_unknown_3() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PushRequestRemoveBreakInTarget::clear_unknown_3() {
  if (unknown_3_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unknown_3_->clear();
  }
  clear_has_unknown_3();
}
inline const ::std::string& PushRequestRemoveBreakInTarget::unknown_3() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.PushRequestRemoveBreakInTarget.unknown_3)
  return *unknown_3_;
}
inline void PushRequestRemoveBreakInTarget::set_unknown_3(const ::std::string& value) {
  set_has_unknown_3();
  if (unknown_3_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unknown_3_ = new ::std::string;
  }
  unknown_3_->assign(value);
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.PushRequestRemoveBreakInTarget.unknown_3)
}
inline void PushRequestRemoveBreakInTarget::set_unknown_3(const char* value) {
  set_has_unknown_3();
  if (unknown_3_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unknown_3_ = new ::std::string;
  }
  unknown_3_->assign(value);
  // @@protoc_insertion_point(field_set_char:DS3_Frpg2RequestMessage.PushRequestRemoveBreakInTarget.unknown_3)
}
inline void PushRequestRemoveBreakInTarget::set_unknown_3(const char* value, size_t size) {
  set_has_unknown_3();
  if (unknown_3_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unknown_3_ = new ::std::string;
  }
  unknown_3_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DS3_Frpg2RequestMessage.PushRequestRemoveBreakInTarget.unknown_3)
}
inline ::std::string* PushRequestRemoveBreakInTarget::mutable_unknown_3() {
  set_has_unknown_3();
  if (unknown_3_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unknown_3_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.PushRequestRemoveBreakInTarget.unknown_3)
  return unknown_3_;
}
inline ::std::string* PushRequestRemoveBreakInTarget::release_unknown_3() {
  clear_has_unknown_3();
  if (unknown_3_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = unknown_3_;
    unknown_3_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PushRequestRemoveBreakInTarget::set_allocated_unknown_3(::std::string* unknown_3) {
  if (unknown_3_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete unknown_3_;
  }
  if (unknown_3) {
    set_has_unknown_3();
    unknown_3_ = unknown_3;
  } else {
    clear_has_unknown_3();
    unknown_3_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.PushRequestRemoveBreakInTarget.unknown_3)
}

// required uint32 unknown_4 = 4;
inline bool PushRequestRemoveBreakInTarget::has_unknown_4() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PushRequestRemoveBreakInTarget::set_has_unknown_4() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PushRequestRemoveBreakInTarget::clear_has_unknown_4() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PushRequestRemoveBreakInTarget::clear_unknown_4() {
  unknown_4_ = 0u;
  clear_has_unknown_4();
}
inline ::google::protobuf::uint32 PushRequestRemoveBreakInTarget::unknown_4() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.PushRequestRemoveBreakInTarget.unknown_4)
  return unknown_4_;
}
inline void PushRequestRemoveBreakInTarget::set_unknown_4(::google::protobuf::uint32 value) {
  set_has_unknown_4();
  unknown_4_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.PushRequestRemoveBreakInTarget.unknown_4)
}

// -------------------------------------------------------------------

// RequestBreakInTarget

// required uint32 map_id = 1;
inline bool RequestBreakInTarget::has_map_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestBreakInTarget::set_has_map_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestBreakInTarget::clear_has_map_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestBreakInTarget::clear_map_id() {
  map_id_ = 0u;
  clear_has_map_id();
}
inline ::google::protobuf::uint32 RequestBreakInTarget::map_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestBreakInTarget.map_id)
  return map_id_;
}
inline void RequestBreakInTarget::set_map_id(::google::protobuf::uint32 value) {
  set_has_map_id();
  map_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestBreakInTarget.map_id)
}

// required uint32 online_area_id = 2;
inline bool RequestBreakInTarget::has_online_area_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestBreakInTarget::set_has_online_area_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestBreakInTarget::clear_has_online_area_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestBreakInTarget::clear_online_area_id() {
  online_area_id_ = 0u;
  clear_has_online_area_id();
}
inline ::google::protobuf::uint32 RequestBreakInTarget::online_area_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestBreakInTarget.online_area_id)
  return online_area_id_;
}
inline void RequestBreakInTarget::set_online_area_id(::google::protobuf::uint32 value) {
  set_has_online_area_id();
  online_area_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestBreakInTarget.online_area_id)
}

// required uint32 player_id = 3;
inline bool RequestBreakInTarget::has_player_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestBreakInTarget::set_has_player_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestBreakInTarget::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestBreakInTarget::clear_player_id() {
  player_id_ = 0u;
  clear_has_player_id();
}
inline ::google::protobuf::uint32 RequestBreakInTarget::player_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestBreakInTarget.player_id)
  return player_id_;
}
inline void RequestBreakInTarget::set_player_id(::google::protobuf::uint32 value) {
  set_has_player_id();
  player_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestBreakInTarget.player_id)
}

// required uint32 unknown_4 = 4;
inline bool RequestBreakInTarget::has_unknown_4() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestBreakInTarget::set_has_unknown_4() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestBreakInTarget::clear_has_unknown_4() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestBreakInTarget::clear_unknown_4() {
  unknown_4_ = 0u;
  clear_has_unknown_4();
}
inline ::google::protobuf::uint32 RequestBreakInTarget::unknown_4() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestBreakInTarget.unknown_4)
  return unknown_4_;
}
inline void RequestBreakInTarget::set_unknown_4(::google::protobuf::uint32 value) {
  set_has_unknown_4();
  unknown_4_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestBreakInTarget.unknown_4)
}

// -------------------------------------------------------------------

// RequestRejectBreakInTarget

// required uint32 player_id = 1;
inline bool RequestRejectBreakInTarget::has_player_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestRejectBreakInTarget::set_has_player_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestRejectBreakInTarget::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestRejectBreakInTarget::clear_player_id() {
  player_id_ = 0u;
  clear_has_player_id();
}
inline ::google::protobuf::uint32 RequestRejectBreakInTarget::player_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestRejectBreakInTarget.player_id)
  return player_id_;
}
inline void RequestRejectBreakInTarget::set_player_id(::google::protobuf::uint32 value) {
  set_has_player_id();
  player_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestRejectBreakInTarget.player_id)
}

// required uint32 unknown_2 = 2;
inline bool RequestRejectBreakInTarget::has_unknown_2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestRejectBreakInTarget::set_has_unknown_2() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestRejectBreakInTarget::clear_has_unknown_2() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestRejectBreakInTarget::clear_unknown_2() {
  unknown_2_ = 0u;
  clear_has_unknown_2();
}
inline ::google::protobuf::uint32 RequestRejectBreakInTarget::unknown_2() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestRejectBreakInTarget.unknown_2)
  return unknown_2_;
}
inline void RequestRejectBreakInTarget::set_unknown_2(::google::protobuf::uint32 value) {
  set_has_unknown_2();
  unknown_2_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestRejectBreakInTarget.unknown_2)
}

// required uint32 map_id = 3;
inline bool RequestRejectBreakInTarget::has_map_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestRejectBreakInTarget::set_has_map_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestRejectBreakInTarget::clear_has_map_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestRejectBreakInTarget::clear_map_id() {
  map_id_ = 0u;
  clear_has_map_id();
}
inline ::google::protobuf::uint32 RequestRejectBreakInTarget::map_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestRejectBreakInTarget.map_id)
  return map_id_;
}
inline void RequestRejectBreakInTarget::set_map_id(::google::protobuf::uint32 value) {
  set_has_map_id();
  map_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestRejectBreakInTarget.map_id)
}

// required uint32 online_area_id = 4;
inline bool RequestRejectBreakInTarget::has_online_area_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestRejectBreakInTarget::set_has_online_area_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestRejectBreakInTarget::clear_has_online_area_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestRejectBreakInTarget::clear_online_area_id() {
  online_area_id_ = 0u;
  clear_has_online_area_id();
}
inline ::google::protobuf::uint32 RequestRejectBreakInTarget::online_area_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestRejectBreakInTarget.online_area_id)
  return online_area_id_;
}
inline void RequestRejectBreakInTarget::set_online_area_id(::google::protobuf::uint32 value) {
  set_has_online_area_id();
  online_area_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestRejectBreakInTarget.online_area_id)
}

// required uint32 unknown_5 = 5;
inline bool RequestRejectBreakInTarget::has_unknown_5() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RequestRejectBreakInTarget::set_has_unknown_5() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RequestRejectBreakInTarget::clear_has_unknown_5() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RequestRejectBreakInTarget::clear_unknown_5() {
  unknown_5_ = 0u;
  clear_has_unknown_5();
}
inline ::google::protobuf::uint32 RequestRejectBreakInTarget::unknown_5() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestRejectBreakInTarget.unknown_5)
  return unknown_5_;
}
inline void RequestRejectBreakInTarget::set_unknown_5(::google::protobuf::uint32 value) {
  set_has_unknown_5();
  unknown_5_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestRejectBreakInTarget.unknown_5)
}

// -------------------------------------------------------------------

// PushRequestRejectBreakInTarget

// required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
inline bool PushRequestRejectBreakInTarget::has_push_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PushRequestRejectBreakInTarget::set_has_push_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PushRequestRejectBreakInTarget::clear_has_push_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PushRequestRejectBreakInTarget::clear_push_message_id() {
  push_message_id_ = 829;
  clear_has_push_message_id();
}
inline ::DS3_Frpg2RequestMessage::PushMessageId PushRequestRejectBreakInTarget::push_message_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.PushRequestRejectBreakInTarget.push_message_id)
  return static_cast< ::DS3_Frpg2RequestMessage::PushMessageId >(push_message_id_);
}
inline void PushRequestRejectBreakInTarget::set_push_message_id(::DS3_Frpg2RequestMessage::PushMessageId value) {
  assert(::DS3_Frpg2RequestMessage::PushMessageId_IsValid(value));
  set_has_push_message_id();
  push_message_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.PushRequestRejectBreakInTarget.push_message_id)
}

// required uint32 player_id = 2;
inline bool PushRequestRejectBreakInTarget::has_player_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PushRequestRejectBreakInTarget::set_has_player_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PushRequestRejectBreakInTarget::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PushRequestRejectBreakInTarget::clear_player_id() {
  player_id_ = 0u;
  clear_has_player_id();
}
inline ::google::protobuf::uint32 PushRequestRejectBreakInTarget::player_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.PushRequestRejectBreakInTarget.player_id)
  return player_id_;
}
inline void PushRequestRejectBreakInTarget::set_player_id(::google::protobuf::uint32 value) {
  set_has_player_id();
  player_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.PushRequestRejectBreakInTarget.player_id)
}

// required uint32 unknown_3 = 3;
inline bool PushRequestRejectBreakInTarget::has_unknown_3() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PushRequestRejectBreakInTarget::set_has_unknown_3() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PushRequestRejectBreakInTarget::clear_has_unknown_3() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PushRequestRejectBreakInTarget::clear_unknown_3() {
  unknown_3_ = 0u;
  clear_has_unknown_3();
}
inline ::google::protobuf::uint32 PushRequestRejectBreakInTarget::unknown_3() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.PushRequestRejectBreakInTarget.unknown_3)
  return unknown_3_;
}
inline void PushRequestRejectBreakInTarget::set_unknown_3(::google::protobuf::uint32 value) {
  set_has_unknown_3();
  unknown_3_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.PushRequestRejectBreakInTarget.unknown_3)
}

// required string steam_id = 4;
inline bool PushRequestRejectBreakInTarget::has_steam_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PushRequestRejectBreakInTarget::set_has_steam_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PushRequestRejectBreakInTarget::clear_has_steam_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PushRequestRejectBreakInTarget::clear_steam_id() {
  if (steam_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    steam_id_->clear();
  }
  clear_has_steam_id();
}
inline const ::std::string& PushRequestRejectBreakInTarget::steam_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.PushRequestRejectBreakInTarget.steam_id)
  return *steam_id_;
}
inline void PushRequestRejectBreakInTarget::set_steam_id(const ::std::string& value) {
  set_has_steam_id();
  if (steam_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    steam_id_ = new ::std::string;
  }
  steam_id_->assign(value);
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.PushRequestRejectBreakInTarget.steam_id)
}
inline void PushRequestRejectBreakInTarget::set_steam_id(const char* value) {
  set_has_steam_id();
  if (steam_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    steam_id_ = new ::std::string;
  }
  steam_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:DS3_Frpg2RequestMessage.PushRequestRejectBreakInTarget.steam_id)
}
inline void PushRequestRejectBreakInTarget::set_steam_id(const char* value, size_t size) {
  set_has_steam_id();
  if (steam_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    steam_id_ = new ::std::string;
  }
  steam_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DS3_Frpg2RequestMessage.PushRequestRejectBreakInTarget.steam_id)
}
inline ::std::string* PushRequestRejectBreakInTarget::mutable_steam_id() {
  set_has_steam_id();
  if (steam_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    steam_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.PushRequestRejectBreakInTarget.steam_id)
  return steam_id_;
}
inline ::std::string* PushRequestRejectBreakInTarget::release_steam_id() {
  clear_has_steam_id();
  if (steam_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = steam_id_;
    steam_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PushRequestRejectBreakInTarget::set_allocated_steam_id(::std::string* steam_id) {
  if (steam_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete steam_id_;
  }
  if (steam_id) {
    set_has_steam_id();
    steam_id_ = steam_id;
  } else {
    clear_has_steam_id();
    steam_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.PushRequestRejectBreakInTarget.steam_id)
}

// required uint32 unknown_5 = 5;
inline bool PushRequestRejectBreakInTarget::has_unknown_5() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PushRequestRejectBreakInTarget::set_has_unknown_5() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PushRequestRejectBreakInTarget::clear_has_unknown_5() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PushRequestRejectBreakInTarget::clear_unknown_5() {
  unknown_5_ = 0u;
  clear_has_unknown_5();
}
inline ::google::protobuf::uint32 PushRequestRejectBreakInTarget::unknown_5() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.PushRequestRejectBreakInTarget.unknown_5)
  return unknown_5_;
}
inline void PushRequestRejectBreakInTarget::set_unknown_5(::google::protobuf::uint32 value) {
  set_has_unknown_5();
  unknown_5_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.PushRequestRejectBreakInTarget.unknown_5)
}

// -------------------------------------------------------------------

// RequestBreakInTargetResponse

// -------------------------------------------------------------------

// RequestRejectBreakInTargetResponse

// -------------------------------------------------------------------

// RequestGetGhostDataList

// required uint32 max_ghosts = 1;
inline bool RequestGetGhostDataList::has_max_ghosts() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestGetGhostDataList::set_has_max_ghosts() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestGetGhostDataList::clear_has_max_ghosts() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestGetGhostDataList::clear_max_ghosts() {
  max_ghosts_ = 0u;
  clear_has_max_ghosts();
}
inline ::google::protobuf::uint32 RequestGetGhostDataList::max_ghosts() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestGetGhostDataList.max_ghosts)
  return max_ghosts_;
}
inline void RequestGetGhostDataList::set_max_ghosts(::google::protobuf::uint32 value) {
  set_has_max_ghosts();
  max_ghosts_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestGetGhostDataList.max_ghosts)
}

// repeated .DS3_Frpg2RequestMessage.DomainLimitData search_areas = 2;
inline int RequestGetGhostDataList::search_areas_size() const {
  return search_areas_.size();
}
inline void RequestGetGhostDataList::clear_search_areas() {
  search_areas_.Clear();
}
inline const ::DS3_Frpg2RequestMessage::DomainLimitData& RequestGetGhostDataList::search_areas(int index) const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestGetGhostDataList.search_areas)
  return search_areas_.Get(index);
}
inline ::DS3_Frpg2RequestMessage::DomainLimitData* RequestGetGhostDataList::mutable_search_areas(int index) {
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.RequestGetGhostDataList.search_areas)
  return search_areas_.Mutable(index);
}
inline ::DS3_Frpg2RequestMessage::DomainLimitData* RequestGetGhostDataList::add_search_areas() {
  // @@protoc_insertion_point(field_add:DS3_Frpg2RequestMessage.RequestGetGhostDataList.search_areas)
  return search_areas_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::DomainLimitData >&
RequestGetGhostDataList::search_areas() const {
  // @@protoc_insertion_point(field_list:DS3_Frpg2RequestMessage.RequestGetGhostDataList.search_areas)
  return search_areas_;
}
inline ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::DomainLimitData >*
RequestGetGhostDataList::mutable_search_areas() {
  // @@protoc_insertion_point(field_mutable_list:DS3_Frpg2RequestMessage.RequestGetGhostDataList.search_areas)
  return &search_areas_;
}

// -------------------------------------------------------------------

// GhostData

// required uint32 unknown_1 = 1;
inline bool GhostData::has_unknown_1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GhostData::set_has_unknown_1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GhostData::clear_has_unknown_1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GhostData::clear_unknown_1() {
  unknown_1_ = 0u;
  clear_has_unknown_1();
}
inline ::google::protobuf::uint32 GhostData::unknown_1() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.GhostData.unknown_1)
  return unknown_1_;
}
inline void GhostData::set_unknown_1(::google::protobuf::uint32 value) {
  set_has_unknown_1();
  unknown_1_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.GhostData.unknown_1)
}

// required uint32 ghost_id = 2;
inline bool GhostData::has_ghost_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GhostData::set_has_ghost_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GhostData::clear_has_ghost_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GhostData::clear_ghost_id() {
  ghost_id_ = 0u;
  clear_has_ghost_id();
}
inline ::google::protobuf::uint32 GhostData::ghost_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.GhostData.ghost_id)
  return ghost_id_;
}
inline void GhostData::set_ghost_id(::google::protobuf::uint32 value) {
  set_has_ghost_id();
  ghost_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.GhostData.ghost_id)
}

// required bytes data = 3;
inline bool GhostData::has_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GhostData::set_has_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GhostData::clear_has_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GhostData::clear_data() {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& GhostData::data() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.GhostData.data)
  return *data_;
}
inline void GhostData::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.GhostData.data)
}
inline void GhostData::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set_char:DS3_Frpg2RequestMessage.GhostData.data)
}
inline void GhostData::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DS3_Frpg2RequestMessage.GhostData.data)
}
inline ::std::string* GhostData::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.GhostData.data)
  return data_;
}
inline ::std::string* GhostData::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GhostData::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.GhostData.data)
}

// -------------------------------------------------------------------

// RequestCreateGhostData

// required uint32 online_area_id = 1;
inline bool RequestCreateGhostData::has_online_area_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestCreateGhostData::set_has_online_area_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestCreateGhostData::clear_has_online_area_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestCreateGhostData::clear_online_area_id() {
  online_area_id_ = 0u;
  clear_has_online_area_id();
}
inline ::google::protobuf::uint32 RequestCreateGhostData::online_area_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestCreateGhostData.online_area_id)
  return online_area_id_;
}
inline void RequestCreateGhostData::set_online_area_id(::google::protobuf::uint32 value) {
  set_has_online_area_id();
  online_area_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestCreateGhostData.online_area_id)
}

// required bytes data = 2;
inline bool RequestCreateGhostData::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestCreateGhostData::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestCreateGhostData::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestCreateGhostData::clear_data() {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& RequestCreateGhostData::data() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestCreateGhostData.data)
  return *data_;
}
inline void RequestCreateGhostData::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestCreateGhostData.data)
}
inline void RequestCreateGhostData::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set_char:DS3_Frpg2RequestMessage.RequestCreateGhostData.data)
}
inline void RequestCreateGhostData::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DS3_Frpg2RequestMessage.RequestCreateGhostData.data)
}
inline ::std::string* RequestCreateGhostData::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.RequestCreateGhostData.data)
  return data_;
}
inline ::std::string* RequestCreateGhostData::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RequestCreateGhostData::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.RequestCreateGhostData.data)
}

// -------------------------------------------------------------------

// RequestCreateGhostDataResponse

// -------------------------------------------------------------------

// RequestGetGhostDataListResponse

// repeated .DS3_Frpg2RequestMessage.GhostData ghosts = 1;
inline int RequestGetGhostDataListResponse::ghosts_size() const {
  return ghosts_.size();
}
inline void RequestGetGhostDataListResponse::clear_ghosts() {
  ghosts_.Clear();
}
inline const ::DS3_Frpg2RequestMessage::GhostData& RequestGetGhostDataListResponse::ghosts(int index) const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestGetGhostDataListResponse.ghosts)
  return ghosts_.Get(index);
}
inline ::DS3_Frpg2RequestMessage::GhostData* RequestGetGhostDataListResponse::mutable_ghosts(int index) {
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.RequestGetGhostDataListResponse.ghosts)
  return ghosts_.Mutable(index);
}
inline ::DS3_Frpg2RequestMessage::GhostData* RequestGetGhostDataListResponse::add_ghosts() {
  // @@protoc_insertion_point(field_add:DS3_Frpg2RequestMessage.RequestGetGhostDataListResponse.ghosts)
  return ghosts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::GhostData >&
RequestGetGhostDataListResponse::ghosts() const {
  // @@protoc_insertion_point(field_list:DS3_Frpg2RequestMessage.RequestGetGhostDataListResponse.ghosts)
  return ghosts_;
}
inline ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::GhostData >*
RequestGetGhostDataListResponse::mutable_ghosts() {
  // @@protoc_insertion_point(field_mutable_list:DS3_Frpg2RequestMessage.RequestGetGhostDataListResponse.ghosts)
  return &ghosts_;
}

// -------------------------------------------------------------------

// RequestGetVisitorList

// required uint32 map_id = 1;
inline bool RequestGetVisitorList::has_map_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestGetVisitorList::set_has_map_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestGetVisitorList::clear_has_map_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestGetVisitorList::clear_map_id() {
  map_id_ = 0u;
  clear_has_map_id();
}
inline ::google::protobuf::uint32 RequestGetVisitorList::map_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestGetVisitorList.map_id)
  return map_id_;
}
inline void RequestGetVisitorList::set_map_id(::google::protobuf::uint32 value) {
  set_has_map_id();
  map_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestGetVisitorList.map_id)
}

// required uint32 online_area_id = 2;
inline bool RequestGetVisitorList::has_online_area_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestGetVisitorList::set_has_online_area_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestGetVisitorList::clear_has_online_area_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestGetVisitorList::clear_online_area_id() {
  online_area_id_ = 0u;
  clear_has_online_area_id();
}
inline ::google::protobuf::uint32 RequestGetVisitorList::online_area_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestGetVisitorList.online_area_id)
  return online_area_id_;
}
inline void RequestGetVisitorList::set_online_area_id(::google::protobuf::uint32 value) {
  set_has_online_area_id();
  online_area_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestGetVisitorList.online_area_id)
}

// required uint32 max_visitors = 3;
inline bool RequestGetVisitorList::has_max_visitors() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestGetVisitorList::set_has_max_visitors() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestGetVisitorList::clear_has_max_visitors() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestGetVisitorList::clear_max_visitors() {
  max_visitors_ = 0u;
  clear_has_max_visitors();
}
inline ::google::protobuf::uint32 RequestGetVisitorList::max_visitors() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestGetVisitorList.max_visitors)
  return max_visitors_;
}
inline void RequestGetVisitorList::set_max_visitors(::google::protobuf::uint32 value) {
  set_has_max_visitors();
  max_visitors_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestGetVisitorList.max_visitors)
}

// required .DS3_Frpg2RequestMessage.MatchingParameter matching_parameter = 4;
inline bool RequestGetVisitorList::has_matching_parameter() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestGetVisitorList::set_has_matching_parameter() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestGetVisitorList::clear_has_matching_parameter() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestGetVisitorList::clear_matching_parameter() {
  if (matching_parameter_ != NULL) matching_parameter_->::DS3_Frpg2RequestMessage::MatchingParameter::Clear();
  clear_has_matching_parameter();
}
inline const ::DS3_Frpg2RequestMessage::MatchingParameter& RequestGetVisitorList::matching_parameter() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestGetVisitorList.matching_parameter)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return matching_parameter_ != NULL ? *matching_parameter_ : *default_instance().matching_parameter_;
#else
  return matching_parameter_ != NULL ? *matching_parameter_ : *default_instance_->matching_parameter_;
#endif
}
inline ::DS3_Frpg2RequestMessage::MatchingParameter* RequestGetVisitorList::mutable_matching_parameter() {
  set_has_matching_parameter();
  if (matching_parameter_ == NULL) matching_parameter_ = new ::DS3_Frpg2RequestMessage::MatchingParameter;
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.RequestGetVisitorList.matching_parameter)
  return matching_parameter_;
}
inline ::DS3_Frpg2RequestMessage::MatchingParameter* RequestGetVisitorList::release_matching_parameter() {
  clear_has_matching_parameter();
  ::DS3_Frpg2RequestMessage::MatchingParameter* temp = matching_parameter_;
  matching_parameter_ = NULL;
  return temp;
}
inline void RequestGetVisitorList::set_allocated_matching_parameter(::DS3_Frpg2RequestMessage::MatchingParameter* matching_parameter) {
  delete matching_parameter_;
  matching_parameter_ = matching_parameter;
  if (matching_parameter) {
    set_has_matching_parameter();
  } else {
    clear_has_matching_parameter();
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.RequestGetVisitorList.matching_parameter)
}

// required .DS3_Frpg2RequestMessage.VisitorPool visitor_pool = 5;
inline bool RequestGetVisitorList::has_visitor_pool() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RequestGetVisitorList::set_has_visitor_pool() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RequestGetVisitorList::clear_has_visitor_pool() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RequestGetVisitorList::clear_visitor_pool() {
  visitor_pool_ = -1;
  clear_has_visitor_pool();
}
inline ::DS3_Frpg2RequestMessage::VisitorPool RequestGetVisitorList::visitor_pool() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestGetVisitorList.visitor_pool)
  return static_cast< ::DS3_Frpg2RequestMessage::VisitorPool >(visitor_pool_);
}
inline void RequestGetVisitorList::set_visitor_pool(::DS3_Frpg2RequestMessage::VisitorPool value) {
  assert(::DS3_Frpg2RequestMessage::VisitorPool_IsValid(value));
  set_has_visitor_pool();
  visitor_pool_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestGetVisitorList.visitor_pool)
}

// required uint32 unknown_6 = 6;
inline bool RequestGetVisitorList::has_unknown_6() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RequestGetVisitorList::set_has_unknown_6() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RequestGetVisitorList::clear_has_unknown_6() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RequestGetVisitorList::clear_unknown_6() {
  unknown_6_ = 0u;
  clear_has_unknown_6();
}
inline ::google::protobuf::uint32 RequestGetVisitorList::unknown_6() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestGetVisitorList.unknown_6)
  return unknown_6_;
}
inline void RequestGetVisitorList::set_unknown_6(::google::protobuf::uint32 value) {
  set_has_unknown_6();
  unknown_6_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestGetVisitorList.unknown_6)
}

// -------------------------------------------------------------------

// VisitorData

// required uint32 player_id = 1;
inline bool VisitorData::has_player_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VisitorData::set_has_player_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VisitorData::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VisitorData::clear_player_id() {
  player_id_ = 0u;
  clear_has_player_id();
}
inline ::google::protobuf::uint32 VisitorData::player_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.VisitorData.player_id)
  return player_id_;
}
inline void VisitorData::set_player_id(::google::protobuf::uint32 value) {
  set_has_player_id();
  player_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.VisitorData.player_id)
}

// required string player_steam_id = 2;
inline bool VisitorData::has_player_steam_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VisitorData::set_has_player_steam_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VisitorData::clear_has_player_steam_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VisitorData::clear_player_steam_id() {
  if (player_steam_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    player_steam_id_->clear();
  }
  clear_has_player_steam_id();
}
inline const ::std::string& VisitorData::player_steam_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.VisitorData.player_steam_id)
  return *player_steam_id_;
}
inline void VisitorData::set_player_steam_id(const ::std::string& value) {
  set_has_player_steam_id();
  if (player_steam_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    player_steam_id_ = new ::std::string;
  }
  player_steam_id_->assign(value);
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.VisitorData.player_steam_id)
}
inline void VisitorData::set_player_steam_id(const char* value) {
  set_has_player_steam_id();
  if (player_steam_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    player_steam_id_ = new ::std::string;
  }
  player_steam_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:DS3_Frpg2RequestMessage.VisitorData.player_steam_id)
}
inline void VisitorData::set_player_steam_id(const char* value, size_t size) {
  set_has_player_steam_id();
  if (player_steam_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    player_steam_id_ = new ::std::string;
  }
  player_steam_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DS3_Frpg2RequestMessage.VisitorData.player_steam_id)
}
inline ::std::string* VisitorData::mutable_player_steam_id() {
  set_has_player_steam_id();
  if (player_steam_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    player_steam_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.VisitorData.player_steam_id)
  return player_steam_id_;
}
inline ::std::string* VisitorData::release_player_steam_id() {
  clear_has_player_steam_id();
  if (player_steam_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = player_steam_id_;
    player_steam_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void VisitorData::set_allocated_player_steam_id(::std::string* player_steam_id) {
  if (player_steam_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete player_steam_id_;
  }
  if (player_steam_id) {
    set_has_player_steam_id();
    player_steam_id_ = player_steam_id;
  } else {
    clear_has_player_steam_id();
    player_steam_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.VisitorData.player_steam_id)
}

// -------------------------------------------------------------------

// RequestGetVisitorListResponse

// required uint32 map_id = 1;
inline bool RequestGetVisitorListResponse::has_map_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestGetVisitorListResponse::set_has_map_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestGetVisitorListResponse::clear_has_map_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestGetVisitorListResponse::clear_map_id() {
  map_id_ = 0u;
  clear_has_map_id();
}
inline ::google::protobuf::uint32 RequestGetVisitorListResponse::map_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestGetVisitorListResponse.map_id)
  return map_id_;
}
inline void RequestGetVisitorListResponse::set_map_id(::google::protobuf::uint32 value) {
  set_has_map_id();
  map_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestGetVisitorListResponse.map_id)
}

// required uint32 online_area_id = 2;
inline bool RequestGetVisitorListResponse::has_online_area_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestGetVisitorListResponse::set_has_online_area_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestGetVisitorListResponse::clear_has_online_area_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestGetVisitorListResponse::clear_online_area_id() {
  online_area_id_ = 0u;
  clear_has_online_area_id();
}
inline ::google::protobuf::uint32 RequestGetVisitorListResponse::online_area_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestGetVisitorListResponse.online_area_id)
  return online_area_id_;
}
inline void RequestGetVisitorListResponse::set_online_area_id(::google::protobuf::uint32 value) {
  set_has_online_area_id();
  online_area_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestGetVisitorListResponse.online_area_id)
}

// repeated .DS3_Frpg2RequestMessage.VisitorData visitors = 3;
inline int RequestGetVisitorListResponse::visitors_size() const {
  return visitors_.size();
}
inline void RequestGetVisitorListResponse::clear_visitors() {
  visitors_.Clear();
}
inline const ::DS3_Frpg2RequestMessage::VisitorData& RequestGetVisitorListResponse::visitors(int index) const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestGetVisitorListResponse.visitors)
  return visitors_.Get(index);
}
inline ::DS3_Frpg2RequestMessage::VisitorData* RequestGetVisitorListResponse::mutable_visitors(int index) {
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.RequestGetVisitorListResponse.visitors)
  return visitors_.Mutable(index);
}
inline ::DS3_Frpg2RequestMessage::VisitorData* RequestGetVisitorListResponse::add_visitors() {
  // @@protoc_insertion_point(field_add:DS3_Frpg2RequestMessage.RequestGetVisitorListResponse.visitors)
  return visitors_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::VisitorData >&
RequestGetVisitorListResponse::visitors() const {
  // @@protoc_insertion_point(field_list:DS3_Frpg2RequestMessage.RequestGetVisitorListResponse.visitors)
  return visitors_;
}
inline ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::VisitorData >*
RequestGetVisitorListResponse::mutable_visitors() {
  // @@protoc_insertion_point(field_mutable_list:DS3_Frpg2RequestMessage.RequestGetVisitorListResponse.visitors)
  return &visitors_;
}

// -------------------------------------------------------------------

// PushRequestRemoveVisitor

// required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
inline bool PushRequestRemoveVisitor::has_push_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PushRequestRemoveVisitor::set_has_push_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PushRequestRemoveVisitor::clear_has_push_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PushRequestRemoveVisitor::clear_push_message_id() {
  push_message_id_ = 829;
  clear_has_push_message_id();
}
inline ::DS3_Frpg2RequestMessage::PushMessageId PushRequestRemoveVisitor::push_message_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.PushRequestRemoveVisitor.push_message_id)
  return static_cast< ::DS3_Frpg2RequestMessage::PushMessageId >(push_message_id_);
}
inline void PushRequestRemoveVisitor::set_push_message_id(::DS3_Frpg2RequestMessage::PushMessageId value) {
  assert(::DS3_Frpg2RequestMessage::PushMessageId_IsValid(value));
  set_has_push_message_id();
  push_message_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.PushRequestRemoveVisitor.push_message_id)
}

// required uint32 player_id = 2;
inline bool PushRequestRemoveVisitor::has_player_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PushRequestRemoveVisitor::set_has_player_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PushRequestRemoveVisitor::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PushRequestRemoveVisitor::clear_player_id() {
  player_id_ = 0u;
  clear_has_player_id();
}
inline ::google::protobuf::uint32 PushRequestRemoveVisitor::player_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.PushRequestRemoveVisitor.player_id)
  return player_id_;
}
inline void PushRequestRemoveVisitor::set_player_id(::google::protobuf::uint32 value) {
  set_has_player_id();
  player_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.PushRequestRemoveVisitor.player_id)
}

// required string player_steam_id = 3;
inline bool PushRequestRemoveVisitor::has_player_steam_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PushRequestRemoveVisitor::set_has_player_steam_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PushRequestRemoveVisitor::clear_has_player_steam_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PushRequestRemoveVisitor::clear_player_steam_id() {
  if (player_steam_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    player_steam_id_->clear();
  }
  clear_has_player_steam_id();
}
inline const ::std::string& PushRequestRemoveVisitor::player_steam_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.PushRequestRemoveVisitor.player_steam_id)
  return *player_steam_id_;
}
inline void PushRequestRemoveVisitor::set_player_steam_id(const ::std::string& value) {
  set_has_player_steam_id();
  if (player_steam_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    player_steam_id_ = new ::std::string;
  }
  player_steam_id_->assign(value);
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.PushRequestRemoveVisitor.player_steam_id)
}
inline void PushRequestRemoveVisitor::set_player_steam_id(const char* value) {
  set_has_player_steam_id();
  if (player_steam_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    player_steam_id_ = new ::std::string;
  }
  player_steam_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:DS3_Frpg2RequestMessage.PushRequestRemoveVisitor.player_steam_id)
}
inline void PushRequestRemoveVisitor::set_player_steam_id(const char* value, size_t size) {
  set_has_player_steam_id();
  if (player_steam_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    player_steam_id_ = new ::std::string;
  }
  player_steam_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DS3_Frpg2RequestMessage.PushRequestRemoveVisitor.player_steam_id)
}
inline ::std::string* PushRequestRemoveVisitor::mutable_player_steam_id() {
  set_has_player_steam_id();
  if (player_steam_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    player_steam_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.PushRequestRemoveVisitor.player_steam_id)
  return player_steam_id_;
}
inline ::std::string* PushRequestRemoveVisitor::release_player_steam_id() {
  clear_has_player_steam_id();
  if (player_steam_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = player_steam_id_;
    player_steam_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PushRequestRemoveVisitor::set_allocated_player_steam_id(::std::string* player_steam_id) {
  if (player_steam_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete player_steam_id_;
  }
  if (player_steam_id) {
    set_has_player_steam_id();
    player_steam_id_ = player_steam_id;
  } else {
    clear_has_player_steam_id();
    player_steam_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.PushRequestRemoveVisitor.player_steam_id)
}

// required .DS3_Frpg2RequestMessage.VisitorPool visitor_pool = 4;
inline bool PushRequestRemoveVisitor::has_visitor_pool() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PushRequestRemoveVisitor::set_has_visitor_pool() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PushRequestRemoveVisitor::clear_has_visitor_pool() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PushRequestRemoveVisitor::clear_visitor_pool() {
  visitor_pool_ = -1;
  clear_has_visitor_pool();
}
inline ::DS3_Frpg2RequestMessage::VisitorPool PushRequestRemoveVisitor::visitor_pool() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.PushRequestRemoveVisitor.visitor_pool)
  return static_cast< ::DS3_Frpg2RequestMessage::VisitorPool >(visitor_pool_);
}
inline void PushRequestRemoveVisitor::set_visitor_pool(::DS3_Frpg2RequestMessage::VisitorPool value) {
  assert(::DS3_Frpg2RequestMessage::VisitorPool_IsValid(value));
  set_has_visitor_pool();
  visitor_pool_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.PushRequestRemoveVisitor.visitor_pool)
}

// -------------------------------------------------------------------

// RequestVisit

// required uint32 map_id = 1;
inline bool RequestVisit::has_map_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestVisit::set_has_map_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestVisit::clear_has_map_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestVisit::clear_map_id() {
  map_id_ = 0u;
  clear_has_map_id();
}
inline ::google::protobuf::uint32 RequestVisit::map_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestVisit.map_id)
  return map_id_;
}
inline void RequestVisit::set_map_id(::google::protobuf::uint32 value) {
  set_has_map_id();
  map_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestVisit.map_id)
}

// required uint32 online_area_id = 2;
inline bool RequestVisit::has_online_area_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestVisit::set_has_online_area_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestVisit::clear_has_online_area_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestVisit::clear_online_area_id() {
  online_area_id_ = 0u;
  clear_has_online_area_id();
}
inline ::google::protobuf::uint32 RequestVisit::online_area_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestVisit.online_area_id)
  return online_area_id_;
}
inline void RequestVisit::set_online_area_id(::google::protobuf::uint32 value) {
  set_has_online_area_id();
  online_area_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestVisit.online_area_id)
}

// required .DS3_Frpg2RequestMessage.VisitorPool visitor_pool = 3;
inline bool RequestVisit::has_visitor_pool() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestVisit::set_has_visitor_pool() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestVisit::clear_has_visitor_pool() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestVisit::clear_visitor_pool() {
  visitor_pool_ = -1;
  clear_has_visitor_pool();
}
inline ::DS3_Frpg2RequestMessage::VisitorPool RequestVisit::visitor_pool() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestVisit.visitor_pool)
  return static_cast< ::DS3_Frpg2RequestMessage::VisitorPool >(visitor_pool_);
}
inline void RequestVisit::set_visitor_pool(::DS3_Frpg2RequestMessage::VisitorPool value) {
  assert(::DS3_Frpg2RequestMessage::VisitorPool_IsValid(value));
  set_has_visitor_pool();
  visitor_pool_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestVisit.visitor_pool)
}

// required uint32 player_id = 4;
inline bool RequestVisit::has_player_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestVisit::set_has_player_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestVisit::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestVisit::clear_player_id() {
  player_id_ = 0u;
  clear_has_player_id();
}
inline ::google::protobuf::uint32 RequestVisit::player_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestVisit.player_id)
  return player_id_;
}
inline void RequestVisit::set_player_id(::google::protobuf::uint32 value) {
  set_has_player_id();
  player_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestVisit.player_id)
}

// required bytes data = 5;
inline bool RequestVisit::has_data() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RequestVisit::set_has_data() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RequestVisit::clear_has_data() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RequestVisit::clear_data() {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& RequestVisit::data() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestVisit.data)
  return *data_;
}
inline void RequestVisit::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestVisit.data)
}
inline void RequestVisit::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set_char:DS3_Frpg2RequestMessage.RequestVisit.data)
}
inline void RequestVisit::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DS3_Frpg2RequestMessage.RequestVisit.data)
}
inline ::std::string* RequestVisit::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.RequestVisit.data)
  return data_;
}
inline ::std::string* RequestVisit::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RequestVisit::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.RequestVisit.data)
}

// -------------------------------------------------------------------

// PushRequestVisit

// required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
inline bool PushRequestVisit::has_push_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PushRequestVisit::set_has_push_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PushRequestVisit::clear_has_push_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PushRequestVisit::clear_push_message_id() {
  push_message_id_ = 829;
  clear_has_push_message_id();
}
inline ::DS3_Frpg2RequestMessage::PushMessageId PushRequestVisit::push_message_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.PushRequestVisit.push_message_id)
  return static_cast< ::DS3_Frpg2RequestMessage::PushMessageId >(push_message_id_);
}
inline void PushRequestVisit::set_push_message_id(::DS3_Frpg2RequestMessage::PushMessageId value) {
  assert(::DS3_Frpg2RequestMessage::PushMessageId_IsValid(value));
  set_has_push_message_id();
  push_message_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.PushRequestVisit.push_message_id)
}

// required uint32 player_id = 2;
inline bool PushRequestVisit::has_player_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PushRequestVisit::set_has_player_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PushRequestVisit::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PushRequestVisit::clear_player_id() {
  player_id_ = 0u;
  clear_has_player_id();
}
inline ::google::protobuf::uint32 PushRequestVisit::player_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.PushRequestVisit.player_id)
  return player_id_;
}
inline void PushRequestVisit::set_player_id(::google::protobuf::uint32 value) {
  set_has_player_id();
  player_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.PushRequestVisit.player_id)
}

// required string player_steam_id = 3;
inline bool PushRequestVisit::has_player_steam_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PushRequestVisit::set_has_player_steam_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PushRequestVisit::clear_has_player_steam_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PushRequestVisit::clear_player_steam_id() {
  if (player_steam_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    player_steam_id_->clear();
  }
  clear_has_player_steam_id();
}
inline const ::std::string& PushRequestVisit::player_steam_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.PushRequestVisit.player_steam_id)
  return *player_steam_id_;
}
inline void PushRequestVisit::set_player_steam_id(const ::std::string& value) {
  set_has_player_steam_id();
  if (player_steam_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    player_steam_id_ = new ::std::string;
  }
  player_steam_id_->assign(value);
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.PushRequestVisit.player_steam_id)
}
inline void PushRequestVisit::set_player_steam_id(const char* value) {
  set_has_player_steam_id();
  if (player_steam_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    player_steam_id_ = new ::std::string;
  }
  player_steam_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:DS3_Frpg2RequestMessage.PushRequestVisit.player_steam_id)
}
inline void PushRequestVisit::set_player_steam_id(const char* value, size_t size) {
  set_has_player_steam_id();
  if (player_steam_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    player_steam_id_ = new ::std::string;
  }
  player_steam_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DS3_Frpg2RequestMessage.PushRequestVisit.player_steam_id)
}
inline ::std::string* PushRequestVisit::mutable_player_steam_id() {
  set_has_player_steam_id();
  if (player_steam_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    player_steam_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.PushRequestVisit.player_steam_id)
  return player_steam_id_;
}
inline ::std::string* PushRequestVisit::release_player_steam_id() {
  clear_has_player_steam_id();
  if (player_steam_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = player_steam_id_;
    player_steam_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PushRequestVisit::set_allocated_player_steam_id(::std::string* player_steam_id) {
  if (player_steam_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete player_steam_id_;
  }
  if (player_steam_id) {
    set_has_player_steam_id();
    player_steam_id_ = player_steam_id;
  } else {
    clear_has_player_steam_id();
    player_steam_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.PushRequestVisit.player_steam_id)
}

// required bytes data = 4;
inline bool PushRequestVisit::has_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PushRequestVisit::set_has_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PushRequestVisit::clear_has_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PushRequestVisit::clear_data() {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& PushRequestVisit::data() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.PushRequestVisit.data)
  return *data_;
}
inline void PushRequestVisit::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.PushRequestVisit.data)
}
inline void PushRequestVisit::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set_char:DS3_Frpg2RequestMessage.PushRequestVisit.data)
}
inline void PushRequestVisit::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DS3_Frpg2RequestMessage.PushRequestVisit.data)
}
inline ::std::string* PushRequestVisit::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.PushRequestVisit.data)
  return data_;
}
inline ::std::string* PushRequestVisit::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PushRequestVisit::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.PushRequestVisit.data)
}

// required .DS3_Frpg2RequestMessage.VisitorPool visitor_pool = 5;
inline bool PushRequestVisit::has_visitor_pool() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PushRequestVisit::set_has_visitor_pool() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PushRequestVisit::clear_has_visitor_pool() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PushRequestVisit::clear_visitor_pool() {
  visitor_pool_ = -1;
  clear_has_visitor_pool();
}
inline ::DS3_Frpg2RequestMessage::VisitorPool PushRequestVisit::visitor_pool() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.PushRequestVisit.visitor_pool)
  return static_cast< ::DS3_Frpg2RequestMessage::VisitorPool >(visitor_pool_);
}
inline void PushRequestVisit::set_visitor_pool(::DS3_Frpg2RequestMessage::VisitorPool value) {
  assert(::DS3_Frpg2RequestMessage::VisitorPool_IsValid(value));
  set_has_visitor_pool();
  visitor_pool_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.PushRequestVisit.visitor_pool)
}

// required uint32 map_id = 6;
inline bool PushRequestVisit::has_map_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PushRequestVisit::set_has_map_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PushRequestVisit::clear_has_map_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PushRequestVisit::clear_map_id() {
  map_id_ = 0u;
  clear_has_map_id();
}
inline ::google::protobuf::uint32 PushRequestVisit::map_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.PushRequestVisit.map_id)
  return map_id_;
}
inline void PushRequestVisit::set_map_id(::google::protobuf::uint32 value) {
  set_has_map_id();
  map_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.PushRequestVisit.map_id)
}

// required uint32 online_area_id = 7;
inline bool PushRequestVisit::has_online_area_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PushRequestVisit::set_has_online_area_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PushRequestVisit::clear_has_online_area_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PushRequestVisit::clear_online_area_id() {
  online_area_id_ = 0u;
  clear_has_online_area_id();
}
inline ::google::protobuf::uint32 PushRequestVisit::online_area_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.PushRequestVisit.online_area_id)
  return online_area_id_;
}
inline void PushRequestVisit::set_online_area_id(::google::protobuf::uint32 value) {
  set_has_online_area_id();
  online_area_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.PushRequestVisit.online_area_id)
}

// -------------------------------------------------------------------

// RequestRejectVisit

// required uint32 player_id = 1;
inline bool RequestRejectVisit::has_player_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestRejectVisit::set_has_player_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestRejectVisit::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestRejectVisit::clear_player_id() {
  player_id_ = 0u;
  clear_has_player_id();
}
inline ::google::protobuf::uint32 RequestRejectVisit::player_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestRejectVisit.player_id)
  return player_id_;
}
inline void RequestRejectVisit::set_player_id(::google::protobuf::uint32 value) {
  set_has_player_id();
  player_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestRejectVisit.player_id)
}

// required .DS3_Frpg2RequestMessage.VisitorPool visitor_pool = 2;
inline bool RequestRejectVisit::has_visitor_pool() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestRejectVisit::set_has_visitor_pool() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestRejectVisit::clear_has_visitor_pool() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestRejectVisit::clear_visitor_pool() {
  visitor_pool_ = -1;
  clear_has_visitor_pool();
}
inline ::DS3_Frpg2RequestMessage::VisitorPool RequestRejectVisit::visitor_pool() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestRejectVisit.visitor_pool)
  return static_cast< ::DS3_Frpg2RequestMessage::VisitorPool >(visitor_pool_);
}
inline void RequestRejectVisit::set_visitor_pool(::DS3_Frpg2RequestMessage::VisitorPool value) {
  assert(::DS3_Frpg2RequestMessage::VisitorPool_IsValid(value));
  set_has_visitor_pool();
  visitor_pool_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestRejectVisit.visitor_pool)
}

// required uint32 map_id = 3;
inline bool RequestRejectVisit::has_map_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestRejectVisit::set_has_map_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestRejectVisit::clear_has_map_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestRejectVisit::clear_map_id() {
  map_id_ = 0u;
  clear_has_map_id();
}
inline ::google::protobuf::uint32 RequestRejectVisit::map_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestRejectVisit.map_id)
  return map_id_;
}
inline void RequestRejectVisit::set_map_id(::google::protobuf::uint32 value) {
  set_has_map_id();
  map_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestRejectVisit.map_id)
}

// required uint32 online_area_id = 4;
inline bool RequestRejectVisit::has_online_area_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestRejectVisit::set_has_online_area_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestRejectVisit::clear_has_online_area_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestRejectVisit::clear_online_area_id() {
  online_area_id_ = 0u;
  clear_has_online_area_id();
}
inline ::google::protobuf::uint32 RequestRejectVisit::online_area_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestRejectVisit.online_area_id)
  return online_area_id_;
}
inline void RequestRejectVisit::set_online_area_id(::google::protobuf::uint32 value) {
  set_has_online_area_id();
  online_area_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestRejectVisit.online_area_id)
}

// required uint32 unknown_5 = 5;
inline bool RequestRejectVisit::has_unknown_5() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RequestRejectVisit::set_has_unknown_5() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RequestRejectVisit::clear_has_unknown_5() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RequestRejectVisit::clear_unknown_5() {
  unknown_5_ = 0u;
  clear_has_unknown_5();
}
inline ::google::protobuf::uint32 RequestRejectVisit::unknown_5() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestRejectVisit.unknown_5)
  return unknown_5_;
}
inline void RequestRejectVisit::set_unknown_5(::google::protobuf::uint32 value) {
  set_has_unknown_5();
  unknown_5_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestRejectVisit.unknown_5)
}

// -------------------------------------------------------------------

// PushRequestRejectVisit

// required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
inline bool PushRequestRejectVisit::has_push_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PushRequestRejectVisit::set_has_push_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PushRequestRejectVisit::clear_has_push_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PushRequestRejectVisit::clear_push_message_id() {
  push_message_id_ = 829;
  clear_has_push_message_id();
}
inline ::DS3_Frpg2RequestMessage::PushMessageId PushRequestRejectVisit::push_message_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.PushRequestRejectVisit.push_message_id)
  return static_cast< ::DS3_Frpg2RequestMessage::PushMessageId >(push_message_id_);
}
inline void PushRequestRejectVisit::set_push_message_id(::DS3_Frpg2RequestMessage::PushMessageId value) {
  assert(::DS3_Frpg2RequestMessage::PushMessageId_IsValid(value));
  set_has_push_message_id();
  push_message_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.PushRequestRejectVisit.push_message_id)
}

// required uint32 player_id = 2;
inline bool PushRequestRejectVisit::has_player_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PushRequestRejectVisit::set_has_player_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PushRequestRejectVisit::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PushRequestRejectVisit::clear_player_id() {
  player_id_ = 0u;
  clear_has_player_id();
}
inline ::google::protobuf::uint32 PushRequestRejectVisit::player_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.PushRequestRejectVisit.player_id)
  return player_id_;
}
inline void PushRequestRejectVisit::set_player_id(::google::protobuf::uint32 value) {
  set_has_player_id();
  player_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.PushRequestRejectVisit.player_id)
}

// optional .DS3_Frpg2RequestMessage.VisitorPool visitor_pool = 3;
inline bool PushRequestRejectVisit::has_visitor_pool() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PushRequestRejectVisit::set_has_visitor_pool() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PushRequestRejectVisit::clear_has_visitor_pool() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PushRequestRejectVisit::clear_visitor_pool() {
  visitor_pool_ = -1;
  clear_has_visitor_pool();
}
inline ::DS3_Frpg2RequestMessage::VisitorPool PushRequestRejectVisit::visitor_pool() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.PushRequestRejectVisit.visitor_pool)
  return static_cast< ::DS3_Frpg2RequestMessage::VisitorPool >(visitor_pool_);
}
inline void PushRequestRejectVisit::set_visitor_pool(::DS3_Frpg2RequestMessage::VisitorPool value) {
  assert(::DS3_Frpg2RequestMessage::VisitorPool_IsValid(value));
  set_has_visitor_pool();
  visitor_pool_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.PushRequestRejectVisit.visitor_pool)
}

// required string steam_id = 4;
inline bool PushRequestRejectVisit::has_steam_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PushRequestRejectVisit::set_has_steam_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PushRequestRejectVisit::clear_has_steam_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PushRequestRejectVisit::clear_steam_id() {
  if (steam_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    steam_id_->clear();
  }
  clear_has_steam_id();
}
inline const ::std::string& PushRequestRejectVisit::steam_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.PushRequestRejectVisit.steam_id)
  return *steam_id_;
}
inline void PushRequestRejectVisit::set_steam_id(const ::std::string& value) {
  set_has_steam_id();
  if (steam_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    steam_id_ = new ::std::string;
  }
  steam_id_->assign(value);
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.PushRequestRejectVisit.steam_id)
}
inline void PushRequestRejectVisit::set_steam_id(const char* value) {
  set_has_steam_id();
  if (steam_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    steam_id_ = new ::std::string;
  }
  steam_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:DS3_Frpg2RequestMessage.PushRequestRejectVisit.steam_id)
}
inline void PushRequestRejectVisit::set_steam_id(const char* value, size_t size) {
  set_has_steam_id();
  if (steam_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    steam_id_ = new ::std::string;
  }
  steam_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DS3_Frpg2RequestMessage.PushRequestRejectVisit.steam_id)
}
inline ::std::string* PushRequestRejectVisit::mutable_steam_id() {
  set_has_steam_id();
  if (steam_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    steam_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.PushRequestRejectVisit.steam_id)
  return steam_id_;
}
inline ::std::string* PushRequestRejectVisit::release_steam_id() {
  clear_has_steam_id();
  if (steam_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = steam_id_;
    steam_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PushRequestRejectVisit::set_allocated_steam_id(::std::string* steam_id) {
  if (steam_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete steam_id_;
  }
  if (steam_id) {
    set_has_steam_id();
    steam_id_ = steam_id;
  } else {
    clear_has_steam_id();
    steam_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.PushRequestRejectVisit.steam_id)
}

// required uint32 unknown_5 = 5;
inline bool PushRequestRejectVisit::has_unknown_5() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PushRequestRejectVisit::set_has_unknown_5() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PushRequestRejectVisit::clear_has_unknown_5() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PushRequestRejectVisit::clear_unknown_5() {
  unknown_5_ = 0u;
  clear_has_unknown_5();
}
inline ::google::protobuf::uint32 PushRequestRejectVisit::unknown_5() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.PushRequestRejectVisit.unknown_5)
  return unknown_5_;
}
inline void PushRequestRejectVisit::set_unknown_5(::google::protobuf::uint32 value) {
  set_has_unknown_5();
  unknown_5_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.PushRequestRejectVisit.unknown_5)
}

// -------------------------------------------------------------------

// RequestVisitResponse

// -------------------------------------------------------------------

// RequestRejectVisitResponse

// -------------------------------------------------------------------

// RequestNotifyRingBell

// required uint32 online_area_id = 1;
inline bool RequestNotifyRingBell::has_online_area_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestNotifyRingBell::set_has_online_area_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestNotifyRingBell::clear_has_online_area_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestNotifyRingBell::clear_online_area_id() {
  online_area_id_ = 0u;
  clear_has_online_area_id();
}
inline ::google::protobuf::uint32 RequestNotifyRingBell::online_area_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestNotifyRingBell.online_area_id)
  return online_area_id_;
}
inline void RequestNotifyRingBell::set_online_area_id(::google::protobuf::uint32 value) {
  set_has_online_area_id();
  online_area_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestNotifyRingBell.online_area_id)
}

// required bytes data = 2;
inline bool RequestNotifyRingBell::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestNotifyRingBell::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestNotifyRingBell::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestNotifyRingBell::clear_data() {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& RequestNotifyRingBell::data() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestNotifyRingBell.data)
  return *data_;
}
inline void RequestNotifyRingBell::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestNotifyRingBell.data)
}
inline void RequestNotifyRingBell::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set_char:DS3_Frpg2RequestMessage.RequestNotifyRingBell.data)
}
inline void RequestNotifyRingBell::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DS3_Frpg2RequestMessage.RequestNotifyRingBell.data)
}
inline ::std::string* RequestNotifyRingBell::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.RequestNotifyRingBell.data)
  return data_;
}
inline ::std::string* RequestNotifyRingBell::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RequestNotifyRingBell::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.RequestNotifyRingBell.data)
}

// -------------------------------------------------------------------

// RequestNotifyRingBellResponse

// -------------------------------------------------------------------

// PushRequestNotifyRingBell

// required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
inline bool PushRequestNotifyRingBell::has_push_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PushRequestNotifyRingBell::set_has_push_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PushRequestNotifyRingBell::clear_has_push_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PushRequestNotifyRingBell::clear_push_message_id() {
  push_message_id_ = 829;
  clear_has_push_message_id();
}
inline ::DS3_Frpg2RequestMessage::PushMessageId PushRequestNotifyRingBell::push_message_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.PushRequestNotifyRingBell.push_message_id)
  return static_cast< ::DS3_Frpg2RequestMessage::PushMessageId >(push_message_id_);
}
inline void PushRequestNotifyRingBell::set_push_message_id(::DS3_Frpg2RequestMessage::PushMessageId value) {
  assert(::DS3_Frpg2RequestMessage::PushMessageId_IsValid(value));
  set_has_push_message_id();
  push_message_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.PushRequestNotifyRingBell.push_message_id)
}

// required uint32 player_id = 2;
inline bool PushRequestNotifyRingBell::has_player_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PushRequestNotifyRingBell::set_has_player_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PushRequestNotifyRingBell::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PushRequestNotifyRingBell::clear_player_id() {
  player_id_ = 0u;
  clear_has_player_id();
}
inline ::google::protobuf::uint32 PushRequestNotifyRingBell::player_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.PushRequestNotifyRingBell.player_id)
  return player_id_;
}
inline void PushRequestNotifyRingBell::set_player_id(::google::protobuf::uint32 value) {
  set_has_player_id();
  player_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.PushRequestNotifyRingBell.player_id)
}

// required uint32 online_area_id = 3;
inline bool PushRequestNotifyRingBell::has_online_area_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PushRequestNotifyRingBell::set_has_online_area_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PushRequestNotifyRingBell::clear_has_online_area_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PushRequestNotifyRingBell::clear_online_area_id() {
  online_area_id_ = 0u;
  clear_has_online_area_id();
}
inline ::google::protobuf::uint32 PushRequestNotifyRingBell::online_area_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.PushRequestNotifyRingBell.online_area_id)
  return online_area_id_;
}
inline void PushRequestNotifyRingBell::set_online_area_id(::google::protobuf::uint32 value) {
  set_has_online_area_id();
  online_area_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.PushRequestNotifyRingBell.online_area_id)
}

// required bytes data = 4;
inline bool PushRequestNotifyRingBell::has_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PushRequestNotifyRingBell::set_has_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PushRequestNotifyRingBell::clear_has_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PushRequestNotifyRingBell::clear_data() {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& PushRequestNotifyRingBell::data() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.PushRequestNotifyRingBell.data)
  return *data_;
}
inline void PushRequestNotifyRingBell::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.PushRequestNotifyRingBell.data)
}
inline void PushRequestNotifyRingBell::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set_char:DS3_Frpg2RequestMessage.PushRequestNotifyRingBell.data)
}
inline void PushRequestNotifyRingBell::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DS3_Frpg2RequestMessage.PushRequestNotifyRingBell.data)
}
inline ::std::string* PushRequestNotifyRingBell::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.PushRequestNotifyRingBell.data)
  return data_;
}
inline ::std::string* PushRequestNotifyRingBell::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PushRequestNotifyRingBell::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.PushRequestNotifyRingBell.data)
}

// -------------------------------------------------------------------

// RequestGetRegulationFile

// -------------------------------------------------------------------

// RequestGetRegulationFileResponse

// -------------------------------------------------------------------

// RegulationFileMessage

// -------------------------------------------------------------------

// RegulationFileDiffData

// -------------------------------------------------------------------

// RegulationFileUpdateMessage

// -------------------------------------------------------------------

// RegulationFileUpdatePushMessage

// required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
inline bool RegulationFileUpdatePushMessage::has_push_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegulationFileUpdatePushMessage::set_has_push_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegulationFileUpdatePushMessage::clear_has_push_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegulationFileUpdatePushMessage::clear_push_message_id() {
  push_message_id_ = 829;
  clear_has_push_message_id();
}
inline ::DS3_Frpg2RequestMessage::PushMessageId RegulationFileUpdatePushMessage::push_message_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RegulationFileUpdatePushMessage.push_message_id)
  return static_cast< ::DS3_Frpg2RequestMessage::PushMessageId >(push_message_id_);
}
inline void RegulationFileUpdatePushMessage::set_push_message_id(::DS3_Frpg2RequestMessage::PushMessageId value) {
  assert(::DS3_Frpg2RequestMessage::PushMessageId_IsValid(value));
  set_has_push_message_id();
  push_message_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RegulationFileUpdatePushMessage.push_message_id)
}

// required .DS3_Frpg2RequestMessage.RegulationFileUpdateMessage update_message = 2;
inline bool RegulationFileUpdatePushMessage::has_update_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegulationFileUpdatePushMessage::set_has_update_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegulationFileUpdatePushMessage::clear_has_update_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegulationFileUpdatePushMessage::clear_update_message() {
  if (update_message_ != NULL) update_message_->::DS3_Frpg2RequestMessage::RegulationFileUpdateMessage::Clear();
  clear_has_update_message();
}
inline const ::DS3_Frpg2RequestMessage::RegulationFileUpdateMessage& RegulationFileUpdatePushMessage::update_message() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RegulationFileUpdatePushMessage.update_message)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return update_message_ != NULL ? *update_message_ : *default_instance().update_message_;
#else
  return update_message_ != NULL ? *update_message_ : *default_instance_->update_message_;
#endif
}
inline ::DS3_Frpg2RequestMessage::RegulationFileUpdateMessage* RegulationFileUpdatePushMessage::mutable_update_message() {
  set_has_update_message();
  if (update_message_ == NULL) update_message_ = new ::DS3_Frpg2RequestMessage::RegulationFileUpdateMessage;
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.RegulationFileUpdatePushMessage.update_message)
  return update_message_;
}
inline ::DS3_Frpg2RequestMessage::RegulationFileUpdateMessage* RegulationFileUpdatePushMessage::release_update_message() {
  clear_has_update_message();
  ::DS3_Frpg2RequestMessage::RegulationFileUpdateMessage* temp = update_message_;
  update_message_ = NULL;
  return temp;
}
inline void RegulationFileUpdatePushMessage::set_allocated_update_message(::DS3_Frpg2RequestMessage::RegulationFileUpdateMessage* update_message) {
  delete update_message_;
  update_message_ = update_message;
  if (update_message) {
    set_has_update_message();
  } else {
    clear_has_update_message();
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.RegulationFileUpdatePushMessage.update_message)
}

// -------------------------------------------------------------------

// RequestBenchmarkThroughput

// -------------------------------------------------------------------

// RequestBenchmarkThroughputResponse

// -------------------------------------------------------------------

// RequestGetLoginPlayerCharacter

// -------------------------------------------------------------------

// RequestGetLoginPlayerCharacterResponse

// -------------------------------------------------------------------

// RequestGetPlayerCharacterList

// -------------------------------------------------------------------

// RequestGetPlayerCharacterListResponse

// -------------------------------------------------------------------

// RequestMeasureUploadBandwidth

// -------------------------------------------------------------------

// RequestMeasureUploadBandwidthResponse

// -------------------------------------------------------------------

// RequestMeasureDownloadBandwidth

// -------------------------------------------------------------------

// RequestMeasureDownloadBandwidthResponse

// -------------------------------------------------------------------

// RequestSendMessageToPlayers

// repeated uint32 player_ids = 1;
inline int RequestSendMessageToPlayers::player_ids_size() const {
  return player_ids_.size();
}
inline void RequestSendMessageToPlayers::clear_player_ids() {
  player_ids_.Clear();
}
inline ::google::protobuf::uint32 RequestSendMessageToPlayers::player_ids(int index) const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestSendMessageToPlayers.player_ids)
  return player_ids_.Get(index);
}
inline void RequestSendMessageToPlayers::set_player_ids(int index, ::google::protobuf::uint32 value) {
  player_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestSendMessageToPlayers.player_ids)
}
inline void RequestSendMessageToPlayers::add_player_ids(::google::protobuf::uint32 value) {
  player_ids_.Add(value);
  // @@protoc_insertion_point(field_add:DS3_Frpg2RequestMessage.RequestSendMessageToPlayers.player_ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
RequestSendMessageToPlayers::player_ids() const {
  // @@protoc_insertion_point(field_list:DS3_Frpg2RequestMessage.RequestSendMessageToPlayers.player_ids)
  return player_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
RequestSendMessageToPlayers::mutable_player_ids() {
  // @@protoc_insertion_point(field_mutable_list:DS3_Frpg2RequestMessage.RequestSendMessageToPlayers.player_ids)
  return &player_ids_;
}

// required bytes message = 2;
inline bool RequestSendMessageToPlayers::has_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestSendMessageToPlayers::set_has_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestSendMessageToPlayers::clear_has_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestSendMessageToPlayers::clear_message() {
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& RequestSendMessageToPlayers::message() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestSendMessageToPlayers.message)
  return *message_;
}
inline void RequestSendMessageToPlayers::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(value);
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestSendMessageToPlayers.message)
}
inline void RequestSendMessageToPlayers::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(value);
  // @@protoc_insertion_point(field_set_char:DS3_Frpg2RequestMessage.RequestSendMessageToPlayers.message)
}
inline void RequestSendMessageToPlayers::set_message(const void* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DS3_Frpg2RequestMessage.RequestSendMessageToPlayers.message)
}
inline ::std::string* RequestSendMessageToPlayers::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.RequestSendMessageToPlayers.message)
  return message_;
}
inline ::std::string* RequestSendMessageToPlayers::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RequestSendMessageToPlayers::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.RequestSendMessageToPlayers.message)
}

// -------------------------------------------------------------------

// RequestSendMessageToPlayersResponse

// -------------------------------------------------------------------

// RequestSendMessageToSelectLanguagePlayers

// -------------------------------------------------------------------

// RequestSendMessageToSelectLanguagePlayersResponse

// -------------------------------------------------------------------

// RequestSendMessageToAllPlayers

// -------------------------------------------------------------------

// RequestSendMessageToAllPlayersResponse

// -------------------------------------------------------------------

// RequestSendPlayerList

// -------------------------------------------------------------------

// RankingData

// required uint32 player_id = 1;
inline bool RankingData::has_player_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RankingData::set_has_player_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RankingData::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RankingData::clear_player_id() {
  player_id_ = 0u;
  clear_has_player_id();
}
inline ::google::protobuf::uint32 RankingData::player_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RankingData.player_id)
  return player_id_;
}
inline void RankingData::set_player_id(::google::protobuf::uint32 value) {
  set_has_player_id();
  player_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RankingData.player_id)
}

// required uint32 character_id = 2;
inline bool RankingData::has_character_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RankingData::set_has_character_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RankingData::clear_has_character_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RankingData::clear_character_id() {
  character_id_ = 0u;
  clear_has_character_id();
}
inline ::google::protobuf::uint32 RankingData::character_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RankingData.character_id)
  return character_id_;
}
inline void RankingData::set_character_id(::google::protobuf::uint32 value) {
  set_has_character_id();
  character_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RankingData.character_id)
}

// required uint32 serial_rank = 3;
inline bool RankingData::has_serial_rank() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RankingData::set_has_serial_rank() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RankingData::clear_has_serial_rank() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RankingData::clear_serial_rank() {
  serial_rank_ = 0u;
  clear_has_serial_rank();
}
inline ::google::protobuf::uint32 RankingData::serial_rank() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RankingData.serial_rank)
  return serial_rank_;
}
inline void RankingData::set_serial_rank(::google::protobuf::uint32 value) {
  set_has_serial_rank();
  serial_rank_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RankingData.serial_rank)
}

// required uint32 rank = 4;
inline bool RankingData::has_rank() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RankingData::set_has_rank() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RankingData::clear_has_rank() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RankingData::clear_rank() {
  rank_ = 0u;
  clear_has_rank();
}
inline ::google::protobuf::uint32 RankingData::rank() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RankingData.rank)
  return rank_;
}
inline void RankingData::set_rank(::google::protobuf::uint32 value) {
  set_has_rank();
  rank_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RankingData.rank)
}

// required uint32 score = 5;
inline bool RankingData::has_score() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RankingData::set_has_score() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RankingData::clear_has_score() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RankingData::clear_score() {
  score_ = 0u;
  clear_has_score();
}
inline ::google::protobuf::uint32 RankingData::score() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RankingData.score)
  return score_;
}
inline void RankingData::set_score(::google::protobuf::uint32 value) {
  set_has_score();
  score_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RankingData.score)
}

// required bytes data = 6;
inline bool RankingData::has_data() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RankingData::set_has_data() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RankingData::clear_has_data() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RankingData::clear_data() {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& RankingData::data() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RankingData.data)
  return *data_;
}
inline void RankingData::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RankingData.data)
}
inline void RankingData::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set_char:DS3_Frpg2RequestMessage.RankingData.data)
}
inline void RankingData::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DS3_Frpg2RequestMessage.RankingData.data)
}
inline ::std::string* RankingData::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.RankingData.data)
  return data_;
}
inline ::std::string* RankingData::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RankingData::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.RankingData.data)
}

// -------------------------------------------------------------------

// RankingRotationID

// -------------------------------------------------------------------

// RankingRecordCount

// -------------------------------------------------------------------

// RankingDataPack

// -------------------------------------------------------------------

// RequestRegisterRankingData

// required uint32 board_id = 1;
inline bool RequestRegisterRankingData::has_board_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestRegisterRankingData::set_has_board_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestRegisterRankingData::clear_has_board_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestRegisterRankingData::clear_board_id() {
  board_id_ = 0u;
  clear_has_board_id();
}
inline ::google::protobuf::uint32 RequestRegisterRankingData::board_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestRegisterRankingData.board_id)
  return board_id_;
}
inline void RequestRegisterRankingData::set_board_id(::google::protobuf::uint32 value) {
  set_has_board_id();
  board_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestRegisterRankingData.board_id)
}

// required uint32 character_id = 2;
inline bool RequestRegisterRankingData::has_character_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestRegisterRankingData::set_has_character_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestRegisterRankingData::clear_has_character_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestRegisterRankingData::clear_character_id() {
  character_id_ = 0u;
  clear_has_character_id();
}
inline ::google::protobuf::uint32 RequestRegisterRankingData::character_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestRegisterRankingData.character_id)
  return character_id_;
}
inline void RequestRegisterRankingData::set_character_id(::google::protobuf::uint32 value) {
  set_has_character_id();
  character_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestRegisterRankingData.character_id)
}

// required uint32 score = 3;
inline bool RequestRegisterRankingData::has_score() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestRegisterRankingData::set_has_score() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestRegisterRankingData::clear_has_score() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestRegisterRankingData::clear_score() {
  score_ = 0u;
  clear_has_score();
}
inline ::google::protobuf::uint32 RequestRegisterRankingData::score() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestRegisterRankingData.score)
  return score_;
}
inline void RequestRegisterRankingData::set_score(::google::protobuf::uint32 value) {
  set_has_score();
  score_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestRegisterRankingData.score)
}

// required bytes data = 4;
inline bool RequestRegisterRankingData::has_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestRegisterRankingData::set_has_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestRegisterRankingData::clear_has_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestRegisterRankingData::clear_data() {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& RequestRegisterRankingData::data() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestRegisterRankingData.data)
  return *data_;
}
inline void RequestRegisterRankingData::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestRegisterRankingData.data)
}
inline void RequestRegisterRankingData::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set_char:DS3_Frpg2RequestMessage.RequestRegisterRankingData.data)
}
inline void RequestRegisterRankingData::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DS3_Frpg2RequestMessage.RequestRegisterRankingData.data)
}
inline ::std::string* RequestRegisterRankingData::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.RequestRegisterRankingData.data)
  return data_;
}
inline ::std::string* RequestRegisterRankingData::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RequestRegisterRankingData::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.RequestRegisterRankingData.data)
}

// -------------------------------------------------------------------

// RequestRegisterRankingDataResponse

// -------------------------------------------------------------------

// RequestGetRankingData

// required uint32 board_id = 1;
inline bool RequestGetRankingData::has_board_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestGetRankingData::set_has_board_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestGetRankingData::clear_has_board_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestGetRankingData::clear_board_id() {
  board_id_ = 0u;
  clear_has_board_id();
}
inline ::google::protobuf::uint32 RequestGetRankingData::board_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestGetRankingData.board_id)
  return board_id_;
}
inline void RequestGetRankingData::set_board_id(::google::protobuf::uint32 value) {
  set_has_board_id();
  board_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestGetRankingData.board_id)
}

// required uint32 offset = 2;
inline bool RequestGetRankingData::has_offset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestGetRankingData::set_has_offset() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestGetRankingData::clear_has_offset() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestGetRankingData::clear_offset() {
  offset_ = 0u;
  clear_has_offset();
}
inline ::google::protobuf::uint32 RequestGetRankingData::offset() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestGetRankingData.offset)
  return offset_;
}
inline void RequestGetRankingData::set_offset(::google::protobuf::uint32 value) {
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestGetRankingData.offset)
}

// required uint32 count = 3;
inline bool RequestGetRankingData::has_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestGetRankingData::set_has_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestGetRankingData::clear_has_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestGetRankingData::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 RequestGetRankingData::count() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestGetRankingData.count)
  return count_;
}
inline void RequestGetRankingData::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestGetRankingData.count)
}

// -------------------------------------------------------------------

// RequestGetRankingDataResponse

// repeated .DS3_Frpg2RequestMessage.RankingData data = 1;
inline int RequestGetRankingDataResponse::data_size() const {
  return data_.size();
}
inline void RequestGetRankingDataResponse::clear_data() {
  data_.Clear();
}
inline const ::DS3_Frpg2RequestMessage::RankingData& RequestGetRankingDataResponse::data(int index) const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestGetRankingDataResponse.data)
  return data_.Get(index);
}
inline ::DS3_Frpg2RequestMessage::RankingData* RequestGetRankingDataResponse::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.RequestGetRankingDataResponse.data)
  return data_.Mutable(index);
}
inline ::DS3_Frpg2RequestMessage::RankingData* RequestGetRankingDataResponse::add_data() {
  // @@protoc_insertion_point(field_add:DS3_Frpg2RequestMessage.RequestGetRankingDataResponse.data)
  return data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::RankingData >&
RequestGetRankingDataResponse::data() const {
  // @@protoc_insertion_point(field_list:DS3_Frpg2RequestMessage.RequestGetRankingDataResponse.data)
  return data_;
}
inline ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::RankingData >*
RequestGetRankingDataResponse::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:DS3_Frpg2RequestMessage.RequestGetRankingDataResponse.data)
  return &data_;
}

// -------------------------------------------------------------------

// RequestGetCharacterRankingData

// required uint32 board_id = 1;
inline bool RequestGetCharacterRankingData::has_board_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestGetCharacterRankingData::set_has_board_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestGetCharacterRankingData::clear_has_board_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestGetCharacterRankingData::clear_board_id() {
  board_id_ = 0u;
  clear_has_board_id();
}
inline ::google::protobuf::uint32 RequestGetCharacterRankingData::board_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestGetCharacterRankingData.board_id)
  return board_id_;
}
inline void RequestGetCharacterRankingData::set_board_id(::google::protobuf::uint32 value) {
  set_has_board_id();
  board_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestGetCharacterRankingData.board_id)
}

// required uint32 character_id = 2;
inline bool RequestGetCharacterRankingData::has_character_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestGetCharacterRankingData::set_has_character_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestGetCharacterRankingData::clear_has_character_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestGetCharacterRankingData::clear_character_id() {
  character_id_ = 0u;
  clear_has_character_id();
}
inline ::google::protobuf::uint32 RequestGetCharacterRankingData::character_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestGetCharacterRankingData.character_id)
  return character_id_;
}
inline void RequestGetCharacterRankingData::set_character_id(::google::protobuf::uint32 value) {
  set_has_character_id();
  character_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestGetCharacterRankingData.character_id)
}

// -------------------------------------------------------------------

// RequestGetCharacterRankingDataResponse

// optional .DS3_Frpg2RequestMessage.RankingData data = 1;
inline bool RequestGetCharacterRankingDataResponse::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestGetCharacterRankingDataResponse::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestGetCharacterRankingDataResponse::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestGetCharacterRankingDataResponse::clear_data() {
  if (data_ != NULL) data_->::DS3_Frpg2RequestMessage::RankingData::Clear();
  clear_has_data();
}
inline const ::DS3_Frpg2RequestMessage::RankingData& RequestGetCharacterRankingDataResponse::data() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestGetCharacterRankingDataResponse.data)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return data_ != NULL ? *data_ : *default_instance().data_;
#else
  return data_ != NULL ? *data_ : *default_instance_->data_;
#endif
}
inline ::DS3_Frpg2RequestMessage::RankingData* RequestGetCharacterRankingDataResponse::mutable_data() {
  set_has_data();
  if (data_ == NULL) data_ = new ::DS3_Frpg2RequestMessage::RankingData;
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.RequestGetCharacterRankingDataResponse.data)
  return data_;
}
inline ::DS3_Frpg2RequestMessage::RankingData* RequestGetCharacterRankingDataResponse::release_data() {
  clear_has_data();
  ::DS3_Frpg2RequestMessage::RankingData* temp = data_;
  data_ = NULL;
  return temp;
}
inline void RequestGetCharacterRankingDataResponse::set_allocated_data(::DS3_Frpg2RequestMessage::RankingData* data) {
  delete data_;
  data_ = data;
  if (data) {
    set_has_data();
  } else {
    clear_has_data();
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.RequestGetCharacterRankingDataResponse.data)
}

// -------------------------------------------------------------------

// RequestCountRankingData

// required uint32 board_id = 1;
inline bool RequestCountRankingData::has_board_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestCountRankingData::set_has_board_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestCountRankingData::clear_has_board_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestCountRankingData::clear_board_id() {
  board_id_ = 0u;
  clear_has_board_id();
}
inline ::google::protobuf::uint32 RequestCountRankingData::board_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestCountRankingData.board_id)
  return board_id_;
}
inline void RequestCountRankingData::set_board_id(::google::protobuf::uint32 value) {
  set_has_board_id();
  board_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestCountRankingData.board_id)
}

// -------------------------------------------------------------------

// RequestCountRankingDataResponse

// required uint32 count = 1;
inline bool RequestCountRankingDataResponse::has_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestCountRankingDataResponse::set_has_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestCountRankingDataResponse::clear_has_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestCountRankingDataResponse::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 RequestCountRankingDataResponse::count() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestCountRankingDataResponse.count)
  return count_;
}
inline void RequestCountRankingDataResponse::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestCountRankingDataResponse.count)
}

// -------------------------------------------------------------------

// RequestGetCurrentRank

// -------------------------------------------------------------------

// RequestGetCurrentRankResponse

// -------------------------------------------------------------------

// QuickMatchRank

// optional uint32 rank = 1;
inline bool QuickMatchRank::has_rank() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QuickMatchRank::set_has_rank() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QuickMatchRank::clear_has_rank() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QuickMatchRank::clear_rank() {
  rank_ = 0u;
  clear_has_rank();
}
inline ::google::protobuf::uint32 QuickMatchRank::rank() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.QuickMatchRank.rank)
  return rank_;
}
inline void QuickMatchRank::set_rank(::google::protobuf::uint32 value) {
  set_has_rank();
  rank_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.QuickMatchRank.rank)
}

// optional uint32 xp = 2;
inline bool QuickMatchRank::has_xp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QuickMatchRank::set_has_xp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void QuickMatchRank::clear_has_xp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void QuickMatchRank::clear_xp() {
  xp_ = 0u;
  clear_has_xp();
}
inline ::google::protobuf::uint32 QuickMatchRank::xp() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.QuickMatchRank.xp)
  return xp_;
}
inline void QuickMatchRank::set_xp(::google::protobuf::uint32 value) {
  set_has_xp();
  xp_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.QuickMatchRank.xp)
}

// -------------------------------------------------------------------

// QuickMatchRankCache

// -------------------------------------------------------------------

// QuickMatchSession_Result_list

// -------------------------------------------------------------------

// QuickMatchSession

// repeated group Result_list = 2 {
inline int QuickMatchSession::result_list_size() const {
  return result_list_.size();
}
inline void QuickMatchSession::clear_result_list() {
  result_list_.Clear();
}
inline const ::DS3_Frpg2RequestMessage::QuickMatchSession_Result_list& QuickMatchSession::result_list(int index) const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.QuickMatchSession.result_list)
  return result_list_.Get(index);
}
inline ::DS3_Frpg2RequestMessage::QuickMatchSession_Result_list* QuickMatchSession::mutable_result_list(int index) {
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.QuickMatchSession.result_list)
  return result_list_.Mutable(index);
}
inline ::DS3_Frpg2RequestMessage::QuickMatchSession_Result_list* QuickMatchSession::add_result_list() {
  // @@protoc_insertion_point(field_add:DS3_Frpg2RequestMessage.QuickMatchSession.result_list)
  return result_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::QuickMatchSession_Result_list >&
QuickMatchSession::result_list() const {
  // @@protoc_insertion_point(field_list:DS3_Frpg2RequestMessage.QuickMatchSession.result_list)
  return result_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::QuickMatchSession_Result_list >*
QuickMatchSession::mutable_result_list() {
  // @@protoc_insertion_point(field_mutable_list:DS3_Frpg2RequestMessage.QuickMatchSession.result_list)
  return &result_list_;
}

// -------------------------------------------------------------------

// QuickMatchApologyPoint

// -------------------------------------------------------------------

// QuickMatchData

// required uint32 host_player_id = 1;
inline bool QuickMatchData::has_host_player_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QuickMatchData::set_has_host_player_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QuickMatchData::clear_has_host_player_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QuickMatchData::clear_host_player_id() {
  host_player_id_ = 0u;
  clear_has_host_player_id();
}
inline ::google::protobuf::uint32 QuickMatchData::host_player_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.QuickMatchData.host_player_id)
  return host_player_id_;
}
inline void QuickMatchData::set_host_player_id(::google::protobuf::uint32 value) {
  set_has_host_player_id();
  host_player_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.QuickMatchData.host_player_id)
}

// required string host_player_steam_id = 2;
inline bool QuickMatchData::has_host_player_steam_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QuickMatchData::set_has_host_player_steam_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void QuickMatchData::clear_has_host_player_steam_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void QuickMatchData::clear_host_player_steam_id() {
  if (host_player_steam_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    host_player_steam_id_->clear();
  }
  clear_has_host_player_steam_id();
}
inline const ::std::string& QuickMatchData::host_player_steam_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.QuickMatchData.host_player_steam_id)
  return *host_player_steam_id_;
}
inline void QuickMatchData::set_host_player_steam_id(const ::std::string& value) {
  set_has_host_player_steam_id();
  if (host_player_steam_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    host_player_steam_id_ = new ::std::string;
  }
  host_player_steam_id_->assign(value);
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.QuickMatchData.host_player_steam_id)
}
inline void QuickMatchData::set_host_player_steam_id(const char* value) {
  set_has_host_player_steam_id();
  if (host_player_steam_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    host_player_steam_id_ = new ::std::string;
  }
  host_player_steam_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:DS3_Frpg2RequestMessage.QuickMatchData.host_player_steam_id)
}
inline void QuickMatchData::set_host_player_steam_id(const char* value, size_t size) {
  set_has_host_player_steam_id();
  if (host_player_steam_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    host_player_steam_id_ = new ::std::string;
  }
  host_player_steam_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DS3_Frpg2RequestMessage.QuickMatchData.host_player_steam_id)
}
inline ::std::string* QuickMatchData::mutable_host_player_steam_id() {
  set_has_host_player_steam_id();
  if (host_player_steam_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    host_player_steam_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.QuickMatchData.host_player_steam_id)
  return host_player_steam_id_;
}
inline ::std::string* QuickMatchData::release_host_player_steam_id() {
  clear_has_host_player_steam_id();
  if (host_player_steam_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = host_player_steam_id_;
    host_player_steam_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void QuickMatchData::set_allocated_host_player_steam_id(::std::string* host_player_steam_id) {
  if (host_player_steam_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete host_player_steam_id_;
  }
  if (host_player_steam_id) {
    set_has_host_player_steam_id();
    host_player_steam_id_ = host_player_steam_id;
  } else {
    clear_has_host_player_steam_id();
    host_player_steam_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.QuickMatchData.host_player_steam_id)
}

// required uint32 online_area_id = 3;
inline bool QuickMatchData::has_online_area_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void QuickMatchData::set_has_online_area_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void QuickMatchData::clear_has_online_area_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void QuickMatchData::clear_online_area_id() {
  online_area_id_ = 0u;
  clear_has_online_area_id();
}
inline ::google::protobuf::uint32 QuickMatchData::online_area_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.QuickMatchData.online_area_id)
  return online_area_id_;
}
inline void QuickMatchData::set_online_area_id(::google::protobuf::uint32 value) {
  set_has_online_area_id();
  online_area_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.QuickMatchData.online_area_id)
}

// -------------------------------------------------------------------

// QuickMatchSearchResult

// optional .DS3_Frpg2RequestMessage.QuickMatchData data = 2;
inline bool QuickMatchSearchResult::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QuickMatchSearchResult::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QuickMatchSearchResult::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QuickMatchSearchResult::clear_data() {
  if (data_ != NULL) data_->::DS3_Frpg2RequestMessage::QuickMatchData::Clear();
  clear_has_data();
}
inline const ::DS3_Frpg2RequestMessage::QuickMatchData& QuickMatchSearchResult::data() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.QuickMatchSearchResult.data)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return data_ != NULL ? *data_ : *default_instance().data_;
#else
  return data_ != NULL ? *data_ : *default_instance_->data_;
#endif
}
inline ::DS3_Frpg2RequestMessage::QuickMatchData* QuickMatchSearchResult::mutable_data() {
  set_has_data();
  if (data_ == NULL) data_ = new ::DS3_Frpg2RequestMessage::QuickMatchData;
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.QuickMatchSearchResult.data)
  return data_;
}
inline ::DS3_Frpg2RequestMessage::QuickMatchData* QuickMatchSearchResult::release_data() {
  clear_has_data();
  ::DS3_Frpg2RequestMessage::QuickMatchData* temp = data_;
  data_ = NULL;
  return temp;
}
inline void QuickMatchSearchResult::set_allocated_data(::DS3_Frpg2RequestMessage::QuickMatchData* data) {
  delete data_;
  data_ = data;
  if (data) {
    set_has_data();
  } else {
    clear_has_data();
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.QuickMatchSearchResult.data)
}

// required uint32 unknown_3 = 3;
inline bool QuickMatchSearchResult::has_unknown_3() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QuickMatchSearchResult::set_has_unknown_3() {
  _has_bits_[0] |= 0x00000002u;
}
inline void QuickMatchSearchResult::clear_has_unknown_3() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void QuickMatchSearchResult::clear_unknown_3() {
  unknown_3_ = 0u;
  clear_has_unknown_3();
}
inline ::google::protobuf::uint32 QuickMatchSearchResult::unknown_3() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.QuickMatchSearchResult.unknown_3)
  return unknown_3_;
}
inline void QuickMatchSearchResult::set_unknown_3(::google::protobuf::uint32 value) {
  set_has_unknown_3();
  unknown_3_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.QuickMatchSearchResult.unknown_3)
}

// required uint32 unknown_4 = 4;
inline bool QuickMatchSearchResult::has_unknown_4() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void QuickMatchSearchResult::set_has_unknown_4() {
  _has_bits_[0] |= 0x00000004u;
}
inline void QuickMatchSearchResult::clear_has_unknown_4() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void QuickMatchSearchResult::clear_unknown_4() {
  unknown_4_ = 0u;
  clear_has_unknown_4();
}
inline ::google::protobuf::uint32 QuickMatchSearchResult::unknown_4() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.QuickMatchSearchResult.unknown_4)
  return unknown_4_;
}
inline void QuickMatchSearchResult::set_unknown_4(::google::protobuf::uint32 value) {
  set_has_unknown_4();
  unknown_4_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.QuickMatchSearchResult.unknown_4)
}

// -------------------------------------------------------------------

// AcceptQuickMatchMessage

// required uint32 host_player_id = 1;
inline bool AcceptQuickMatchMessage::has_host_player_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AcceptQuickMatchMessage::set_has_host_player_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AcceptQuickMatchMessage::clear_has_host_player_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AcceptQuickMatchMessage::clear_host_player_id() {
  host_player_id_ = 0u;
  clear_has_host_player_id();
}
inline ::google::protobuf::uint32 AcceptQuickMatchMessage::host_player_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.AcceptQuickMatchMessage.host_player_id)
  return host_player_id_;
}
inline void AcceptQuickMatchMessage::set_host_player_id(::google::protobuf::uint32 value) {
  set_has_host_player_id();
  host_player_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.AcceptQuickMatchMessage.host_player_id)
}

// required string host_player_steam_id = 2;
inline bool AcceptQuickMatchMessage::has_host_player_steam_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AcceptQuickMatchMessage::set_has_host_player_steam_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AcceptQuickMatchMessage::clear_has_host_player_steam_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AcceptQuickMatchMessage::clear_host_player_steam_id() {
  if (host_player_steam_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    host_player_steam_id_->clear();
  }
  clear_has_host_player_steam_id();
}
inline const ::std::string& AcceptQuickMatchMessage::host_player_steam_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.AcceptQuickMatchMessage.host_player_steam_id)
  return *host_player_steam_id_;
}
inline void AcceptQuickMatchMessage::set_host_player_steam_id(const ::std::string& value) {
  set_has_host_player_steam_id();
  if (host_player_steam_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    host_player_steam_id_ = new ::std::string;
  }
  host_player_steam_id_->assign(value);
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.AcceptQuickMatchMessage.host_player_steam_id)
}
inline void AcceptQuickMatchMessage::set_host_player_steam_id(const char* value) {
  set_has_host_player_steam_id();
  if (host_player_steam_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    host_player_steam_id_ = new ::std::string;
  }
  host_player_steam_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:DS3_Frpg2RequestMessage.AcceptQuickMatchMessage.host_player_steam_id)
}
inline void AcceptQuickMatchMessage::set_host_player_steam_id(const char* value, size_t size) {
  set_has_host_player_steam_id();
  if (host_player_steam_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    host_player_steam_id_ = new ::std::string;
  }
  host_player_steam_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DS3_Frpg2RequestMessage.AcceptQuickMatchMessage.host_player_steam_id)
}
inline ::std::string* AcceptQuickMatchMessage::mutable_host_player_steam_id() {
  set_has_host_player_steam_id();
  if (host_player_steam_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    host_player_steam_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.AcceptQuickMatchMessage.host_player_steam_id)
  return host_player_steam_id_;
}
inline ::std::string* AcceptQuickMatchMessage::release_host_player_steam_id() {
  clear_has_host_player_steam_id();
  if (host_player_steam_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = host_player_steam_id_;
    host_player_steam_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AcceptQuickMatchMessage::set_allocated_host_player_steam_id(::std::string* host_player_steam_id) {
  if (host_player_steam_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete host_player_steam_id_;
  }
  if (host_player_steam_id) {
    set_has_host_player_steam_id();
    host_player_steam_id_ = host_player_steam_id;
  } else {
    clear_has_host_player_steam_id();
    host_player_steam_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.AcceptQuickMatchMessage.host_player_steam_id)
}

// required bytes metadata = 3;
inline bool AcceptQuickMatchMessage::has_metadata() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AcceptQuickMatchMessage::set_has_metadata() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AcceptQuickMatchMessage::clear_has_metadata() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AcceptQuickMatchMessage::clear_metadata() {
  if (metadata_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    metadata_->clear();
  }
  clear_has_metadata();
}
inline const ::std::string& AcceptQuickMatchMessage::metadata() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.AcceptQuickMatchMessage.metadata)
  return *metadata_;
}
inline void AcceptQuickMatchMessage::set_metadata(const ::std::string& value) {
  set_has_metadata();
  if (metadata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    metadata_ = new ::std::string;
  }
  metadata_->assign(value);
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.AcceptQuickMatchMessage.metadata)
}
inline void AcceptQuickMatchMessage::set_metadata(const char* value) {
  set_has_metadata();
  if (metadata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    metadata_ = new ::std::string;
  }
  metadata_->assign(value);
  // @@protoc_insertion_point(field_set_char:DS3_Frpg2RequestMessage.AcceptQuickMatchMessage.metadata)
}
inline void AcceptQuickMatchMessage::set_metadata(const void* value, size_t size) {
  set_has_metadata();
  if (metadata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    metadata_ = new ::std::string;
  }
  metadata_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DS3_Frpg2RequestMessage.AcceptQuickMatchMessage.metadata)
}
inline ::std::string* AcceptQuickMatchMessage::mutable_metadata() {
  set_has_metadata();
  if (metadata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    metadata_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.AcceptQuickMatchMessage.metadata)
  return metadata_;
}
inline ::std::string* AcceptQuickMatchMessage::release_metadata() {
  clear_has_metadata();
  if (metadata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = metadata_;
    metadata_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AcceptQuickMatchMessage::set_allocated_metadata(::std::string* metadata) {
  if (metadata_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete metadata_;
  }
  if (metadata) {
    set_has_metadata();
    metadata_ = metadata;
  } else {
    clear_has_metadata();
    metadata_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.AcceptQuickMatchMessage.metadata)
}

// -------------------------------------------------------------------

// RejectQuickMatchMessage

// required uint32 host_player_id = 1;
inline bool RejectQuickMatchMessage::has_host_player_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RejectQuickMatchMessage::set_has_host_player_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RejectQuickMatchMessage::clear_has_host_player_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RejectQuickMatchMessage::clear_host_player_id() {
  host_player_id_ = 0u;
  clear_has_host_player_id();
}
inline ::google::protobuf::uint32 RejectQuickMatchMessage::host_player_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RejectQuickMatchMessage.host_player_id)
  return host_player_id_;
}
inline void RejectQuickMatchMessage::set_host_player_id(::google::protobuf::uint32 value) {
  set_has_host_player_id();
  host_player_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RejectQuickMatchMessage.host_player_id)
}

// required uint32 unknown_2 = 2;
inline bool RejectQuickMatchMessage::has_unknown_2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RejectQuickMatchMessage::set_has_unknown_2() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RejectQuickMatchMessage::clear_has_unknown_2() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RejectQuickMatchMessage::clear_unknown_2() {
  unknown_2_ = 0u;
  clear_has_unknown_2();
}
inline ::google::protobuf::uint32 RejectQuickMatchMessage::unknown_2() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RejectQuickMatchMessage.unknown_2)
  return unknown_2_;
}
inline void RejectQuickMatchMessage::set_unknown_2(::google::protobuf::uint32 value) {
  set_has_unknown_2();
  unknown_2_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RejectQuickMatchMessage.unknown_2)
}

// -------------------------------------------------------------------

// RemoveQuickMatchMessage

// -------------------------------------------------------------------

// JoinQuickMatchMessage

// required uint32 join_player_id = 1;
inline bool JoinQuickMatchMessage::has_join_player_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JoinQuickMatchMessage::set_has_join_player_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JoinQuickMatchMessage::clear_has_join_player_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JoinQuickMatchMessage::clear_join_player_id() {
  join_player_id_ = 0u;
  clear_has_join_player_id();
}
inline ::google::protobuf::uint32 JoinQuickMatchMessage::join_player_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.JoinQuickMatchMessage.join_player_id)
  return join_player_id_;
}
inline void JoinQuickMatchMessage::set_join_player_id(::google::protobuf::uint32 value) {
  set_has_join_player_id();
  join_player_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.JoinQuickMatchMessage.join_player_id)
}

// required string join_player_steam_id = 2;
inline bool JoinQuickMatchMessage::has_join_player_steam_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void JoinQuickMatchMessage::set_has_join_player_steam_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void JoinQuickMatchMessage::clear_has_join_player_steam_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void JoinQuickMatchMessage::clear_join_player_steam_id() {
  if (join_player_steam_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    join_player_steam_id_->clear();
  }
  clear_has_join_player_steam_id();
}
inline const ::std::string& JoinQuickMatchMessage::join_player_steam_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.JoinQuickMatchMessage.join_player_steam_id)
  return *join_player_steam_id_;
}
inline void JoinQuickMatchMessage::set_join_player_steam_id(const ::std::string& value) {
  set_has_join_player_steam_id();
  if (join_player_steam_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    join_player_steam_id_ = new ::std::string;
  }
  join_player_steam_id_->assign(value);
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.JoinQuickMatchMessage.join_player_steam_id)
}
inline void JoinQuickMatchMessage::set_join_player_steam_id(const char* value) {
  set_has_join_player_steam_id();
  if (join_player_steam_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    join_player_steam_id_ = new ::std::string;
  }
  join_player_steam_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:DS3_Frpg2RequestMessage.JoinQuickMatchMessage.join_player_steam_id)
}
inline void JoinQuickMatchMessage::set_join_player_steam_id(const char* value, size_t size) {
  set_has_join_player_steam_id();
  if (join_player_steam_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    join_player_steam_id_ = new ::std::string;
  }
  join_player_steam_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DS3_Frpg2RequestMessage.JoinQuickMatchMessage.join_player_steam_id)
}
inline ::std::string* JoinQuickMatchMessage::mutable_join_player_steam_id() {
  set_has_join_player_steam_id();
  if (join_player_steam_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    join_player_steam_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.JoinQuickMatchMessage.join_player_steam_id)
  return join_player_steam_id_;
}
inline ::std::string* JoinQuickMatchMessage::release_join_player_steam_id() {
  clear_has_join_player_steam_id();
  if (join_player_steam_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = join_player_steam_id_;
    join_player_steam_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void JoinQuickMatchMessage::set_allocated_join_player_steam_id(::std::string* join_player_steam_id) {
  if (join_player_steam_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete join_player_steam_id_;
  }
  if (join_player_steam_id) {
    set_has_join_player_steam_id();
    join_player_steam_id_ = join_player_steam_id;
  } else {
    clear_has_join_player_steam_id();
    join_player_steam_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.JoinQuickMatchMessage.join_player_steam_id)
}

// required uint32 join_character_id = 3;
inline bool JoinQuickMatchMessage::has_join_character_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void JoinQuickMatchMessage::set_has_join_character_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void JoinQuickMatchMessage::clear_has_join_character_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void JoinQuickMatchMessage::clear_join_character_id() {
  join_character_id_ = 0u;
  clear_has_join_character_id();
}
inline ::google::protobuf::uint32 JoinQuickMatchMessage::join_character_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.JoinQuickMatchMessage.join_character_id)
  return join_character_id_;
}
inline void JoinQuickMatchMessage::set_join_character_id(::google::protobuf::uint32 value) {
  set_has_join_character_id();
  join_character_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.JoinQuickMatchMessage.join_character_id)
}

// required uint32 online_area_id = 4;
inline bool JoinQuickMatchMessage::has_online_area_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void JoinQuickMatchMessage::set_has_online_area_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void JoinQuickMatchMessage::clear_has_online_area_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void JoinQuickMatchMessage::clear_online_area_id() {
  online_area_id_ = 0u;
  clear_has_online_area_id();
}
inline ::google::protobuf::uint32 JoinQuickMatchMessage::online_area_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.JoinQuickMatchMessage.online_area_id)
  return online_area_id_;
}
inline void JoinQuickMatchMessage::set_online_area_id(::google::protobuf::uint32 value) {
  set_has_online_area_id();
  online_area_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.JoinQuickMatchMessage.online_area_id)
}

// required uint32 unknown_5 = 5;
inline bool JoinQuickMatchMessage::has_unknown_5() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void JoinQuickMatchMessage::set_has_unknown_5() {
  _has_bits_[0] |= 0x00000010u;
}
inline void JoinQuickMatchMessage::clear_has_unknown_5() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void JoinQuickMatchMessage::clear_unknown_5() {
  unknown_5_ = 0u;
  clear_has_unknown_5();
}
inline ::google::protobuf::uint32 JoinQuickMatchMessage::unknown_5() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.JoinQuickMatchMessage.unknown_5)
  return unknown_5_;
}
inline void JoinQuickMatchMessage::set_unknown_5(::google::protobuf::uint32 value) {
  set_has_unknown_5();
  unknown_5_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.JoinQuickMatchMessage.unknown_5)
}

// required bytes unknown_6 = 6;
inline bool JoinQuickMatchMessage::has_unknown_6() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void JoinQuickMatchMessage::set_has_unknown_6() {
  _has_bits_[0] |= 0x00000020u;
}
inline void JoinQuickMatchMessage::clear_has_unknown_6() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void JoinQuickMatchMessage::clear_unknown_6() {
  if (unknown_6_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unknown_6_->clear();
  }
  clear_has_unknown_6();
}
inline const ::std::string& JoinQuickMatchMessage::unknown_6() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.JoinQuickMatchMessage.unknown_6)
  return *unknown_6_;
}
inline void JoinQuickMatchMessage::set_unknown_6(const ::std::string& value) {
  set_has_unknown_6();
  if (unknown_6_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unknown_6_ = new ::std::string;
  }
  unknown_6_->assign(value);
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.JoinQuickMatchMessage.unknown_6)
}
inline void JoinQuickMatchMessage::set_unknown_6(const char* value) {
  set_has_unknown_6();
  if (unknown_6_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unknown_6_ = new ::std::string;
  }
  unknown_6_->assign(value);
  // @@protoc_insertion_point(field_set_char:DS3_Frpg2RequestMessage.JoinQuickMatchMessage.unknown_6)
}
inline void JoinQuickMatchMessage::set_unknown_6(const void* value, size_t size) {
  set_has_unknown_6();
  if (unknown_6_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unknown_6_ = new ::std::string;
  }
  unknown_6_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DS3_Frpg2RequestMessage.JoinQuickMatchMessage.unknown_6)
}
inline ::std::string* JoinQuickMatchMessage::mutable_unknown_6() {
  set_has_unknown_6();
  if (unknown_6_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unknown_6_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.JoinQuickMatchMessage.unknown_6)
  return unknown_6_;
}
inline ::std::string* JoinQuickMatchMessage::release_unknown_6() {
  clear_has_unknown_6();
  if (unknown_6_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = unknown_6_;
    unknown_6_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void JoinQuickMatchMessage::set_allocated_unknown_6(::std::string* unknown_6) {
  if (unknown_6_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete unknown_6_;
  }
  if (unknown_6) {
    set_has_unknown_6();
    unknown_6_ = unknown_6;
  } else {
    clear_has_unknown_6();
    unknown_6_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.JoinQuickMatchMessage.unknown_6)
}

// -------------------------------------------------------------------

// PushRequestJoinQuickMatch

// required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
inline bool PushRequestJoinQuickMatch::has_push_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PushRequestJoinQuickMatch::set_has_push_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PushRequestJoinQuickMatch::clear_has_push_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PushRequestJoinQuickMatch::clear_push_message_id() {
  push_message_id_ = 829;
  clear_has_push_message_id();
}
inline ::DS3_Frpg2RequestMessage::PushMessageId PushRequestJoinQuickMatch::push_message_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.PushRequestJoinQuickMatch.push_message_id)
  return static_cast< ::DS3_Frpg2RequestMessage::PushMessageId >(push_message_id_);
}
inline void PushRequestJoinQuickMatch::set_push_message_id(::DS3_Frpg2RequestMessage::PushMessageId value) {
  assert(::DS3_Frpg2RequestMessage::PushMessageId_IsValid(value));
  set_has_push_message_id();
  push_message_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.PushRequestJoinQuickMatch.push_message_id)
}

// required .DS3_Frpg2RequestMessage.JoinQuickMatchMessage message = 2;
inline bool PushRequestJoinQuickMatch::has_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PushRequestJoinQuickMatch::set_has_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PushRequestJoinQuickMatch::clear_has_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PushRequestJoinQuickMatch::clear_message() {
  if (message_ != NULL) message_->::DS3_Frpg2RequestMessage::JoinQuickMatchMessage::Clear();
  clear_has_message();
}
inline const ::DS3_Frpg2RequestMessage::JoinQuickMatchMessage& PushRequestJoinQuickMatch::message() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.PushRequestJoinQuickMatch.message)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return message_ != NULL ? *message_ : *default_instance().message_;
#else
  return message_ != NULL ? *message_ : *default_instance_->message_;
#endif
}
inline ::DS3_Frpg2RequestMessage::JoinQuickMatchMessage* PushRequestJoinQuickMatch::mutable_message() {
  set_has_message();
  if (message_ == NULL) message_ = new ::DS3_Frpg2RequestMessage::JoinQuickMatchMessage;
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.PushRequestJoinQuickMatch.message)
  return message_;
}
inline ::DS3_Frpg2RequestMessage::JoinQuickMatchMessage* PushRequestJoinQuickMatch::release_message() {
  clear_has_message();
  ::DS3_Frpg2RequestMessage::JoinQuickMatchMessage* temp = message_;
  message_ = NULL;
  return temp;
}
inline void PushRequestJoinQuickMatch::set_allocated_message(::DS3_Frpg2RequestMessage::JoinQuickMatchMessage* message) {
  delete message_;
  message_ = message;
  if (message) {
    set_has_message();
  } else {
    clear_has_message();
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.PushRequestJoinQuickMatch.message)
}

// -------------------------------------------------------------------

// PushRequestAcceptQuickMatch

// required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
inline bool PushRequestAcceptQuickMatch::has_push_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PushRequestAcceptQuickMatch::set_has_push_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PushRequestAcceptQuickMatch::clear_has_push_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PushRequestAcceptQuickMatch::clear_push_message_id() {
  push_message_id_ = 829;
  clear_has_push_message_id();
}
inline ::DS3_Frpg2RequestMessage::PushMessageId PushRequestAcceptQuickMatch::push_message_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.PushRequestAcceptQuickMatch.push_message_id)
  return static_cast< ::DS3_Frpg2RequestMessage::PushMessageId >(push_message_id_);
}
inline void PushRequestAcceptQuickMatch::set_push_message_id(::DS3_Frpg2RequestMessage::PushMessageId value) {
  assert(::DS3_Frpg2RequestMessage::PushMessageId_IsValid(value));
  set_has_push_message_id();
  push_message_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.PushRequestAcceptQuickMatch.push_message_id)
}

// required .DS3_Frpg2RequestMessage.AcceptQuickMatchMessage message = 2;
inline bool PushRequestAcceptQuickMatch::has_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PushRequestAcceptQuickMatch::set_has_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PushRequestAcceptQuickMatch::clear_has_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PushRequestAcceptQuickMatch::clear_message() {
  if (message_ != NULL) message_->::DS3_Frpg2RequestMessage::AcceptQuickMatchMessage::Clear();
  clear_has_message();
}
inline const ::DS3_Frpg2RequestMessage::AcceptQuickMatchMessage& PushRequestAcceptQuickMatch::message() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.PushRequestAcceptQuickMatch.message)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return message_ != NULL ? *message_ : *default_instance().message_;
#else
  return message_ != NULL ? *message_ : *default_instance_->message_;
#endif
}
inline ::DS3_Frpg2RequestMessage::AcceptQuickMatchMessage* PushRequestAcceptQuickMatch::mutable_message() {
  set_has_message();
  if (message_ == NULL) message_ = new ::DS3_Frpg2RequestMessage::AcceptQuickMatchMessage;
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.PushRequestAcceptQuickMatch.message)
  return message_;
}
inline ::DS3_Frpg2RequestMessage::AcceptQuickMatchMessage* PushRequestAcceptQuickMatch::release_message() {
  clear_has_message();
  ::DS3_Frpg2RequestMessage::AcceptQuickMatchMessage* temp = message_;
  message_ = NULL;
  return temp;
}
inline void PushRequestAcceptQuickMatch::set_allocated_message(::DS3_Frpg2RequestMessage::AcceptQuickMatchMessage* message) {
  delete message_;
  message_ = message;
  if (message) {
    set_has_message();
  } else {
    clear_has_message();
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.PushRequestAcceptQuickMatch.message)
}

// -------------------------------------------------------------------

// PushRequestRejectQuickMatch

// required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
inline bool PushRequestRejectQuickMatch::has_push_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PushRequestRejectQuickMatch::set_has_push_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PushRequestRejectQuickMatch::clear_has_push_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PushRequestRejectQuickMatch::clear_push_message_id() {
  push_message_id_ = 829;
  clear_has_push_message_id();
}
inline ::DS3_Frpg2RequestMessage::PushMessageId PushRequestRejectQuickMatch::push_message_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.PushRequestRejectQuickMatch.push_message_id)
  return static_cast< ::DS3_Frpg2RequestMessage::PushMessageId >(push_message_id_);
}
inline void PushRequestRejectQuickMatch::set_push_message_id(::DS3_Frpg2RequestMessage::PushMessageId value) {
  assert(::DS3_Frpg2RequestMessage::PushMessageId_IsValid(value));
  set_has_push_message_id();
  push_message_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.PushRequestRejectQuickMatch.push_message_id)
}

// required .DS3_Frpg2RequestMessage.RejectQuickMatchMessage message = 2;
inline bool PushRequestRejectQuickMatch::has_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PushRequestRejectQuickMatch::set_has_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PushRequestRejectQuickMatch::clear_has_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PushRequestRejectQuickMatch::clear_message() {
  if (message_ != NULL) message_->::DS3_Frpg2RequestMessage::RejectQuickMatchMessage::Clear();
  clear_has_message();
}
inline const ::DS3_Frpg2RequestMessage::RejectQuickMatchMessage& PushRequestRejectQuickMatch::message() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.PushRequestRejectQuickMatch.message)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return message_ != NULL ? *message_ : *default_instance().message_;
#else
  return message_ != NULL ? *message_ : *default_instance_->message_;
#endif
}
inline ::DS3_Frpg2RequestMessage::RejectQuickMatchMessage* PushRequestRejectQuickMatch::mutable_message() {
  set_has_message();
  if (message_ == NULL) message_ = new ::DS3_Frpg2RequestMessage::RejectQuickMatchMessage;
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.PushRequestRejectQuickMatch.message)
  return message_;
}
inline ::DS3_Frpg2RequestMessage::RejectQuickMatchMessage* PushRequestRejectQuickMatch::release_message() {
  clear_has_message();
  ::DS3_Frpg2RequestMessage::RejectQuickMatchMessage* temp = message_;
  message_ = NULL;
  return temp;
}
inline void PushRequestRejectQuickMatch::set_allocated_message(::DS3_Frpg2RequestMessage::RejectQuickMatchMessage* message) {
  delete message_;
  message_ = message;
  if (message) {
    set_has_message();
  } else {
    clear_has_message();
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.PushRequestRejectQuickMatch.message)
}

// -------------------------------------------------------------------

// RequestSearchQuickMatch_Map_id_list

// required uint32 map_id = 1;
inline bool RequestSearchQuickMatch_Map_id_list::has_map_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestSearchQuickMatch_Map_id_list::set_has_map_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestSearchQuickMatch_Map_id_list::clear_has_map_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestSearchQuickMatch_Map_id_list::clear_map_id() {
  map_id_ = 0u;
  clear_has_map_id();
}
inline ::google::protobuf::uint32 RequestSearchQuickMatch_Map_id_list::map_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestSearchQuickMatch.Map_id_list.map_id)
  return map_id_;
}
inline void RequestSearchQuickMatch_Map_id_list::set_map_id(::google::protobuf::uint32 value) {
  set_has_map_id();
  map_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestSearchQuickMatch.Map_id_list.map_id)
}

// required uint32 online_area_id = 2;
inline bool RequestSearchQuickMatch_Map_id_list::has_online_area_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestSearchQuickMatch_Map_id_list::set_has_online_area_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestSearchQuickMatch_Map_id_list::clear_has_online_area_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestSearchQuickMatch_Map_id_list::clear_online_area_id() {
  online_area_id_ = 0u;
  clear_has_online_area_id();
}
inline ::google::protobuf::uint32 RequestSearchQuickMatch_Map_id_list::online_area_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestSearchQuickMatch.Map_id_list.online_area_id)
  return online_area_id_;
}
inline void RequestSearchQuickMatch_Map_id_list::set_online_area_id(::google::protobuf::uint32 value) {
  set_has_online_area_id();
  online_area_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestSearchQuickMatch.Map_id_list.online_area_id)
}

// -------------------------------------------------------------------

// RequestSearchQuickMatch

// required .DS3_Frpg2RequestMessage.QuickMatchGameMode mode = 1;
inline bool RequestSearchQuickMatch::has_mode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestSearchQuickMatch::set_has_mode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestSearchQuickMatch::clear_has_mode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestSearchQuickMatch::clear_mode() {
  mode_ = 0;
  clear_has_mode();
}
inline ::DS3_Frpg2RequestMessage::QuickMatchGameMode RequestSearchQuickMatch::mode() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestSearchQuickMatch.mode)
  return static_cast< ::DS3_Frpg2RequestMessage::QuickMatchGameMode >(mode_);
}
inline void RequestSearchQuickMatch::set_mode(::DS3_Frpg2RequestMessage::QuickMatchGameMode value) {
  assert(::DS3_Frpg2RequestMessage::QuickMatchGameMode_IsValid(value));
  set_has_mode();
  mode_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestSearchQuickMatch.mode)
}

// repeated group Map_id_list = 2 {
inline int RequestSearchQuickMatch::map_id_list_size() const {
  return map_id_list_.size();
}
inline void RequestSearchQuickMatch::clear_map_id_list() {
  map_id_list_.Clear();
}
inline const ::DS3_Frpg2RequestMessage::RequestSearchQuickMatch_Map_id_list& RequestSearchQuickMatch::map_id_list(int index) const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestSearchQuickMatch.map_id_list)
  return map_id_list_.Get(index);
}
inline ::DS3_Frpg2RequestMessage::RequestSearchQuickMatch_Map_id_list* RequestSearchQuickMatch::mutable_map_id_list(int index) {
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.RequestSearchQuickMatch.map_id_list)
  return map_id_list_.Mutable(index);
}
inline ::DS3_Frpg2RequestMessage::RequestSearchQuickMatch_Map_id_list* RequestSearchQuickMatch::add_map_id_list() {
  // @@protoc_insertion_point(field_add:DS3_Frpg2RequestMessage.RequestSearchQuickMatch.map_id_list)
  return map_id_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::RequestSearchQuickMatch_Map_id_list >&
RequestSearchQuickMatch::map_id_list() const {
  // @@protoc_insertion_point(field_list:DS3_Frpg2RequestMessage.RequestSearchQuickMatch.map_id_list)
  return map_id_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::RequestSearchQuickMatch_Map_id_list >*
RequestSearchQuickMatch::mutable_map_id_list() {
  // @@protoc_insertion_point(field_mutable_list:DS3_Frpg2RequestMessage.RequestSearchQuickMatch.map_id_list)
  return &map_id_list_;
}

// required uint32 unknown_3 = 3;
inline bool RequestSearchQuickMatch::has_unknown_3() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestSearchQuickMatch::set_has_unknown_3() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestSearchQuickMatch::clear_has_unknown_3() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestSearchQuickMatch::clear_unknown_3() {
  unknown_3_ = 0u;
  clear_has_unknown_3();
}
inline ::google::protobuf::uint32 RequestSearchQuickMatch::unknown_3() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestSearchQuickMatch.unknown_3)
  return unknown_3_;
}
inline void RequestSearchQuickMatch::set_unknown_3(::google::protobuf::uint32 value) {
  set_has_unknown_3();
  unknown_3_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestSearchQuickMatch.unknown_3)
}

// required .DS3_Frpg2RequestMessage.MatchingParameter matching_parameter = 4;
inline bool RequestSearchQuickMatch::has_matching_parameter() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestSearchQuickMatch::set_has_matching_parameter() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestSearchQuickMatch::clear_has_matching_parameter() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestSearchQuickMatch::clear_matching_parameter() {
  if (matching_parameter_ != NULL) matching_parameter_->::DS3_Frpg2RequestMessage::MatchingParameter::Clear();
  clear_has_matching_parameter();
}
inline const ::DS3_Frpg2RequestMessage::MatchingParameter& RequestSearchQuickMatch::matching_parameter() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestSearchQuickMatch.matching_parameter)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return matching_parameter_ != NULL ? *matching_parameter_ : *default_instance().matching_parameter_;
#else
  return matching_parameter_ != NULL ? *matching_parameter_ : *default_instance_->matching_parameter_;
#endif
}
inline ::DS3_Frpg2RequestMessage::MatchingParameter* RequestSearchQuickMatch::mutable_matching_parameter() {
  set_has_matching_parameter();
  if (matching_parameter_ == NULL) matching_parameter_ = new ::DS3_Frpg2RequestMessage::MatchingParameter;
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.RequestSearchQuickMatch.matching_parameter)
  return matching_parameter_;
}
inline ::DS3_Frpg2RequestMessage::MatchingParameter* RequestSearchQuickMatch::release_matching_parameter() {
  clear_has_matching_parameter();
  ::DS3_Frpg2RequestMessage::MatchingParameter* temp = matching_parameter_;
  matching_parameter_ = NULL;
  return temp;
}
inline void RequestSearchQuickMatch::set_allocated_matching_parameter(::DS3_Frpg2RequestMessage::MatchingParameter* matching_parameter) {
  delete matching_parameter_;
  matching_parameter_ = matching_parameter;
  if (matching_parameter) {
    set_has_matching_parameter();
  } else {
    clear_has_matching_parameter();
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.RequestSearchQuickMatch.matching_parameter)
}

// -------------------------------------------------------------------

// RequestSearchQuickMatchResponse

// repeated .DS3_Frpg2RequestMessage.QuickMatchSearchResult matches = 1;
inline int RequestSearchQuickMatchResponse::matches_size() const {
  return matches_.size();
}
inline void RequestSearchQuickMatchResponse::clear_matches() {
  matches_.Clear();
}
inline const ::DS3_Frpg2RequestMessage::QuickMatchSearchResult& RequestSearchQuickMatchResponse::matches(int index) const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestSearchQuickMatchResponse.matches)
  return matches_.Get(index);
}
inline ::DS3_Frpg2RequestMessage::QuickMatchSearchResult* RequestSearchQuickMatchResponse::mutable_matches(int index) {
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.RequestSearchQuickMatchResponse.matches)
  return matches_.Mutable(index);
}
inline ::DS3_Frpg2RequestMessage::QuickMatchSearchResult* RequestSearchQuickMatchResponse::add_matches() {
  // @@protoc_insertion_point(field_add:DS3_Frpg2RequestMessage.RequestSearchQuickMatchResponse.matches)
  return matches_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::QuickMatchSearchResult >&
RequestSearchQuickMatchResponse::matches() const {
  // @@protoc_insertion_point(field_list:DS3_Frpg2RequestMessage.RequestSearchQuickMatchResponse.matches)
  return matches_;
}
inline ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::QuickMatchSearchResult >*
RequestSearchQuickMatchResponse::mutable_matches() {
  // @@protoc_insertion_point(field_mutable_list:DS3_Frpg2RequestMessage.RequestSearchQuickMatchResponse.matches)
  return &matches_;
}

// -------------------------------------------------------------------

// RequestRegisterQuickMatch

// required .DS3_Frpg2RequestMessage.QuickMatchGameMode mode = 1;
inline bool RequestRegisterQuickMatch::has_mode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestRegisterQuickMatch::set_has_mode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestRegisterQuickMatch::clear_has_mode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestRegisterQuickMatch::clear_mode() {
  mode_ = 0;
  clear_has_mode();
}
inline ::DS3_Frpg2RequestMessage::QuickMatchGameMode RequestRegisterQuickMatch::mode() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestRegisterQuickMatch.mode)
  return static_cast< ::DS3_Frpg2RequestMessage::QuickMatchGameMode >(mode_);
}
inline void RequestRegisterQuickMatch::set_mode(::DS3_Frpg2RequestMessage::QuickMatchGameMode value) {
  assert(::DS3_Frpg2RequestMessage::QuickMatchGameMode_IsValid(value));
  set_has_mode();
  mode_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestRegisterQuickMatch.mode)
}

// required uint32 map_id = 2;
inline bool RequestRegisterQuickMatch::has_map_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestRegisterQuickMatch::set_has_map_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestRegisterQuickMatch::clear_has_map_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestRegisterQuickMatch::clear_map_id() {
  map_id_ = 0u;
  clear_has_map_id();
}
inline ::google::protobuf::uint32 RequestRegisterQuickMatch::map_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestRegisterQuickMatch.map_id)
  return map_id_;
}
inline void RequestRegisterQuickMatch::set_map_id(::google::protobuf::uint32 value) {
  set_has_map_id();
  map_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestRegisterQuickMatch.map_id)
}

// required uint32 online_area_id = 3;
inline bool RequestRegisterQuickMatch::has_online_area_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestRegisterQuickMatch::set_has_online_area_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestRegisterQuickMatch::clear_has_online_area_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestRegisterQuickMatch::clear_online_area_id() {
  online_area_id_ = 0u;
  clear_has_online_area_id();
}
inline ::google::protobuf::uint32 RequestRegisterQuickMatch::online_area_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestRegisterQuickMatch.online_area_id)
  return online_area_id_;
}
inline void RequestRegisterQuickMatch::set_online_area_id(::google::protobuf::uint32 value) {
  set_has_online_area_id();
  online_area_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestRegisterQuickMatch.online_area_id)
}

// required .DS3_Frpg2RequestMessage.MatchingParameter matching_parameter = 4;
inline bool RequestRegisterQuickMatch::has_matching_parameter() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestRegisterQuickMatch::set_has_matching_parameter() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestRegisterQuickMatch::clear_has_matching_parameter() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestRegisterQuickMatch::clear_matching_parameter() {
  if (matching_parameter_ != NULL) matching_parameter_->::DS3_Frpg2RequestMessage::MatchingParameter::Clear();
  clear_has_matching_parameter();
}
inline const ::DS3_Frpg2RequestMessage::MatchingParameter& RequestRegisterQuickMatch::matching_parameter() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestRegisterQuickMatch.matching_parameter)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return matching_parameter_ != NULL ? *matching_parameter_ : *default_instance().matching_parameter_;
#else
  return matching_parameter_ != NULL ? *matching_parameter_ : *default_instance_->matching_parameter_;
#endif
}
inline ::DS3_Frpg2RequestMessage::MatchingParameter* RequestRegisterQuickMatch::mutable_matching_parameter() {
  set_has_matching_parameter();
  if (matching_parameter_ == NULL) matching_parameter_ = new ::DS3_Frpg2RequestMessage::MatchingParameter;
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.RequestRegisterQuickMatch.matching_parameter)
  return matching_parameter_;
}
inline ::DS3_Frpg2RequestMessage::MatchingParameter* RequestRegisterQuickMatch::release_matching_parameter() {
  clear_has_matching_parameter();
  ::DS3_Frpg2RequestMessage::MatchingParameter* temp = matching_parameter_;
  matching_parameter_ = NULL;
  return temp;
}
inline void RequestRegisterQuickMatch::set_allocated_matching_parameter(::DS3_Frpg2RequestMessage::MatchingParameter* matching_parameter) {
  delete matching_parameter_;
  matching_parameter_ = matching_parameter;
  if (matching_parameter) {
    set_has_matching_parameter();
  } else {
    clear_has_matching_parameter();
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.RequestRegisterQuickMatch.matching_parameter)
}

// required uint32 unknown_5 = 5;
inline bool RequestRegisterQuickMatch::has_unknown_5() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RequestRegisterQuickMatch::set_has_unknown_5() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RequestRegisterQuickMatch::clear_has_unknown_5() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RequestRegisterQuickMatch::clear_unknown_5() {
  unknown_5_ = 0u;
  clear_has_unknown_5();
}
inline ::google::protobuf::uint32 RequestRegisterQuickMatch::unknown_5() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestRegisterQuickMatch.unknown_5)
  return unknown_5_;
}
inline void RequestRegisterQuickMatch::set_unknown_5(::google::protobuf::uint32 value) {
  set_has_unknown_5();
  unknown_5_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestRegisterQuickMatch.unknown_5)
}

// -------------------------------------------------------------------

// RequestUnregisterQuickMatch

// required .DS3_Frpg2RequestMessage.QuickMatchGameMode mode = 1;
inline bool RequestUnregisterQuickMatch::has_mode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestUnregisterQuickMatch::set_has_mode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestUnregisterQuickMatch::clear_has_mode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestUnregisterQuickMatch::clear_mode() {
  mode_ = 0;
  clear_has_mode();
}
inline ::DS3_Frpg2RequestMessage::QuickMatchGameMode RequestUnregisterQuickMatch::mode() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestUnregisterQuickMatch.mode)
  return static_cast< ::DS3_Frpg2RequestMessage::QuickMatchGameMode >(mode_);
}
inline void RequestUnregisterQuickMatch::set_mode(::DS3_Frpg2RequestMessage::QuickMatchGameMode value) {
  assert(::DS3_Frpg2RequestMessage::QuickMatchGameMode_IsValid(value));
  set_has_mode();
  mode_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestUnregisterQuickMatch.mode)
}

// required uint32 map_id = 2;
inline bool RequestUnregisterQuickMatch::has_map_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestUnregisterQuickMatch::set_has_map_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestUnregisterQuickMatch::clear_has_map_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestUnregisterQuickMatch::clear_map_id() {
  map_id_ = 0u;
  clear_has_map_id();
}
inline ::google::protobuf::uint32 RequestUnregisterQuickMatch::map_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestUnregisterQuickMatch.map_id)
  return map_id_;
}
inline void RequestUnregisterQuickMatch::set_map_id(::google::protobuf::uint32 value) {
  set_has_map_id();
  map_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestUnregisterQuickMatch.map_id)
}

// required uint32 online_area_id = 3;
inline bool RequestUnregisterQuickMatch::has_online_area_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestUnregisterQuickMatch::set_has_online_area_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestUnregisterQuickMatch::clear_has_online_area_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestUnregisterQuickMatch::clear_online_area_id() {
  online_area_id_ = 0u;
  clear_has_online_area_id();
}
inline ::google::protobuf::uint32 RequestUnregisterQuickMatch::online_area_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestUnregisterQuickMatch.online_area_id)
  return online_area_id_;
}
inline void RequestUnregisterQuickMatch::set_online_area_id(::google::protobuf::uint32 value) {
  set_has_online_area_id();
  online_area_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestUnregisterQuickMatch.online_area_id)
}

// required uint32 unknown_4 = 4;
inline bool RequestUnregisterQuickMatch::has_unknown_4() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestUnregisterQuickMatch::set_has_unknown_4() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestUnregisterQuickMatch::clear_has_unknown_4() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestUnregisterQuickMatch::clear_unknown_4() {
  unknown_4_ = 0u;
  clear_has_unknown_4();
}
inline ::google::protobuf::uint32 RequestUnregisterQuickMatch::unknown_4() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestUnregisterQuickMatch.unknown_4)
  return unknown_4_;
}
inline void RequestUnregisterQuickMatch::set_unknown_4(::google::protobuf::uint32 value) {
  set_has_unknown_4();
  unknown_4_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestUnregisterQuickMatch.unknown_4)
}

// -------------------------------------------------------------------

// RequestRegisterQuickMatchResponse

// -------------------------------------------------------------------

// RequestUnregisterQuickMatchResponse

// -------------------------------------------------------------------

// RequestUpdateQuickMatch

// required .DS3_Frpg2RequestMessage.QuickMatchGameMode mode = 1;
inline bool RequestUpdateQuickMatch::has_mode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestUpdateQuickMatch::set_has_mode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestUpdateQuickMatch::clear_has_mode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestUpdateQuickMatch::clear_mode() {
  mode_ = 0;
  clear_has_mode();
}
inline ::DS3_Frpg2RequestMessage::QuickMatchGameMode RequestUpdateQuickMatch::mode() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestUpdateQuickMatch.mode)
  return static_cast< ::DS3_Frpg2RequestMessage::QuickMatchGameMode >(mode_);
}
inline void RequestUpdateQuickMatch::set_mode(::DS3_Frpg2RequestMessage::QuickMatchGameMode value) {
  assert(::DS3_Frpg2RequestMessage::QuickMatchGameMode_IsValid(value));
  set_has_mode();
  mode_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestUpdateQuickMatch.mode)
}

// required uint32 map_id = 2;
inline bool RequestUpdateQuickMatch::has_map_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestUpdateQuickMatch::set_has_map_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestUpdateQuickMatch::clear_has_map_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestUpdateQuickMatch::clear_map_id() {
  map_id_ = 0u;
  clear_has_map_id();
}
inline ::google::protobuf::uint32 RequestUpdateQuickMatch::map_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestUpdateQuickMatch.map_id)
  return map_id_;
}
inline void RequestUpdateQuickMatch::set_map_id(::google::protobuf::uint32 value) {
  set_has_map_id();
  map_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestUpdateQuickMatch.map_id)
}

// required uint32 online_area_id = 3;
inline bool RequestUpdateQuickMatch::has_online_area_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestUpdateQuickMatch::set_has_online_area_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestUpdateQuickMatch::clear_has_online_area_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestUpdateQuickMatch::clear_online_area_id() {
  online_area_id_ = 0u;
  clear_has_online_area_id();
}
inline ::google::protobuf::uint32 RequestUpdateQuickMatch::online_area_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestUpdateQuickMatch.online_area_id)
  return online_area_id_;
}
inline void RequestUpdateQuickMatch::set_online_area_id(::google::protobuf::uint32 value) {
  set_has_online_area_id();
  online_area_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestUpdateQuickMatch.online_area_id)
}

// -------------------------------------------------------------------

// RequestUpdateQuickMatchResponse

// -------------------------------------------------------------------

// RequestJoinQuickMatch

// required .DS3_Frpg2RequestMessage.QuickMatchGameMode mode = 1;
inline bool RequestJoinQuickMatch::has_mode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestJoinQuickMatch::set_has_mode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestJoinQuickMatch::clear_has_mode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestJoinQuickMatch::clear_mode() {
  mode_ = 0;
  clear_has_mode();
}
inline ::DS3_Frpg2RequestMessage::QuickMatchGameMode RequestJoinQuickMatch::mode() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestJoinQuickMatch.mode)
  return static_cast< ::DS3_Frpg2RequestMessage::QuickMatchGameMode >(mode_);
}
inline void RequestJoinQuickMatch::set_mode(::DS3_Frpg2RequestMessage::QuickMatchGameMode value) {
  assert(::DS3_Frpg2RequestMessage::QuickMatchGameMode_IsValid(value));
  set_has_mode();
  mode_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestJoinQuickMatch.mode)
}

// required uint32 character_id = 2;
inline bool RequestJoinQuickMatch::has_character_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestJoinQuickMatch::set_has_character_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestJoinQuickMatch::clear_has_character_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestJoinQuickMatch::clear_character_id() {
  character_id_ = 0u;
  clear_has_character_id();
}
inline ::google::protobuf::uint32 RequestJoinQuickMatch::character_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestJoinQuickMatch.character_id)
  return character_id_;
}
inline void RequestJoinQuickMatch::set_character_id(::google::protobuf::uint32 value) {
  set_has_character_id();
  character_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestJoinQuickMatch.character_id)
}

// required uint32 host_player_id = 4;
inline bool RequestJoinQuickMatch::has_host_player_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestJoinQuickMatch::set_has_host_player_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestJoinQuickMatch::clear_has_host_player_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestJoinQuickMatch::clear_host_player_id() {
  host_player_id_ = 0u;
  clear_has_host_player_id();
}
inline ::google::protobuf::uint32 RequestJoinQuickMatch::host_player_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestJoinQuickMatch.host_player_id)
  return host_player_id_;
}
inline void RequestJoinQuickMatch::set_host_player_id(::google::protobuf::uint32 value) {
  set_has_host_player_id();
  host_player_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestJoinQuickMatch.host_player_id)
}

// required uint32 map_id = 5;
inline bool RequestJoinQuickMatch::has_map_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestJoinQuickMatch::set_has_map_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestJoinQuickMatch::clear_has_map_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestJoinQuickMatch::clear_map_id() {
  map_id_ = 0u;
  clear_has_map_id();
}
inline ::google::protobuf::uint32 RequestJoinQuickMatch::map_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestJoinQuickMatch.map_id)
  return map_id_;
}
inline void RequestJoinQuickMatch::set_map_id(::google::protobuf::uint32 value) {
  set_has_map_id();
  map_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestJoinQuickMatch.map_id)
}

// required uint32 online_area_id = 6;
inline bool RequestJoinQuickMatch::has_online_area_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RequestJoinQuickMatch::set_has_online_area_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RequestJoinQuickMatch::clear_has_online_area_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RequestJoinQuickMatch::clear_online_area_id() {
  online_area_id_ = 0u;
  clear_has_online_area_id();
}
inline ::google::protobuf::uint32 RequestJoinQuickMatch::online_area_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestJoinQuickMatch.online_area_id)
  return online_area_id_;
}
inline void RequestJoinQuickMatch::set_online_area_id(::google::protobuf::uint32 value) {
  set_has_online_area_id();
  online_area_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestJoinQuickMatch.online_area_id)
}

// required uint32 unknown_7 = 7;
inline bool RequestJoinQuickMatch::has_unknown_7() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RequestJoinQuickMatch::set_has_unknown_7() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RequestJoinQuickMatch::clear_has_unknown_7() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RequestJoinQuickMatch::clear_unknown_7() {
  unknown_7_ = 0u;
  clear_has_unknown_7();
}
inline ::google::protobuf::uint32 RequestJoinQuickMatch::unknown_7() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestJoinQuickMatch.unknown_7)
  return unknown_7_;
}
inline void RequestJoinQuickMatch::set_unknown_7(::google::protobuf::uint32 value) {
  set_has_unknown_7();
  unknown_7_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestJoinQuickMatch.unknown_7)
}

// required string password = 8;
inline bool RequestJoinQuickMatch::has_password() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RequestJoinQuickMatch::set_has_password() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RequestJoinQuickMatch::clear_has_password() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RequestJoinQuickMatch::clear_password() {
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& RequestJoinQuickMatch::password() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestJoinQuickMatch.password)
  return *password_;
}
inline void RequestJoinQuickMatch::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(value);
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestJoinQuickMatch.password)
}
inline void RequestJoinQuickMatch::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(value);
  // @@protoc_insertion_point(field_set_char:DS3_Frpg2RequestMessage.RequestJoinQuickMatch.password)
}
inline void RequestJoinQuickMatch::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DS3_Frpg2RequestMessage.RequestJoinQuickMatch.password)
}
inline ::std::string* RequestJoinQuickMatch::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.RequestJoinQuickMatch.password)
  return password_;
}
inline ::std::string* RequestJoinQuickMatch::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RequestJoinQuickMatch::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.RequestJoinQuickMatch.password)
}

// -------------------------------------------------------------------

// RequestJoinQuickMatchResponse

// -------------------------------------------------------------------

// RequestAcceptQuickMatch

// required .DS3_Frpg2RequestMessage.QuickMatchGameMode mode = 1;
inline bool RequestAcceptQuickMatch::has_mode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestAcceptQuickMatch::set_has_mode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestAcceptQuickMatch::clear_has_mode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestAcceptQuickMatch::clear_mode() {
  mode_ = 0;
  clear_has_mode();
}
inline ::DS3_Frpg2RequestMessage::QuickMatchGameMode RequestAcceptQuickMatch::mode() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestAcceptQuickMatch.mode)
  return static_cast< ::DS3_Frpg2RequestMessage::QuickMatchGameMode >(mode_);
}
inline void RequestAcceptQuickMatch::set_mode(::DS3_Frpg2RequestMessage::QuickMatchGameMode value) {
  assert(::DS3_Frpg2RequestMessage::QuickMatchGameMode_IsValid(value));
  set_has_mode();
  mode_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestAcceptQuickMatch.mode)
}

// required uint32 join_player_id = 4;
inline bool RequestAcceptQuickMatch::has_join_player_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestAcceptQuickMatch::set_has_join_player_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestAcceptQuickMatch::clear_has_join_player_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestAcceptQuickMatch::clear_join_player_id() {
  join_player_id_ = 0u;
  clear_has_join_player_id();
}
inline ::google::protobuf::uint32 RequestAcceptQuickMatch::join_player_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestAcceptQuickMatch.join_player_id)
  return join_player_id_;
}
inline void RequestAcceptQuickMatch::set_join_player_id(::google::protobuf::uint32 value) {
  set_has_join_player_id();
  join_player_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestAcceptQuickMatch.join_player_id)
}

// required bytes data = 5;
inline bool RequestAcceptQuickMatch::has_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestAcceptQuickMatch::set_has_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestAcceptQuickMatch::clear_has_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestAcceptQuickMatch::clear_data() {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& RequestAcceptQuickMatch::data() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestAcceptQuickMatch.data)
  return *data_;
}
inline void RequestAcceptQuickMatch::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestAcceptQuickMatch.data)
}
inline void RequestAcceptQuickMatch::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set_char:DS3_Frpg2RequestMessage.RequestAcceptQuickMatch.data)
}
inline void RequestAcceptQuickMatch::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DS3_Frpg2RequestMessage.RequestAcceptQuickMatch.data)
}
inline ::std::string* RequestAcceptQuickMatch::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.RequestAcceptQuickMatch.data)
  return data_;
}
inline ::std::string* RequestAcceptQuickMatch::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RequestAcceptQuickMatch::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.RequestAcceptQuickMatch.data)
}

// -------------------------------------------------------------------

// RequestAcceptQuickMatchResponse

// -------------------------------------------------------------------

// RequestRejectQuickMatch

// required .DS3_Frpg2RequestMessage.QuickMatchGameMode mode = 1;
inline bool RequestRejectQuickMatch::has_mode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestRejectQuickMatch::set_has_mode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestRejectQuickMatch::clear_has_mode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestRejectQuickMatch::clear_mode() {
  mode_ = 0;
  clear_has_mode();
}
inline ::DS3_Frpg2RequestMessage::QuickMatchGameMode RequestRejectQuickMatch::mode() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestRejectQuickMatch.mode)
  return static_cast< ::DS3_Frpg2RequestMessage::QuickMatchGameMode >(mode_);
}
inline void RequestRejectQuickMatch::set_mode(::DS3_Frpg2RequestMessage::QuickMatchGameMode value) {
  assert(::DS3_Frpg2RequestMessage::QuickMatchGameMode_IsValid(value));
  set_has_mode();
  mode_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestRejectQuickMatch.mode)
}

// required uint32 map_id = 2;
inline bool RequestRejectQuickMatch::has_map_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestRejectQuickMatch::set_has_map_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestRejectQuickMatch::clear_has_map_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestRejectQuickMatch::clear_map_id() {
  map_id_ = 0u;
  clear_has_map_id();
}
inline ::google::protobuf::uint32 RequestRejectQuickMatch::map_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestRejectQuickMatch.map_id)
  return map_id_;
}
inline void RequestRejectQuickMatch::set_map_id(::google::protobuf::uint32 value) {
  set_has_map_id();
  map_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestRejectQuickMatch.map_id)
}

// required uint32 online_area_id = 3;
inline bool RequestRejectQuickMatch::has_online_area_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestRejectQuickMatch::set_has_online_area_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestRejectQuickMatch::clear_has_online_area_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestRejectQuickMatch::clear_online_area_id() {
  online_area_id_ = 0u;
  clear_has_online_area_id();
}
inline ::google::protobuf::uint32 RequestRejectQuickMatch::online_area_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestRejectQuickMatch.online_area_id)
  return online_area_id_;
}
inline void RequestRejectQuickMatch::set_online_area_id(::google::protobuf::uint32 value) {
  set_has_online_area_id();
  online_area_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestRejectQuickMatch.online_area_id)
}

// required uint32 join_player_id = 4;
inline bool RequestRejectQuickMatch::has_join_player_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestRejectQuickMatch::set_has_join_player_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestRejectQuickMatch::clear_has_join_player_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestRejectQuickMatch::clear_join_player_id() {
  join_player_id_ = 0u;
  clear_has_join_player_id();
}
inline ::google::protobuf::uint32 RequestRejectQuickMatch::join_player_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestRejectQuickMatch.join_player_id)
  return join_player_id_;
}
inline void RequestRejectQuickMatch::set_join_player_id(::google::protobuf::uint32 value) {
  set_has_join_player_id();
  join_player_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestRejectQuickMatch.join_player_id)
}

// required uint32 unknown_5 = 5;
inline bool RequestRejectQuickMatch::has_unknown_5() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RequestRejectQuickMatch::set_has_unknown_5() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RequestRejectQuickMatch::clear_has_unknown_5() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RequestRejectQuickMatch::clear_unknown_5() {
  unknown_5_ = 0u;
  clear_has_unknown_5();
}
inline ::google::protobuf::uint32 RequestRejectQuickMatch::unknown_5() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestRejectQuickMatch.unknown_5)
  return unknown_5_;
}
inline void RequestRejectQuickMatch::set_unknown_5(::google::protobuf::uint32 value) {
  set_has_unknown_5();
  unknown_5_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestRejectQuickMatch.unknown_5)
}

// -------------------------------------------------------------------

// RequestRejectQuickMatchResponse

// -------------------------------------------------------------------

// RequestSendQuickMatchStart_Session_member_list

// required uint32 player_id = 1;
inline bool RequestSendQuickMatchStart_Session_member_list::has_player_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestSendQuickMatchStart_Session_member_list::set_has_player_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestSendQuickMatchStart_Session_member_list::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestSendQuickMatchStart_Session_member_list::clear_player_id() {
  player_id_ = 0u;
  clear_has_player_id();
}
inline ::google::protobuf::uint32 RequestSendQuickMatchStart_Session_member_list::player_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestSendQuickMatchStart.Session_member_list.player_id)
  return player_id_;
}
inline void RequestSendQuickMatchStart_Session_member_list::set_player_id(::google::protobuf::uint32 value) {
  set_has_player_id();
  player_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestSendQuickMatchStart.Session_member_list.player_id)
}

// required uint32 character_id = 2;
inline bool RequestSendQuickMatchStart_Session_member_list::has_character_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestSendQuickMatchStart_Session_member_list::set_has_character_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestSendQuickMatchStart_Session_member_list::clear_has_character_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestSendQuickMatchStart_Session_member_list::clear_character_id() {
  character_id_ = 0u;
  clear_has_character_id();
}
inline ::google::protobuf::uint32 RequestSendQuickMatchStart_Session_member_list::character_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestSendQuickMatchStart.Session_member_list.character_id)
  return character_id_;
}
inline void RequestSendQuickMatchStart_Session_member_list::set_character_id(::google::protobuf::uint32 value) {
  set_has_character_id();
  character_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestSendQuickMatchStart.Session_member_list.character_id)
}

// -------------------------------------------------------------------

// RequestSendQuickMatchStart

// required uint32 unknown_1 = 1;
inline bool RequestSendQuickMatchStart::has_unknown_1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestSendQuickMatchStart::set_has_unknown_1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestSendQuickMatchStart::clear_has_unknown_1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestSendQuickMatchStart::clear_unknown_1() {
  unknown_1_ = 0u;
  clear_has_unknown_1();
}
inline ::google::protobuf::uint32 RequestSendQuickMatchStart::unknown_1() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestSendQuickMatchStart.unknown_1)
  return unknown_1_;
}
inline void RequestSendQuickMatchStart::set_unknown_1(::google::protobuf::uint32 value) {
  set_has_unknown_1();
  unknown_1_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestSendQuickMatchStart.unknown_1)
}

// repeated group Session_member_list = 2 {
inline int RequestSendQuickMatchStart::session_member_list_size() const {
  return session_member_list_.size();
}
inline void RequestSendQuickMatchStart::clear_session_member_list() {
  session_member_list_.Clear();
}
inline const ::DS3_Frpg2RequestMessage::RequestSendQuickMatchStart_Session_member_list& RequestSendQuickMatchStart::session_member_list(int index) const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestSendQuickMatchStart.session_member_list)
  return session_member_list_.Get(index);
}
inline ::DS3_Frpg2RequestMessage::RequestSendQuickMatchStart_Session_member_list* RequestSendQuickMatchStart::mutable_session_member_list(int index) {
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.RequestSendQuickMatchStart.session_member_list)
  return session_member_list_.Mutable(index);
}
inline ::DS3_Frpg2RequestMessage::RequestSendQuickMatchStart_Session_member_list* RequestSendQuickMatchStart::add_session_member_list() {
  // @@protoc_insertion_point(field_add:DS3_Frpg2RequestMessage.RequestSendQuickMatchStart.session_member_list)
  return session_member_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::RequestSendQuickMatchStart_Session_member_list >&
RequestSendQuickMatchStart::session_member_list() const {
  // @@protoc_insertion_point(field_list:DS3_Frpg2RequestMessage.RequestSendQuickMatchStart.session_member_list)
  return session_member_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::RequestSendQuickMatchStart_Session_member_list >*
RequestSendQuickMatchStart::mutable_session_member_list() {
  // @@protoc_insertion_point(field_mutable_list:DS3_Frpg2RequestMessage.RequestSendQuickMatchStart.session_member_list)
  return &session_member_list_;
}

// -------------------------------------------------------------------

// RequestSendQuickMatchStartResponse

// -------------------------------------------------------------------

// RequestSendQuickMatchResult

// required .DS3_Frpg2RequestMessage.QuickMatchGameMode mode = 1;
inline bool RequestSendQuickMatchResult::has_mode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestSendQuickMatchResult::set_has_mode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestSendQuickMatchResult::clear_has_mode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestSendQuickMatchResult::clear_mode() {
  mode_ = 0;
  clear_has_mode();
}
inline ::DS3_Frpg2RequestMessage::QuickMatchGameMode RequestSendQuickMatchResult::mode() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestSendQuickMatchResult.mode)
  return static_cast< ::DS3_Frpg2RequestMessage::QuickMatchGameMode >(mode_);
}
inline void RequestSendQuickMatchResult::set_mode(::DS3_Frpg2RequestMessage::QuickMatchGameMode value) {
  assert(::DS3_Frpg2RequestMessage::QuickMatchGameMode_IsValid(value));
  set_has_mode();
  mode_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestSendQuickMatchResult.mode)
}

// required uint32 unknown_2 = 2;
inline bool RequestSendQuickMatchResult::has_unknown_2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestSendQuickMatchResult::set_has_unknown_2() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestSendQuickMatchResult::clear_has_unknown_2() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestSendQuickMatchResult::clear_unknown_2() {
  unknown_2_ = 0u;
  clear_has_unknown_2();
}
inline ::google::protobuf::uint32 RequestSendQuickMatchResult::unknown_2() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestSendQuickMatchResult.unknown_2)
  return unknown_2_;
}
inline void RequestSendQuickMatchResult::set_unknown_2(::google::protobuf::uint32 value) {
  set_has_unknown_2();
  unknown_2_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestSendQuickMatchResult.unknown_2)
}

// required .DS3_Frpg2RequestMessage.QuickMatchResult result = 3;
inline bool RequestSendQuickMatchResult::has_result() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestSendQuickMatchResult::set_has_result() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestSendQuickMatchResult::clear_has_result() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestSendQuickMatchResult::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::DS3_Frpg2RequestMessage::QuickMatchResult RequestSendQuickMatchResult::result() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestSendQuickMatchResult.result)
  return static_cast< ::DS3_Frpg2RequestMessage::QuickMatchResult >(result_);
}
inline void RequestSendQuickMatchResult::set_result(::DS3_Frpg2RequestMessage::QuickMatchResult value) {
  assert(::DS3_Frpg2RequestMessage::QuickMatchResult_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestSendQuickMatchResult.result)
}

// required bool local_won = 4;
inline bool RequestSendQuickMatchResult::has_local_won() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestSendQuickMatchResult::set_has_local_won() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestSendQuickMatchResult::clear_has_local_won() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestSendQuickMatchResult::clear_local_won() {
  local_won_ = false;
  clear_has_local_won();
}
inline bool RequestSendQuickMatchResult::local_won() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestSendQuickMatchResult.local_won)
  return local_won_;
}
inline void RequestSendQuickMatchResult::set_local_won(bool value) {
  set_has_local_won();
  local_won_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestSendQuickMatchResult.local_won)
}

// required .DS3_Frpg2RequestMessage.QuickMatchRank remote_rank = 5;
inline bool RequestSendQuickMatchResult::has_remote_rank() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RequestSendQuickMatchResult::set_has_remote_rank() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RequestSendQuickMatchResult::clear_has_remote_rank() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RequestSendQuickMatchResult::clear_remote_rank() {
  if (remote_rank_ != NULL) remote_rank_->::DS3_Frpg2RequestMessage::QuickMatchRank::Clear();
  clear_has_remote_rank();
}
inline const ::DS3_Frpg2RequestMessage::QuickMatchRank& RequestSendQuickMatchResult::remote_rank() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestSendQuickMatchResult.remote_rank)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return remote_rank_ != NULL ? *remote_rank_ : *default_instance().remote_rank_;
#else
  return remote_rank_ != NULL ? *remote_rank_ : *default_instance_->remote_rank_;
#endif
}
inline ::DS3_Frpg2RequestMessage::QuickMatchRank* RequestSendQuickMatchResult::mutable_remote_rank() {
  set_has_remote_rank();
  if (remote_rank_ == NULL) remote_rank_ = new ::DS3_Frpg2RequestMessage::QuickMatchRank;
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.RequestSendQuickMatchResult.remote_rank)
  return remote_rank_;
}
inline ::DS3_Frpg2RequestMessage::QuickMatchRank* RequestSendQuickMatchResult::release_remote_rank() {
  clear_has_remote_rank();
  ::DS3_Frpg2RequestMessage::QuickMatchRank* temp = remote_rank_;
  remote_rank_ = NULL;
  return temp;
}
inline void RequestSendQuickMatchResult::set_allocated_remote_rank(::DS3_Frpg2RequestMessage::QuickMatchRank* remote_rank) {
  delete remote_rank_;
  remote_rank_ = remote_rank;
  if (remote_rank) {
    set_has_remote_rank();
  } else {
    clear_has_remote_rank();
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.RequestSendQuickMatchResult.remote_rank)
}

// required .DS3_Frpg2RequestMessage.QuickMatchRank local_rank = 6;
inline bool RequestSendQuickMatchResult::has_local_rank() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RequestSendQuickMatchResult::set_has_local_rank() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RequestSendQuickMatchResult::clear_has_local_rank() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RequestSendQuickMatchResult::clear_local_rank() {
  if (local_rank_ != NULL) local_rank_->::DS3_Frpg2RequestMessage::QuickMatchRank::Clear();
  clear_has_local_rank();
}
inline const ::DS3_Frpg2RequestMessage::QuickMatchRank& RequestSendQuickMatchResult::local_rank() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestSendQuickMatchResult.local_rank)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return local_rank_ != NULL ? *local_rank_ : *default_instance().local_rank_;
#else
  return local_rank_ != NULL ? *local_rank_ : *default_instance_->local_rank_;
#endif
}
inline ::DS3_Frpg2RequestMessage::QuickMatchRank* RequestSendQuickMatchResult::mutable_local_rank() {
  set_has_local_rank();
  if (local_rank_ == NULL) local_rank_ = new ::DS3_Frpg2RequestMessage::QuickMatchRank;
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.RequestSendQuickMatchResult.local_rank)
  return local_rank_;
}
inline ::DS3_Frpg2RequestMessage::QuickMatchRank* RequestSendQuickMatchResult::release_local_rank() {
  clear_has_local_rank();
  ::DS3_Frpg2RequestMessage::QuickMatchRank* temp = local_rank_;
  local_rank_ = NULL;
  return temp;
}
inline void RequestSendQuickMatchResult::set_allocated_local_rank(::DS3_Frpg2RequestMessage::QuickMatchRank* local_rank) {
  delete local_rank_;
  local_rank_ = local_rank;
  if (local_rank) {
    set_has_local_rank();
  } else {
    clear_has_local_rank();
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.RequestSendQuickMatchResult.local_rank)
}

// optional string unknown_7 = 7;
inline bool RequestSendQuickMatchResult::has_unknown_7() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RequestSendQuickMatchResult::set_has_unknown_7() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RequestSendQuickMatchResult::clear_has_unknown_7() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RequestSendQuickMatchResult::clear_unknown_7() {
  if (unknown_7_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unknown_7_->clear();
  }
  clear_has_unknown_7();
}
inline const ::std::string& RequestSendQuickMatchResult::unknown_7() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestSendQuickMatchResult.unknown_7)
  return *unknown_7_;
}
inline void RequestSendQuickMatchResult::set_unknown_7(const ::std::string& value) {
  set_has_unknown_7();
  if (unknown_7_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unknown_7_ = new ::std::string;
  }
  unknown_7_->assign(value);
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestSendQuickMatchResult.unknown_7)
}
inline void RequestSendQuickMatchResult::set_unknown_7(const char* value) {
  set_has_unknown_7();
  if (unknown_7_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unknown_7_ = new ::std::string;
  }
  unknown_7_->assign(value);
  // @@protoc_insertion_point(field_set_char:DS3_Frpg2RequestMessage.RequestSendQuickMatchResult.unknown_7)
}
inline void RequestSendQuickMatchResult::set_unknown_7(const char* value, size_t size) {
  set_has_unknown_7();
  if (unknown_7_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unknown_7_ = new ::std::string;
  }
  unknown_7_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DS3_Frpg2RequestMessage.RequestSendQuickMatchResult.unknown_7)
}
inline ::std::string* RequestSendQuickMatchResult::mutable_unknown_7() {
  set_has_unknown_7();
  if (unknown_7_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unknown_7_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.RequestSendQuickMatchResult.unknown_7)
  return unknown_7_;
}
inline ::std::string* RequestSendQuickMatchResult::release_unknown_7() {
  clear_has_unknown_7();
  if (unknown_7_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = unknown_7_;
    unknown_7_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RequestSendQuickMatchResult::set_allocated_unknown_7(::std::string* unknown_7) {
  if (unknown_7_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete unknown_7_;
  }
  if (unknown_7) {
    set_has_unknown_7();
    unknown_7_ = unknown_7;
  } else {
    clear_has_unknown_7();
    unknown_7_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.RequestSendQuickMatchResult.unknown_7)
}

// -------------------------------------------------------------------

// RequestSendQuickMatchResultResponse

// required uint32 unknown_1 = 1;
inline bool RequestSendQuickMatchResultResponse::has_unknown_1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestSendQuickMatchResultResponse::set_has_unknown_1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestSendQuickMatchResultResponse::clear_has_unknown_1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestSendQuickMatchResultResponse::clear_unknown_1() {
  unknown_1_ = 0u;
  clear_has_unknown_1();
}
inline ::google::protobuf::uint32 RequestSendQuickMatchResultResponse::unknown_1() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestSendQuickMatchResultResponse.unknown_1)
  return unknown_1_;
}
inline void RequestSendQuickMatchResultResponse::set_unknown_1(::google::protobuf::uint32 value) {
  set_has_unknown_1();
  unknown_1_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.RequestSendQuickMatchResultResponse.unknown_1)
}

// required .DS3_Frpg2RequestMessage.QuickMatchRank new_local_rank = 2;
inline bool RequestSendQuickMatchResultResponse::has_new_local_rank() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestSendQuickMatchResultResponse::set_has_new_local_rank() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestSendQuickMatchResultResponse::clear_has_new_local_rank() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestSendQuickMatchResultResponse::clear_new_local_rank() {
  if (new_local_rank_ != NULL) new_local_rank_->::DS3_Frpg2RequestMessage::QuickMatchRank::Clear();
  clear_has_new_local_rank();
}
inline const ::DS3_Frpg2RequestMessage::QuickMatchRank& RequestSendQuickMatchResultResponse::new_local_rank() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestSendQuickMatchResultResponse.new_local_rank)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return new_local_rank_ != NULL ? *new_local_rank_ : *default_instance().new_local_rank_;
#else
  return new_local_rank_ != NULL ? *new_local_rank_ : *default_instance_->new_local_rank_;
#endif
}
inline ::DS3_Frpg2RequestMessage::QuickMatchRank* RequestSendQuickMatchResultResponse::mutable_new_local_rank() {
  set_has_new_local_rank();
  if (new_local_rank_ == NULL) new_local_rank_ = new ::DS3_Frpg2RequestMessage::QuickMatchRank;
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.RequestSendQuickMatchResultResponse.new_local_rank)
  return new_local_rank_;
}
inline ::DS3_Frpg2RequestMessage::QuickMatchRank* RequestSendQuickMatchResultResponse::release_new_local_rank() {
  clear_has_new_local_rank();
  ::DS3_Frpg2RequestMessage::QuickMatchRank* temp = new_local_rank_;
  new_local_rank_ = NULL;
  return temp;
}
inline void RequestSendQuickMatchResultResponse::set_allocated_new_local_rank(::DS3_Frpg2RequestMessage::QuickMatchRank* new_local_rank) {
  delete new_local_rank_;
  new_local_rank_ = new_local_rank;
  if (new_local_rank) {
    set_has_new_local_rank();
  } else {
    clear_has_new_local_rank();
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.RequestSendQuickMatchResultResponse.new_local_rank)
}

// -------------------------------------------------------------------

// RequestPushSendQuickMatchStart

// -------------------------------------------------------------------

// RitualMarkData

// -------------------------------------------------------------------

// LocatedRitualMark

// -------------------------------------------------------------------

// RitualMarkDomainLimit

// -------------------------------------------------------------------

// RequestCreateMark

// -------------------------------------------------------------------

// RequestCreateMarkResponse

// -------------------------------------------------------------------

// RequestRemoveMark

// -------------------------------------------------------------------

// RequestRemoveMarkResponse

// -------------------------------------------------------------------

// RequestReentryMark

// -------------------------------------------------------------------

// RequestReentryMarkResponse

// -------------------------------------------------------------------

// RequestGetMarkList

// -------------------------------------------------------------------

// RequestGetMarkListResponse

// -------------------------------------------------------------------

// PushRequestHeader

// required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
inline bool PushRequestHeader::has_push_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PushRequestHeader::set_has_push_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PushRequestHeader::clear_has_push_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PushRequestHeader::clear_push_message_id() {
  push_message_id_ = 829;
  clear_has_push_message_id();
}
inline ::DS3_Frpg2RequestMessage::PushMessageId PushRequestHeader::push_message_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.PushRequestHeader.push_message_id)
  return static_cast< ::DS3_Frpg2RequestMessage::PushMessageId >(push_message_id_);
}
inline void PushRequestHeader::set_push_message_id(::DS3_Frpg2RequestMessage::PushMessageId value) {
  assert(::DS3_Frpg2RequestMessage::PushMessageId_IsValid(value));
  set_has_push_message_id();
  push_message_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.PushRequestHeader.push_message_id)
}

// -------------------------------------------------------------------

// RangedLimit

// -------------------------------------------------------------------

// PlayerUserIDPair

// -------------------------------------------------------------------

// ManagementTextMessage

// required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
inline bool ManagementTextMessage::has_push_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ManagementTextMessage::set_has_push_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ManagementTextMessage::clear_has_push_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ManagementTextMessage::clear_push_message_id() {
  push_message_id_ = 829;
  clear_has_push_message_id();
}
inline ::DS3_Frpg2RequestMessage::PushMessageId ManagementTextMessage::push_message_id() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.ManagementTextMessage.push_message_id)
  return static_cast< ::DS3_Frpg2RequestMessage::PushMessageId >(push_message_id_);
}
inline void ManagementTextMessage::set_push_message_id(::DS3_Frpg2RequestMessage::PushMessageId value) {
  assert(::DS3_Frpg2RequestMessage::PushMessageId_IsValid(value));
  set_has_push_message_id();
  push_message_id_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.ManagementTextMessage.push_message_id)
}

// required string message = 2;
inline bool ManagementTextMessage::has_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ManagementTextMessage::set_has_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ManagementTextMessage::clear_has_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ManagementTextMessage::clear_message() {
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& ManagementTextMessage::message() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.ManagementTextMessage.message)
  return *message_;
}
inline void ManagementTextMessage::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(value);
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.ManagementTextMessage.message)
}
inline void ManagementTextMessage::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(value);
  // @@protoc_insertion_point(field_set_char:DS3_Frpg2RequestMessage.ManagementTextMessage.message)
}
inline void ManagementTextMessage::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DS3_Frpg2RequestMessage.ManagementTextMessage.message)
}
inline ::std::string* ManagementTextMessage::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.ManagementTextMessage.message)
  return message_;
}
inline ::std::string* ManagementTextMessage::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ManagementTextMessage::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.ManagementTextMessage.message)
}

// required .DS3_Frpg2PlayerData.DateTime timestamp = 3;
inline bool ManagementTextMessage::has_timestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ManagementTextMessage::set_has_timestamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ManagementTextMessage::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ManagementTextMessage::clear_timestamp() {
  if (timestamp_ != NULL) timestamp_->::DS3_Frpg2PlayerData::DateTime::Clear();
  clear_has_timestamp();
}
inline const ::DS3_Frpg2PlayerData::DateTime& ManagementTextMessage::timestamp() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.ManagementTextMessage.timestamp)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return timestamp_ != NULL ? *timestamp_ : *default_instance().timestamp_;
#else
  return timestamp_ != NULL ? *timestamp_ : *default_instance_->timestamp_;
#endif
}
inline ::DS3_Frpg2PlayerData::DateTime* ManagementTextMessage::mutable_timestamp() {
  set_has_timestamp();
  if (timestamp_ == NULL) timestamp_ = new ::DS3_Frpg2PlayerData::DateTime;
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.ManagementTextMessage.timestamp)
  return timestamp_;
}
inline ::DS3_Frpg2PlayerData::DateTime* ManagementTextMessage::release_timestamp() {
  clear_has_timestamp();
  ::DS3_Frpg2PlayerData::DateTime* temp = timestamp_;
  timestamp_ = NULL;
  return temp;
}
inline void ManagementTextMessage::set_allocated_timestamp(::DS3_Frpg2PlayerData::DateTime* timestamp) {
  delete timestamp_;
  timestamp_ = timestamp;
  if (timestamp) {
    set_has_timestamp();
  } else {
    clear_has_timestamp();
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.ManagementTextMessage.timestamp)
}

// required uint32 unknown_4 = 4;
inline bool ManagementTextMessage::has_unknown_4() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ManagementTextMessage::set_has_unknown_4() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ManagementTextMessage::clear_has_unknown_4() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ManagementTextMessage::clear_unknown_4() {
  unknown_4_ = 0u;
  clear_has_unknown_4();
}
inline ::google::protobuf::uint32 ManagementTextMessage::unknown_4() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.ManagementTextMessage.unknown_4)
  return unknown_4_;
}
inline void ManagementTextMessage::set_unknown_4(::google::protobuf::uint32 value) {
  set_has_unknown_4();
  unknown_4_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.ManagementTextMessage.unknown_4)
}

// required uint32 unknown_5 = 5;
inline bool ManagementTextMessage::has_unknown_5() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ManagementTextMessage::set_has_unknown_5() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ManagementTextMessage::clear_has_unknown_5() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ManagementTextMessage::clear_unknown_5() {
  unknown_5_ = 0u;
  clear_has_unknown_5();
}
inline ::google::protobuf::uint32 ManagementTextMessage::unknown_5() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.ManagementTextMessage.unknown_5)
  return unknown_5_;
}
inline void ManagementTextMessage::set_unknown_5(::google::protobuf::uint32 value) {
  set_has_unknown_5();
  unknown_5_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.ManagementTextMessage.unknown_5)
}

// -------------------------------------------------------------------

// NRLogUploadRequest

// required uint32 unknown_1 = 1;
inline bool NRLogUploadRequest::has_unknown_1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NRLogUploadRequest::set_has_unknown_1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NRLogUploadRequest::clear_has_unknown_1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NRLogUploadRequest::clear_unknown_1() {
  unknown_1_ = 0u;
  clear_has_unknown_1();
}
inline ::google::protobuf::uint32 NRLogUploadRequest::unknown_1() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.NRLogUploadRequest.unknown_1)
  return unknown_1_;
}
inline void NRLogUploadRequest::set_unknown_1(::google::protobuf::uint32 value) {
  set_has_unknown_1();
  unknown_1_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.NRLogUploadRequest.unknown_1)
}

// required uint32 unknown_2 = 2;
inline bool NRLogUploadRequest::has_unknown_2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NRLogUploadRequest::set_has_unknown_2() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NRLogUploadRequest::clear_has_unknown_2() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NRLogUploadRequest::clear_unknown_2() {
  unknown_2_ = 0u;
  clear_has_unknown_2();
}
inline ::google::protobuf::uint32 NRLogUploadRequest::unknown_2() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.NRLogUploadRequest.unknown_2)
  return unknown_2_;
}
inline void NRLogUploadRequest::set_unknown_2(::google::protobuf::uint32 value) {
  set_has_unknown_2();
  unknown_2_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.NRLogUploadRequest.unknown_2)
}

// -------------------------------------------------------------------

// NRLoggingMessage

// required uint32 unknown_1 = 1;
inline bool NRLoggingMessage::has_unknown_1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NRLoggingMessage::set_has_unknown_1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NRLoggingMessage::clear_has_unknown_1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NRLoggingMessage::clear_unknown_1() {
  unknown_1_ = 0u;
  clear_has_unknown_1();
}
inline ::google::protobuf::uint32 NRLoggingMessage::unknown_1() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.NRLoggingMessage.unknown_1)
  return unknown_1_;
}
inline void NRLoggingMessage::set_unknown_1(::google::protobuf::uint32 value) {
  set_has_unknown_1();
  unknown_1_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.NRLoggingMessage.unknown_1)
}

// required bytes unknown_2 = 2;
inline bool NRLoggingMessage::has_unknown_2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NRLoggingMessage::set_has_unknown_2() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NRLoggingMessage::clear_has_unknown_2() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NRLoggingMessage::clear_unknown_2() {
  if (unknown_2_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unknown_2_->clear();
  }
  clear_has_unknown_2();
}
inline const ::std::string& NRLoggingMessage::unknown_2() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.NRLoggingMessage.unknown_2)
  return *unknown_2_;
}
inline void NRLoggingMessage::set_unknown_2(const ::std::string& value) {
  set_has_unknown_2();
  if (unknown_2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unknown_2_ = new ::std::string;
  }
  unknown_2_->assign(value);
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.NRLoggingMessage.unknown_2)
}
inline void NRLoggingMessage::set_unknown_2(const char* value) {
  set_has_unknown_2();
  if (unknown_2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unknown_2_ = new ::std::string;
  }
  unknown_2_->assign(value);
  // @@protoc_insertion_point(field_set_char:DS3_Frpg2RequestMessage.NRLoggingMessage.unknown_2)
}
inline void NRLoggingMessage::set_unknown_2(const void* value, size_t size) {
  set_has_unknown_2();
  if (unknown_2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unknown_2_ = new ::std::string;
  }
  unknown_2_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DS3_Frpg2RequestMessage.NRLoggingMessage.unknown_2)
}
inline ::std::string* NRLoggingMessage::mutable_unknown_2() {
  set_has_unknown_2();
  if (unknown_2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unknown_2_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.NRLoggingMessage.unknown_2)
  return unknown_2_;
}
inline ::std::string* NRLoggingMessage::release_unknown_2() {
  clear_has_unknown_2();
  if (unknown_2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = unknown_2_;
    unknown_2_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void NRLoggingMessage::set_allocated_unknown_2(::std::string* unknown_2) {
  if (unknown_2_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete unknown_2_;
  }
  if (unknown_2) {
    set_has_unknown_2();
    unknown_2_ = unknown_2;
  } else {
    clear_has_unknown_2();
    unknown_2_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DS3_Frpg2RequestMessage.NRLoggingMessage.unknown_2)
}

// -------------------------------------------------------------------

// ServerPing

// required uint32 unknown_1 = 1;
inline bool ServerPing::has_unknown_1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerPing::set_has_unknown_1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerPing::clear_has_unknown_1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerPing::clear_unknown_1() {
  unknown_1_ = 0u;
  clear_has_unknown_1();
}
inline ::google::protobuf::uint32 ServerPing::unknown_1() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.ServerPing.unknown_1)
  return unknown_1_;
}
inline void ServerPing::set_unknown_1(::google::protobuf::uint32 value) {
  set_has_unknown_1();
  unknown_1_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.ServerPing.unknown_1)
}

// -------------------------------------------------------------------

// RequestGetOnlineShopItemList

// -------------------------------------------------------------------

// RequestGetOnlineShopItemListResponse_Lineup

// -------------------------------------------------------------------

// RequestGetOnlineShopItemListResponse

// repeated group Lineup = 2 {
inline int RequestGetOnlineShopItemListResponse::lineup_size() const {
  return lineup_.size();
}
inline void RequestGetOnlineShopItemListResponse::clear_lineup() {
  lineup_.Clear();
}
inline const ::DS3_Frpg2RequestMessage::RequestGetOnlineShopItemListResponse_Lineup& RequestGetOnlineShopItemListResponse::lineup(int index) const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.RequestGetOnlineShopItemListResponse.lineup)
  return lineup_.Get(index);
}
inline ::DS3_Frpg2RequestMessage::RequestGetOnlineShopItemListResponse_Lineup* RequestGetOnlineShopItemListResponse::mutable_lineup(int index) {
  // @@protoc_insertion_point(field_mutable:DS3_Frpg2RequestMessage.RequestGetOnlineShopItemListResponse.lineup)
  return lineup_.Mutable(index);
}
inline ::DS3_Frpg2RequestMessage::RequestGetOnlineShopItemListResponse_Lineup* RequestGetOnlineShopItemListResponse::add_lineup() {
  // @@protoc_insertion_point(field_add:DS3_Frpg2RequestMessage.RequestGetOnlineShopItemListResponse.lineup)
  return lineup_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::RequestGetOnlineShopItemListResponse_Lineup >&
RequestGetOnlineShopItemListResponse::lineup() const {
  // @@protoc_insertion_point(field_list:DS3_Frpg2RequestMessage.RequestGetOnlineShopItemListResponse.lineup)
  return lineup_;
}
inline ::google::protobuf::RepeatedPtrField< ::DS3_Frpg2RequestMessage::RequestGetOnlineShopItemListResponse_Lineup >*
RequestGetOnlineShopItemListResponse::mutable_lineup() {
  // @@protoc_insertion_point(field_mutable_list:DS3_Frpg2RequestMessage.RequestGetOnlineShopItemListResponse.lineup)
  return &lineup_;
}

// -------------------------------------------------------------------

// LoginForXboxOne

// -------------------------------------------------------------------

// SocketOptionSetting

// -------------------------------------------------------------------

// GetConnectGameServerPortIdResponse

// -------------------------------------------------------------------

// NotifyLoginToPushServer

// -------------------------------------------------------------------

// NotifyLogoutToPushServer

// -------------------------------------------------------------------

// UserLoginInfo

// -------------------------------------------------------------------

// UserLogout

// -------------------------------------------------------------------

// LoginClientInfo

// -------------------------------------------------------------------

// NotifyClientServerInfoToPushServer

// required uint32 unknown_1 = 1;
inline bool NotifyClientServerInfoToPushServer::has_unknown_1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NotifyClientServerInfoToPushServer::set_has_unknown_1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NotifyClientServerInfoToPushServer::clear_has_unknown_1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NotifyClientServerInfoToPushServer::clear_unknown_1() {
  unknown_1_ = 0u;
  clear_has_unknown_1();
}
inline ::google::protobuf::uint32 NotifyClientServerInfoToPushServer::unknown_1() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.NotifyClientServerInfoToPushServer.unknown_1)
  return unknown_1_;
}
inline void NotifyClientServerInfoToPushServer::set_unknown_1(::google::protobuf::uint32 value) {
  set_has_unknown_1();
  unknown_1_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.NotifyClientServerInfoToPushServer.unknown_1)
}

// required uint32 unknown_2 = 2;
inline bool NotifyClientServerInfoToPushServer::has_unknown_2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NotifyClientServerInfoToPushServer::set_has_unknown_2() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NotifyClientServerInfoToPushServer::clear_has_unknown_2() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NotifyClientServerInfoToPushServer::clear_unknown_2() {
  unknown_2_ = 0u;
  clear_has_unknown_2();
}
inline ::google::protobuf::uint32 NotifyClientServerInfoToPushServer::unknown_2() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.NotifyClientServerInfoToPushServer.unknown_2)
  return unknown_2_;
}
inline void NotifyClientServerInfoToPushServer::set_unknown_2(::google::protobuf::uint32 value) {
  set_has_unknown_2();
  unknown_2_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.NotifyClientServerInfoToPushServer.unknown_2)
}

// required uint32 unknown_3 = 3;
inline bool NotifyClientServerInfoToPushServer::has_unknown_3() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NotifyClientServerInfoToPushServer::set_has_unknown_3() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NotifyClientServerInfoToPushServer::clear_has_unknown_3() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NotifyClientServerInfoToPushServer::clear_unknown_3() {
  unknown_3_ = 0u;
  clear_has_unknown_3();
}
inline ::google::protobuf::uint32 NotifyClientServerInfoToPushServer::unknown_3() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.NotifyClientServerInfoToPushServer.unknown_3)
  return unknown_3_;
}
inline void NotifyClientServerInfoToPushServer::set_unknown_3(::google::protobuf::uint32 value) {
  set_has_unknown_3();
  unknown_3_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.NotifyClientServerInfoToPushServer.unknown_3)
}

// -------------------------------------------------------------------

// PushLoginUserInfo

// required uint32 unknown_1 = 1;
inline bool PushLoginUserInfo::has_unknown_1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PushLoginUserInfo::set_has_unknown_1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PushLoginUserInfo::clear_has_unknown_1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PushLoginUserInfo::clear_unknown_1() {
  unknown_1_ = 0u;
  clear_has_unknown_1();
}
inline ::google::protobuf::uint32 PushLoginUserInfo::unknown_1() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.PushLoginUserInfo.unknown_1)
  return unknown_1_;
}
inline void PushLoginUserInfo::set_unknown_1(::google::protobuf::uint32 value) {
  set_has_unknown_1();
  unknown_1_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.PushLoginUserInfo.unknown_1)
}

// required uint32 unknown_2 = 2;
inline bool PushLoginUserInfo::has_unknown_2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PushLoginUserInfo::set_has_unknown_2() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PushLoginUserInfo::clear_has_unknown_2() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PushLoginUserInfo::clear_unknown_2() {
  unknown_2_ = 0u;
  clear_has_unknown_2();
}
inline ::google::protobuf::uint32 PushLoginUserInfo::unknown_2() const {
  // @@protoc_insertion_point(field_get:DS3_Frpg2RequestMessage.PushLoginUserInfo.unknown_2)
  return unknown_2_;
}
inline void PushLoginUserInfo::set_unknown_2(::google::protobuf::uint32 value) {
  set_has_unknown_2();
  unknown_2_ = value;
  // @@protoc_insertion_point(field_set:DS3_Frpg2RequestMessage.PushLoginUserInfo.unknown_2)
}

// -------------------------------------------------------------------

// RequestCheckLogin

// -------------------------------------------------------------------

// RequestCheckLoginResponse

// -------------------------------------------------------------------

// RequestGetPlayerConnectGameServer

// -------------------------------------------------------------------

// PlayerConnectServerInfo

// -------------------------------------------------------------------

// RequestGetPlayerConnectGameServerResponse

// -------------------------------------------------------------------

// RequestGetServerConnectTime

// -------------------------------------------------------------------

// RequestGetServerConnectTimeResponse

// -------------------------------------------------------------------

// RequestGetConnectionCount

// -------------------------------------------------------------------

// RequestGetConnectionCountResponse

// -------------------------------------------------------------------

// RequestDisconnectUser

// -------------------------------------------------------------------

// RequestDisconnectAllUser

// -------------------------------------------------------------------

// RequestSendMessageToPushClient

// -------------------------------------------------------------------

// RequestGetServerSidePlayerStatus


// @@protoc_insertion_point(namespace_scope)

}  // namespace DS3_Frpg2RequestMessage

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_DS3_5fFrpg2RequestMessage_2eproto__INCLUDED
