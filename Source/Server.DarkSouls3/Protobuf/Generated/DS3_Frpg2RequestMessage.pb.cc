// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: DS3_Frpg2RequestMessage.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "DS3_Frpg2RequestMessage.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace DS3_Frpg2RequestMessage {

void protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto() {
  delete EmptyResponse::default_instance_;
  delete RequestWaitForUserLogin::default_instance_;
  delete RequestWaitForUserLoginResponse::default_instance_;
  delete PlayerStatusUploadConfig::default_instance_;
  delete AnnounceMessageData::default_instance_;
  delete AnnounceMessageDataList::default_instance_;
  delete RequestGetAnnounceMessageList::default_instance_;
  delete RequestGetAnnounceMessageListResponse::default_instance_;
  delete PlayerCharacterData::default_instance_;
  delete PlayerCharacterID::default_instance_;
  delete PlayerInfoUploadConfigPushMessage::default_instance_;
  delete RequestUpdateLoginPlayerCharacter::default_instance_;
  delete RequestUpdateLoginPlayerCharacterResponse::default_instance_;
  delete RequestUpdatePlayerStatus::default_instance_;
  delete RequestUpdatePlayerStatusResponse::default_instance_;
  delete RequestUpdatePlayerCharacter::default_instance_;
  delete RequestUpdatePlayerCharacterResponse::default_instance_;
  delete RequestGetPlayerCharacter::default_instance_;
  delete RequestGetPlayerCharacterResponse::default_instance_;
  delete BloodMessageData::default_instance_;
  delete LocatedBloodMessage::default_instance_;
  delete BloodMessageDomainLimitData::default_instance_;
  delete RequestReentryBloodMessage::default_instance_;
  delete RequestReentryBloodMessageResponse::default_instance_;
  delete RequestCreateBloodMessage::default_instance_;
  delete RequestCreateBloodMessageResponse::default_instance_;
  delete RequestReCreateBloodMessageList::default_instance_;
  delete RequestReCreateBloodMessageList_Blood_message_info_list::default_instance_;
  delete RequestReCreateBloodMessageListResponse::default_instance_;
  delete RequestRemoveBloodMessage::default_instance_;
  delete RequestRemoveBloodMessageResponse::default_instance_;
  delete RequestGetBloodMessageList::default_instance_;
  delete RequestGetBloodMessageListResponse::default_instance_;
  delete RequestEvaluateBloodMessage::default_instance_;
  delete RequestEvaluateBloodMessageResponse::default_instance_;
  delete RequestGetBloodMessageEvaluation::default_instance_;
  delete BloodMessageEvaluationData::default_instance_;
  delete RequestGetBloodMessageEvaluationResponse::default_instance_;
  delete PushRequestEvaluateBloodMessage::default_instance_;
  delete BloodstainInfo::default_instance_;
  delete RequestCreateBloodstain::default_instance_;
  delete RequestGetBloodstainList::default_instance_;
  delete RequestGetBloodstainListResponse::default_instance_;
  delete RequestGetDeadingGhost::default_instance_;
  delete RequestGetDeadingGhostResponse::default_instance_;
  delete LogCommonInfo_1::default_instance_;
  delete LogCommonInfo::default_instance_;
  delete DomainLimitData::default_instance_;
  delete KillerInfo::default_instance_;
  delete KillEnemyInfo::default_instance_;
  delete PartyMemberInfo::default_instance_;
  delete RequestNotifyProtoBufLog::default_instance_;
  delete RequestNotifyDie::default_instance_;
  delete RequestNotifyKillEnemy::default_instance_;
  delete RequestNotifyKillBoss::default_instance_;
  delete RequestNotifyJoinMultiplay::default_instance_;
  delete RequestNotifyLeaveMultiplay::default_instance_;
  delete RequestNotifyCreateSignResult::default_instance_;
  delete RequestNotifySummonSignResult::default_instance_;
  delete RequestNotifyBreakInResult::default_instance_;
  delete RequestNotifyDisconnectSession::default_instance_;
  delete RequestNotifyDisconnectSessionResponse::default_instance_;
  delete RequestNotifyRegisterCharacter::default_instance_;
  delete SummonSignMessage::default_instance_;
  delete RemoveSignMessage::default_instance_;
  delete RejectSignMessage::default_instance_;
  delete CachedSign::default_instance_;
  delete GetSignResult::default_instance_;
  delete SignInfo::default_instance_;
  delete SignData::default_instance_;
  delete MatchingParameter::default_instance_;
  delete SignGetFlags::default_instance_;
  delete SignDomainGetInfo::default_instance_;
  delete RequestGetSignList::default_instance_;
  delete RequestGetSignListResponse::default_instance_;
  delete RequestCreateSign::default_instance_;
  delete RequestCreateSignResponse::default_instance_;
  delete RequestSummonSign::default_instance_;
  delete RequestSummonSignResponse::default_instance_;
  delete RequestRemoveSign::default_instance_;
  delete RequestRemoveSignResponse::default_instance_;
  delete RequestUpdateSign::default_instance_;
  delete RequestUpdateSignResponse::default_instance_;
  delete RequestRejectSign::default_instance_;
  delete RequestRejectSignResponse::default_instance_;
  delete RequestGetRightMatchingArea::default_instance_;
  delete RequestGetRightMatchingAreaResponse::default_instance_;
  delete RequestGetRightMatchingAreaResponse_Area_info::default_instance_;
  delete PushRequestRemoveSign::default_instance_;
  delete PushRequestSummonSign::default_instance_;
  delete PushRequestRejectSign::default_instance_;
  delete BreakInTargetData::default_instance_;
  delete RequestGetBreakInTargetList::default_instance_;
  delete RequestGetBreakInTargetListResponse::default_instance_;
  delete PushRequestAllowBreakInTarget::default_instance_;
  delete PushRequestBreakInTarget::default_instance_;
  delete PushRequestRemoveBreakInTarget::default_instance_;
  delete RequestBreakInTarget::default_instance_;
  delete RequestRejectBreakInTarget::default_instance_;
  delete PushRequestRejectBreakInTarget::default_instance_;
  delete RequestBreakInTargetResponse::default_instance_;
  delete RequestRejectBreakInTargetResponse::default_instance_;
  delete RequestGetGhostDataList::default_instance_;
  delete GhostData::default_instance_;
  delete RequestCreateGhostData::default_instance_;
  delete RequestCreateGhostDataResponse::default_instance_;
  delete RequestGetGhostDataListResponse::default_instance_;
  delete RequestGetVisitorList::default_instance_;
  delete VisitorData::default_instance_;
  delete RequestGetVisitorListResponse::default_instance_;
  delete PushRequestRemoveVisitor::default_instance_;
  delete RequestVisit::default_instance_;
  delete PushRequestVisit::default_instance_;
  delete RequestRejectVisit::default_instance_;
  delete PushRequestRejectVisit::default_instance_;
  delete RequestVisitResponse::default_instance_;
  delete RequestRejectVisitResponse::default_instance_;
  delete RequestNotifyRingBell::default_instance_;
  delete RequestNotifyRingBellResponse::default_instance_;
  delete PushRequestNotifyRingBell::default_instance_;
  delete RequestGetRegulationFile::default_instance_;
  delete RequestGetRegulationFileResponse::default_instance_;
  delete RegulationFileMessage::default_instance_;
  delete RegulationFileDiffData::default_instance_;
  delete RegulationFileUpdateMessage::default_instance_;
  delete RegulationFileUpdatePushMessage::default_instance_;
  delete RequestBenchmarkThroughput::default_instance_;
  delete RequestBenchmarkThroughputResponse::default_instance_;
  delete RequestGetLoginPlayerCharacter::default_instance_;
  delete RequestGetLoginPlayerCharacterResponse::default_instance_;
  delete RequestGetPlayerCharacterList::default_instance_;
  delete RequestGetPlayerCharacterListResponse::default_instance_;
  delete RequestMeasureUploadBandwidth::default_instance_;
  delete RequestMeasureUploadBandwidthResponse::default_instance_;
  delete RequestMeasureDownloadBandwidth::default_instance_;
  delete RequestMeasureDownloadBandwidthResponse::default_instance_;
  delete RequestSendMessageToPlayers::default_instance_;
  delete RequestSendMessageToPlayersResponse::default_instance_;
  delete RequestSendMessageToSelectLanguagePlayers::default_instance_;
  delete RequestSendMessageToSelectLanguagePlayersResponse::default_instance_;
  delete RequestSendMessageToAllPlayers::default_instance_;
  delete RequestSendMessageToAllPlayersResponse::default_instance_;
  delete RequestSendPlayerList::default_instance_;
  delete RankingData::default_instance_;
  delete RankingRotationID::default_instance_;
  delete RankingRecordCount::default_instance_;
  delete RankingDataPack::default_instance_;
  delete RequestRegisterRankingData::default_instance_;
  delete RequestRegisterRankingDataResponse::default_instance_;
  delete RequestGetRankingData::default_instance_;
  delete RequestGetRankingDataResponse::default_instance_;
  delete RequestGetCharacterRankingData::default_instance_;
  delete RequestGetCharacterRankingDataResponse::default_instance_;
  delete RequestCountRankingData::default_instance_;
  delete RequestCountRankingDataResponse::default_instance_;
  delete RequestGetCurrentRank::default_instance_;
  delete RequestGetCurrentRankResponse::default_instance_;
  delete QuickMatchRank::default_instance_;
  delete QuickMatchRankCache::default_instance_;
  delete QuickMatchSession::default_instance_;
  delete QuickMatchSession_Result_list::default_instance_;
  delete QuickMatchApologyPoint::default_instance_;
  delete QuickMatchData::default_instance_;
  delete QuickMatchSearchResult::default_instance_;
  delete AcceptQuickMatchMessage::default_instance_;
  delete RejectQuickMatchMessage::default_instance_;
  delete RemoveQuickMatchMessage::default_instance_;
  delete JoinQuickMatchMessage::default_instance_;
  delete PushRequestJoinQuickMatch::default_instance_;
  delete PushRequestAcceptQuickMatch::default_instance_;
  delete PushRequestRejectQuickMatch::default_instance_;
  delete RequestSearchQuickMatch::default_instance_;
  delete RequestSearchQuickMatch_Map_id_list::default_instance_;
  delete RequestSearchQuickMatchResponse::default_instance_;
  delete RequestRegisterQuickMatch::default_instance_;
  delete RequestUnregisterQuickMatch::default_instance_;
  delete RequestRegisterQuickMatchResponse::default_instance_;
  delete RequestUnregisterQuickMatchResponse::default_instance_;
  delete RequestUpdateQuickMatch::default_instance_;
  delete RequestUpdateQuickMatchResponse::default_instance_;
  delete RequestJoinQuickMatch::default_instance_;
  delete RequestJoinQuickMatchResponse::default_instance_;
  delete RequestAcceptQuickMatch::default_instance_;
  delete RequestAcceptQuickMatchResponse::default_instance_;
  delete RequestRejectQuickMatch::default_instance_;
  delete RequestRejectQuickMatchResponse::default_instance_;
  delete RequestSendQuickMatchStart::default_instance_;
  delete RequestSendQuickMatchStart_Session_member_list::default_instance_;
  delete RequestSendQuickMatchStartResponse::default_instance_;
  delete RequestSendQuickMatchResult::default_instance_;
  delete RequestSendQuickMatchResultResponse::default_instance_;
  delete RequestPushSendQuickMatchStart::default_instance_;
  delete RitualMarkData::default_instance_;
  delete LocatedRitualMark::default_instance_;
  delete RitualMarkDomainLimit::default_instance_;
  delete RequestCreateMark::default_instance_;
  delete RequestCreateMarkResponse::default_instance_;
  delete RequestRemoveMark::default_instance_;
  delete RequestRemoveMarkResponse::default_instance_;
  delete RequestReentryMark::default_instance_;
  delete RequestReentryMarkResponse::default_instance_;
  delete RequestGetMarkList::default_instance_;
  delete RequestGetMarkListResponse::default_instance_;
  delete PushRequestHeader::default_instance_;
  delete RangedLimit::default_instance_;
  delete PlayerUserIDPair::default_instance_;
  delete ManagementTextMessage::default_instance_;
  delete NRLogUploadRequest::default_instance_;
  delete NRLoggingMessage::default_instance_;
  delete ServerPing::default_instance_;
  delete RequestGetOnlineShopItemList::default_instance_;
  delete RequestGetOnlineShopItemListResponse::default_instance_;
  delete RequestGetOnlineShopItemListResponse_Lineup::default_instance_;
  delete LoginForXboxOne::default_instance_;
  delete SocketOptionSetting::default_instance_;
  delete GetConnectGameServerPortIdResponse::default_instance_;
  delete NotifyLoginToPushServer::default_instance_;
  delete NotifyLogoutToPushServer::default_instance_;
  delete UserLoginInfo::default_instance_;
  delete UserLogout::default_instance_;
  delete LoginClientInfo::default_instance_;
  delete NotifyClientServerInfoToPushServer::default_instance_;
  delete PushLoginUserInfo::default_instance_;
  delete RequestCheckLogin::default_instance_;
  delete RequestCheckLoginResponse::default_instance_;
  delete RequestGetPlayerConnectGameServer::default_instance_;
  delete PlayerConnectServerInfo::default_instance_;
  delete RequestGetPlayerConnectGameServerResponse::default_instance_;
  delete RequestGetServerConnectTime::default_instance_;
  delete RequestGetServerConnectTimeResponse::default_instance_;
  delete RequestGetConnectionCount::default_instance_;
  delete RequestGetConnectionCountResponse::default_instance_;
  delete RequestDisconnectUser::default_instance_;
  delete RequestDisconnectAllUser::default_instance_;
  delete RequestSendMessageToPushClient::default_instance_;
  delete RequestGetServerSidePlayerStatus::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  ::DS3_Frpg2PlayerData::protobuf_AddDesc_DS3_5fFrpg2PlayerData_2eproto();
  EmptyResponse::default_instance_ = new EmptyResponse();
  RequestWaitForUserLogin::default_instance_ = new RequestWaitForUserLogin();
  RequestWaitForUserLoginResponse::default_instance_ = new RequestWaitForUserLoginResponse();
  PlayerStatusUploadConfig::default_instance_ = new PlayerStatusUploadConfig();
  AnnounceMessageData::default_instance_ = new AnnounceMessageData();
  AnnounceMessageDataList::default_instance_ = new AnnounceMessageDataList();
  RequestGetAnnounceMessageList::default_instance_ = new RequestGetAnnounceMessageList();
  RequestGetAnnounceMessageListResponse::default_instance_ = new RequestGetAnnounceMessageListResponse();
  PlayerCharacterData::default_instance_ = new PlayerCharacterData();
  PlayerCharacterID::default_instance_ = new PlayerCharacterID();
  PlayerInfoUploadConfigPushMessage::default_instance_ = new PlayerInfoUploadConfigPushMessage();
  RequestUpdateLoginPlayerCharacter::default_instance_ = new RequestUpdateLoginPlayerCharacter();
  RequestUpdateLoginPlayerCharacterResponse::default_instance_ = new RequestUpdateLoginPlayerCharacterResponse();
  RequestUpdatePlayerStatus::default_instance_ = new RequestUpdatePlayerStatus();
  RequestUpdatePlayerStatusResponse::default_instance_ = new RequestUpdatePlayerStatusResponse();
  RequestUpdatePlayerCharacter::default_instance_ = new RequestUpdatePlayerCharacter();
  RequestUpdatePlayerCharacterResponse::default_instance_ = new RequestUpdatePlayerCharacterResponse();
  RequestGetPlayerCharacter::default_instance_ = new RequestGetPlayerCharacter();
  RequestGetPlayerCharacterResponse::default_instance_ = new RequestGetPlayerCharacterResponse();
  BloodMessageData::default_instance_ = new BloodMessageData();
  LocatedBloodMessage::default_instance_ = new LocatedBloodMessage();
  BloodMessageDomainLimitData::default_instance_ = new BloodMessageDomainLimitData();
  RequestReentryBloodMessage::default_instance_ = new RequestReentryBloodMessage();
  RequestReentryBloodMessageResponse::default_instance_ = new RequestReentryBloodMessageResponse();
  RequestCreateBloodMessage::default_instance_ = new RequestCreateBloodMessage();
  RequestCreateBloodMessageResponse::default_instance_ = new RequestCreateBloodMessageResponse();
  RequestReCreateBloodMessageList::default_instance_ = new RequestReCreateBloodMessageList();
  RequestReCreateBloodMessageList_Blood_message_info_list::default_instance_ = new RequestReCreateBloodMessageList_Blood_message_info_list();
  RequestReCreateBloodMessageListResponse::default_instance_ = new RequestReCreateBloodMessageListResponse();
  RequestRemoveBloodMessage::default_instance_ = new RequestRemoveBloodMessage();
  RequestRemoveBloodMessageResponse::default_instance_ = new RequestRemoveBloodMessageResponse();
  RequestGetBloodMessageList::default_instance_ = new RequestGetBloodMessageList();
  RequestGetBloodMessageListResponse::default_instance_ = new RequestGetBloodMessageListResponse();
  RequestEvaluateBloodMessage::default_instance_ = new RequestEvaluateBloodMessage();
  RequestEvaluateBloodMessageResponse::default_instance_ = new RequestEvaluateBloodMessageResponse();
  RequestGetBloodMessageEvaluation::default_instance_ = new RequestGetBloodMessageEvaluation();
  BloodMessageEvaluationData::default_instance_ = new BloodMessageEvaluationData();
  RequestGetBloodMessageEvaluationResponse::default_instance_ = new RequestGetBloodMessageEvaluationResponse();
  PushRequestEvaluateBloodMessage::default_instance_ = new PushRequestEvaluateBloodMessage();
  BloodstainInfo::default_instance_ = new BloodstainInfo();
  RequestCreateBloodstain::default_instance_ = new RequestCreateBloodstain();
  RequestGetBloodstainList::default_instance_ = new RequestGetBloodstainList();
  RequestGetBloodstainListResponse::default_instance_ = new RequestGetBloodstainListResponse();
  RequestGetDeadingGhost::default_instance_ = new RequestGetDeadingGhost();
  RequestGetDeadingGhostResponse::default_instance_ = new RequestGetDeadingGhostResponse();
  LogCommonInfo_1::default_instance_ = new LogCommonInfo_1();
  LogCommonInfo::default_instance_ = new LogCommonInfo();
  DomainLimitData::default_instance_ = new DomainLimitData();
  KillerInfo::default_instance_ = new KillerInfo();
  KillEnemyInfo::default_instance_ = new KillEnemyInfo();
  PartyMemberInfo::default_instance_ = new PartyMemberInfo();
  RequestNotifyProtoBufLog::default_instance_ = new RequestNotifyProtoBufLog();
  RequestNotifyDie::default_instance_ = new RequestNotifyDie();
  RequestNotifyKillEnemy::default_instance_ = new RequestNotifyKillEnemy();
  RequestNotifyKillBoss::default_instance_ = new RequestNotifyKillBoss();
  RequestNotifyJoinMultiplay::default_instance_ = new RequestNotifyJoinMultiplay();
  RequestNotifyLeaveMultiplay::default_instance_ = new RequestNotifyLeaveMultiplay();
  RequestNotifyCreateSignResult::default_instance_ = new RequestNotifyCreateSignResult();
  RequestNotifySummonSignResult::default_instance_ = new RequestNotifySummonSignResult();
  RequestNotifyBreakInResult::default_instance_ = new RequestNotifyBreakInResult();
  RequestNotifyDisconnectSession::default_instance_ = new RequestNotifyDisconnectSession();
  RequestNotifyDisconnectSessionResponse::default_instance_ = new RequestNotifyDisconnectSessionResponse();
  RequestNotifyRegisterCharacter::default_instance_ = new RequestNotifyRegisterCharacter();
  SummonSignMessage::default_instance_ = new SummonSignMessage();
  RemoveSignMessage::default_instance_ = new RemoveSignMessage();
  RejectSignMessage::default_instance_ = new RejectSignMessage();
  CachedSign::default_instance_ = new CachedSign();
  GetSignResult::default_instance_ = new GetSignResult();
  SignInfo::default_instance_ = new SignInfo();
  SignData::default_instance_ = new SignData();
  MatchingParameter::default_instance_ = new MatchingParameter();
  SignGetFlags::default_instance_ = new SignGetFlags();
  SignDomainGetInfo::default_instance_ = new SignDomainGetInfo();
  RequestGetSignList::default_instance_ = new RequestGetSignList();
  RequestGetSignListResponse::default_instance_ = new RequestGetSignListResponse();
  RequestCreateSign::default_instance_ = new RequestCreateSign();
  RequestCreateSignResponse::default_instance_ = new RequestCreateSignResponse();
  RequestSummonSign::default_instance_ = new RequestSummonSign();
  RequestSummonSignResponse::default_instance_ = new RequestSummonSignResponse();
  RequestRemoveSign::default_instance_ = new RequestRemoveSign();
  RequestRemoveSignResponse::default_instance_ = new RequestRemoveSignResponse();
  RequestUpdateSign::default_instance_ = new RequestUpdateSign();
  RequestUpdateSignResponse::default_instance_ = new RequestUpdateSignResponse();
  RequestRejectSign::default_instance_ = new RequestRejectSign();
  RequestRejectSignResponse::default_instance_ = new RequestRejectSignResponse();
  RequestGetRightMatchingArea::default_instance_ = new RequestGetRightMatchingArea();
  RequestGetRightMatchingAreaResponse::default_instance_ = new RequestGetRightMatchingAreaResponse();
  RequestGetRightMatchingAreaResponse_Area_info::default_instance_ = new RequestGetRightMatchingAreaResponse_Area_info();
  PushRequestRemoveSign::default_instance_ = new PushRequestRemoveSign();
  PushRequestSummonSign::default_instance_ = new PushRequestSummonSign();
  PushRequestRejectSign::default_instance_ = new PushRequestRejectSign();
  BreakInTargetData::default_instance_ = new BreakInTargetData();
  RequestGetBreakInTargetList::default_instance_ = new RequestGetBreakInTargetList();
  RequestGetBreakInTargetListResponse::default_instance_ = new RequestGetBreakInTargetListResponse();
  PushRequestAllowBreakInTarget::default_instance_ = new PushRequestAllowBreakInTarget();
  PushRequestBreakInTarget::default_instance_ = new PushRequestBreakInTarget();
  PushRequestRemoveBreakInTarget::default_instance_ = new PushRequestRemoveBreakInTarget();
  RequestBreakInTarget::default_instance_ = new RequestBreakInTarget();
  RequestRejectBreakInTarget::default_instance_ = new RequestRejectBreakInTarget();
  PushRequestRejectBreakInTarget::default_instance_ = new PushRequestRejectBreakInTarget();
  RequestBreakInTargetResponse::default_instance_ = new RequestBreakInTargetResponse();
  RequestRejectBreakInTargetResponse::default_instance_ = new RequestRejectBreakInTargetResponse();
  RequestGetGhostDataList::default_instance_ = new RequestGetGhostDataList();
  GhostData::default_instance_ = new GhostData();
  RequestCreateGhostData::default_instance_ = new RequestCreateGhostData();
  RequestCreateGhostDataResponse::default_instance_ = new RequestCreateGhostDataResponse();
  RequestGetGhostDataListResponse::default_instance_ = new RequestGetGhostDataListResponse();
  RequestGetVisitorList::default_instance_ = new RequestGetVisitorList();
  VisitorData::default_instance_ = new VisitorData();
  RequestGetVisitorListResponse::default_instance_ = new RequestGetVisitorListResponse();
  PushRequestRemoveVisitor::default_instance_ = new PushRequestRemoveVisitor();
  RequestVisit::default_instance_ = new RequestVisit();
  PushRequestVisit::default_instance_ = new PushRequestVisit();
  RequestRejectVisit::default_instance_ = new RequestRejectVisit();
  PushRequestRejectVisit::default_instance_ = new PushRequestRejectVisit();
  RequestVisitResponse::default_instance_ = new RequestVisitResponse();
  RequestRejectVisitResponse::default_instance_ = new RequestRejectVisitResponse();
  RequestNotifyRingBell::default_instance_ = new RequestNotifyRingBell();
  RequestNotifyRingBellResponse::default_instance_ = new RequestNotifyRingBellResponse();
  PushRequestNotifyRingBell::default_instance_ = new PushRequestNotifyRingBell();
  RequestGetRegulationFile::default_instance_ = new RequestGetRegulationFile();
  RequestGetRegulationFileResponse::default_instance_ = new RequestGetRegulationFileResponse();
  RegulationFileMessage::default_instance_ = new RegulationFileMessage();
  RegulationFileDiffData::default_instance_ = new RegulationFileDiffData();
  RegulationFileUpdateMessage::default_instance_ = new RegulationFileUpdateMessage();
  RegulationFileUpdatePushMessage::default_instance_ = new RegulationFileUpdatePushMessage();
  RequestBenchmarkThroughput::default_instance_ = new RequestBenchmarkThroughput();
  RequestBenchmarkThroughputResponse::default_instance_ = new RequestBenchmarkThroughputResponse();
  RequestGetLoginPlayerCharacter::default_instance_ = new RequestGetLoginPlayerCharacter();
  RequestGetLoginPlayerCharacterResponse::default_instance_ = new RequestGetLoginPlayerCharacterResponse();
  RequestGetPlayerCharacterList::default_instance_ = new RequestGetPlayerCharacterList();
  RequestGetPlayerCharacterListResponse::default_instance_ = new RequestGetPlayerCharacterListResponse();
  RequestMeasureUploadBandwidth::default_instance_ = new RequestMeasureUploadBandwidth();
  RequestMeasureUploadBandwidthResponse::default_instance_ = new RequestMeasureUploadBandwidthResponse();
  RequestMeasureDownloadBandwidth::default_instance_ = new RequestMeasureDownloadBandwidth();
  RequestMeasureDownloadBandwidthResponse::default_instance_ = new RequestMeasureDownloadBandwidthResponse();
  RequestSendMessageToPlayers::default_instance_ = new RequestSendMessageToPlayers();
  RequestSendMessageToPlayersResponse::default_instance_ = new RequestSendMessageToPlayersResponse();
  RequestSendMessageToSelectLanguagePlayers::default_instance_ = new RequestSendMessageToSelectLanguagePlayers();
  RequestSendMessageToSelectLanguagePlayersResponse::default_instance_ = new RequestSendMessageToSelectLanguagePlayersResponse();
  RequestSendMessageToAllPlayers::default_instance_ = new RequestSendMessageToAllPlayers();
  RequestSendMessageToAllPlayersResponse::default_instance_ = new RequestSendMessageToAllPlayersResponse();
  RequestSendPlayerList::default_instance_ = new RequestSendPlayerList();
  RankingData::default_instance_ = new RankingData();
  RankingRotationID::default_instance_ = new RankingRotationID();
  RankingRecordCount::default_instance_ = new RankingRecordCount();
  RankingDataPack::default_instance_ = new RankingDataPack();
  RequestRegisterRankingData::default_instance_ = new RequestRegisterRankingData();
  RequestRegisterRankingDataResponse::default_instance_ = new RequestRegisterRankingDataResponse();
  RequestGetRankingData::default_instance_ = new RequestGetRankingData();
  RequestGetRankingDataResponse::default_instance_ = new RequestGetRankingDataResponse();
  RequestGetCharacterRankingData::default_instance_ = new RequestGetCharacterRankingData();
  RequestGetCharacterRankingDataResponse::default_instance_ = new RequestGetCharacterRankingDataResponse();
  RequestCountRankingData::default_instance_ = new RequestCountRankingData();
  RequestCountRankingDataResponse::default_instance_ = new RequestCountRankingDataResponse();
  RequestGetCurrentRank::default_instance_ = new RequestGetCurrentRank();
  RequestGetCurrentRankResponse::default_instance_ = new RequestGetCurrentRankResponse();
  QuickMatchRank::default_instance_ = new QuickMatchRank();
  QuickMatchRankCache::default_instance_ = new QuickMatchRankCache();
  QuickMatchSession::default_instance_ = new QuickMatchSession();
  QuickMatchSession_Result_list::default_instance_ = new QuickMatchSession_Result_list();
  QuickMatchApologyPoint::default_instance_ = new QuickMatchApologyPoint();
  QuickMatchData::default_instance_ = new QuickMatchData();
  QuickMatchSearchResult::default_instance_ = new QuickMatchSearchResult();
  AcceptQuickMatchMessage::default_instance_ = new AcceptQuickMatchMessage();
  RejectQuickMatchMessage::default_instance_ = new RejectQuickMatchMessage();
  RemoveQuickMatchMessage::default_instance_ = new RemoveQuickMatchMessage();
  JoinQuickMatchMessage::default_instance_ = new JoinQuickMatchMessage();
  PushRequestJoinQuickMatch::default_instance_ = new PushRequestJoinQuickMatch();
  PushRequestAcceptQuickMatch::default_instance_ = new PushRequestAcceptQuickMatch();
  PushRequestRejectQuickMatch::default_instance_ = new PushRequestRejectQuickMatch();
  RequestSearchQuickMatch::default_instance_ = new RequestSearchQuickMatch();
  RequestSearchQuickMatch_Map_id_list::default_instance_ = new RequestSearchQuickMatch_Map_id_list();
  RequestSearchQuickMatchResponse::default_instance_ = new RequestSearchQuickMatchResponse();
  RequestRegisterQuickMatch::default_instance_ = new RequestRegisterQuickMatch();
  RequestUnregisterQuickMatch::default_instance_ = new RequestUnregisterQuickMatch();
  RequestRegisterQuickMatchResponse::default_instance_ = new RequestRegisterQuickMatchResponse();
  RequestUnregisterQuickMatchResponse::default_instance_ = new RequestUnregisterQuickMatchResponse();
  RequestUpdateQuickMatch::default_instance_ = new RequestUpdateQuickMatch();
  RequestUpdateQuickMatchResponse::default_instance_ = new RequestUpdateQuickMatchResponse();
  RequestJoinQuickMatch::default_instance_ = new RequestJoinQuickMatch();
  RequestJoinQuickMatchResponse::default_instance_ = new RequestJoinQuickMatchResponse();
  RequestAcceptQuickMatch::default_instance_ = new RequestAcceptQuickMatch();
  RequestAcceptQuickMatchResponse::default_instance_ = new RequestAcceptQuickMatchResponse();
  RequestRejectQuickMatch::default_instance_ = new RequestRejectQuickMatch();
  RequestRejectQuickMatchResponse::default_instance_ = new RequestRejectQuickMatchResponse();
  RequestSendQuickMatchStart::default_instance_ = new RequestSendQuickMatchStart();
  RequestSendQuickMatchStart_Session_member_list::default_instance_ = new RequestSendQuickMatchStart_Session_member_list();
  RequestSendQuickMatchStartResponse::default_instance_ = new RequestSendQuickMatchStartResponse();
  RequestSendQuickMatchResult::default_instance_ = new RequestSendQuickMatchResult();
  RequestSendQuickMatchResultResponse::default_instance_ = new RequestSendQuickMatchResultResponse();
  RequestPushSendQuickMatchStart::default_instance_ = new RequestPushSendQuickMatchStart();
  RitualMarkData::default_instance_ = new RitualMarkData();
  LocatedRitualMark::default_instance_ = new LocatedRitualMark();
  RitualMarkDomainLimit::default_instance_ = new RitualMarkDomainLimit();
  RequestCreateMark::default_instance_ = new RequestCreateMark();
  RequestCreateMarkResponse::default_instance_ = new RequestCreateMarkResponse();
  RequestRemoveMark::default_instance_ = new RequestRemoveMark();
  RequestRemoveMarkResponse::default_instance_ = new RequestRemoveMarkResponse();
  RequestReentryMark::default_instance_ = new RequestReentryMark();
  RequestReentryMarkResponse::default_instance_ = new RequestReentryMarkResponse();
  RequestGetMarkList::default_instance_ = new RequestGetMarkList();
  RequestGetMarkListResponse::default_instance_ = new RequestGetMarkListResponse();
  PushRequestHeader::default_instance_ = new PushRequestHeader();
  RangedLimit::default_instance_ = new RangedLimit();
  PlayerUserIDPair::default_instance_ = new PlayerUserIDPair();
  ManagementTextMessage::default_instance_ = new ManagementTextMessage();
  NRLogUploadRequest::default_instance_ = new NRLogUploadRequest();
  NRLoggingMessage::default_instance_ = new NRLoggingMessage();
  ServerPing::default_instance_ = new ServerPing();
  RequestGetOnlineShopItemList::default_instance_ = new RequestGetOnlineShopItemList();
  RequestGetOnlineShopItemListResponse::default_instance_ = new RequestGetOnlineShopItemListResponse();
  RequestGetOnlineShopItemListResponse_Lineup::default_instance_ = new RequestGetOnlineShopItemListResponse_Lineup();
  LoginForXboxOne::default_instance_ = new LoginForXboxOne();
  SocketOptionSetting::default_instance_ = new SocketOptionSetting();
  GetConnectGameServerPortIdResponse::default_instance_ = new GetConnectGameServerPortIdResponse();
  NotifyLoginToPushServer::default_instance_ = new NotifyLoginToPushServer();
  NotifyLogoutToPushServer::default_instance_ = new NotifyLogoutToPushServer();
  UserLoginInfo::default_instance_ = new UserLoginInfo();
  UserLogout::default_instance_ = new UserLogout();
  LoginClientInfo::default_instance_ = new LoginClientInfo();
  NotifyClientServerInfoToPushServer::default_instance_ = new NotifyClientServerInfoToPushServer();
  PushLoginUserInfo::default_instance_ = new PushLoginUserInfo();
  RequestCheckLogin::default_instance_ = new RequestCheckLogin();
  RequestCheckLoginResponse::default_instance_ = new RequestCheckLoginResponse();
  RequestGetPlayerConnectGameServer::default_instance_ = new RequestGetPlayerConnectGameServer();
  PlayerConnectServerInfo::default_instance_ = new PlayerConnectServerInfo();
  RequestGetPlayerConnectGameServerResponse::default_instance_ = new RequestGetPlayerConnectGameServerResponse();
  RequestGetServerConnectTime::default_instance_ = new RequestGetServerConnectTime();
  RequestGetServerConnectTimeResponse::default_instance_ = new RequestGetServerConnectTimeResponse();
  RequestGetConnectionCount::default_instance_ = new RequestGetConnectionCount();
  RequestGetConnectionCountResponse::default_instance_ = new RequestGetConnectionCountResponse();
  RequestDisconnectUser::default_instance_ = new RequestDisconnectUser();
  RequestDisconnectAllUser::default_instance_ = new RequestDisconnectAllUser();
  RequestSendMessageToPushClient::default_instance_ = new RequestSendMessageToPushClient();
  RequestGetServerSidePlayerStatus::default_instance_ = new RequestGetServerSidePlayerStatus();
  EmptyResponse::default_instance_->InitAsDefaultInstance();
  RequestWaitForUserLogin::default_instance_->InitAsDefaultInstance();
  RequestWaitForUserLoginResponse::default_instance_->InitAsDefaultInstance();
  PlayerStatusUploadConfig::default_instance_->InitAsDefaultInstance();
  AnnounceMessageData::default_instance_->InitAsDefaultInstance();
  AnnounceMessageDataList::default_instance_->InitAsDefaultInstance();
  RequestGetAnnounceMessageList::default_instance_->InitAsDefaultInstance();
  RequestGetAnnounceMessageListResponse::default_instance_->InitAsDefaultInstance();
  PlayerCharacterData::default_instance_->InitAsDefaultInstance();
  PlayerCharacterID::default_instance_->InitAsDefaultInstance();
  PlayerInfoUploadConfigPushMessage::default_instance_->InitAsDefaultInstance();
  RequestUpdateLoginPlayerCharacter::default_instance_->InitAsDefaultInstance();
  RequestUpdateLoginPlayerCharacterResponse::default_instance_->InitAsDefaultInstance();
  RequestUpdatePlayerStatus::default_instance_->InitAsDefaultInstance();
  RequestUpdatePlayerStatusResponse::default_instance_->InitAsDefaultInstance();
  RequestUpdatePlayerCharacter::default_instance_->InitAsDefaultInstance();
  RequestUpdatePlayerCharacterResponse::default_instance_->InitAsDefaultInstance();
  RequestGetPlayerCharacter::default_instance_->InitAsDefaultInstance();
  RequestGetPlayerCharacterResponse::default_instance_->InitAsDefaultInstance();
  BloodMessageData::default_instance_->InitAsDefaultInstance();
  LocatedBloodMessage::default_instance_->InitAsDefaultInstance();
  BloodMessageDomainLimitData::default_instance_->InitAsDefaultInstance();
  RequestReentryBloodMessage::default_instance_->InitAsDefaultInstance();
  RequestReentryBloodMessageResponse::default_instance_->InitAsDefaultInstance();
  RequestCreateBloodMessage::default_instance_->InitAsDefaultInstance();
  RequestCreateBloodMessageResponse::default_instance_->InitAsDefaultInstance();
  RequestReCreateBloodMessageList::default_instance_->InitAsDefaultInstance();
  RequestReCreateBloodMessageList_Blood_message_info_list::default_instance_->InitAsDefaultInstance();
  RequestReCreateBloodMessageListResponse::default_instance_->InitAsDefaultInstance();
  RequestRemoveBloodMessage::default_instance_->InitAsDefaultInstance();
  RequestRemoveBloodMessageResponse::default_instance_->InitAsDefaultInstance();
  RequestGetBloodMessageList::default_instance_->InitAsDefaultInstance();
  RequestGetBloodMessageListResponse::default_instance_->InitAsDefaultInstance();
  RequestEvaluateBloodMessage::default_instance_->InitAsDefaultInstance();
  RequestEvaluateBloodMessageResponse::default_instance_->InitAsDefaultInstance();
  RequestGetBloodMessageEvaluation::default_instance_->InitAsDefaultInstance();
  BloodMessageEvaluationData::default_instance_->InitAsDefaultInstance();
  RequestGetBloodMessageEvaluationResponse::default_instance_->InitAsDefaultInstance();
  PushRequestEvaluateBloodMessage::default_instance_->InitAsDefaultInstance();
  BloodstainInfo::default_instance_->InitAsDefaultInstance();
  RequestCreateBloodstain::default_instance_->InitAsDefaultInstance();
  RequestGetBloodstainList::default_instance_->InitAsDefaultInstance();
  RequestGetBloodstainListResponse::default_instance_->InitAsDefaultInstance();
  RequestGetDeadingGhost::default_instance_->InitAsDefaultInstance();
  RequestGetDeadingGhostResponse::default_instance_->InitAsDefaultInstance();
  LogCommonInfo_1::default_instance_->InitAsDefaultInstance();
  LogCommonInfo::default_instance_->InitAsDefaultInstance();
  DomainLimitData::default_instance_->InitAsDefaultInstance();
  KillerInfo::default_instance_->InitAsDefaultInstance();
  KillEnemyInfo::default_instance_->InitAsDefaultInstance();
  PartyMemberInfo::default_instance_->InitAsDefaultInstance();
  RequestNotifyProtoBufLog::default_instance_->InitAsDefaultInstance();
  RequestNotifyDie::default_instance_->InitAsDefaultInstance();
  RequestNotifyKillEnemy::default_instance_->InitAsDefaultInstance();
  RequestNotifyKillBoss::default_instance_->InitAsDefaultInstance();
  RequestNotifyJoinMultiplay::default_instance_->InitAsDefaultInstance();
  RequestNotifyLeaveMultiplay::default_instance_->InitAsDefaultInstance();
  RequestNotifyCreateSignResult::default_instance_->InitAsDefaultInstance();
  RequestNotifySummonSignResult::default_instance_->InitAsDefaultInstance();
  RequestNotifyBreakInResult::default_instance_->InitAsDefaultInstance();
  RequestNotifyDisconnectSession::default_instance_->InitAsDefaultInstance();
  RequestNotifyDisconnectSessionResponse::default_instance_->InitAsDefaultInstance();
  RequestNotifyRegisterCharacter::default_instance_->InitAsDefaultInstance();
  SummonSignMessage::default_instance_->InitAsDefaultInstance();
  RemoveSignMessage::default_instance_->InitAsDefaultInstance();
  RejectSignMessage::default_instance_->InitAsDefaultInstance();
  CachedSign::default_instance_->InitAsDefaultInstance();
  GetSignResult::default_instance_->InitAsDefaultInstance();
  SignInfo::default_instance_->InitAsDefaultInstance();
  SignData::default_instance_->InitAsDefaultInstance();
  MatchingParameter::default_instance_->InitAsDefaultInstance();
  SignGetFlags::default_instance_->InitAsDefaultInstance();
  SignDomainGetInfo::default_instance_->InitAsDefaultInstance();
  RequestGetSignList::default_instance_->InitAsDefaultInstance();
  RequestGetSignListResponse::default_instance_->InitAsDefaultInstance();
  RequestCreateSign::default_instance_->InitAsDefaultInstance();
  RequestCreateSignResponse::default_instance_->InitAsDefaultInstance();
  RequestSummonSign::default_instance_->InitAsDefaultInstance();
  RequestSummonSignResponse::default_instance_->InitAsDefaultInstance();
  RequestRemoveSign::default_instance_->InitAsDefaultInstance();
  RequestRemoveSignResponse::default_instance_->InitAsDefaultInstance();
  RequestUpdateSign::default_instance_->InitAsDefaultInstance();
  RequestUpdateSignResponse::default_instance_->InitAsDefaultInstance();
  RequestRejectSign::default_instance_->InitAsDefaultInstance();
  RequestRejectSignResponse::default_instance_->InitAsDefaultInstance();
  RequestGetRightMatchingArea::default_instance_->InitAsDefaultInstance();
  RequestGetRightMatchingAreaResponse::default_instance_->InitAsDefaultInstance();
  RequestGetRightMatchingAreaResponse_Area_info::default_instance_->InitAsDefaultInstance();
  PushRequestRemoveSign::default_instance_->InitAsDefaultInstance();
  PushRequestSummonSign::default_instance_->InitAsDefaultInstance();
  PushRequestRejectSign::default_instance_->InitAsDefaultInstance();
  BreakInTargetData::default_instance_->InitAsDefaultInstance();
  RequestGetBreakInTargetList::default_instance_->InitAsDefaultInstance();
  RequestGetBreakInTargetListResponse::default_instance_->InitAsDefaultInstance();
  PushRequestAllowBreakInTarget::default_instance_->InitAsDefaultInstance();
  PushRequestBreakInTarget::default_instance_->InitAsDefaultInstance();
  PushRequestRemoveBreakInTarget::default_instance_->InitAsDefaultInstance();
  RequestBreakInTarget::default_instance_->InitAsDefaultInstance();
  RequestRejectBreakInTarget::default_instance_->InitAsDefaultInstance();
  PushRequestRejectBreakInTarget::default_instance_->InitAsDefaultInstance();
  RequestBreakInTargetResponse::default_instance_->InitAsDefaultInstance();
  RequestRejectBreakInTargetResponse::default_instance_->InitAsDefaultInstance();
  RequestGetGhostDataList::default_instance_->InitAsDefaultInstance();
  GhostData::default_instance_->InitAsDefaultInstance();
  RequestCreateGhostData::default_instance_->InitAsDefaultInstance();
  RequestCreateGhostDataResponse::default_instance_->InitAsDefaultInstance();
  RequestGetGhostDataListResponse::default_instance_->InitAsDefaultInstance();
  RequestGetVisitorList::default_instance_->InitAsDefaultInstance();
  VisitorData::default_instance_->InitAsDefaultInstance();
  RequestGetVisitorListResponse::default_instance_->InitAsDefaultInstance();
  PushRequestRemoveVisitor::default_instance_->InitAsDefaultInstance();
  RequestVisit::default_instance_->InitAsDefaultInstance();
  PushRequestVisit::default_instance_->InitAsDefaultInstance();
  RequestRejectVisit::default_instance_->InitAsDefaultInstance();
  PushRequestRejectVisit::default_instance_->InitAsDefaultInstance();
  RequestVisitResponse::default_instance_->InitAsDefaultInstance();
  RequestRejectVisitResponse::default_instance_->InitAsDefaultInstance();
  RequestNotifyRingBell::default_instance_->InitAsDefaultInstance();
  RequestNotifyRingBellResponse::default_instance_->InitAsDefaultInstance();
  PushRequestNotifyRingBell::default_instance_->InitAsDefaultInstance();
  RequestGetRegulationFile::default_instance_->InitAsDefaultInstance();
  RequestGetRegulationFileResponse::default_instance_->InitAsDefaultInstance();
  RegulationFileMessage::default_instance_->InitAsDefaultInstance();
  RegulationFileDiffData::default_instance_->InitAsDefaultInstance();
  RegulationFileUpdateMessage::default_instance_->InitAsDefaultInstance();
  RegulationFileUpdatePushMessage::default_instance_->InitAsDefaultInstance();
  RequestBenchmarkThroughput::default_instance_->InitAsDefaultInstance();
  RequestBenchmarkThroughputResponse::default_instance_->InitAsDefaultInstance();
  RequestGetLoginPlayerCharacter::default_instance_->InitAsDefaultInstance();
  RequestGetLoginPlayerCharacterResponse::default_instance_->InitAsDefaultInstance();
  RequestGetPlayerCharacterList::default_instance_->InitAsDefaultInstance();
  RequestGetPlayerCharacterListResponse::default_instance_->InitAsDefaultInstance();
  RequestMeasureUploadBandwidth::default_instance_->InitAsDefaultInstance();
  RequestMeasureUploadBandwidthResponse::default_instance_->InitAsDefaultInstance();
  RequestMeasureDownloadBandwidth::default_instance_->InitAsDefaultInstance();
  RequestMeasureDownloadBandwidthResponse::default_instance_->InitAsDefaultInstance();
  RequestSendMessageToPlayers::default_instance_->InitAsDefaultInstance();
  RequestSendMessageToPlayersResponse::default_instance_->InitAsDefaultInstance();
  RequestSendMessageToSelectLanguagePlayers::default_instance_->InitAsDefaultInstance();
  RequestSendMessageToSelectLanguagePlayersResponse::default_instance_->InitAsDefaultInstance();
  RequestSendMessageToAllPlayers::default_instance_->InitAsDefaultInstance();
  RequestSendMessageToAllPlayersResponse::default_instance_->InitAsDefaultInstance();
  RequestSendPlayerList::default_instance_->InitAsDefaultInstance();
  RankingData::default_instance_->InitAsDefaultInstance();
  RankingRotationID::default_instance_->InitAsDefaultInstance();
  RankingRecordCount::default_instance_->InitAsDefaultInstance();
  RankingDataPack::default_instance_->InitAsDefaultInstance();
  RequestRegisterRankingData::default_instance_->InitAsDefaultInstance();
  RequestRegisterRankingDataResponse::default_instance_->InitAsDefaultInstance();
  RequestGetRankingData::default_instance_->InitAsDefaultInstance();
  RequestGetRankingDataResponse::default_instance_->InitAsDefaultInstance();
  RequestGetCharacterRankingData::default_instance_->InitAsDefaultInstance();
  RequestGetCharacterRankingDataResponse::default_instance_->InitAsDefaultInstance();
  RequestCountRankingData::default_instance_->InitAsDefaultInstance();
  RequestCountRankingDataResponse::default_instance_->InitAsDefaultInstance();
  RequestGetCurrentRank::default_instance_->InitAsDefaultInstance();
  RequestGetCurrentRankResponse::default_instance_->InitAsDefaultInstance();
  QuickMatchRank::default_instance_->InitAsDefaultInstance();
  QuickMatchRankCache::default_instance_->InitAsDefaultInstance();
  QuickMatchSession::default_instance_->InitAsDefaultInstance();
  QuickMatchSession_Result_list::default_instance_->InitAsDefaultInstance();
  QuickMatchApologyPoint::default_instance_->InitAsDefaultInstance();
  QuickMatchData::default_instance_->InitAsDefaultInstance();
  QuickMatchSearchResult::default_instance_->InitAsDefaultInstance();
  AcceptQuickMatchMessage::default_instance_->InitAsDefaultInstance();
  RejectQuickMatchMessage::default_instance_->InitAsDefaultInstance();
  RemoveQuickMatchMessage::default_instance_->InitAsDefaultInstance();
  JoinQuickMatchMessage::default_instance_->InitAsDefaultInstance();
  PushRequestJoinQuickMatch::default_instance_->InitAsDefaultInstance();
  PushRequestAcceptQuickMatch::default_instance_->InitAsDefaultInstance();
  PushRequestRejectQuickMatch::default_instance_->InitAsDefaultInstance();
  RequestSearchQuickMatch::default_instance_->InitAsDefaultInstance();
  RequestSearchQuickMatch_Map_id_list::default_instance_->InitAsDefaultInstance();
  RequestSearchQuickMatchResponse::default_instance_->InitAsDefaultInstance();
  RequestRegisterQuickMatch::default_instance_->InitAsDefaultInstance();
  RequestUnregisterQuickMatch::default_instance_->InitAsDefaultInstance();
  RequestRegisterQuickMatchResponse::default_instance_->InitAsDefaultInstance();
  RequestUnregisterQuickMatchResponse::default_instance_->InitAsDefaultInstance();
  RequestUpdateQuickMatch::default_instance_->InitAsDefaultInstance();
  RequestUpdateQuickMatchResponse::default_instance_->InitAsDefaultInstance();
  RequestJoinQuickMatch::default_instance_->InitAsDefaultInstance();
  RequestJoinQuickMatchResponse::default_instance_->InitAsDefaultInstance();
  RequestAcceptQuickMatch::default_instance_->InitAsDefaultInstance();
  RequestAcceptQuickMatchResponse::default_instance_->InitAsDefaultInstance();
  RequestRejectQuickMatch::default_instance_->InitAsDefaultInstance();
  RequestRejectQuickMatchResponse::default_instance_->InitAsDefaultInstance();
  RequestSendQuickMatchStart::default_instance_->InitAsDefaultInstance();
  RequestSendQuickMatchStart_Session_member_list::default_instance_->InitAsDefaultInstance();
  RequestSendQuickMatchStartResponse::default_instance_->InitAsDefaultInstance();
  RequestSendQuickMatchResult::default_instance_->InitAsDefaultInstance();
  RequestSendQuickMatchResultResponse::default_instance_->InitAsDefaultInstance();
  RequestPushSendQuickMatchStart::default_instance_->InitAsDefaultInstance();
  RitualMarkData::default_instance_->InitAsDefaultInstance();
  LocatedRitualMark::default_instance_->InitAsDefaultInstance();
  RitualMarkDomainLimit::default_instance_->InitAsDefaultInstance();
  RequestCreateMark::default_instance_->InitAsDefaultInstance();
  RequestCreateMarkResponse::default_instance_->InitAsDefaultInstance();
  RequestRemoveMark::default_instance_->InitAsDefaultInstance();
  RequestRemoveMarkResponse::default_instance_->InitAsDefaultInstance();
  RequestReentryMark::default_instance_->InitAsDefaultInstance();
  RequestReentryMarkResponse::default_instance_->InitAsDefaultInstance();
  RequestGetMarkList::default_instance_->InitAsDefaultInstance();
  RequestGetMarkListResponse::default_instance_->InitAsDefaultInstance();
  PushRequestHeader::default_instance_->InitAsDefaultInstance();
  RangedLimit::default_instance_->InitAsDefaultInstance();
  PlayerUserIDPair::default_instance_->InitAsDefaultInstance();
  ManagementTextMessage::default_instance_->InitAsDefaultInstance();
  NRLogUploadRequest::default_instance_->InitAsDefaultInstance();
  NRLoggingMessage::default_instance_->InitAsDefaultInstance();
  ServerPing::default_instance_->InitAsDefaultInstance();
  RequestGetOnlineShopItemList::default_instance_->InitAsDefaultInstance();
  RequestGetOnlineShopItemListResponse::default_instance_->InitAsDefaultInstance();
  RequestGetOnlineShopItemListResponse_Lineup::default_instance_->InitAsDefaultInstance();
  LoginForXboxOne::default_instance_->InitAsDefaultInstance();
  SocketOptionSetting::default_instance_->InitAsDefaultInstance();
  GetConnectGameServerPortIdResponse::default_instance_->InitAsDefaultInstance();
  NotifyLoginToPushServer::default_instance_->InitAsDefaultInstance();
  NotifyLogoutToPushServer::default_instance_->InitAsDefaultInstance();
  UserLoginInfo::default_instance_->InitAsDefaultInstance();
  UserLogout::default_instance_->InitAsDefaultInstance();
  LoginClientInfo::default_instance_->InitAsDefaultInstance();
  NotifyClientServerInfoToPushServer::default_instance_->InitAsDefaultInstance();
  PushLoginUserInfo::default_instance_->InitAsDefaultInstance();
  RequestCheckLogin::default_instance_->InitAsDefaultInstance();
  RequestCheckLoginResponse::default_instance_->InitAsDefaultInstance();
  RequestGetPlayerConnectGameServer::default_instance_->InitAsDefaultInstance();
  PlayerConnectServerInfo::default_instance_->InitAsDefaultInstance();
  RequestGetPlayerConnectGameServerResponse::default_instance_->InitAsDefaultInstance();
  RequestGetServerConnectTime::default_instance_->InitAsDefaultInstance();
  RequestGetServerConnectTimeResponse::default_instance_->InitAsDefaultInstance();
  RequestGetConnectionCount::default_instance_->InitAsDefaultInstance();
  RequestGetConnectionCountResponse::default_instance_->InitAsDefaultInstance();
  RequestDisconnectUser::default_instance_->InitAsDefaultInstance();
  RequestDisconnectAllUser::default_instance_->InitAsDefaultInstance();
  RequestSendMessageToPushClient::default_instance_->InitAsDefaultInstance();
  RequestGetServerSidePlayerStatus::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_DS3_5fFrpg2RequestMessage_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_once_);
void protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_once_,
                 &protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_DS3_5fFrpg2RequestMessage_2eproto {
  StaticDescriptorInitializer_DS3_5fFrpg2RequestMessage_2eproto() {
    protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
  }
} static_descriptor_initializer_DS3_5fFrpg2RequestMessage_2eproto_;
#endif
bool PushMessageId_IsValid(int value) {
  switch(value) {
    case 829:
    case 830:
    case 831:
    case 832:
    case 833:
    case 834:
    case 905:
    case 907:
    case 908:
    case 918:
    case 933:
    case 934:
    case 935:
    case 951:
    case 952:
    case 953:
    case 969:
      return true;
    default:
      return false;
  }
}

bool LogType_IsValid(int value) {
  switch(value) {
    case 2020:
    case 2021:
    case 3000:
    case 3001:
    case 3002:
    case 3003:
    case 3004:
    case 3005:
    case 3010:
    case 5001:
    case 7040:
    case 7050:
    case 7060:
    case 8001:
      return true;
    default:
      return false;
  }
}

bool CauseOfDeath_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

bool Covenant_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
      return true;
    default:
      return false;
  }
}

bool SignType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

bool VisitorPool_IsValid(int value) {
  switch(value) {
    case -1:
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

bool QuickMatchGameMode_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

bool QuickMatchResult_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

EmptyResponse::EmptyResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.EmptyResponse)
}

void EmptyResponse::InitAsDefaultInstance() {
}

EmptyResponse::EmptyResponse(const EmptyResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.EmptyResponse)
}

void EmptyResponse::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EmptyResponse::~EmptyResponse() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.EmptyResponse)
  SharedDtor();
}

void EmptyResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void EmptyResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const EmptyResponse& EmptyResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

EmptyResponse* EmptyResponse::default_instance_ = NULL;

EmptyResponse* EmptyResponse::New() const {
  return new EmptyResponse;
}

void EmptyResponse::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool EmptyResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.EmptyResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.EmptyResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.EmptyResponse)
  return false;
#undef DO_
}

void EmptyResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.EmptyResponse)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.EmptyResponse)
}

int EmptyResponse::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EmptyResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const EmptyResponse*>(&from));
}

void EmptyResponse::MergeFrom(const EmptyResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void EmptyResponse::CopyFrom(const EmptyResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EmptyResponse::IsInitialized() const {

  return true;
}

void EmptyResponse::Swap(EmptyResponse* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string EmptyResponse::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.EmptyResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestWaitForUserLogin::kSteamIdFieldNumber;
const int RequestWaitForUserLogin::kUnknown1FieldNumber;
const int RequestWaitForUserLogin::kUnknown2FieldNumber;
const int RequestWaitForUserLogin::kUnknown3FieldNumber;
const int RequestWaitForUserLogin::kUnknown4FieldNumber;
#endif  // !_MSC_VER

RequestWaitForUserLogin::RequestWaitForUserLogin()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestWaitForUserLogin)
}

void RequestWaitForUserLogin::InitAsDefaultInstance() {
}

RequestWaitForUserLogin::RequestWaitForUserLogin(const RequestWaitForUserLogin& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestWaitForUserLogin)
}

void RequestWaitForUserLogin::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  steam_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  unknown_1_ = 0u;
  unknown_2_ = 0u;
  unknown_3_ = 0u;
  unknown_4_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestWaitForUserLogin::~RequestWaitForUserLogin() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestWaitForUserLogin)
  SharedDtor();
}

void RequestWaitForUserLogin::SharedDtor() {
  if (steam_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete steam_id_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestWaitForUserLogin::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestWaitForUserLogin& RequestWaitForUserLogin::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestWaitForUserLogin* RequestWaitForUserLogin::default_instance_ = NULL;

RequestWaitForUserLogin* RequestWaitForUserLogin::New() const {
  return new RequestWaitForUserLogin;
}

void RequestWaitForUserLogin::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<RequestWaitForUserLogin*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 31) {
    ZR_(unknown_1_, unknown_4_);
    if (has_steam_id()) {
      if (steam_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        steam_id_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestWaitForUserLogin::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestWaitForUserLogin)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string steam_id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_steam_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_unknown_1;
        break;
      }

      // required uint32 unknown_1 = 2;
      case 2: {
        if (tag == 16) {
         parse_unknown_1:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_1_)));
          set_has_unknown_1();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_unknown_2;
        break;
      }

      // required uint32 unknown_2 = 3;
      case 3: {
        if (tag == 24) {
         parse_unknown_2:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_2_)));
          set_has_unknown_2();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_unknown_3;
        break;
      }

      // required uint32 unknown_3 = 4;
      case 4: {
        if (tag == 32) {
         parse_unknown_3:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_3_)));
          set_has_unknown_3();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_unknown_4;
        break;
      }

      // required uint32 unknown_4 = 5;
      case 5: {
        if (tag == 40) {
         parse_unknown_4:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_4_)));
          set_has_unknown_4();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestWaitForUserLogin)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestWaitForUserLogin)
  return false;
#undef DO_
}

void RequestWaitForUserLogin::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestWaitForUserLogin)
  // required string steam_id = 1;
  if (has_steam_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->steam_id(), output);
  }

  // required uint32 unknown_1 = 2;
  if (has_unknown_1()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->unknown_1(), output);
  }

  // required uint32 unknown_2 = 3;
  if (has_unknown_2()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->unknown_2(), output);
  }

  // required uint32 unknown_3 = 4;
  if (has_unknown_3()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->unknown_3(), output);
  }

  // required uint32 unknown_4 = 5;
  if (has_unknown_4()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->unknown_4(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestWaitForUserLogin)
}

int RequestWaitForUserLogin::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string steam_id = 1;
    if (has_steam_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->steam_id());
    }

    // required uint32 unknown_1 = 2;
    if (has_unknown_1()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_1());
    }

    // required uint32 unknown_2 = 3;
    if (has_unknown_2()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_2());
    }

    // required uint32 unknown_3 = 4;
    if (has_unknown_3()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_3());
    }

    // required uint32 unknown_4 = 5;
    if (has_unknown_4()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_4());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestWaitForUserLogin::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestWaitForUserLogin*>(&from));
}

void RequestWaitForUserLogin::MergeFrom(const RequestWaitForUserLogin& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_steam_id()) {
      set_steam_id(from.steam_id());
    }
    if (from.has_unknown_1()) {
      set_unknown_1(from.unknown_1());
    }
    if (from.has_unknown_2()) {
      set_unknown_2(from.unknown_2());
    }
    if (from.has_unknown_3()) {
      set_unknown_3(from.unknown_3());
    }
    if (from.has_unknown_4()) {
      set_unknown_4(from.unknown_4());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestWaitForUserLogin::CopyFrom(const RequestWaitForUserLogin& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestWaitForUserLogin::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;

  return true;
}

void RequestWaitForUserLogin::Swap(RequestWaitForUserLogin* other) {
  if (other != this) {
    std::swap(steam_id_, other->steam_id_);
    std::swap(unknown_1_, other->unknown_1_);
    std::swap(unknown_2_, other->unknown_2_);
    std::swap(unknown_3_, other->unknown_3_);
    std::swap(unknown_4_, other->unknown_4_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestWaitForUserLogin::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestWaitForUserLogin";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestWaitForUserLoginResponse::kSteamIdFieldNumber;
const int RequestWaitForUserLoginResponse::kPlayerIdFieldNumber;
#endif  // !_MSC_VER

RequestWaitForUserLoginResponse::RequestWaitForUserLoginResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestWaitForUserLoginResponse)
}

void RequestWaitForUserLoginResponse::InitAsDefaultInstance() {
}

RequestWaitForUserLoginResponse::RequestWaitForUserLoginResponse(const RequestWaitForUserLoginResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestWaitForUserLoginResponse)
}

void RequestWaitForUserLoginResponse::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  steam_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  player_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestWaitForUserLoginResponse::~RequestWaitForUserLoginResponse() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestWaitForUserLoginResponse)
  SharedDtor();
}

void RequestWaitForUserLoginResponse::SharedDtor() {
  if (steam_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete steam_id_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestWaitForUserLoginResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestWaitForUserLoginResponse& RequestWaitForUserLoginResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestWaitForUserLoginResponse* RequestWaitForUserLoginResponse::default_instance_ = NULL;

RequestWaitForUserLoginResponse* RequestWaitForUserLoginResponse::New() const {
  return new RequestWaitForUserLoginResponse;
}

void RequestWaitForUserLoginResponse::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_steam_id()) {
      if (steam_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        steam_id_->clear();
      }
    }
    player_id_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestWaitForUserLoginResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestWaitForUserLoginResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string steam_id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_steam_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_player_id;
        break;
      }

      // required uint32 player_id = 2;
      case 2: {
        if (tag == 16) {
         parse_player_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &player_id_)));
          set_has_player_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestWaitForUserLoginResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestWaitForUserLoginResponse)
  return false;
#undef DO_
}

void RequestWaitForUserLoginResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestWaitForUserLoginResponse)
  // required string steam_id = 1;
  if (has_steam_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->steam_id(), output);
  }

  // required uint32 player_id = 2;
  if (has_player_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->player_id(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestWaitForUserLoginResponse)
}

int RequestWaitForUserLoginResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string steam_id = 1;
    if (has_steam_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->steam_id());
    }

    // required uint32 player_id = 2;
    if (has_player_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->player_id());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestWaitForUserLoginResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestWaitForUserLoginResponse*>(&from));
}

void RequestWaitForUserLoginResponse::MergeFrom(const RequestWaitForUserLoginResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_steam_id()) {
      set_steam_id(from.steam_id());
    }
    if (from.has_player_id()) {
      set_player_id(from.player_id());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestWaitForUserLoginResponse::CopyFrom(const RequestWaitForUserLoginResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestWaitForUserLoginResponse::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void RequestWaitForUserLoginResponse::Swap(RequestWaitForUserLoginResponse* other) {
  if (other != this) {
    std::swap(steam_id_, other->steam_id_);
    std::swap(player_id_, other->player_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestWaitForUserLoginResponse::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestWaitForUserLoginResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int PlayerStatusUploadConfig::kPlayerDataMaskFieldNumber;
const int PlayerStatusUploadConfig::kUploadIntervalFieldNumber;
#endif  // !_MSC_VER

PlayerStatusUploadConfig::PlayerStatusUploadConfig()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.PlayerStatusUploadConfig)
}

void PlayerStatusUploadConfig::InitAsDefaultInstance() {
}

PlayerStatusUploadConfig::PlayerStatusUploadConfig(const PlayerStatusUploadConfig& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.PlayerStatusUploadConfig)
}

void PlayerStatusUploadConfig::SharedCtor() {
  _cached_size_ = 0;
  upload_interval_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PlayerStatusUploadConfig::~PlayerStatusUploadConfig() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.PlayerStatusUploadConfig)
  SharedDtor();
}

void PlayerStatusUploadConfig::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void PlayerStatusUploadConfig::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PlayerStatusUploadConfig& PlayerStatusUploadConfig::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

PlayerStatusUploadConfig* PlayerStatusUploadConfig::default_instance_ = NULL;

PlayerStatusUploadConfig* PlayerStatusUploadConfig::New() const {
  return new PlayerStatusUploadConfig;
}

void PlayerStatusUploadConfig::Clear() {
  upload_interval_ = 0u;
  player_data_mask_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool PlayerStatusUploadConfig::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.PlayerStatusUploadConfig)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 player_data_mask = 1;
      case 1: {
        if (tag == 8) {
         parse_player_data_mask:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 8, input, this->mutable_player_data_mask())));
        } else if (tag == 10) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_player_data_mask())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(8)) goto parse_player_data_mask;
        if (input->ExpectTag(16)) goto parse_upload_interval;
        break;
      }

      // required uint32 upload_interval = 2;
      case 2: {
        if (tag == 16) {
         parse_upload_interval:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &upload_interval_)));
          set_has_upload_interval();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.PlayerStatusUploadConfig)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.PlayerStatusUploadConfig)
  return false;
#undef DO_
}

void PlayerStatusUploadConfig::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.PlayerStatusUploadConfig)
  // repeated uint32 player_data_mask = 1;
  for (int i = 0; i < this->player_data_mask_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      1, this->player_data_mask(i), output);
  }

  // required uint32 upload_interval = 2;
  if (has_upload_interval()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->upload_interval(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.PlayerStatusUploadConfig)
}

int PlayerStatusUploadConfig::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // required uint32 upload_interval = 2;
    if (has_upload_interval()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->upload_interval());
    }

  }
  // repeated uint32 player_data_mask = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->player_data_mask_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->player_data_mask(i));
    }
    total_size += 1 * this->player_data_mask_size() + data_size;
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PlayerStatusUploadConfig::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PlayerStatusUploadConfig*>(&from));
}

void PlayerStatusUploadConfig::MergeFrom(const PlayerStatusUploadConfig& from) {
  GOOGLE_CHECK_NE(&from, this);
  player_data_mask_.MergeFrom(from.player_data_mask_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_upload_interval()) {
      set_upload_interval(from.upload_interval());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void PlayerStatusUploadConfig::CopyFrom(const PlayerStatusUploadConfig& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlayerStatusUploadConfig::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;

  return true;
}

void PlayerStatusUploadConfig::Swap(PlayerStatusUploadConfig* other) {
  if (other != this) {
    player_data_mask_.Swap(&other->player_data_mask_);
    std::swap(upload_interval_, other->upload_interval_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PlayerStatusUploadConfig::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.PlayerStatusUploadConfig";
}


// ===================================================================

#ifndef _MSC_VER
const int AnnounceMessageData::kUnknown1FieldNumber;
const int AnnounceMessageData::kIndexFieldNumber;
const int AnnounceMessageData::kUnknown2FieldNumber;
const int AnnounceMessageData::kHeaderFieldNumber;
const int AnnounceMessageData::kMessageFieldNumber;
const int AnnounceMessageData::kDatetimeFieldNumber;
#endif  // !_MSC_VER

AnnounceMessageData::AnnounceMessageData()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.AnnounceMessageData)
}

void AnnounceMessageData::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  datetime_ = const_cast< ::DS3_Frpg2PlayerData::DateTime*>(
      ::DS3_Frpg2PlayerData::DateTime::internal_default_instance());
#else
  datetime_ = const_cast< ::DS3_Frpg2PlayerData::DateTime*>(&::DS3_Frpg2PlayerData::DateTime::default_instance());
#endif
}

AnnounceMessageData::AnnounceMessageData(const AnnounceMessageData& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.AnnounceMessageData)
}

void AnnounceMessageData::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  unknown_1_ = 0u;
  index_ = 0u;
  unknown_2_ = 0u;
  header_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  datetime_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AnnounceMessageData::~AnnounceMessageData() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.AnnounceMessageData)
  SharedDtor();
}

void AnnounceMessageData::SharedDtor() {
  if (header_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete header_;
  }
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete message_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete datetime_;
  }
}

void AnnounceMessageData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const AnnounceMessageData& AnnounceMessageData::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

AnnounceMessageData* AnnounceMessageData::default_instance_ = NULL;

AnnounceMessageData* AnnounceMessageData::New() const {
  return new AnnounceMessageData;
}

void AnnounceMessageData::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<AnnounceMessageData*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 63) {
    ZR_(unknown_1_, index_);
    unknown_2_ = 0u;
    if (has_header()) {
      if (header_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        header_->clear();
      }
    }
    if (has_message()) {
      if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        message_->clear();
      }
    }
    if (has_datetime()) {
      if (datetime_ != NULL) datetime_->::DS3_Frpg2PlayerData::DateTime::Clear();
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool AnnounceMessageData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.AnnounceMessageData)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 unknown_1 = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_1_)));
          set_has_unknown_1();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_index;
        break;
      }

      // required uint32 index = 2;
      case 2: {
        if (tag == 16) {
         parse_index:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &index_)));
          set_has_index();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_unknown_2;
        break;
      }

      // required uint32 unknown_2 = 3;
      case 3: {
        if (tag == 24) {
         parse_unknown_2:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_2_)));
          set_has_unknown_2();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_header;
        break;
      }

      // required string header = 4;
      case 4: {
        if (tag == 34) {
         parse_header:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_message;
        break;
      }

      // required string message = 5;
      case 5: {
        if (tag == 42) {
         parse_message:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_message()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_datetime;
        break;
      }

      // required .DS3_Frpg2PlayerData.DateTime datetime = 6;
      case 6: {
        if (tag == 50) {
         parse_datetime:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_datetime()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.AnnounceMessageData)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.AnnounceMessageData)
  return false;
#undef DO_
}

void AnnounceMessageData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.AnnounceMessageData)
  // required uint32 unknown_1 = 1;
  if (has_unknown_1()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->unknown_1(), output);
  }

  // required uint32 index = 2;
  if (has_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->index(), output);
  }

  // required uint32 unknown_2 = 3;
  if (has_unknown_2()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->unknown_2(), output);
  }

  // required string header = 4;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->header(), output);
  }

  // required string message = 5;
  if (has_message()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->message(), output);
  }

  // required .DS3_Frpg2PlayerData.DateTime datetime = 6;
  if (has_datetime()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, this->datetime(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.AnnounceMessageData)
}

int AnnounceMessageData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 unknown_1 = 1;
    if (has_unknown_1()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_1());
    }

    // required uint32 index = 2;
    if (has_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->index());
    }

    // required uint32 unknown_2 = 3;
    if (has_unknown_2()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_2());
    }

    // required string header = 4;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->header());
    }

    // required string message = 5;
    if (has_message()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->message());
    }

    // required .DS3_Frpg2PlayerData.DateTime datetime = 6;
    if (has_datetime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->datetime());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AnnounceMessageData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const AnnounceMessageData*>(&from));
}

void AnnounceMessageData::MergeFrom(const AnnounceMessageData& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_unknown_1()) {
      set_unknown_1(from.unknown_1());
    }
    if (from.has_index()) {
      set_index(from.index());
    }
    if (from.has_unknown_2()) {
      set_unknown_2(from.unknown_2());
    }
    if (from.has_header()) {
      set_header(from.header());
    }
    if (from.has_message()) {
      set_message(from.message());
    }
    if (from.has_datetime()) {
      mutable_datetime()->::DS3_Frpg2PlayerData::DateTime::MergeFrom(from.datetime());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void AnnounceMessageData::CopyFrom(const AnnounceMessageData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AnnounceMessageData::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003f) != 0x0000003f) return false;

  if (has_datetime()) {
    if (!this->datetime().IsInitialized()) return false;
  }
  return true;
}

void AnnounceMessageData::Swap(AnnounceMessageData* other) {
  if (other != this) {
    std::swap(unknown_1_, other->unknown_1_);
    std::swap(index_, other->index_);
    std::swap(unknown_2_, other->unknown_2_);
    std::swap(header_, other->header_);
    std::swap(message_, other->message_);
    std::swap(datetime_, other->datetime_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string AnnounceMessageData::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.AnnounceMessageData";
}


// ===================================================================

#ifndef _MSC_VER
const int AnnounceMessageDataList::kItemsFieldNumber;
#endif  // !_MSC_VER

AnnounceMessageDataList::AnnounceMessageDataList()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.AnnounceMessageDataList)
}

void AnnounceMessageDataList::InitAsDefaultInstance() {
}

AnnounceMessageDataList::AnnounceMessageDataList(const AnnounceMessageDataList& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.AnnounceMessageDataList)
}

void AnnounceMessageDataList::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AnnounceMessageDataList::~AnnounceMessageDataList() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.AnnounceMessageDataList)
  SharedDtor();
}

void AnnounceMessageDataList::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void AnnounceMessageDataList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const AnnounceMessageDataList& AnnounceMessageDataList::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

AnnounceMessageDataList* AnnounceMessageDataList::default_instance_ = NULL;

AnnounceMessageDataList* AnnounceMessageDataList::New() const {
  return new AnnounceMessageDataList;
}

void AnnounceMessageDataList::Clear() {
  items_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool AnnounceMessageDataList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.AnnounceMessageDataList)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .DS3_Frpg2RequestMessage.AnnounceMessageData items = 1;
      case 1: {
        if (tag == 10) {
         parse_items:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_items()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_items;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.AnnounceMessageDataList)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.AnnounceMessageDataList)
  return false;
#undef DO_
}

void AnnounceMessageDataList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.AnnounceMessageDataList)
  // repeated .DS3_Frpg2RequestMessage.AnnounceMessageData items = 1;
  for (int i = 0; i < this->items_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->items(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.AnnounceMessageDataList)
}

int AnnounceMessageDataList::ByteSize() const {
  int total_size = 0;

  // repeated .DS3_Frpg2RequestMessage.AnnounceMessageData items = 1;
  total_size += 1 * this->items_size();
  for (int i = 0; i < this->items_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->items(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AnnounceMessageDataList::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const AnnounceMessageDataList*>(&from));
}

void AnnounceMessageDataList::MergeFrom(const AnnounceMessageDataList& from) {
  GOOGLE_CHECK_NE(&from, this);
  items_.MergeFrom(from.items_);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void AnnounceMessageDataList::CopyFrom(const AnnounceMessageDataList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AnnounceMessageDataList::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->items())) return false;
  return true;
}

void AnnounceMessageDataList::Swap(AnnounceMessageDataList* other) {
  if (other != this) {
    items_.Swap(&other->items_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string AnnounceMessageDataList::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.AnnounceMessageDataList";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestGetAnnounceMessageList::kMaxEntriesFieldNumber;
#endif  // !_MSC_VER

RequestGetAnnounceMessageList::RequestGetAnnounceMessageList()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestGetAnnounceMessageList)
}

void RequestGetAnnounceMessageList::InitAsDefaultInstance() {
}

RequestGetAnnounceMessageList::RequestGetAnnounceMessageList(const RequestGetAnnounceMessageList& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestGetAnnounceMessageList)
}

void RequestGetAnnounceMessageList::SharedCtor() {
  _cached_size_ = 0;
  max_entries_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestGetAnnounceMessageList::~RequestGetAnnounceMessageList() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestGetAnnounceMessageList)
  SharedDtor();
}

void RequestGetAnnounceMessageList::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestGetAnnounceMessageList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestGetAnnounceMessageList& RequestGetAnnounceMessageList::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestGetAnnounceMessageList* RequestGetAnnounceMessageList::default_instance_ = NULL;

RequestGetAnnounceMessageList* RequestGetAnnounceMessageList::New() const {
  return new RequestGetAnnounceMessageList;
}

void RequestGetAnnounceMessageList::Clear() {
  max_entries_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestGetAnnounceMessageList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestGetAnnounceMessageList)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 max_entries = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &max_entries_)));
          set_has_max_entries();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestGetAnnounceMessageList)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestGetAnnounceMessageList)
  return false;
#undef DO_
}

void RequestGetAnnounceMessageList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestGetAnnounceMessageList)
  // required uint32 max_entries = 1;
  if (has_max_entries()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->max_entries(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestGetAnnounceMessageList)
}

int RequestGetAnnounceMessageList::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 max_entries = 1;
    if (has_max_entries()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->max_entries());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestGetAnnounceMessageList::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestGetAnnounceMessageList*>(&from));
}

void RequestGetAnnounceMessageList::MergeFrom(const RequestGetAnnounceMessageList& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_max_entries()) {
      set_max_entries(from.max_entries());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestGetAnnounceMessageList::CopyFrom(const RequestGetAnnounceMessageList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestGetAnnounceMessageList::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void RequestGetAnnounceMessageList::Swap(RequestGetAnnounceMessageList* other) {
  if (other != this) {
    std::swap(max_entries_, other->max_entries_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestGetAnnounceMessageList::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestGetAnnounceMessageList";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestGetAnnounceMessageListResponse::kChangesFieldNumber;
const int RequestGetAnnounceMessageListResponse::kNoticesFieldNumber;
#endif  // !_MSC_VER

RequestGetAnnounceMessageListResponse::RequestGetAnnounceMessageListResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestGetAnnounceMessageListResponse)
}

void RequestGetAnnounceMessageListResponse::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  changes_ = const_cast< ::DS3_Frpg2RequestMessage::AnnounceMessageDataList*>(
      ::DS3_Frpg2RequestMessage::AnnounceMessageDataList::internal_default_instance());
#else
  changes_ = const_cast< ::DS3_Frpg2RequestMessage::AnnounceMessageDataList*>(&::DS3_Frpg2RequestMessage::AnnounceMessageDataList::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  notices_ = const_cast< ::DS3_Frpg2RequestMessage::AnnounceMessageDataList*>(
      ::DS3_Frpg2RequestMessage::AnnounceMessageDataList::internal_default_instance());
#else
  notices_ = const_cast< ::DS3_Frpg2RequestMessage::AnnounceMessageDataList*>(&::DS3_Frpg2RequestMessage::AnnounceMessageDataList::default_instance());
#endif
}

RequestGetAnnounceMessageListResponse::RequestGetAnnounceMessageListResponse(const RequestGetAnnounceMessageListResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestGetAnnounceMessageListResponse)
}

void RequestGetAnnounceMessageListResponse::SharedCtor() {
  _cached_size_ = 0;
  changes_ = NULL;
  notices_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestGetAnnounceMessageListResponse::~RequestGetAnnounceMessageListResponse() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestGetAnnounceMessageListResponse)
  SharedDtor();
}

void RequestGetAnnounceMessageListResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete changes_;
    delete notices_;
  }
}

void RequestGetAnnounceMessageListResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestGetAnnounceMessageListResponse& RequestGetAnnounceMessageListResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestGetAnnounceMessageListResponse* RequestGetAnnounceMessageListResponse::default_instance_ = NULL;

RequestGetAnnounceMessageListResponse* RequestGetAnnounceMessageListResponse::New() const {
  return new RequestGetAnnounceMessageListResponse;
}

void RequestGetAnnounceMessageListResponse::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_changes()) {
      if (changes_ != NULL) changes_->::DS3_Frpg2RequestMessage::AnnounceMessageDataList::Clear();
    }
    if (has_notices()) {
      if (notices_ != NULL) notices_->::DS3_Frpg2RequestMessage::AnnounceMessageDataList::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestGetAnnounceMessageListResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestGetAnnounceMessageListResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .DS3_Frpg2RequestMessage.AnnounceMessageDataList changes = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_changes()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_notices;
        break;
      }

      // required .DS3_Frpg2RequestMessage.AnnounceMessageDataList notices = 2;
      case 2: {
        if (tag == 18) {
         parse_notices:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_notices()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestGetAnnounceMessageListResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestGetAnnounceMessageListResponse)
  return false;
#undef DO_
}

void RequestGetAnnounceMessageListResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestGetAnnounceMessageListResponse)
  // required .DS3_Frpg2RequestMessage.AnnounceMessageDataList changes = 1;
  if (has_changes()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->changes(), output);
  }

  // required .DS3_Frpg2RequestMessage.AnnounceMessageDataList notices = 2;
  if (has_notices()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->notices(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestGetAnnounceMessageListResponse)
}

int RequestGetAnnounceMessageListResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .DS3_Frpg2RequestMessage.AnnounceMessageDataList changes = 1;
    if (has_changes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->changes());
    }

    // required .DS3_Frpg2RequestMessage.AnnounceMessageDataList notices = 2;
    if (has_notices()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->notices());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestGetAnnounceMessageListResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestGetAnnounceMessageListResponse*>(&from));
}

void RequestGetAnnounceMessageListResponse::MergeFrom(const RequestGetAnnounceMessageListResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_changes()) {
      mutable_changes()->::DS3_Frpg2RequestMessage::AnnounceMessageDataList::MergeFrom(from.changes());
    }
    if (from.has_notices()) {
      mutable_notices()->::DS3_Frpg2RequestMessage::AnnounceMessageDataList::MergeFrom(from.notices());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestGetAnnounceMessageListResponse::CopyFrom(const RequestGetAnnounceMessageListResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestGetAnnounceMessageListResponse::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_changes()) {
    if (!this->changes().IsInitialized()) return false;
  }
  if (has_notices()) {
    if (!this->notices().IsInitialized()) return false;
  }
  return true;
}

void RequestGetAnnounceMessageListResponse::Swap(RequestGetAnnounceMessageListResponse* other) {
  if (other != this) {
    std::swap(changes_, other->changes_);
    std::swap(notices_, other->notices_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestGetAnnounceMessageListResponse::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestGetAnnounceMessageListResponse";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

PlayerCharacterData::PlayerCharacterData()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.PlayerCharacterData)
}

void PlayerCharacterData::InitAsDefaultInstance() {
}

PlayerCharacterData::PlayerCharacterData(const PlayerCharacterData& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.PlayerCharacterData)
}

void PlayerCharacterData::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PlayerCharacterData::~PlayerCharacterData() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.PlayerCharacterData)
  SharedDtor();
}

void PlayerCharacterData::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void PlayerCharacterData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PlayerCharacterData& PlayerCharacterData::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

PlayerCharacterData* PlayerCharacterData::default_instance_ = NULL;

PlayerCharacterData* PlayerCharacterData::New() const {
  return new PlayerCharacterData;
}

void PlayerCharacterData::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool PlayerCharacterData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.PlayerCharacterData)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.PlayerCharacterData)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.PlayerCharacterData)
  return false;
#undef DO_
}

void PlayerCharacterData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.PlayerCharacterData)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.PlayerCharacterData)
}

int PlayerCharacterData::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PlayerCharacterData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PlayerCharacterData*>(&from));
}

void PlayerCharacterData::MergeFrom(const PlayerCharacterData& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void PlayerCharacterData::CopyFrom(const PlayerCharacterData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlayerCharacterData::IsInitialized() const {

  return true;
}

void PlayerCharacterData::Swap(PlayerCharacterData* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PlayerCharacterData::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.PlayerCharacterData";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

PlayerCharacterID::PlayerCharacterID()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.PlayerCharacterID)
}

void PlayerCharacterID::InitAsDefaultInstance() {
}

PlayerCharacterID::PlayerCharacterID(const PlayerCharacterID& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.PlayerCharacterID)
}

void PlayerCharacterID::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PlayerCharacterID::~PlayerCharacterID() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.PlayerCharacterID)
  SharedDtor();
}

void PlayerCharacterID::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void PlayerCharacterID::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PlayerCharacterID& PlayerCharacterID::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

PlayerCharacterID* PlayerCharacterID::default_instance_ = NULL;

PlayerCharacterID* PlayerCharacterID::New() const {
  return new PlayerCharacterID;
}

void PlayerCharacterID::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool PlayerCharacterID::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.PlayerCharacterID)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.PlayerCharacterID)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.PlayerCharacterID)
  return false;
#undef DO_
}

void PlayerCharacterID::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.PlayerCharacterID)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.PlayerCharacterID)
}

int PlayerCharacterID::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PlayerCharacterID::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PlayerCharacterID*>(&from));
}

void PlayerCharacterID::MergeFrom(const PlayerCharacterID& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void PlayerCharacterID::CopyFrom(const PlayerCharacterID& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlayerCharacterID::IsInitialized() const {

  return true;
}

void PlayerCharacterID::Swap(PlayerCharacterID* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PlayerCharacterID::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.PlayerCharacterID";
}


// ===================================================================

#ifndef _MSC_VER
const int PlayerInfoUploadConfigPushMessage::kPushMessageIdFieldNumber;
const int PlayerInfoUploadConfigPushMessage::kConfigFieldNumber;
const int PlayerInfoUploadConfigPushMessage::kPlayerCharacterUpdateSendDelayFieldNumber;
const int PlayerInfoUploadConfigPushMessage::kPlayerStatusSendDelayFieldNumber;
#endif  // !_MSC_VER

PlayerInfoUploadConfigPushMessage::PlayerInfoUploadConfigPushMessage()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.PlayerInfoUploadConfigPushMessage)
}

void PlayerInfoUploadConfigPushMessage::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  config_ = const_cast< ::DS3_Frpg2RequestMessage::PlayerStatusUploadConfig*>(
      ::DS3_Frpg2RequestMessage::PlayerStatusUploadConfig::internal_default_instance());
#else
  config_ = const_cast< ::DS3_Frpg2RequestMessage::PlayerStatusUploadConfig*>(&::DS3_Frpg2RequestMessage::PlayerStatusUploadConfig::default_instance());
#endif
}

PlayerInfoUploadConfigPushMessage::PlayerInfoUploadConfigPushMessage(const PlayerInfoUploadConfigPushMessage& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.PlayerInfoUploadConfigPushMessage)
}

void PlayerInfoUploadConfigPushMessage::SharedCtor() {
  _cached_size_ = 0;
  push_message_id_ = 829;
  config_ = NULL;
  player_character_update_send_delay_ = 0u;
  player_status_send_delay_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PlayerInfoUploadConfigPushMessage::~PlayerInfoUploadConfigPushMessage() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.PlayerInfoUploadConfigPushMessage)
  SharedDtor();
}

void PlayerInfoUploadConfigPushMessage::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete config_;
  }
}

void PlayerInfoUploadConfigPushMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PlayerInfoUploadConfigPushMessage& PlayerInfoUploadConfigPushMessage::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

PlayerInfoUploadConfigPushMessage* PlayerInfoUploadConfigPushMessage::default_instance_ = NULL;

PlayerInfoUploadConfigPushMessage* PlayerInfoUploadConfigPushMessage::New() const {
  return new PlayerInfoUploadConfigPushMessage;
}

void PlayerInfoUploadConfigPushMessage::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<PlayerInfoUploadConfigPushMessage*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 15) {
    ZR_(player_character_update_send_delay_, player_status_send_delay_);
    push_message_id_ = 829;
    if (has_config()) {
      if (config_ != NULL) config_->::DS3_Frpg2RequestMessage::PlayerStatusUploadConfig::Clear();
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool PlayerInfoUploadConfigPushMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.PlayerInfoUploadConfigPushMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::DS3_Frpg2RequestMessage::PushMessageId_IsValid(value)) {
            set_push_message_id(static_cast< ::DS3_Frpg2RequestMessage::PushMessageId >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_config;
        break;
      }

      // required .DS3_Frpg2RequestMessage.PlayerStatusUploadConfig config = 2;
      case 2: {
        if (tag == 18) {
         parse_config:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_config()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_player_character_update_send_delay;
        break;
      }

      // required uint32 player_character_update_send_delay = 3;
      case 3: {
        if (tag == 24) {
         parse_player_character_update_send_delay:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &player_character_update_send_delay_)));
          set_has_player_character_update_send_delay();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_player_status_send_delay;
        break;
      }

      // required uint32 player_status_send_delay = 4;
      case 4: {
        if (tag == 32) {
         parse_player_status_send_delay:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &player_status_send_delay_)));
          set_has_player_status_send_delay();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.PlayerInfoUploadConfigPushMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.PlayerInfoUploadConfigPushMessage)
  return false;
#undef DO_
}

void PlayerInfoUploadConfigPushMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.PlayerInfoUploadConfigPushMessage)
  // required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
  if (has_push_message_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->push_message_id(), output);
  }

  // required .DS3_Frpg2RequestMessage.PlayerStatusUploadConfig config = 2;
  if (has_config()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->config(), output);
  }

  // required uint32 player_character_update_send_delay = 3;
  if (has_player_character_update_send_delay()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->player_character_update_send_delay(), output);
  }

  // required uint32 player_status_send_delay = 4;
  if (has_player_status_send_delay()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->player_status_send_delay(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.PlayerInfoUploadConfigPushMessage)
}

int PlayerInfoUploadConfigPushMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
    if (has_push_message_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->push_message_id());
    }

    // required .DS3_Frpg2RequestMessage.PlayerStatusUploadConfig config = 2;
    if (has_config()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->config());
    }

    // required uint32 player_character_update_send_delay = 3;
    if (has_player_character_update_send_delay()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->player_character_update_send_delay());
    }

    // required uint32 player_status_send_delay = 4;
    if (has_player_status_send_delay()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->player_status_send_delay());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PlayerInfoUploadConfigPushMessage::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PlayerInfoUploadConfigPushMessage*>(&from));
}

void PlayerInfoUploadConfigPushMessage::MergeFrom(const PlayerInfoUploadConfigPushMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_push_message_id()) {
      set_push_message_id(from.push_message_id());
    }
    if (from.has_config()) {
      mutable_config()->::DS3_Frpg2RequestMessage::PlayerStatusUploadConfig::MergeFrom(from.config());
    }
    if (from.has_player_character_update_send_delay()) {
      set_player_character_update_send_delay(from.player_character_update_send_delay());
    }
    if (from.has_player_status_send_delay()) {
      set_player_status_send_delay(from.player_status_send_delay());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void PlayerInfoUploadConfigPushMessage::CopyFrom(const PlayerInfoUploadConfigPushMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlayerInfoUploadConfigPushMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  if (has_config()) {
    if (!this->config().IsInitialized()) return false;
  }
  return true;
}

void PlayerInfoUploadConfigPushMessage::Swap(PlayerInfoUploadConfigPushMessage* other) {
  if (other != this) {
    std::swap(push_message_id_, other->push_message_id_);
    std::swap(config_, other->config_);
    std::swap(player_character_update_send_delay_, other->player_character_update_send_delay_);
    std::swap(player_status_send_delay_, other->player_status_send_delay_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PlayerInfoUploadConfigPushMessage::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.PlayerInfoUploadConfigPushMessage";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestUpdateLoginPlayerCharacter::kCharacterIdFieldNumber;
const int RequestUpdateLoginPlayerCharacter::kUnknown2FieldNumber;
#endif  // !_MSC_VER

RequestUpdateLoginPlayerCharacter::RequestUpdateLoginPlayerCharacter()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestUpdateLoginPlayerCharacter)
}

void RequestUpdateLoginPlayerCharacter::InitAsDefaultInstance() {
}

RequestUpdateLoginPlayerCharacter::RequestUpdateLoginPlayerCharacter(const RequestUpdateLoginPlayerCharacter& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestUpdateLoginPlayerCharacter)
}

void RequestUpdateLoginPlayerCharacter::SharedCtor() {
  _cached_size_ = 0;
  character_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestUpdateLoginPlayerCharacter::~RequestUpdateLoginPlayerCharacter() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestUpdateLoginPlayerCharacter)
  SharedDtor();
}

void RequestUpdateLoginPlayerCharacter::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestUpdateLoginPlayerCharacter::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestUpdateLoginPlayerCharacter& RequestUpdateLoginPlayerCharacter::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestUpdateLoginPlayerCharacter* RequestUpdateLoginPlayerCharacter::default_instance_ = NULL;

RequestUpdateLoginPlayerCharacter* RequestUpdateLoginPlayerCharacter::New() const {
  return new RequestUpdateLoginPlayerCharacter;
}

void RequestUpdateLoginPlayerCharacter::Clear() {
  character_id_ = 0u;
  unknown_2_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestUpdateLoginPlayerCharacter::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestUpdateLoginPlayerCharacter)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 character_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &character_id_)));
          set_has_character_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_unknown_2;
        break;
      }

      // repeated uint32 unknown_2 = 2;
      case 2: {
        if (tag == 16) {
         parse_unknown_2:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 16, input, this->mutable_unknown_2())));
        } else if (tag == 18) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_unknown_2())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_unknown_2;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestUpdateLoginPlayerCharacter)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestUpdateLoginPlayerCharacter)
  return false;
#undef DO_
}

void RequestUpdateLoginPlayerCharacter::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestUpdateLoginPlayerCharacter)
  // required uint32 character_id = 1;
  if (has_character_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->character_id(), output);
  }

  // repeated uint32 unknown_2 = 2;
  for (int i = 0; i < this->unknown_2_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      2, this->unknown_2(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestUpdateLoginPlayerCharacter)
}

int RequestUpdateLoginPlayerCharacter::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 character_id = 1;
    if (has_character_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->character_id());
    }

  }
  // repeated uint32 unknown_2 = 2;
  {
    int data_size = 0;
    for (int i = 0; i < this->unknown_2_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->unknown_2(i));
    }
    total_size += 1 * this->unknown_2_size() + data_size;
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestUpdateLoginPlayerCharacter::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestUpdateLoginPlayerCharacter*>(&from));
}

void RequestUpdateLoginPlayerCharacter::MergeFrom(const RequestUpdateLoginPlayerCharacter& from) {
  GOOGLE_CHECK_NE(&from, this);
  unknown_2_.MergeFrom(from.unknown_2_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_character_id()) {
      set_character_id(from.character_id());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestUpdateLoginPlayerCharacter::CopyFrom(const RequestUpdateLoginPlayerCharacter& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestUpdateLoginPlayerCharacter::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void RequestUpdateLoginPlayerCharacter::Swap(RequestUpdateLoginPlayerCharacter* other) {
  if (other != this) {
    std::swap(character_id_, other->character_id_);
    unknown_2_.Swap(&other->unknown_2_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestUpdateLoginPlayerCharacter::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestUpdateLoginPlayerCharacter";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestUpdateLoginPlayerCharacterResponse::kCharacterIdFieldNumber;
const int RequestUpdateLoginPlayerCharacterResponse::kQuickmatchBrawlRankFieldNumber;
const int RequestUpdateLoginPlayerCharacterResponse::kQuickmatchDualRankFieldNumber;
#endif  // !_MSC_VER

RequestUpdateLoginPlayerCharacterResponse::RequestUpdateLoginPlayerCharacterResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestUpdateLoginPlayerCharacterResponse)
}

void RequestUpdateLoginPlayerCharacterResponse::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  quickmatch_brawl_rank_ = const_cast< ::DS3_Frpg2RequestMessage::QuickMatchRank*>(
      ::DS3_Frpg2RequestMessage::QuickMatchRank::internal_default_instance());
#else
  quickmatch_brawl_rank_ = const_cast< ::DS3_Frpg2RequestMessage::QuickMatchRank*>(&::DS3_Frpg2RequestMessage::QuickMatchRank::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  quickmatch_dual_rank_ = const_cast< ::DS3_Frpg2RequestMessage::QuickMatchRank*>(
      ::DS3_Frpg2RequestMessage::QuickMatchRank::internal_default_instance());
#else
  quickmatch_dual_rank_ = const_cast< ::DS3_Frpg2RequestMessage::QuickMatchRank*>(&::DS3_Frpg2RequestMessage::QuickMatchRank::default_instance());
#endif
}

RequestUpdateLoginPlayerCharacterResponse::RequestUpdateLoginPlayerCharacterResponse(const RequestUpdateLoginPlayerCharacterResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestUpdateLoginPlayerCharacterResponse)
}

void RequestUpdateLoginPlayerCharacterResponse::SharedCtor() {
  _cached_size_ = 0;
  character_id_ = 0u;
  quickmatch_brawl_rank_ = NULL;
  quickmatch_dual_rank_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestUpdateLoginPlayerCharacterResponse::~RequestUpdateLoginPlayerCharacterResponse() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestUpdateLoginPlayerCharacterResponse)
  SharedDtor();
}

void RequestUpdateLoginPlayerCharacterResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete quickmatch_brawl_rank_;
    delete quickmatch_dual_rank_;
  }
}

void RequestUpdateLoginPlayerCharacterResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestUpdateLoginPlayerCharacterResponse& RequestUpdateLoginPlayerCharacterResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestUpdateLoginPlayerCharacterResponse* RequestUpdateLoginPlayerCharacterResponse::default_instance_ = NULL;

RequestUpdateLoginPlayerCharacterResponse* RequestUpdateLoginPlayerCharacterResponse::New() const {
  return new RequestUpdateLoginPlayerCharacterResponse;
}

void RequestUpdateLoginPlayerCharacterResponse::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    character_id_ = 0u;
    if (has_quickmatch_brawl_rank()) {
      if (quickmatch_brawl_rank_ != NULL) quickmatch_brawl_rank_->::DS3_Frpg2RequestMessage::QuickMatchRank::Clear();
    }
    if (has_quickmatch_dual_rank()) {
      if (quickmatch_dual_rank_ != NULL) quickmatch_dual_rank_->::DS3_Frpg2RequestMessage::QuickMatchRank::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestUpdateLoginPlayerCharacterResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestUpdateLoginPlayerCharacterResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 character_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &character_id_)));
          set_has_character_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_quickmatch_brawl_rank;
        break;
      }

      // required .DS3_Frpg2RequestMessage.QuickMatchRank quickmatch_brawl_rank = 2;
      case 2: {
        if (tag == 18) {
         parse_quickmatch_brawl_rank:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_quickmatch_brawl_rank()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_quickmatch_dual_rank;
        break;
      }

      // required .DS3_Frpg2RequestMessage.QuickMatchRank quickmatch_dual_rank = 3;
      case 3: {
        if (tag == 26) {
         parse_quickmatch_dual_rank:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_quickmatch_dual_rank()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestUpdateLoginPlayerCharacterResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestUpdateLoginPlayerCharacterResponse)
  return false;
#undef DO_
}

void RequestUpdateLoginPlayerCharacterResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestUpdateLoginPlayerCharacterResponse)
  // required uint32 character_id = 1;
  if (has_character_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->character_id(), output);
  }

  // required .DS3_Frpg2RequestMessage.QuickMatchRank quickmatch_brawl_rank = 2;
  if (has_quickmatch_brawl_rank()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->quickmatch_brawl_rank(), output);
  }

  // required .DS3_Frpg2RequestMessage.QuickMatchRank quickmatch_dual_rank = 3;
  if (has_quickmatch_dual_rank()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->quickmatch_dual_rank(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestUpdateLoginPlayerCharacterResponse)
}

int RequestUpdateLoginPlayerCharacterResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 character_id = 1;
    if (has_character_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->character_id());
    }

    // required .DS3_Frpg2RequestMessage.QuickMatchRank quickmatch_brawl_rank = 2;
    if (has_quickmatch_brawl_rank()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->quickmatch_brawl_rank());
    }

    // required .DS3_Frpg2RequestMessage.QuickMatchRank quickmatch_dual_rank = 3;
    if (has_quickmatch_dual_rank()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->quickmatch_dual_rank());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestUpdateLoginPlayerCharacterResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestUpdateLoginPlayerCharacterResponse*>(&from));
}

void RequestUpdateLoginPlayerCharacterResponse::MergeFrom(const RequestUpdateLoginPlayerCharacterResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_character_id()) {
      set_character_id(from.character_id());
    }
    if (from.has_quickmatch_brawl_rank()) {
      mutable_quickmatch_brawl_rank()->::DS3_Frpg2RequestMessage::QuickMatchRank::MergeFrom(from.quickmatch_brawl_rank());
    }
    if (from.has_quickmatch_dual_rank()) {
      mutable_quickmatch_dual_rank()->::DS3_Frpg2RequestMessage::QuickMatchRank::MergeFrom(from.quickmatch_dual_rank());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestUpdateLoginPlayerCharacterResponse::CopyFrom(const RequestUpdateLoginPlayerCharacterResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestUpdateLoginPlayerCharacterResponse::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void RequestUpdateLoginPlayerCharacterResponse::Swap(RequestUpdateLoginPlayerCharacterResponse* other) {
  if (other != this) {
    std::swap(character_id_, other->character_id_);
    std::swap(quickmatch_brawl_rank_, other->quickmatch_brawl_rank_);
    std::swap(quickmatch_dual_rank_, other->quickmatch_dual_rank_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestUpdateLoginPlayerCharacterResponse::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestUpdateLoginPlayerCharacterResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestUpdatePlayerStatus::kStatusFieldNumber;
#endif  // !_MSC_VER

RequestUpdatePlayerStatus::RequestUpdatePlayerStatus()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestUpdatePlayerStatus)
}

void RequestUpdatePlayerStatus::InitAsDefaultInstance() {
}

RequestUpdatePlayerStatus::RequestUpdatePlayerStatus(const RequestUpdatePlayerStatus& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestUpdatePlayerStatus)
}

void RequestUpdatePlayerStatus::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  status_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestUpdatePlayerStatus::~RequestUpdatePlayerStatus() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestUpdatePlayerStatus)
  SharedDtor();
}

void RequestUpdatePlayerStatus::SharedDtor() {
  if (status_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete status_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestUpdatePlayerStatus::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestUpdatePlayerStatus& RequestUpdatePlayerStatus::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestUpdatePlayerStatus* RequestUpdatePlayerStatus::default_instance_ = NULL;

RequestUpdatePlayerStatus* RequestUpdatePlayerStatus::New() const {
  return new RequestUpdatePlayerStatus;
}

void RequestUpdatePlayerStatus::Clear() {
  if (has_status()) {
    if (status_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
      status_->clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestUpdatePlayerStatus::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestUpdatePlayerStatus)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes status = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_status()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestUpdatePlayerStatus)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestUpdatePlayerStatus)
  return false;
#undef DO_
}

void RequestUpdatePlayerStatus::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestUpdatePlayerStatus)
  // required bytes status = 1;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->status(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestUpdatePlayerStatus)
}

int RequestUpdatePlayerStatus::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes status = 1;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->status());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestUpdatePlayerStatus::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestUpdatePlayerStatus*>(&from));
}

void RequestUpdatePlayerStatus::MergeFrom(const RequestUpdatePlayerStatus& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_status()) {
      set_status(from.status());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestUpdatePlayerStatus::CopyFrom(const RequestUpdatePlayerStatus& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestUpdatePlayerStatus::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void RequestUpdatePlayerStatus::Swap(RequestUpdatePlayerStatus* other) {
  if (other != this) {
    std::swap(status_, other->status_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestUpdatePlayerStatus::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestUpdatePlayerStatus";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RequestUpdatePlayerStatusResponse::RequestUpdatePlayerStatusResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestUpdatePlayerStatusResponse)
}

void RequestUpdatePlayerStatusResponse::InitAsDefaultInstance() {
}

RequestUpdatePlayerStatusResponse::RequestUpdatePlayerStatusResponse(const RequestUpdatePlayerStatusResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestUpdatePlayerStatusResponse)
}

void RequestUpdatePlayerStatusResponse::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestUpdatePlayerStatusResponse::~RequestUpdatePlayerStatusResponse() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestUpdatePlayerStatusResponse)
  SharedDtor();
}

void RequestUpdatePlayerStatusResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestUpdatePlayerStatusResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestUpdatePlayerStatusResponse& RequestUpdatePlayerStatusResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestUpdatePlayerStatusResponse* RequestUpdatePlayerStatusResponse::default_instance_ = NULL;

RequestUpdatePlayerStatusResponse* RequestUpdatePlayerStatusResponse::New() const {
  return new RequestUpdatePlayerStatusResponse;
}

void RequestUpdatePlayerStatusResponse::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestUpdatePlayerStatusResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestUpdatePlayerStatusResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestUpdatePlayerStatusResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestUpdatePlayerStatusResponse)
  return false;
#undef DO_
}

void RequestUpdatePlayerStatusResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestUpdatePlayerStatusResponse)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestUpdatePlayerStatusResponse)
}

int RequestUpdatePlayerStatusResponse::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestUpdatePlayerStatusResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestUpdatePlayerStatusResponse*>(&from));
}

void RequestUpdatePlayerStatusResponse::MergeFrom(const RequestUpdatePlayerStatusResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestUpdatePlayerStatusResponse::CopyFrom(const RequestUpdatePlayerStatusResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestUpdatePlayerStatusResponse::IsInitialized() const {

  return true;
}

void RequestUpdatePlayerStatusResponse::Swap(RequestUpdatePlayerStatusResponse* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestUpdatePlayerStatusResponse::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestUpdatePlayerStatusResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestUpdatePlayerCharacter::kCharacterIdFieldNumber;
const int RequestUpdatePlayerCharacter::kCharacterDataFieldNumber;
#endif  // !_MSC_VER

RequestUpdatePlayerCharacter::RequestUpdatePlayerCharacter()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestUpdatePlayerCharacter)
}

void RequestUpdatePlayerCharacter::InitAsDefaultInstance() {
}

RequestUpdatePlayerCharacter::RequestUpdatePlayerCharacter(const RequestUpdatePlayerCharacter& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestUpdatePlayerCharacter)
}

void RequestUpdatePlayerCharacter::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  character_id_ = 0u;
  character_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestUpdatePlayerCharacter::~RequestUpdatePlayerCharacter() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestUpdatePlayerCharacter)
  SharedDtor();
}

void RequestUpdatePlayerCharacter::SharedDtor() {
  if (character_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete character_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestUpdatePlayerCharacter::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestUpdatePlayerCharacter& RequestUpdatePlayerCharacter::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestUpdatePlayerCharacter* RequestUpdatePlayerCharacter::default_instance_ = NULL;

RequestUpdatePlayerCharacter* RequestUpdatePlayerCharacter::New() const {
  return new RequestUpdatePlayerCharacter;
}

void RequestUpdatePlayerCharacter::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    character_id_ = 0u;
    if (has_character_data()) {
      if (character_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        character_data_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestUpdatePlayerCharacter::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestUpdatePlayerCharacter)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 character_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &character_id_)));
          set_has_character_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_character_data;
        break;
      }

      // required bytes character_data = 2;
      case 2: {
        if (tag == 18) {
         parse_character_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_character_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestUpdatePlayerCharacter)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestUpdatePlayerCharacter)
  return false;
#undef DO_
}

void RequestUpdatePlayerCharacter::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestUpdatePlayerCharacter)
  // required uint32 character_id = 1;
  if (has_character_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->character_id(), output);
  }

  // required bytes character_data = 2;
  if (has_character_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->character_data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestUpdatePlayerCharacter)
}

int RequestUpdatePlayerCharacter::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 character_id = 1;
    if (has_character_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->character_id());
    }

    // required bytes character_data = 2;
    if (has_character_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->character_data());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestUpdatePlayerCharacter::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestUpdatePlayerCharacter*>(&from));
}

void RequestUpdatePlayerCharacter::MergeFrom(const RequestUpdatePlayerCharacter& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_character_id()) {
      set_character_id(from.character_id());
    }
    if (from.has_character_data()) {
      set_character_data(from.character_data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestUpdatePlayerCharacter::CopyFrom(const RequestUpdatePlayerCharacter& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestUpdatePlayerCharacter::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void RequestUpdatePlayerCharacter::Swap(RequestUpdatePlayerCharacter* other) {
  if (other != this) {
    std::swap(character_id_, other->character_id_);
    std::swap(character_data_, other->character_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestUpdatePlayerCharacter::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestUpdatePlayerCharacter";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RequestUpdatePlayerCharacterResponse::RequestUpdatePlayerCharacterResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestUpdatePlayerCharacterResponse)
}

void RequestUpdatePlayerCharacterResponse::InitAsDefaultInstance() {
}

RequestUpdatePlayerCharacterResponse::RequestUpdatePlayerCharacterResponse(const RequestUpdatePlayerCharacterResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestUpdatePlayerCharacterResponse)
}

void RequestUpdatePlayerCharacterResponse::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestUpdatePlayerCharacterResponse::~RequestUpdatePlayerCharacterResponse() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestUpdatePlayerCharacterResponse)
  SharedDtor();
}

void RequestUpdatePlayerCharacterResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestUpdatePlayerCharacterResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestUpdatePlayerCharacterResponse& RequestUpdatePlayerCharacterResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestUpdatePlayerCharacterResponse* RequestUpdatePlayerCharacterResponse::default_instance_ = NULL;

RequestUpdatePlayerCharacterResponse* RequestUpdatePlayerCharacterResponse::New() const {
  return new RequestUpdatePlayerCharacterResponse;
}

void RequestUpdatePlayerCharacterResponse::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestUpdatePlayerCharacterResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestUpdatePlayerCharacterResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestUpdatePlayerCharacterResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestUpdatePlayerCharacterResponse)
  return false;
#undef DO_
}

void RequestUpdatePlayerCharacterResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestUpdatePlayerCharacterResponse)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestUpdatePlayerCharacterResponse)
}

int RequestUpdatePlayerCharacterResponse::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestUpdatePlayerCharacterResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestUpdatePlayerCharacterResponse*>(&from));
}

void RequestUpdatePlayerCharacterResponse::MergeFrom(const RequestUpdatePlayerCharacterResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestUpdatePlayerCharacterResponse::CopyFrom(const RequestUpdatePlayerCharacterResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestUpdatePlayerCharacterResponse::IsInitialized() const {

  return true;
}

void RequestUpdatePlayerCharacterResponse::Swap(RequestUpdatePlayerCharacterResponse* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestUpdatePlayerCharacterResponse::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestUpdatePlayerCharacterResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestGetPlayerCharacter::kPlayerIdFieldNumber;
const int RequestGetPlayerCharacter::kCharacterIdFieldNumber;
#endif  // !_MSC_VER

RequestGetPlayerCharacter::RequestGetPlayerCharacter()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestGetPlayerCharacter)
}

void RequestGetPlayerCharacter::InitAsDefaultInstance() {
}

RequestGetPlayerCharacter::RequestGetPlayerCharacter(const RequestGetPlayerCharacter& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestGetPlayerCharacter)
}

void RequestGetPlayerCharacter::SharedCtor() {
  _cached_size_ = 0;
  player_id_ = 0u;
  character_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestGetPlayerCharacter::~RequestGetPlayerCharacter() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestGetPlayerCharacter)
  SharedDtor();
}

void RequestGetPlayerCharacter::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestGetPlayerCharacter::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestGetPlayerCharacter& RequestGetPlayerCharacter::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestGetPlayerCharacter* RequestGetPlayerCharacter::default_instance_ = NULL;

RequestGetPlayerCharacter* RequestGetPlayerCharacter::New() const {
  return new RequestGetPlayerCharacter;
}

void RequestGetPlayerCharacter::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<RequestGetPlayerCharacter*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(player_id_, character_id_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestGetPlayerCharacter::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestGetPlayerCharacter)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 player_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &player_id_)));
          set_has_player_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_character_id;
        break;
      }

      // required uint32 character_id = 2;
      case 2: {
        if (tag == 16) {
         parse_character_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &character_id_)));
          set_has_character_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestGetPlayerCharacter)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestGetPlayerCharacter)
  return false;
#undef DO_
}

void RequestGetPlayerCharacter::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestGetPlayerCharacter)
  // required uint32 player_id = 1;
  if (has_player_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->player_id(), output);
  }

  // required uint32 character_id = 2;
  if (has_character_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->character_id(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestGetPlayerCharacter)
}

int RequestGetPlayerCharacter::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 player_id = 1;
    if (has_player_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->player_id());
    }

    // required uint32 character_id = 2;
    if (has_character_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->character_id());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestGetPlayerCharacter::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestGetPlayerCharacter*>(&from));
}

void RequestGetPlayerCharacter::MergeFrom(const RequestGetPlayerCharacter& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_player_id()) {
      set_player_id(from.player_id());
    }
    if (from.has_character_id()) {
      set_character_id(from.character_id());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestGetPlayerCharacter::CopyFrom(const RequestGetPlayerCharacter& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestGetPlayerCharacter::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void RequestGetPlayerCharacter::Swap(RequestGetPlayerCharacter* other) {
  if (other != this) {
    std::swap(player_id_, other->player_id_);
    std::swap(character_id_, other->character_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestGetPlayerCharacter::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestGetPlayerCharacter";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestGetPlayerCharacterResponse::kPlayerIdFieldNumber;
const int RequestGetPlayerCharacterResponse::kCharacterIdFieldNumber;
const int RequestGetPlayerCharacterResponse::kCharacterDataFieldNumber;
#endif  // !_MSC_VER

RequestGetPlayerCharacterResponse::RequestGetPlayerCharacterResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestGetPlayerCharacterResponse)
}

void RequestGetPlayerCharacterResponse::InitAsDefaultInstance() {
}

RequestGetPlayerCharacterResponse::RequestGetPlayerCharacterResponse(const RequestGetPlayerCharacterResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestGetPlayerCharacterResponse)
}

void RequestGetPlayerCharacterResponse::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  player_id_ = 0u;
  character_id_ = 0u;
  character_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestGetPlayerCharacterResponse::~RequestGetPlayerCharacterResponse() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestGetPlayerCharacterResponse)
  SharedDtor();
}

void RequestGetPlayerCharacterResponse::SharedDtor() {
  if (character_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete character_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestGetPlayerCharacterResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestGetPlayerCharacterResponse& RequestGetPlayerCharacterResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestGetPlayerCharacterResponse* RequestGetPlayerCharacterResponse::default_instance_ = NULL;

RequestGetPlayerCharacterResponse* RequestGetPlayerCharacterResponse::New() const {
  return new RequestGetPlayerCharacterResponse;
}

void RequestGetPlayerCharacterResponse::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<RequestGetPlayerCharacterResponse*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 7) {
    ZR_(player_id_, character_id_);
    if (has_character_data()) {
      if (character_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        character_data_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestGetPlayerCharacterResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestGetPlayerCharacterResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 player_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &player_id_)));
          set_has_player_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_character_id;
        break;
      }

      // required uint32 character_id = 2;
      case 2: {
        if (tag == 16) {
         parse_character_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &character_id_)));
          set_has_character_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_character_data;
        break;
      }

      // required bytes character_data = 3;
      case 3: {
        if (tag == 26) {
         parse_character_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_character_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestGetPlayerCharacterResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestGetPlayerCharacterResponse)
  return false;
#undef DO_
}

void RequestGetPlayerCharacterResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestGetPlayerCharacterResponse)
  // required uint32 player_id = 1;
  if (has_player_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->player_id(), output);
  }

  // required uint32 character_id = 2;
  if (has_character_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->character_id(), output);
  }

  // required bytes character_data = 3;
  if (has_character_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->character_data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestGetPlayerCharacterResponse)
}

int RequestGetPlayerCharacterResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 player_id = 1;
    if (has_player_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->player_id());
    }

    // required uint32 character_id = 2;
    if (has_character_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->character_id());
    }

    // required bytes character_data = 3;
    if (has_character_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->character_data());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestGetPlayerCharacterResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestGetPlayerCharacterResponse*>(&from));
}

void RequestGetPlayerCharacterResponse::MergeFrom(const RequestGetPlayerCharacterResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_player_id()) {
      set_player_id(from.player_id());
    }
    if (from.has_character_id()) {
      set_character_id(from.character_id());
    }
    if (from.has_character_data()) {
      set_character_data(from.character_data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestGetPlayerCharacterResponse::CopyFrom(const RequestGetPlayerCharacterResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestGetPlayerCharacterResponse::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void RequestGetPlayerCharacterResponse::Swap(RequestGetPlayerCharacterResponse* other) {
  if (other != this) {
    std::swap(player_id_, other->player_id_);
    std::swap(character_id_, other->character_id_);
    std::swap(character_data_, other->character_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestGetPlayerCharacterResponse::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestGetPlayerCharacterResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int BloodMessageData::kPlayerIdFieldNumber;
const int BloodMessageData::kCharacterIdFieldNumber;
const int BloodMessageData::kMessageIdFieldNumber;
const int BloodMessageData::kGoodFieldNumber;
const int BloodMessageData::kMessageDataFieldNumber;
const int BloodMessageData::kPlayerSteamIdFieldNumber;
const int BloodMessageData::kOnlineAreaIdFieldNumber;
const int BloodMessageData::kPoorFieldNumber;
#endif  // !_MSC_VER

BloodMessageData::BloodMessageData()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.BloodMessageData)
}

void BloodMessageData::InitAsDefaultInstance() {
}

BloodMessageData::BloodMessageData(const BloodMessageData& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.BloodMessageData)
}

void BloodMessageData::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  player_id_ = 0u;
  character_id_ = 0u;
  message_id_ = 0u;
  good_ = 0u;
  message_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  player_steam_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  online_area_id_ = 0u;
  poor_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BloodMessageData::~BloodMessageData() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.BloodMessageData)
  SharedDtor();
}

void BloodMessageData::SharedDtor() {
  if (message_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete message_data_;
  }
  if (player_steam_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete player_steam_id_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void BloodMessageData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BloodMessageData& BloodMessageData::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

BloodMessageData* BloodMessageData::default_instance_ = NULL;

BloodMessageData* BloodMessageData::New() const {
  return new BloodMessageData;
}

void BloodMessageData::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<BloodMessageData*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(player_id_, good_);
    ZR_(online_area_id_, poor_);
    if (has_message_data()) {
      if (message_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        message_data_->clear();
      }
    }
    if (has_player_steam_id()) {
      if (player_steam_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        player_steam_id_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool BloodMessageData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.BloodMessageData)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 player_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &player_id_)));
          set_has_player_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_character_id;
        break;
      }

      // required uint32 character_id = 2;
      case 2: {
        if (tag == 16) {
         parse_character_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &character_id_)));
          set_has_character_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_message_id;
        break;
      }

      // required uint32 message_id = 3;
      case 3: {
        if (tag == 24) {
         parse_message_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &message_id_)));
          set_has_message_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_good;
        break;
      }

      // required uint32 good = 4;
      case 4: {
        if (tag == 32) {
         parse_good:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &good_)));
          set_has_good();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_message_data;
        break;
      }

      // required bytes message_data = 5;
      case 5: {
        if (tag == 42) {
         parse_message_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_message_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_player_steam_id;
        break;
      }

      // required string player_steam_id = 6;
      case 6: {
        if (tag == 50) {
         parse_player_steam_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_player_steam_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_online_area_id;
        break;
      }

      // required uint32 online_area_id = 7;
      case 7: {
        if (tag == 56) {
         parse_online_area_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &online_area_id_)));
          set_has_online_area_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_poor;
        break;
      }

      // required uint32 poor = 8;
      case 8: {
        if (tag == 64) {
         parse_poor:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &poor_)));
          set_has_poor();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.BloodMessageData)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.BloodMessageData)
  return false;
#undef DO_
}

void BloodMessageData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.BloodMessageData)
  // required uint32 player_id = 1;
  if (has_player_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->player_id(), output);
  }

  // required uint32 character_id = 2;
  if (has_character_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->character_id(), output);
  }

  // required uint32 message_id = 3;
  if (has_message_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->message_id(), output);
  }

  // required uint32 good = 4;
  if (has_good()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->good(), output);
  }

  // required bytes message_data = 5;
  if (has_message_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      5, this->message_data(), output);
  }

  // required string player_steam_id = 6;
  if (has_player_steam_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      6, this->player_steam_id(), output);
  }

  // required uint32 online_area_id = 7;
  if (has_online_area_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->online_area_id(), output);
  }

  // required uint32 poor = 8;
  if (has_poor()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->poor(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.BloodMessageData)
}

int BloodMessageData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 player_id = 1;
    if (has_player_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->player_id());
    }

    // required uint32 character_id = 2;
    if (has_character_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->character_id());
    }

    // required uint32 message_id = 3;
    if (has_message_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->message_id());
    }

    // required uint32 good = 4;
    if (has_good()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->good());
    }

    // required bytes message_data = 5;
    if (has_message_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->message_data());
    }

    // required string player_steam_id = 6;
    if (has_player_steam_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->player_steam_id());
    }

    // required uint32 online_area_id = 7;
    if (has_online_area_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->online_area_id());
    }

    // required uint32 poor = 8;
    if (has_poor()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->poor());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BloodMessageData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BloodMessageData*>(&from));
}

void BloodMessageData::MergeFrom(const BloodMessageData& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_player_id()) {
      set_player_id(from.player_id());
    }
    if (from.has_character_id()) {
      set_character_id(from.character_id());
    }
    if (from.has_message_id()) {
      set_message_id(from.message_id());
    }
    if (from.has_good()) {
      set_good(from.good());
    }
    if (from.has_message_data()) {
      set_message_data(from.message_data());
    }
    if (from.has_player_steam_id()) {
      set_player_steam_id(from.player_steam_id());
    }
    if (from.has_online_area_id()) {
      set_online_area_id(from.online_area_id());
    }
    if (from.has_poor()) {
      set_poor(from.poor());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void BloodMessageData::CopyFrom(const BloodMessageData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BloodMessageData::IsInitialized() const {
  if ((_has_bits_[0] & 0x000000ff) != 0x000000ff) return false;

  return true;
}

void BloodMessageData::Swap(BloodMessageData* other) {
  if (other != this) {
    std::swap(player_id_, other->player_id_);
    std::swap(character_id_, other->character_id_);
    std::swap(message_id_, other->message_id_);
    std::swap(good_, other->good_);
    std::swap(message_data_, other->message_data_);
    std::swap(player_steam_id_, other->player_steam_id_);
    std::swap(online_area_id_, other->online_area_id_);
    std::swap(poor_, other->poor_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string BloodMessageData::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.BloodMessageData";
}


// ===================================================================

#ifndef _MSC_VER
const int LocatedBloodMessage::kOnlineAreaIdFieldNumber;
const int LocatedBloodMessage::kMessageIdFieldNumber;
#endif  // !_MSC_VER

LocatedBloodMessage::LocatedBloodMessage()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.LocatedBloodMessage)
}

void LocatedBloodMessage::InitAsDefaultInstance() {
}

LocatedBloodMessage::LocatedBloodMessage(const LocatedBloodMessage& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.LocatedBloodMessage)
}

void LocatedBloodMessage::SharedCtor() {
  _cached_size_ = 0;
  online_area_id_ = 0u;
  message_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LocatedBloodMessage::~LocatedBloodMessage() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.LocatedBloodMessage)
  SharedDtor();
}

void LocatedBloodMessage::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void LocatedBloodMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const LocatedBloodMessage& LocatedBloodMessage::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

LocatedBloodMessage* LocatedBloodMessage::default_instance_ = NULL;

LocatedBloodMessage* LocatedBloodMessage::New() const {
  return new LocatedBloodMessage;
}

void LocatedBloodMessage::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<LocatedBloodMessage*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(online_area_id_, message_id_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool LocatedBloodMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.LocatedBloodMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 online_area_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &online_area_id_)));
          set_has_online_area_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_message_id;
        break;
      }

      // required uint32 message_id = 2;
      case 2: {
        if (tag == 16) {
         parse_message_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &message_id_)));
          set_has_message_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.LocatedBloodMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.LocatedBloodMessage)
  return false;
#undef DO_
}

void LocatedBloodMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.LocatedBloodMessage)
  // required uint32 online_area_id = 1;
  if (has_online_area_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->online_area_id(), output);
  }

  // required uint32 message_id = 2;
  if (has_message_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->message_id(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.LocatedBloodMessage)
}

int LocatedBloodMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 online_area_id = 1;
    if (has_online_area_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->online_area_id());
    }

    // required uint32 message_id = 2;
    if (has_message_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->message_id());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LocatedBloodMessage::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const LocatedBloodMessage*>(&from));
}

void LocatedBloodMessage::MergeFrom(const LocatedBloodMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_online_area_id()) {
      set_online_area_id(from.online_area_id());
    }
    if (from.has_message_id()) {
      set_message_id(from.message_id());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void LocatedBloodMessage::CopyFrom(const LocatedBloodMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LocatedBloodMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void LocatedBloodMessage::Swap(LocatedBloodMessage* other) {
  if (other != this) {
    std::swap(online_area_id_, other->online_area_id_);
    std::swap(message_id_, other->message_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string LocatedBloodMessage::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.LocatedBloodMessage";
}


// ===================================================================

#ifndef _MSC_VER
const int BloodMessageDomainLimitData::kOnlineAreaIdFieldNumber;
const int BloodMessageDomainLimitData::kMaxType1FieldNumber;
const int BloodMessageDomainLimitData::kMaxType2FieldNumber;
#endif  // !_MSC_VER

BloodMessageDomainLimitData::BloodMessageDomainLimitData()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.BloodMessageDomainLimitData)
}

void BloodMessageDomainLimitData::InitAsDefaultInstance() {
}

BloodMessageDomainLimitData::BloodMessageDomainLimitData(const BloodMessageDomainLimitData& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.BloodMessageDomainLimitData)
}

void BloodMessageDomainLimitData::SharedCtor() {
  _cached_size_ = 0;
  online_area_id_ = 0u;
  max_type_1_ = 0u;
  max_type_2_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BloodMessageDomainLimitData::~BloodMessageDomainLimitData() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.BloodMessageDomainLimitData)
  SharedDtor();
}

void BloodMessageDomainLimitData::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void BloodMessageDomainLimitData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BloodMessageDomainLimitData& BloodMessageDomainLimitData::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

BloodMessageDomainLimitData* BloodMessageDomainLimitData::default_instance_ = NULL;

BloodMessageDomainLimitData* BloodMessageDomainLimitData::New() const {
  return new BloodMessageDomainLimitData;
}

void BloodMessageDomainLimitData::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<BloodMessageDomainLimitData*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(online_area_id_, max_type_2_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool BloodMessageDomainLimitData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.BloodMessageDomainLimitData)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 online_area_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &online_area_id_)));
          set_has_online_area_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_max_type_1;
        break;
      }

      // required uint32 max_type_1 = 2;
      case 2: {
        if (tag == 16) {
         parse_max_type_1:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &max_type_1_)));
          set_has_max_type_1();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_max_type_2;
        break;
      }

      // required uint32 max_type_2 = 3;
      case 3: {
        if (tag == 24) {
         parse_max_type_2:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &max_type_2_)));
          set_has_max_type_2();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.BloodMessageDomainLimitData)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.BloodMessageDomainLimitData)
  return false;
#undef DO_
}

void BloodMessageDomainLimitData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.BloodMessageDomainLimitData)
  // required uint32 online_area_id = 1;
  if (has_online_area_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->online_area_id(), output);
  }

  // required uint32 max_type_1 = 2;
  if (has_max_type_1()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->max_type_1(), output);
  }

  // required uint32 max_type_2 = 3;
  if (has_max_type_2()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->max_type_2(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.BloodMessageDomainLimitData)
}

int BloodMessageDomainLimitData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 online_area_id = 1;
    if (has_online_area_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->online_area_id());
    }

    // required uint32 max_type_1 = 2;
    if (has_max_type_1()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->max_type_1());
    }

    // required uint32 max_type_2 = 3;
    if (has_max_type_2()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->max_type_2());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BloodMessageDomainLimitData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BloodMessageDomainLimitData*>(&from));
}

void BloodMessageDomainLimitData::MergeFrom(const BloodMessageDomainLimitData& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_online_area_id()) {
      set_online_area_id(from.online_area_id());
    }
    if (from.has_max_type_1()) {
      set_max_type_1(from.max_type_1());
    }
    if (from.has_max_type_2()) {
      set_max_type_2(from.max_type_2());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void BloodMessageDomainLimitData::CopyFrom(const BloodMessageDomainLimitData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BloodMessageDomainLimitData::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void BloodMessageDomainLimitData::Swap(BloodMessageDomainLimitData* other) {
  if (other != this) {
    std::swap(online_area_id_, other->online_area_id_);
    std::swap(max_type_1_, other->max_type_1_);
    std::swap(max_type_2_, other->max_type_2_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string BloodMessageDomainLimitData::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.BloodMessageDomainLimitData";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestReentryBloodMessage::kMessagesFieldNumber;
const int RequestReentryBloodMessage::kCharacterIdFieldNumber;
#endif  // !_MSC_VER

RequestReentryBloodMessage::RequestReentryBloodMessage()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestReentryBloodMessage)
}

void RequestReentryBloodMessage::InitAsDefaultInstance() {
}

RequestReentryBloodMessage::RequestReentryBloodMessage(const RequestReentryBloodMessage& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestReentryBloodMessage)
}

void RequestReentryBloodMessage::SharedCtor() {
  _cached_size_ = 0;
  character_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestReentryBloodMessage::~RequestReentryBloodMessage() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestReentryBloodMessage)
  SharedDtor();
}

void RequestReentryBloodMessage::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestReentryBloodMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestReentryBloodMessage& RequestReentryBloodMessage::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestReentryBloodMessage* RequestReentryBloodMessage::default_instance_ = NULL;

RequestReentryBloodMessage* RequestReentryBloodMessage::New() const {
  return new RequestReentryBloodMessage;
}

void RequestReentryBloodMessage::Clear() {
  character_id_ = 0u;
  messages_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestReentryBloodMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestReentryBloodMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .DS3_Frpg2RequestMessage.LocatedBloodMessage messages = 1;
      case 1: {
        if (tag == 10) {
         parse_messages:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_messages()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_messages;
        if (input->ExpectTag(16)) goto parse_character_id;
        break;
      }

      // required uint32 character_id = 2;
      case 2: {
        if (tag == 16) {
         parse_character_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &character_id_)));
          set_has_character_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestReentryBloodMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestReentryBloodMessage)
  return false;
#undef DO_
}

void RequestReentryBloodMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestReentryBloodMessage)
  // repeated .DS3_Frpg2RequestMessage.LocatedBloodMessage messages = 1;
  for (int i = 0; i < this->messages_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->messages(i), output);
  }

  // required uint32 character_id = 2;
  if (has_character_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->character_id(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestReentryBloodMessage)
}

int RequestReentryBloodMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // required uint32 character_id = 2;
    if (has_character_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->character_id());
    }

  }
  // repeated .DS3_Frpg2RequestMessage.LocatedBloodMessage messages = 1;
  total_size += 1 * this->messages_size();
  for (int i = 0; i < this->messages_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->messages(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestReentryBloodMessage::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestReentryBloodMessage*>(&from));
}

void RequestReentryBloodMessage::MergeFrom(const RequestReentryBloodMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  messages_.MergeFrom(from.messages_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_character_id()) {
      set_character_id(from.character_id());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestReentryBloodMessage::CopyFrom(const RequestReentryBloodMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestReentryBloodMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->messages())) return false;
  return true;
}

void RequestReentryBloodMessage::Swap(RequestReentryBloodMessage* other) {
  if (other != this) {
    messages_.Swap(&other->messages_);
    std::swap(character_id_, other->character_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestReentryBloodMessage::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestReentryBloodMessage";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestReentryBloodMessageResponse::kRecreateMessageIdsFieldNumber;
#endif  // !_MSC_VER

RequestReentryBloodMessageResponse::RequestReentryBloodMessageResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestReentryBloodMessageResponse)
}

void RequestReentryBloodMessageResponse::InitAsDefaultInstance() {
}

RequestReentryBloodMessageResponse::RequestReentryBloodMessageResponse(const RequestReentryBloodMessageResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestReentryBloodMessageResponse)
}

void RequestReentryBloodMessageResponse::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestReentryBloodMessageResponse::~RequestReentryBloodMessageResponse() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestReentryBloodMessageResponse)
  SharedDtor();
}

void RequestReentryBloodMessageResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestReentryBloodMessageResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestReentryBloodMessageResponse& RequestReentryBloodMessageResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestReentryBloodMessageResponse* RequestReentryBloodMessageResponse::default_instance_ = NULL;

RequestReentryBloodMessageResponse* RequestReentryBloodMessageResponse::New() const {
  return new RequestReentryBloodMessageResponse;
}

void RequestReentryBloodMessageResponse::Clear() {
  recreate_message_ids_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestReentryBloodMessageResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestReentryBloodMessageResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 recreate_message_ids = 1;
      case 1: {
        if (tag == 8) {
         parse_recreate_message_ids:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 8, input, this->mutable_recreate_message_ids())));
        } else if (tag == 10) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_recreate_message_ids())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(8)) goto parse_recreate_message_ids;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestReentryBloodMessageResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestReentryBloodMessageResponse)
  return false;
#undef DO_
}

void RequestReentryBloodMessageResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestReentryBloodMessageResponse)
  // repeated uint32 recreate_message_ids = 1;
  for (int i = 0; i < this->recreate_message_ids_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      1, this->recreate_message_ids(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestReentryBloodMessageResponse)
}

int RequestReentryBloodMessageResponse::ByteSize() const {
  int total_size = 0;

  // repeated uint32 recreate_message_ids = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->recreate_message_ids_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->recreate_message_ids(i));
    }
    total_size += 1 * this->recreate_message_ids_size() + data_size;
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestReentryBloodMessageResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestReentryBloodMessageResponse*>(&from));
}

void RequestReentryBloodMessageResponse::MergeFrom(const RequestReentryBloodMessageResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  recreate_message_ids_.MergeFrom(from.recreate_message_ids_);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestReentryBloodMessageResponse::CopyFrom(const RequestReentryBloodMessageResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestReentryBloodMessageResponse::IsInitialized() const {

  return true;
}

void RequestReentryBloodMessageResponse::Swap(RequestReentryBloodMessageResponse* other) {
  if (other != this) {
    recreate_message_ids_.Swap(&other->recreate_message_ids_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestReentryBloodMessageResponse::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestReentryBloodMessageResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestCreateBloodMessage::kOnlineAreaIdFieldNumber;
const int RequestCreateBloodMessage::kCharacterIdFieldNumber;
const int RequestCreateBloodMessage::kMessageDataFieldNumber;
#endif  // !_MSC_VER

RequestCreateBloodMessage::RequestCreateBloodMessage()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestCreateBloodMessage)
}

void RequestCreateBloodMessage::InitAsDefaultInstance() {
}

RequestCreateBloodMessage::RequestCreateBloodMessage(const RequestCreateBloodMessage& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestCreateBloodMessage)
}

void RequestCreateBloodMessage::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  online_area_id_ = 0u;
  character_id_ = 0u;
  message_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestCreateBloodMessage::~RequestCreateBloodMessage() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestCreateBloodMessage)
  SharedDtor();
}

void RequestCreateBloodMessage::SharedDtor() {
  if (message_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete message_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestCreateBloodMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestCreateBloodMessage& RequestCreateBloodMessage::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestCreateBloodMessage* RequestCreateBloodMessage::default_instance_ = NULL;

RequestCreateBloodMessage* RequestCreateBloodMessage::New() const {
  return new RequestCreateBloodMessage;
}

void RequestCreateBloodMessage::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<RequestCreateBloodMessage*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 7) {
    ZR_(online_area_id_, character_id_);
    if (has_message_data()) {
      if (message_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        message_data_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestCreateBloodMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestCreateBloodMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 online_area_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &online_area_id_)));
          set_has_online_area_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_character_id;
        break;
      }

      // required uint32 character_id = 2;
      case 2: {
        if (tag == 16) {
         parse_character_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &character_id_)));
          set_has_character_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_message_data;
        break;
      }

      // required bytes message_data = 3;
      case 3: {
        if (tag == 26) {
         parse_message_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_message_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestCreateBloodMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestCreateBloodMessage)
  return false;
#undef DO_
}

void RequestCreateBloodMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestCreateBloodMessage)
  // required uint32 online_area_id = 1;
  if (has_online_area_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->online_area_id(), output);
  }

  // required uint32 character_id = 2;
  if (has_character_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->character_id(), output);
  }

  // required bytes message_data = 3;
  if (has_message_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->message_data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestCreateBloodMessage)
}

int RequestCreateBloodMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 online_area_id = 1;
    if (has_online_area_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->online_area_id());
    }

    // required uint32 character_id = 2;
    if (has_character_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->character_id());
    }

    // required bytes message_data = 3;
    if (has_message_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->message_data());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestCreateBloodMessage::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestCreateBloodMessage*>(&from));
}

void RequestCreateBloodMessage::MergeFrom(const RequestCreateBloodMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_online_area_id()) {
      set_online_area_id(from.online_area_id());
    }
    if (from.has_character_id()) {
      set_character_id(from.character_id());
    }
    if (from.has_message_data()) {
      set_message_data(from.message_data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestCreateBloodMessage::CopyFrom(const RequestCreateBloodMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestCreateBloodMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void RequestCreateBloodMessage::Swap(RequestCreateBloodMessage* other) {
  if (other != this) {
    std::swap(online_area_id_, other->online_area_id_);
    std::swap(character_id_, other->character_id_);
    std::swap(message_data_, other->message_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestCreateBloodMessage::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestCreateBloodMessage";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestCreateBloodMessageResponse::kMessageIdFieldNumber;
#endif  // !_MSC_VER

RequestCreateBloodMessageResponse::RequestCreateBloodMessageResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestCreateBloodMessageResponse)
}

void RequestCreateBloodMessageResponse::InitAsDefaultInstance() {
}

RequestCreateBloodMessageResponse::RequestCreateBloodMessageResponse(const RequestCreateBloodMessageResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestCreateBloodMessageResponse)
}

void RequestCreateBloodMessageResponse::SharedCtor() {
  _cached_size_ = 0;
  message_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestCreateBloodMessageResponse::~RequestCreateBloodMessageResponse() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestCreateBloodMessageResponse)
  SharedDtor();
}

void RequestCreateBloodMessageResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestCreateBloodMessageResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestCreateBloodMessageResponse& RequestCreateBloodMessageResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestCreateBloodMessageResponse* RequestCreateBloodMessageResponse::default_instance_ = NULL;

RequestCreateBloodMessageResponse* RequestCreateBloodMessageResponse::New() const {
  return new RequestCreateBloodMessageResponse;
}

void RequestCreateBloodMessageResponse::Clear() {
  message_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestCreateBloodMessageResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestCreateBloodMessageResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 message_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &message_id_)));
          set_has_message_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestCreateBloodMessageResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestCreateBloodMessageResponse)
  return false;
#undef DO_
}

void RequestCreateBloodMessageResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestCreateBloodMessageResponse)
  // required uint32 message_id = 1;
  if (has_message_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->message_id(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestCreateBloodMessageResponse)
}

int RequestCreateBloodMessageResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 message_id = 1;
    if (has_message_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->message_id());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestCreateBloodMessageResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestCreateBloodMessageResponse*>(&from));
}

void RequestCreateBloodMessageResponse::MergeFrom(const RequestCreateBloodMessageResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_message_id()) {
      set_message_id(from.message_id());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestCreateBloodMessageResponse::CopyFrom(const RequestCreateBloodMessageResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestCreateBloodMessageResponse::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void RequestCreateBloodMessageResponse::Swap(RequestCreateBloodMessageResponse* other) {
  if (other != this) {
    std::swap(message_id_, other->message_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestCreateBloodMessageResponse::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestCreateBloodMessageResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestReCreateBloodMessageList_Blood_message_info_list::kOnlineAreaIdFieldNumber;
const int RequestReCreateBloodMessageList_Blood_message_info_list::kMessageDataFieldNumber;
const int RequestReCreateBloodMessageList_Blood_message_info_list::kUnknown1FieldNumber;
const int RequestReCreateBloodMessageList_Blood_message_info_list::kUnknown2FieldNumber;
#endif  // !_MSC_VER

RequestReCreateBloodMessageList_Blood_message_info_list::RequestReCreateBloodMessageList_Blood_message_info_list()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestReCreateBloodMessageList.Blood_message_info_list)
}

void RequestReCreateBloodMessageList_Blood_message_info_list::InitAsDefaultInstance() {
}

RequestReCreateBloodMessageList_Blood_message_info_list::RequestReCreateBloodMessageList_Blood_message_info_list(const RequestReCreateBloodMessageList_Blood_message_info_list& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestReCreateBloodMessageList.Blood_message_info_list)
}

void RequestReCreateBloodMessageList_Blood_message_info_list::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  online_area_id_ = 0u;
  message_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  unknown_1_ = 0u;
  unknown_2_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestReCreateBloodMessageList_Blood_message_info_list::~RequestReCreateBloodMessageList_Blood_message_info_list() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestReCreateBloodMessageList.Blood_message_info_list)
  SharedDtor();
}

void RequestReCreateBloodMessageList_Blood_message_info_list::SharedDtor() {
  if (message_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete message_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestReCreateBloodMessageList_Blood_message_info_list::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestReCreateBloodMessageList_Blood_message_info_list& RequestReCreateBloodMessageList_Blood_message_info_list::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestReCreateBloodMessageList_Blood_message_info_list* RequestReCreateBloodMessageList_Blood_message_info_list::default_instance_ = NULL;

RequestReCreateBloodMessageList_Blood_message_info_list* RequestReCreateBloodMessageList_Blood_message_info_list::New() const {
  return new RequestReCreateBloodMessageList_Blood_message_info_list;
}

void RequestReCreateBloodMessageList_Blood_message_info_list::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<RequestReCreateBloodMessageList_Blood_message_info_list*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 15) {
    ZR_(online_area_id_, unknown_2_);
    if (has_message_data()) {
      if (message_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        message_data_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestReCreateBloodMessageList_Blood_message_info_list::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestReCreateBloodMessageList.Blood_message_info_list)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 online_area_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &online_area_id_)));
          set_has_online_area_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_message_data;
        break;
      }

      // required bytes message_data = 2;
      case 2: {
        if (tag == 18) {
         parse_message_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_message_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_unknown_1;
        break;
      }

      // required uint32 unknown_1 = 3;
      case 3: {
        if (tag == 24) {
         parse_unknown_1:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_1_)));
          set_has_unknown_1();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_unknown_2;
        break;
      }

      // required uint32 unknown_2 = 4;
      case 4: {
        if (tag == 32) {
         parse_unknown_2:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_2_)));
          set_has_unknown_2();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestReCreateBloodMessageList.Blood_message_info_list)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestReCreateBloodMessageList.Blood_message_info_list)
  return false;
#undef DO_
}

void RequestReCreateBloodMessageList_Blood_message_info_list::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestReCreateBloodMessageList.Blood_message_info_list)
  // required uint32 online_area_id = 1;
  if (has_online_area_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->online_area_id(), output);
  }

  // required bytes message_data = 2;
  if (has_message_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->message_data(), output);
  }

  // required uint32 unknown_1 = 3;
  if (has_unknown_1()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->unknown_1(), output);
  }

  // required uint32 unknown_2 = 4;
  if (has_unknown_2()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->unknown_2(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestReCreateBloodMessageList.Blood_message_info_list)
}

int RequestReCreateBloodMessageList_Blood_message_info_list::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 online_area_id = 1;
    if (has_online_area_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->online_area_id());
    }

    // required bytes message_data = 2;
    if (has_message_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->message_data());
    }

    // required uint32 unknown_1 = 3;
    if (has_unknown_1()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_1());
    }

    // required uint32 unknown_2 = 4;
    if (has_unknown_2()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_2());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestReCreateBloodMessageList_Blood_message_info_list::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestReCreateBloodMessageList_Blood_message_info_list*>(&from));
}

void RequestReCreateBloodMessageList_Blood_message_info_list::MergeFrom(const RequestReCreateBloodMessageList_Blood_message_info_list& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_online_area_id()) {
      set_online_area_id(from.online_area_id());
    }
    if (from.has_message_data()) {
      set_message_data(from.message_data());
    }
    if (from.has_unknown_1()) {
      set_unknown_1(from.unknown_1());
    }
    if (from.has_unknown_2()) {
      set_unknown_2(from.unknown_2());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestReCreateBloodMessageList_Blood_message_info_list::CopyFrom(const RequestReCreateBloodMessageList_Blood_message_info_list& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestReCreateBloodMessageList_Blood_message_info_list::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void RequestReCreateBloodMessageList_Blood_message_info_list::Swap(RequestReCreateBloodMessageList_Blood_message_info_list* other) {
  if (other != this) {
    std::swap(online_area_id_, other->online_area_id_);
    std::swap(message_data_, other->message_data_);
    std::swap(unknown_1_, other->unknown_1_);
    std::swap(unknown_2_, other->unknown_2_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestReCreateBloodMessageList_Blood_message_info_list::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestReCreateBloodMessageList.Blood_message_info_list";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int RequestReCreateBloodMessageList::kCharacterIdFieldNumber;
const int RequestReCreateBloodMessageList::kBloodMessageInfoListFieldNumber;
#endif  // !_MSC_VER

RequestReCreateBloodMessageList::RequestReCreateBloodMessageList()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestReCreateBloodMessageList)
}

void RequestReCreateBloodMessageList::InitAsDefaultInstance() {
}

RequestReCreateBloodMessageList::RequestReCreateBloodMessageList(const RequestReCreateBloodMessageList& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestReCreateBloodMessageList)
}

void RequestReCreateBloodMessageList::SharedCtor() {
  _cached_size_ = 0;
  character_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestReCreateBloodMessageList::~RequestReCreateBloodMessageList() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestReCreateBloodMessageList)
  SharedDtor();
}

void RequestReCreateBloodMessageList::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestReCreateBloodMessageList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestReCreateBloodMessageList& RequestReCreateBloodMessageList::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestReCreateBloodMessageList* RequestReCreateBloodMessageList::default_instance_ = NULL;

RequestReCreateBloodMessageList* RequestReCreateBloodMessageList::New() const {
  return new RequestReCreateBloodMessageList;
}

void RequestReCreateBloodMessageList::Clear() {
  character_id_ = 0u;
  blood_message_info_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestReCreateBloodMessageList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestReCreateBloodMessageList)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 character_id = 2;
      case 2: {
        if (tag == 16) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &character_id_)));
          set_has_character_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(27)) goto parse_blood_message_info_list;
        break;
      }

      // repeated group Blood_message_info_list = 3 {
      case 3: {
        if (tag == 27) {
         parse_blood_message_info_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadGroupNoVirtual(
                3, input, add_blood_message_info_list()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(27)) goto parse_blood_message_info_list;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestReCreateBloodMessageList)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestReCreateBloodMessageList)
  return false;
#undef DO_
}

void RequestReCreateBloodMessageList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestReCreateBloodMessageList)
  // required uint32 character_id = 2;
  if (has_character_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->character_id(), output);
  }

  // repeated group Blood_message_info_list = 3 {
  for (int i = 0; i < this->blood_message_info_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteGroup(
      3, this->blood_message_info_list(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestReCreateBloodMessageList)
}

int RequestReCreateBloodMessageList::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 character_id = 2;
    if (has_character_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->character_id());
    }

  }
  // repeated group Blood_message_info_list = 3 {
  total_size += 2 * this->blood_message_info_list_size();
  for (int i = 0; i < this->blood_message_info_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::GroupSizeNoVirtual(
        this->blood_message_info_list(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestReCreateBloodMessageList::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestReCreateBloodMessageList*>(&from));
}

void RequestReCreateBloodMessageList::MergeFrom(const RequestReCreateBloodMessageList& from) {
  GOOGLE_CHECK_NE(&from, this);
  blood_message_info_list_.MergeFrom(from.blood_message_info_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_character_id()) {
      set_character_id(from.character_id());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestReCreateBloodMessageList::CopyFrom(const RequestReCreateBloodMessageList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestReCreateBloodMessageList::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->blood_message_info_list())) return false;
  return true;
}

void RequestReCreateBloodMessageList::Swap(RequestReCreateBloodMessageList* other) {
  if (other != this) {
    std::swap(character_id_, other->character_id_);
    blood_message_info_list_.Swap(&other->blood_message_info_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestReCreateBloodMessageList::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestReCreateBloodMessageList";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestReCreateBloodMessageListResponse::kMessageIdsFieldNumber;
#endif  // !_MSC_VER

RequestReCreateBloodMessageListResponse::RequestReCreateBloodMessageListResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestReCreateBloodMessageListResponse)
}

void RequestReCreateBloodMessageListResponse::InitAsDefaultInstance() {
}

RequestReCreateBloodMessageListResponse::RequestReCreateBloodMessageListResponse(const RequestReCreateBloodMessageListResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestReCreateBloodMessageListResponse)
}

void RequestReCreateBloodMessageListResponse::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestReCreateBloodMessageListResponse::~RequestReCreateBloodMessageListResponse() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestReCreateBloodMessageListResponse)
  SharedDtor();
}

void RequestReCreateBloodMessageListResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestReCreateBloodMessageListResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestReCreateBloodMessageListResponse& RequestReCreateBloodMessageListResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestReCreateBloodMessageListResponse* RequestReCreateBloodMessageListResponse::default_instance_ = NULL;

RequestReCreateBloodMessageListResponse* RequestReCreateBloodMessageListResponse::New() const {
  return new RequestReCreateBloodMessageListResponse;
}

void RequestReCreateBloodMessageListResponse::Clear() {
  message_ids_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestReCreateBloodMessageListResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestReCreateBloodMessageListResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 message_ids = 1;
      case 1: {
        if (tag == 8) {
         parse_message_ids:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 8, input, this->mutable_message_ids())));
        } else if (tag == 10) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_message_ids())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(8)) goto parse_message_ids;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestReCreateBloodMessageListResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestReCreateBloodMessageListResponse)
  return false;
#undef DO_
}

void RequestReCreateBloodMessageListResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestReCreateBloodMessageListResponse)
  // repeated uint32 message_ids = 1;
  for (int i = 0; i < this->message_ids_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      1, this->message_ids(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestReCreateBloodMessageListResponse)
}

int RequestReCreateBloodMessageListResponse::ByteSize() const {
  int total_size = 0;

  // repeated uint32 message_ids = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->message_ids_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->message_ids(i));
    }
    total_size += 1 * this->message_ids_size() + data_size;
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestReCreateBloodMessageListResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestReCreateBloodMessageListResponse*>(&from));
}

void RequestReCreateBloodMessageListResponse::MergeFrom(const RequestReCreateBloodMessageListResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  message_ids_.MergeFrom(from.message_ids_);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestReCreateBloodMessageListResponse::CopyFrom(const RequestReCreateBloodMessageListResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestReCreateBloodMessageListResponse::IsInitialized() const {

  return true;
}

void RequestReCreateBloodMessageListResponse::Swap(RequestReCreateBloodMessageListResponse* other) {
  if (other != this) {
    message_ids_.Swap(&other->message_ids_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestReCreateBloodMessageListResponse::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestReCreateBloodMessageListResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestRemoveBloodMessage::kOnlineAreaIdFieldNumber;
const int RequestRemoveBloodMessage::kMessageIdFieldNumber;
#endif  // !_MSC_VER

RequestRemoveBloodMessage::RequestRemoveBloodMessage()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestRemoveBloodMessage)
}

void RequestRemoveBloodMessage::InitAsDefaultInstance() {
}

RequestRemoveBloodMessage::RequestRemoveBloodMessage(const RequestRemoveBloodMessage& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestRemoveBloodMessage)
}

void RequestRemoveBloodMessage::SharedCtor() {
  _cached_size_ = 0;
  online_area_id_ = 0u;
  message_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestRemoveBloodMessage::~RequestRemoveBloodMessage() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestRemoveBloodMessage)
  SharedDtor();
}

void RequestRemoveBloodMessage::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestRemoveBloodMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestRemoveBloodMessage& RequestRemoveBloodMessage::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestRemoveBloodMessage* RequestRemoveBloodMessage::default_instance_ = NULL;

RequestRemoveBloodMessage* RequestRemoveBloodMessage::New() const {
  return new RequestRemoveBloodMessage;
}

void RequestRemoveBloodMessage::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<RequestRemoveBloodMessage*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(online_area_id_, message_id_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestRemoveBloodMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestRemoveBloodMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 online_area_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &online_area_id_)));
          set_has_online_area_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_message_id;
        break;
      }

      // required uint32 message_id = 2;
      case 2: {
        if (tag == 16) {
         parse_message_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &message_id_)));
          set_has_message_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestRemoveBloodMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestRemoveBloodMessage)
  return false;
#undef DO_
}

void RequestRemoveBloodMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestRemoveBloodMessage)
  // required uint32 online_area_id = 1;
  if (has_online_area_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->online_area_id(), output);
  }

  // required uint32 message_id = 2;
  if (has_message_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->message_id(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestRemoveBloodMessage)
}

int RequestRemoveBloodMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 online_area_id = 1;
    if (has_online_area_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->online_area_id());
    }

    // required uint32 message_id = 2;
    if (has_message_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->message_id());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestRemoveBloodMessage::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestRemoveBloodMessage*>(&from));
}

void RequestRemoveBloodMessage::MergeFrom(const RequestRemoveBloodMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_online_area_id()) {
      set_online_area_id(from.online_area_id());
    }
    if (from.has_message_id()) {
      set_message_id(from.message_id());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestRemoveBloodMessage::CopyFrom(const RequestRemoveBloodMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestRemoveBloodMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void RequestRemoveBloodMessage::Swap(RequestRemoveBloodMessage* other) {
  if (other != this) {
    std::swap(online_area_id_, other->online_area_id_);
    std::swap(message_id_, other->message_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestRemoveBloodMessage::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestRemoveBloodMessage";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RequestRemoveBloodMessageResponse::RequestRemoveBloodMessageResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestRemoveBloodMessageResponse)
}

void RequestRemoveBloodMessageResponse::InitAsDefaultInstance() {
}

RequestRemoveBloodMessageResponse::RequestRemoveBloodMessageResponse(const RequestRemoveBloodMessageResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestRemoveBloodMessageResponse)
}

void RequestRemoveBloodMessageResponse::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestRemoveBloodMessageResponse::~RequestRemoveBloodMessageResponse() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestRemoveBloodMessageResponse)
  SharedDtor();
}

void RequestRemoveBloodMessageResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestRemoveBloodMessageResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestRemoveBloodMessageResponse& RequestRemoveBloodMessageResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestRemoveBloodMessageResponse* RequestRemoveBloodMessageResponse::default_instance_ = NULL;

RequestRemoveBloodMessageResponse* RequestRemoveBloodMessageResponse::New() const {
  return new RequestRemoveBloodMessageResponse;
}

void RequestRemoveBloodMessageResponse::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestRemoveBloodMessageResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestRemoveBloodMessageResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestRemoveBloodMessageResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestRemoveBloodMessageResponse)
  return false;
#undef DO_
}

void RequestRemoveBloodMessageResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestRemoveBloodMessageResponse)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestRemoveBloodMessageResponse)
}

int RequestRemoveBloodMessageResponse::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestRemoveBloodMessageResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestRemoveBloodMessageResponse*>(&from));
}

void RequestRemoveBloodMessageResponse::MergeFrom(const RequestRemoveBloodMessageResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestRemoveBloodMessageResponse::CopyFrom(const RequestRemoveBloodMessageResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestRemoveBloodMessageResponse::IsInitialized() const {

  return true;
}

void RequestRemoveBloodMessageResponse::Swap(RequestRemoveBloodMessageResponse* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestRemoveBloodMessageResponse::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestRemoveBloodMessageResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestGetBloodMessageList::kMaxMessagesFieldNumber;
const int RequestGetBloodMessageList::kSearchAreasFieldNumber;
#endif  // !_MSC_VER

RequestGetBloodMessageList::RequestGetBloodMessageList()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestGetBloodMessageList)
}

void RequestGetBloodMessageList::InitAsDefaultInstance() {
}

RequestGetBloodMessageList::RequestGetBloodMessageList(const RequestGetBloodMessageList& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestGetBloodMessageList)
}

void RequestGetBloodMessageList::SharedCtor() {
  _cached_size_ = 0;
  max_messages_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestGetBloodMessageList::~RequestGetBloodMessageList() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestGetBloodMessageList)
  SharedDtor();
}

void RequestGetBloodMessageList::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestGetBloodMessageList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestGetBloodMessageList& RequestGetBloodMessageList::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestGetBloodMessageList* RequestGetBloodMessageList::default_instance_ = NULL;

RequestGetBloodMessageList* RequestGetBloodMessageList::New() const {
  return new RequestGetBloodMessageList;
}

void RequestGetBloodMessageList::Clear() {
  max_messages_ = 0u;
  search_areas_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestGetBloodMessageList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestGetBloodMessageList)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 max_messages = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &max_messages_)));
          set_has_max_messages();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_search_areas;
        break;
      }

      // repeated .DS3_Frpg2RequestMessage.BloodMessageDomainLimitData search_areas = 2;
      case 2: {
        if (tag == 18) {
         parse_search_areas:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_search_areas()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_search_areas;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestGetBloodMessageList)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestGetBloodMessageList)
  return false;
#undef DO_
}

void RequestGetBloodMessageList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestGetBloodMessageList)
  // required uint32 max_messages = 1;
  if (has_max_messages()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->max_messages(), output);
  }

  // repeated .DS3_Frpg2RequestMessage.BloodMessageDomainLimitData search_areas = 2;
  for (int i = 0; i < this->search_areas_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->search_areas(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestGetBloodMessageList)
}

int RequestGetBloodMessageList::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 max_messages = 1;
    if (has_max_messages()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->max_messages());
    }

  }
  // repeated .DS3_Frpg2RequestMessage.BloodMessageDomainLimitData search_areas = 2;
  total_size += 1 * this->search_areas_size();
  for (int i = 0; i < this->search_areas_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->search_areas(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestGetBloodMessageList::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestGetBloodMessageList*>(&from));
}

void RequestGetBloodMessageList::MergeFrom(const RequestGetBloodMessageList& from) {
  GOOGLE_CHECK_NE(&from, this);
  search_areas_.MergeFrom(from.search_areas_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_max_messages()) {
      set_max_messages(from.max_messages());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestGetBloodMessageList::CopyFrom(const RequestGetBloodMessageList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestGetBloodMessageList::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->search_areas())) return false;
  return true;
}

void RequestGetBloodMessageList::Swap(RequestGetBloodMessageList* other) {
  if (other != this) {
    std::swap(max_messages_, other->max_messages_);
    search_areas_.Swap(&other->search_areas_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestGetBloodMessageList::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestGetBloodMessageList";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestGetBloodMessageListResponse::kMessagesFieldNumber;
#endif  // !_MSC_VER

RequestGetBloodMessageListResponse::RequestGetBloodMessageListResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestGetBloodMessageListResponse)
}

void RequestGetBloodMessageListResponse::InitAsDefaultInstance() {
}

RequestGetBloodMessageListResponse::RequestGetBloodMessageListResponse(const RequestGetBloodMessageListResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestGetBloodMessageListResponse)
}

void RequestGetBloodMessageListResponse::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestGetBloodMessageListResponse::~RequestGetBloodMessageListResponse() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestGetBloodMessageListResponse)
  SharedDtor();
}

void RequestGetBloodMessageListResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestGetBloodMessageListResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestGetBloodMessageListResponse& RequestGetBloodMessageListResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestGetBloodMessageListResponse* RequestGetBloodMessageListResponse::default_instance_ = NULL;

RequestGetBloodMessageListResponse* RequestGetBloodMessageListResponse::New() const {
  return new RequestGetBloodMessageListResponse;
}

void RequestGetBloodMessageListResponse::Clear() {
  messages_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestGetBloodMessageListResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestGetBloodMessageListResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .DS3_Frpg2RequestMessage.BloodMessageData messages = 1;
      case 1: {
        if (tag == 10) {
         parse_messages:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_messages()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_messages;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestGetBloodMessageListResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestGetBloodMessageListResponse)
  return false;
#undef DO_
}

void RequestGetBloodMessageListResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestGetBloodMessageListResponse)
  // repeated .DS3_Frpg2RequestMessage.BloodMessageData messages = 1;
  for (int i = 0; i < this->messages_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->messages(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestGetBloodMessageListResponse)
}

int RequestGetBloodMessageListResponse::ByteSize() const {
  int total_size = 0;

  // repeated .DS3_Frpg2RequestMessage.BloodMessageData messages = 1;
  total_size += 1 * this->messages_size();
  for (int i = 0; i < this->messages_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->messages(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestGetBloodMessageListResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestGetBloodMessageListResponse*>(&from));
}

void RequestGetBloodMessageListResponse::MergeFrom(const RequestGetBloodMessageListResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  messages_.MergeFrom(from.messages_);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestGetBloodMessageListResponse::CopyFrom(const RequestGetBloodMessageListResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestGetBloodMessageListResponse::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->messages())) return false;
  return true;
}

void RequestGetBloodMessageListResponse::Swap(RequestGetBloodMessageListResponse* other) {
  if (other != this) {
    messages_.Swap(&other->messages_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestGetBloodMessageListResponse::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestGetBloodMessageListResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestEvaluateBloodMessage::kOnlineAreaIdFieldNumber;
const int RequestEvaluateBloodMessage::kMessageIdFieldNumber;
const int RequestEvaluateBloodMessage::kWasPoorFieldNumber;
#endif  // !_MSC_VER

RequestEvaluateBloodMessage::RequestEvaluateBloodMessage()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestEvaluateBloodMessage)
}

void RequestEvaluateBloodMessage::InitAsDefaultInstance() {
}

RequestEvaluateBloodMessage::RequestEvaluateBloodMessage(const RequestEvaluateBloodMessage& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestEvaluateBloodMessage)
}

void RequestEvaluateBloodMessage::SharedCtor() {
  _cached_size_ = 0;
  online_area_id_ = 0u;
  message_id_ = 0u;
  was_poor_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestEvaluateBloodMessage::~RequestEvaluateBloodMessage() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestEvaluateBloodMessage)
  SharedDtor();
}

void RequestEvaluateBloodMessage::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestEvaluateBloodMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestEvaluateBloodMessage& RequestEvaluateBloodMessage::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestEvaluateBloodMessage* RequestEvaluateBloodMessage::default_instance_ = NULL;

RequestEvaluateBloodMessage* RequestEvaluateBloodMessage::New() const {
  return new RequestEvaluateBloodMessage;
}

void RequestEvaluateBloodMessage::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<RequestEvaluateBloodMessage*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(online_area_id_, was_poor_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestEvaluateBloodMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestEvaluateBloodMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 online_area_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &online_area_id_)));
          set_has_online_area_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_message_id;
        break;
      }

      // required uint32 message_id = 2;
      case 2: {
        if (tag == 16) {
         parse_message_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &message_id_)));
          set_has_message_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_was_poor;
        break;
      }

      // required bool was_poor = 3;
      case 3: {
        if (tag == 24) {
         parse_was_poor:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &was_poor_)));
          set_has_was_poor();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestEvaluateBloodMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestEvaluateBloodMessage)
  return false;
#undef DO_
}

void RequestEvaluateBloodMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestEvaluateBloodMessage)
  // required uint32 online_area_id = 1;
  if (has_online_area_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->online_area_id(), output);
  }

  // required uint32 message_id = 2;
  if (has_message_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->message_id(), output);
  }

  // required bool was_poor = 3;
  if (has_was_poor()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->was_poor(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestEvaluateBloodMessage)
}

int RequestEvaluateBloodMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 online_area_id = 1;
    if (has_online_area_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->online_area_id());
    }

    // required uint32 message_id = 2;
    if (has_message_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->message_id());
    }

    // required bool was_poor = 3;
    if (has_was_poor()) {
      total_size += 1 + 1;
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestEvaluateBloodMessage::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestEvaluateBloodMessage*>(&from));
}

void RequestEvaluateBloodMessage::MergeFrom(const RequestEvaluateBloodMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_online_area_id()) {
      set_online_area_id(from.online_area_id());
    }
    if (from.has_message_id()) {
      set_message_id(from.message_id());
    }
    if (from.has_was_poor()) {
      set_was_poor(from.was_poor());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestEvaluateBloodMessage::CopyFrom(const RequestEvaluateBloodMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestEvaluateBloodMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void RequestEvaluateBloodMessage::Swap(RequestEvaluateBloodMessage* other) {
  if (other != this) {
    std::swap(online_area_id_, other->online_area_id_);
    std::swap(message_id_, other->message_id_);
    std::swap(was_poor_, other->was_poor_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestEvaluateBloodMessage::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestEvaluateBloodMessage";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RequestEvaluateBloodMessageResponse::RequestEvaluateBloodMessageResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestEvaluateBloodMessageResponse)
}

void RequestEvaluateBloodMessageResponse::InitAsDefaultInstance() {
}

RequestEvaluateBloodMessageResponse::RequestEvaluateBloodMessageResponse(const RequestEvaluateBloodMessageResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestEvaluateBloodMessageResponse)
}

void RequestEvaluateBloodMessageResponse::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestEvaluateBloodMessageResponse::~RequestEvaluateBloodMessageResponse() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestEvaluateBloodMessageResponse)
  SharedDtor();
}

void RequestEvaluateBloodMessageResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestEvaluateBloodMessageResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestEvaluateBloodMessageResponse& RequestEvaluateBloodMessageResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestEvaluateBloodMessageResponse* RequestEvaluateBloodMessageResponse::default_instance_ = NULL;

RequestEvaluateBloodMessageResponse* RequestEvaluateBloodMessageResponse::New() const {
  return new RequestEvaluateBloodMessageResponse;
}

void RequestEvaluateBloodMessageResponse::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestEvaluateBloodMessageResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestEvaluateBloodMessageResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestEvaluateBloodMessageResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestEvaluateBloodMessageResponse)
  return false;
#undef DO_
}

void RequestEvaluateBloodMessageResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestEvaluateBloodMessageResponse)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestEvaluateBloodMessageResponse)
}

int RequestEvaluateBloodMessageResponse::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestEvaluateBloodMessageResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestEvaluateBloodMessageResponse*>(&from));
}

void RequestEvaluateBloodMessageResponse::MergeFrom(const RequestEvaluateBloodMessageResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestEvaluateBloodMessageResponse::CopyFrom(const RequestEvaluateBloodMessageResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestEvaluateBloodMessageResponse::IsInitialized() const {

  return true;
}

void RequestEvaluateBloodMessageResponse::Swap(RequestEvaluateBloodMessageResponse* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestEvaluateBloodMessageResponse::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestEvaluateBloodMessageResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestGetBloodMessageEvaluation::kMessagesFieldNumber;
#endif  // !_MSC_VER

RequestGetBloodMessageEvaluation::RequestGetBloodMessageEvaluation()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestGetBloodMessageEvaluation)
}

void RequestGetBloodMessageEvaluation::InitAsDefaultInstance() {
}

RequestGetBloodMessageEvaluation::RequestGetBloodMessageEvaluation(const RequestGetBloodMessageEvaluation& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestGetBloodMessageEvaluation)
}

void RequestGetBloodMessageEvaluation::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestGetBloodMessageEvaluation::~RequestGetBloodMessageEvaluation() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestGetBloodMessageEvaluation)
  SharedDtor();
}

void RequestGetBloodMessageEvaluation::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestGetBloodMessageEvaluation::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestGetBloodMessageEvaluation& RequestGetBloodMessageEvaluation::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestGetBloodMessageEvaluation* RequestGetBloodMessageEvaluation::default_instance_ = NULL;

RequestGetBloodMessageEvaluation* RequestGetBloodMessageEvaluation::New() const {
  return new RequestGetBloodMessageEvaluation;
}

void RequestGetBloodMessageEvaluation::Clear() {
  messages_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestGetBloodMessageEvaluation::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestGetBloodMessageEvaluation)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .DS3_Frpg2RequestMessage.LocatedBloodMessage messages = 1;
      case 1: {
        if (tag == 10) {
         parse_messages:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_messages()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_messages;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestGetBloodMessageEvaluation)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestGetBloodMessageEvaluation)
  return false;
#undef DO_
}

void RequestGetBloodMessageEvaluation::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestGetBloodMessageEvaluation)
  // repeated .DS3_Frpg2RequestMessage.LocatedBloodMessage messages = 1;
  for (int i = 0; i < this->messages_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->messages(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestGetBloodMessageEvaluation)
}

int RequestGetBloodMessageEvaluation::ByteSize() const {
  int total_size = 0;

  // repeated .DS3_Frpg2RequestMessage.LocatedBloodMessage messages = 1;
  total_size += 1 * this->messages_size();
  for (int i = 0; i < this->messages_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->messages(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestGetBloodMessageEvaluation::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestGetBloodMessageEvaluation*>(&from));
}

void RequestGetBloodMessageEvaluation::MergeFrom(const RequestGetBloodMessageEvaluation& from) {
  GOOGLE_CHECK_NE(&from, this);
  messages_.MergeFrom(from.messages_);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestGetBloodMessageEvaluation::CopyFrom(const RequestGetBloodMessageEvaluation& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestGetBloodMessageEvaluation::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->messages())) return false;
  return true;
}

void RequestGetBloodMessageEvaluation::Swap(RequestGetBloodMessageEvaluation* other) {
  if (other != this) {
    messages_.Swap(&other->messages_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestGetBloodMessageEvaluation::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestGetBloodMessageEvaluation";
}


// ===================================================================

#ifndef _MSC_VER
const int BloodMessageEvaluationData::kMessageIdFieldNumber;
const int BloodMessageEvaluationData::kGoodFieldNumber;
const int BloodMessageEvaluationData::kPoorFieldNumber;
#endif  // !_MSC_VER

BloodMessageEvaluationData::BloodMessageEvaluationData()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.BloodMessageEvaluationData)
}

void BloodMessageEvaluationData::InitAsDefaultInstance() {
}

BloodMessageEvaluationData::BloodMessageEvaluationData(const BloodMessageEvaluationData& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.BloodMessageEvaluationData)
}

void BloodMessageEvaluationData::SharedCtor() {
  _cached_size_ = 0;
  message_id_ = 0u;
  good_ = 0u;
  poor_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BloodMessageEvaluationData::~BloodMessageEvaluationData() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.BloodMessageEvaluationData)
  SharedDtor();
}

void BloodMessageEvaluationData::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void BloodMessageEvaluationData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BloodMessageEvaluationData& BloodMessageEvaluationData::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

BloodMessageEvaluationData* BloodMessageEvaluationData::default_instance_ = NULL;

BloodMessageEvaluationData* BloodMessageEvaluationData::New() const {
  return new BloodMessageEvaluationData;
}

void BloodMessageEvaluationData::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<BloodMessageEvaluationData*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(message_id_, poor_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool BloodMessageEvaluationData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.BloodMessageEvaluationData)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 message_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &message_id_)));
          set_has_message_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_good;
        break;
      }

      // required uint32 good = 2;
      case 2: {
        if (tag == 16) {
         parse_good:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &good_)));
          set_has_good();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_poor;
        break;
      }

      // required uint32 poor = 3;
      case 3: {
        if (tag == 24) {
         parse_poor:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &poor_)));
          set_has_poor();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.BloodMessageEvaluationData)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.BloodMessageEvaluationData)
  return false;
#undef DO_
}

void BloodMessageEvaluationData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.BloodMessageEvaluationData)
  // required uint32 message_id = 1;
  if (has_message_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->message_id(), output);
  }

  // required uint32 good = 2;
  if (has_good()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->good(), output);
  }

  // required uint32 poor = 3;
  if (has_poor()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->poor(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.BloodMessageEvaluationData)
}

int BloodMessageEvaluationData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 message_id = 1;
    if (has_message_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->message_id());
    }

    // required uint32 good = 2;
    if (has_good()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->good());
    }

    // required uint32 poor = 3;
    if (has_poor()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->poor());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BloodMessageEvaluationData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BloodMessageEvaluationData*>(&from));
}

void BloodMessageEvaluationData::MergeFrom(const BloodMessageEvaluationData& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_message_id()) {
      set_message_id(from.message_id());
    }
    if (from.has_good()) {
      set_good(from.good());
    }
    if (from.has_poor()) {
      set_poor(from.poor());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void BloodMessageEvaluationData::CopyFrom(const BloodMessageEvaluationData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BloodMessageEvaluationData::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void BloodMessageEvaluationData::Swap(BloodMessageEvaluationData* other) {
  if (other != this) {
    std::swap(message_id_, other->message_id_);
    std::swap(good_, other->good_);
    std::swap(poor_, other->poor_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string BloodMessageEvaluationData::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.BloodMessageEvaluationData";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestGetBloodMessageEvaluationResponse::kMessagesFieldNumber;
#endif  // !_MSC_VER

RequestGetBloodMessageEvaluationResponse::RequestGetBloodMessageEvaluationResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestGetBloodMessageEvaluationResponse)
}

void RequestGetBloodMessageEvaluationResponse::InitAsDefaultInstance() {
}

RequestGetBloodMessageEvaluationResponse::RequestGetBloodMessageEvaluationResponse(const RequestGetBloodMessageEvaluationResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestGetBloodMessageEvaluationResponse)
}

void RequestGetBloodMessageEvaluationResponse::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestGetBloodMessageEvaluationResponse::~RequestGetBloodMessageEvaluationResponse() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestGetBloodMessageEvaluationResponse)
  SharedDtor();
}

void RequestGetBloodMessageEvaluationResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestGetBloodMessageEvaluationResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestGetBloodMessageEvaluationResponse& RequestGetBloodMessageEvaluationResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestGetBloodMessageEvaluationResponse* RequestGetBloodMessageEvaluationResponse::default_instance_ = NULL;

RequestGetBloodMessageEvaluationResponse* RequestGetBloodMessageEvaluationResponse::New() const {
  return new RequestGetBloodMessageEvaluationResponse;
}

void RequestGetBloodMessageEvaluationResponse::Clear() {
  messages_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestGetBloodMessageEvaluationResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestGetBloodMessageEvaluationResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .DS3_Frpg2RequestMessage.BloodMessageEvaluationData messages = 1;
      case 1: {
        if (tag == 10) {
         parse_messages:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_messages()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_messages;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestGetBloodMessageEvaluationResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestGetBloodMessageEvaluationResponse)
  return false;
#undef DO_
}

void RequestGetBloodMessageEvaluationResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestGetBloodMessageEvaluationResponse)
  // repeated .DS3_Frpg2RequestMessage.BloodMessageEvaluationData messages = 1;
  for (int i = 0; i < this->messages_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->messages(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestGetBloodMessageEvaluationResponse)
}

int RequestGetBloodMessageEvaluationResponse::ByteSize() const {
  int total_size = 0;

  // repeated .DS3_Frpg2RequestMessage.BloodMessageEvaluationData messages = 1;
  total_size += 1 * this->messages_size();
  for (int i = 0; i < this->messages_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->messages(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestGetBloodMessageEvaluationResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestGetBloodMessageEvaluationResponse*>(&from));
}

void RequestGetBloodMessageEvaluationResponse::MergeFrom(const RequestGetBloodMessageEvaluationResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  messages_.MergeFrom(from.messages_);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestGetBloodMessageEvaluationResponse::CopyFrom(const RequestGetBloodMessageEvaluationResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestGetBloodMessageEvaluationResponse::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->messages())) return false;
  return true;
}

void RequestGetBloodMessageEvaluationResponse::Swap(RequestGetBloodMessageEvaluationResponse* other) {
  if (other != this) {
    messages_.Swap(&other->messages_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestGetBloodMessageEvaluationResponse::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestGetBloodMessageEvaluationResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int PushRequestEvaluateBloodMessage::kPushMessageIdFieldNumber;
const int PushRequestEvaluateBloodMessage::kPlayerIdFieldNumber;
const int PushRequestEvaluateBloodMessage::kMessageIdFieldNumber;
const int PushRequestEvaluateBloodMessage::kPlayerSteamIdFieldNumber;
const int PushRequestEvaluateBloodMessage::kWasPoorFieldNumber;
#endif  // !_MSC_VER

PushRequestEvaluateBloodMessage::PushRequestEvaluateBloodMessage()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.PushRequestEvaluateBloodMessage)
}

void PushRequestEvaluateBloodMessage::InitAsDefaultInstance() {
}

PushRequestEvaluateBloodMessage::PushRequestEvaluateBloodMessage(const PushRequestEvaluateBloodMessage& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.PushRequestEvaluateBloodMessage)
}

void PushRequestEvaluateBloodMessage::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  push_message_id_ = 829;
  player_id_ = 0u;
  message_id_ = 0u;
  player_steam_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  was_poor_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PushRequestEvaluateBloodMessage::~PushRequestEvaluateBloodMessage() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.PushRequestEvaluateBloodMessage)
  SharedDtor();
}

void PushRequestEvaluateBloodMessage::SharedDtor() {
  if (player_steam_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete player_steam_id_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void PushRequestEvaluateBloodMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PushRequestEvaluateBloodMessage& PushRequestEvaluateBloodMessage::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

PushRequestEvaluateBloodMessage* PushRequestEvaluateBloodMessage::default_instance_ = NULL;

PushRequestEvaluateBloodMessage* PushRequestEvaluateBloodMessage::New() const {
  return new PushRequestEvaluateBloodMessage;
}

void PushRequestEvaluateBloodMessage::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<PushRequestEvaluateBloodMessage*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 31) {
    ZR_(message_id_, was_poor_);
    push_message_id_ = 829;
    player_id_ = 0u;
    if (has_player_steam_id()) {
      if (player_steam_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        player_steam_id_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool PushRequestEvaluateBloodMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.PushRequestEvaluateBloodMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::DS3_Frpg2RequestMessage::PushMessageId_IsValid(value)) {
            set_push_message_id(static_cast< ::DS3_Frpg2RequestMessage::PushMessageId >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_player_id;
        break;
      }

      // required uint32 player_id = 2;
      case 2: {
        if (tag == 16) {
         parse_player_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &player_id_)));
          set_has_player_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_message_id;
        break;
      }

      // required uint32 message_id = 3;
      case 3: {
        if (tag == 24) {
         parse_message_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &message_id_)));
          set_has_message_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_player_steam_id;
        break;
      }

      // required string player_steam_id = 4;
      case 4: {
        if (tag == 34) {
         parse_player_steam_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_player_steam_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_was_poor;
        break;
      }

      // required bool was_poor = 5;
      case 5: {
        if (tag == 40) {
         parse_was_poor:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &was_poor_)));
          set_has_was_poor();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.PushRequestEvaluateBloodMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.PushRequestEvaluateBloodMessage)
  return false;
#undef DO_
}

void PushRequestEvaluateBloodMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.PushRequestEvaluateBloodMessage)
  // required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
  if (has_push_message_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->push_message_id(), output);
  }

  // required uint32 player_id = 2;
  if (has_player_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->player_id(), output);
  }

  // required uint32 message_id = 3;
  if (has_message_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->message_id(), output);
  }

  // required string player_steam_id = 4;
  if (has_player_steam_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->player_steam_id(), output);
  }

  // required bool was_poor = 5;
  if (has_was_poor()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->was_poor(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.PushRequestEvaluateBloodMessage)
}

int PushRequestEvaluateBloodMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
    if (has_push_message_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->push_message_id());
    }

    // required uint32 player_id = 2;
    if (has_player_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->player_id());
    }

    // required uint32 message_id = 3;
    if (has_message_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->message_id());
    }

    // required string player_steam_id = 4;
    if (has_player_steam_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->player_steam_id());
    }

    // required bool was_poor = 5;
    if (has_was_poor()) {
      total_size += 1 + 1;
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PushRequestEvaluateBloodMessage::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PushRequestEvaluateBloodMessage*>(&from));
}

void PushRequestEvaluateBloodMessage::MergeFrom(const PushRequestEvaluateBloodMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_push_message_id()) {
      set_push_message_id(from.push_message_id());
    }
    if (from.has_player_id()) {
      set_player_id(from.player_id());
    }
    if (from.has_message_id()) {
      set_message_id(from.message_id());
    }
    if (from.has_player_steam_id()) {
      set_player_steam_id(from.player_steam_id());
    }
    if (from.has_was_poor()) {
      set_was_poor(from.was_poor());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void PushRequestEvaluateBloodMessage::CopyFrom(const PushRequestEvaluateBloodMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PushRequestEvaluateBloodMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;

  return true;
}

void PushRequestEvaluateBloodMessage::Swap(PushRequestEvaluateBloodMessage* other) {
  if (other != this) {
    std::swap(push_message_id_, other->push_message_id_);
    std::swap(player_id_, other->player_id_);
    std::swap(message_id_, other->message_id_);
    std::swap(player_steam_id_, other->player_steam_id_);
    std::swap(was_poor_, other->was_poor_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PushRequestEvaluateBloodMessage::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.PushRequestEvaluateBloodMessage";
}


// ===================================================================

#ifndef _MSC_VER
const int BloodstainInfo::kOnlineAreaIdFieldNumber;
const int BloodstainInfo::kBloodstainIdFieldNumber;
const int BloodstainInfo::kDataFieldNumber;
#endif  // !_MSC_VER

BloodstainInfo::BloodstainInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.BloodstainInfo)
}

void BloodstainInfo::InitAsDefaultInstance() {
}

BloodstainInfo::BloodstainInfo(const BloodstainInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.BloodstainInfo)
}

void BloodstainInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  online_area_id_ = 0u;
  bloodstain_id_ = 0u;
  data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BloodstainInfo::~BloodstainInfo() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.BloodstainInfo)
  SharedDtor();
}

void BloodstainInfo::SharedDtor() {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void BloodstainInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BloodstainInfo& BloodstainInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

BloodstainInfo* BloodstainInfo::default_instance_ = NULL;

BloodstainInfo* BloodstainInfo::New() const {
  return new BloodstainInfo;
}

void BloodstainInfo::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<BloodstainInfo*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 7) {
    ZR_(online_area_id_, bloodstain_id_);
    if (has_data()) {
      if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        data_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool BloodstainInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.BloodstainInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 online_area_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &online_area_id_)));
          set_has_online_area_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_bloodstain_id;
        break;
      }

      // required uint32 bloodstain_id = 2;
      case 2: {
        if (tag == 16) {
         parse_bloodstain_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &bloodstain_id_)));
          set_has_bloodstain_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_data;
        break;
      }

      // required bytes data = 3;
      case 3: {
        if (tag == 26) {
         parse_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.BloodstainInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.BloodstainInfo)
  return false;
#undef DO_
}

void BloodstainInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.BloodstainInfo)
  // required uint32 online_area_id = 1;
  if (has_online_area_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->online_area_id(), output);
  }

  // required uint32 bloodstain_id = 2;
  if (has_bloodstain_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->bloodstain_id(), output);
  }

  // required bytes data = 3;
  if (has_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.BloodstainInfo)
}

int BloodstainInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 online_area_id = 1;
    if (has_online_area_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->online_area_id());
    }

    // required uint32 bloodstain_id = 2;
    if (has_bloodstain_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->bloodstain_id());
    }

    // required bytes data = 3;
    if (has_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->data());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BloodstainInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BloodstainInfo*>(&from));
}

void BloodstainInfo::MergeFrom(const BloodstainInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_online_area_id()) {
      set_online_area_id(from.online_area_id());
    }
    if (from.has_bloodstain_id()) {
      set_bloodstain_id(from.bloodstain_id());
    }
    if (from.has_data()) {
      set_data(from.data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void BloodstainInfo::CopyFrom(const BloodstainInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BloodstainInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void BloodstainInfo::Swap(BloodstainInfo* other) {
  if (other != this) {
    std::swap(online_area_id_, other->online_area_id_);
    std::swap(bloodstain_id_, other->bloodstain_id_);
    std::swap(data_, other->data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string BloodstainInfo::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.BloodstainInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestCreateBloodstain::kOnlineAreaIdFieldNumber;
const int RequestCreateBloodstain::kDataFieldNumber;
const int RequestCreateBloodstain::kGhostDataFieldNumber;
#endif  // !_MSC_VER

RequestCreateBloodstain::RequestCreateBloodstain()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestCreateBloodstain)
}

void RequestCreateBloodstain::InitAsDefaultInstance() {
}

RequestCreateBloodstain::RequestCreateBloodstain(const RequestCreateBloodstain& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestCreateBloodstain)
}

void RequestCreateBloodstain::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  online_area_id_ = 0u;
  data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ghost_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestCreateBloodstain::~RequestCreateBloodstain() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestCreateBloodstain)
  SharedDtor();
}

void RequestCreateBloodstain::SharedDtor() {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  if (ghost_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ghost_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestCreateBloodstain::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestCreateBloodstain& RequestCreateBloodstain::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestCreateBloodstain* RequestCreateBloodstain::default_instance_ = NULL;

RequestCreateBloodstain* RequestCreateBloodstain::New() const {
  return new RequestCreateBloodstain;
}

void RequestCreateBloodstain::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    online_area_id_ = 0u;
    if (has_data()) {
      if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        data_->clear();
      }
    }
    if (has_ghost_data()) {
      if (ghost_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        ghost_data_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestCreateBloodstain::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestCreateBloodstain)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 online_area_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &online_area_id_)));
          set_has_online_area_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_data;
        break;
      }

      // required bytes data = 2;
      case 2: {
        if (tag == 18) {
         parse_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_ghost_data;
        break;
      }

      // required bytes ghost_data = 3;
      case 3: {
        if (tag == 26) {
         parse_ghost_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_ghost_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestCreateBloodstain)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestCreateBloodstain)
  return false;
#undef DO_
}

void RequestCreateBloodstain::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestCreateBloodstain)
  // required uint32 online_area_id = 1;
  if (has_online_area_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->online_area_id(), output);
  }

  // required bytes data = 2;
  if (has_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->data(), output);
  }

  // required bytes ghost_data = 3;
  if (has_ghost_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->ghost_data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestCreateBloodstain)
}

int RequestCreateBloodstain::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 online_area_id = 1;
    if (has_online_area_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->online_area_id());
    }

    // required bytes data = 2;
    if (has_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->data());
    }

    // required bytes ghost_data = 3;
    if (has_ghost_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->ghost_data());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestCreateBloodstain::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestCreateBloodstain*>(&from));
}

void RequestCreateBloodstain::MergeFrom(const RequestCreateBloodstain& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_online_area_id()) {
      set_online_area_id(from.online_area_id());
    }
    if (from.has_data()) {
      set_data(from.data());
    }
    if (from.has_ghost_data()) {
      set_ghost_data(from.ghost_data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestCreateBloodstain::CopyFrom(const RequestCreateBloodstain& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestCreateBloodstain::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void RequestCreateBloodstain::Swap(RequestCreateBloodstain* other) {
  if (other != this) {
    std::swap(online_area_id_, other->online_area_id_);
    std::swap(data_, other->data_);
    std::swap(ghost_data_, other->ghost_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestCreateBloodstain::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestCreateBloodstain";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestGetBloodstainList::kMaxStainsFieldNumber;
const int RequestGetBloodstainList::kSearchAreasFieldNumber;
#endif  // !_MSC_VER

RequestGetBloodstainList::RequestGetBloodstainList()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestGetBloodstainList)
}

void RequestGetBloodstainList::InitAsDefaultInstance() {
}

RequestGetBloodstainList::RequestGetBloodstainList(const RequestGetBloodstainList& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestGetBloodstainList)
}

void RequestGetBloodstainList::SharedCtor() {
  _cached_size_ = 0;
  max_stains_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestGetBloodstainList::~RequestGetBloodstainList() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestGetBloodstainList)
  SharedDtor();
}

void RequestGetBloodstainList::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestGetBloodstainList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestGetBloodstainList& RequestGetBloodstainList::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestGetBloodstainList* RequestGetBloodstainList::default_instance_ = NULL;

RequestGetBloodstainList* RequestGetBloodstainList::New() const {
  return new RequestGetBloodstainList;
}

void RequestGetBloodstainList::Clear() {
  max_stains_ = 0u;
  search_areas_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestGetBloodstainList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestGetBloodstainList)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 max_stains = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &max_stains_)));
          set_has_max_stains();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_search_areas;
        break;
      }

      // repeated .DS3_Frpg2RequestMessage.DomainLimitData search_areas = 2;
      case 2: {
        if (tag == 18) {
         parse_search_areas:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_search_areas()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_search_areas;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestGetBloodstainList)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestGetBloodstainList)
  return false;
#undef DO_
}

void RequestGetBloodstainList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestGetBloodstainList)
  // required uint32 max_stains = 1;
  if (has_max_stains()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->max_stains(), output);
  }

  // repeated .DS3_Frpg2RequestMessage.DomainLimitData search_areas = 2;
  for (int i = 0; i < this->search_areas_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->search_areas(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestGetBloodstainList)
}

int RequestGetBloodstainList::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 max_stains = 1;
    if (has_max_stains()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->max_stains());
    }

  }
  // repeated .DS3_Frpg2RequestMessage.DomainLimitData search_areas = 2;
  total_size += 1 * this->search_areas_size();
  for (int i = 0; i < this->search_areas_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->search_areas(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestGetBloodstainList::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestGetBloodstainList*>(&from));
}

void RequestGetBloodstainList::MergeFrom(const RequestGetBloodstainList& from) {
  GOOGLE_CHECK_NE(&from, this);
  search_areas_.MergeFrom(from.search_areas_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_max_stains()) {
      set_max_stains(from.max_stains());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestGetBloodstainList::CopyFrom(const RequestGetBloodstainList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestGetBloodstainList::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->search_areas())) return false;
  return true;
}

void RequestGetBloodstainList::Swap(RequestGetBloodstainList* other) {
  if (other != this) {
    std::swap(max_stains_, other->max_stains_);
    search_areas_.Swap(&other->search_areas_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestGetBloodstainList::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestGetBloodstainList";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestGetBloodstainListResponse::kBloodstainsFieldNumber;
#endif  // !_MSC_VER

RequestGetBloodstainListResponse::RequestGetBloodstainListResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestGetBloodstainListResponse)
}

void RequestGetBloodstainListResponse::InitAsDefaultInstance() {
}

RequestGetBloodstainListResponse::RequestGetBloodstainListResponse(const RequestGetBloodstainListResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestGetBloodstainListResponse)
}

void RequestGetBloodstainListResponse::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestGetBloodstainListResponse::~RequestGetBloodstainListResponse() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestGetBloodstainListResponse)
  SharedDtor();
}

void RequestGetBloodstainListResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestGetBloodstainListResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestGetBloodstainListResponse& RequestGetBloodstainListResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestGetBloodstainListResponse* RequestGetBloodstainListResponse::default_instance_ = NULL;

RequestGetBloodstainListResponse* RequestGetBloodstainListResponse::New() const {
  return new RequestGetBloodstainListResponse;
}

void RequestGetBloodstainListResponse::Clear() {
  bloodstains_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestGetBloodstainListResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestGetBloodstainListResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .DS3_Frpg2RequestMessage.BloodstainInfo bloodstains = 1;
      case 1: {
        if (tag == 10) {
         parse_bloodstains:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_bloodstains()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_bloodstains;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestGetBloodstainListResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestGetBloodstainListResponse)
  return false;
#undef DO_
}

void RequestGetBloodstainListResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestGetBloodstainListResponse)
  // repeated .DS3_Frpg2RequestMessage.BloodstainInfo bloodstains = 1;
  for (int i = 0; i < this->bloodstains_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->bloodstains(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestGetBloodstainListResponse)
}

int RequestGetBloodstainListResponse::ByteSize() const {
  int total_size = 0;

  // repeated .DS3_Frpg2RequestMessage.BloodstainInfo bloodstains = 1;
  total_size += 1 * this->bloodstains_size();
  for (int i = 0; i < this->bloodstains_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->bloodstains(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestGetBloodstainListResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestGetBloodstainListResponse*>(&from));
}

void RequestGetBloodstainListResponse::MergeFrom(const RequestGetBloodstainListResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  bloodstains_.MergeFrom(from.bloodstains_);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestGetBloodstainListResponse::CopyFrom(const RequestGetBloodstainListResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestGetBloodstainListResponse::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->bloodstains())) return false;
  return true;
}

void RequestGetBloodstainListResponse::Swap(RequestGetBloodstainListResponse* other) {
  if (other != this) {
    bloodstains_.Swap(&other->bloodstains_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestGetBloodstainListResponse::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestGetBloodstainListResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestGetDeadingGhost::kOnlineAreaIdFieldNumber;
const int RequestGetDeadingGhost::kBloodstainIdFieldNumber;
#endif  // !_MSC_VER

RequestGetDeadingGhost::RequestGetDeadingGhost()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestGetDeadingGhost)
}

void RequestGetDeadingGhost::InitAsDefaultInstance() {
}

RequestGetDeadingGhost::RequestGetDeadingGhost(const RequestGetDeadingGhost& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestGetDeadingGhost)
}

void RequestGetDeadingGhost::SharedCtor() {
  _cached_size_ = 0;
  online_area_id_ = 0u;
  bloodstain_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestGetDeadingGhost::~RequestGetDeadingGhost() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestGetDeadingGhost)
  SharedDtor();
}

void RequestGetDeadingGhost::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestGetDeadingGhost::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestGetDeadingGhost& RequestGetDeadingGhost::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestGetDeadingGhost* RequestGetDeadingGhost::default_instance_ = NULL;

RequestGetDeadingGhost* RequestGetDeadingGhost::New() const {
  return new RequestGetDeadingGhost;
}

void RequestGetDeadingGhost::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<RequestGetDeadingGhost*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(online_area_id_, bloodstain_id_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestGetDeadingGhost::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestGetDeadingGhost)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 online_area_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &online_area_id_)));
          set_has_online_area_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_bloodstain_id;
        break;
      }

      // required uint32 bloodstain_id = 2;
      case 2: {
        if (tag == 16) {
         parse_bloodstain_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &bloodstain_id_)));
          set_has_bloodstain_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestGetDeadingGhost)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestGetDeadingGhost)
  return false;
#undef DO_
}

void RequestGetDeadingGhost::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestGetDeadingGhost)
  // required uint32 online_area_id = 1;
  if (has_online_area_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->online_area_id(), output);
  }

  // required uint32 bloodstain_id = 2;
  if (has_bloodstain_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->bloodstain_id(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestGetDeadingGhost)
}

int RequestGetDeadingGhost::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 online_area_id = 1;
    if (has_online_area_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->online_area_id());
    }

    // required uint32 bloodstain_id = 2;
    if (has_bloodstain_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->bloodstain_id());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestGetDeadingGhost::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestGetDeadingGhost*>(&from));
}

void RequestGetDeadingGhost::MergeFrom(const RequestGetDeadingGhost& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_online_area_id()) {
      set_online_area_id(from.online_area_id());
    }
    if (from.has_bloodstain_id()) {
      set_bloodstain_id(from.bloodstain_id());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestGetDeadingGhost::CopyFrom(const RequestGetDeadingGhost& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestGetDeadingGhost::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void RequestGetDeadingGhost::Swap(RequestGetDeadingGhost* other) {
  if (other != this) {
    std::swap(online_area_id_, other->online_area_id_);
    std::swap(bloodstain_id_, other->bloodstain_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestGetDeadingGhost::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestGetDeadingGhost";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestGetDeadingGhostResponse::kOnlineAreaIdFieldNumber;
const int RequestGetDeadingGhostResponse::kBloodstainIdFieldNumber;
const int RequestGetDeadingGhostResponse::kDataFieldNumber;
#endif  // !_MSC_VER

RequestGetDeadingGhostResponse::RequestGetDeadingGhostResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestGetDeadingGhostResponse)
}

void RequestGetDeadingGhostResponse::InitAsDefaultInstance() {
}

RequestGetDeadingGhostResponse::RequestGetDeadingGhostResponse(const RequestGetDeadingGhostResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestGetDeadingGhostResponse)
}

void RequestGetDeadingGhostResponse::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  online_area_id_ = 0u;
  bloodstain_id_ = 0u;
  data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestGetDeadingGhostResponse::~RequestGetDeadingGhostResponse() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestGetDeadingGhostResponse)
  SharedDtor();
}

void RequestGetDeadingGhostResponse::SharedDtor() {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestGetDeadingGhostResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestGetDeadingGhostResponse& RequestGetDeadingGhostResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestGetDeadingGhostResponse* RequestGetDeadingGhostResponse::default_instance_ = NULL;

RequestGetDeadingGhostResponse* RequestGetDeadingGhostResponse::New() const {
  return new RequestGetDeadingGhostResponse;
}

void RequestGetDeadingGhostResponse::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<RequestGetDeadingGhostResponse*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 7) {
    ZR_(online_area_id_, bloodstain_id_);
    if (has_data()) {
      if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        data_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestGetDeadingGhostResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestGetDeadingGhostResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 online_area_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &online_area_id_)));
          set_has_online_area_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_bloodstain_id;
        break;
      }

      // required uint32 bloodstain_id = 2;
      case 2: {
        if (tag == 16) {
         parse_bloodstain_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &bloodstain_id_)));
          set_has_bloodstain_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_data;
        break;
      }

      // required bytes data = 3;
      case 3: {
        if (tag == 26) {
         parse_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestGetDeadingGhostResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestGetDeadingGhostResponse)
  return false;
#undef DO_
}

void RequestGetDeadingGhostResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestGetDeadingGhostResponse)
  // required uint32 online_area_id = 1;
  if (has_online_area_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->online_area_id(), output);
  }

  // required uint32 bloodstain_id = 2;
  if (has_bloodstain_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->bloodstain_id(), output);
  }

  // required bytes data = 3;
  if (has_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestGetDeadingGhostResponse)
}

int RequestGetDeadingGhostResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 online_area_id = 1;
    if (has_online_area_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->online_area_id());
    }

    // required uint32 bloodstain_id = 2;
    if (has_bloodstain_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->bloodstain_id());
    }

    // required bytes data = 3;
    if (has_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->data());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestGetDeadingGhostResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestGetDeadingGhostResponse*>(&from));
}

void RequestGetDeadingGhostResponse::MergeFrom(const RequestGetDeadingGhostResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_online_area_id()) {
      set_online_area_id(from.online_area_id());
    }
    if (from.has_bloodstain_id()) {
      set_bloodstain_id(from.bloodstain_id());
    }
    if (from.has_data()) {
      set_data(from.data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestGetDeadingGhostResponse::CopyFrom(const RequestGetDeadingGhostResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestGetDeadingGhostResponse::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void RequestGetDeadingGhostResponse::Swap(RequestGetDeadingGhostResponse* other) {
  if (other != this) {
    std::swap(online_area_id_, other->online_area_id_);
    std::swap(bloodstain_id_, other->bloodstain_id_);
    std::swap(data_, other->data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestGetDeadingGhostResponse::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestGetDeadingGhostResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int LogCommonInfo_1::kUnknown1FieldNumber;
const int LogCommonInfo_1::kUnknown2FieldNumber;
#endif  // !_MSC_VER

LogCommonInfo_1::LogCommonInfo_1()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.LogCommonInfo_1)
}

void LogCommonInfo_1::InitAsDefaultInstance() {
}

LogCommonInfo_1::LogCommonInfo_1(const LogCommonInfo_1& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.LogCommonInfo_1)
}

void LogCommonInfo_1::SharedCtor() {
  _cached_size_ = 0;
  unknown_1_ = 0u;
  unknown_2_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LogCommonInfo_1::~LogCommonInfo_1() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.LogCommonInfo_1)
  SharedDtor();
}

void LogCommonInfo_1::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void LogCommonInfo_1::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const LogCommonInfo_1& LogCommonInfo_1::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

LogCommonInfo_1* LogCommonInfo_1::default_instance_ = NULL;

LogCommonInfo_1* LogCommonInfo_1::New() const {
  return new LogCommonInfo_1;
}

void LogCommonInfo_1::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<LogCommonInfo_1*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(unknown_1_, unknown_2_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool LogCommonInfo_1::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.LogCommonInfo_1)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 unknown_1 = 34;
      case 34: {
        if (tag == 272) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_1_)));
          set_has_unknown_1();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(296)) goto parse_unknown_2;
        break;
      }

      // required uint32 unknown_2 = 37;
      case 37: {
        if (tag == 296) {
         parse_unknown_2:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_2_)));
          set_has_unknown_2();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.LogCommonInfo_1)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.LogCommonInfo_1)
  return false;
#undef DO_
}

void LogCommonInfo_1::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.LogCommonInfo_1)
  // required uint32 unknown_1 = 34;
  if (has_unknown_1()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(34, this->unknown_1(), output);
  }

  // required uint32 unknown_2 = 37;
  if (has_unknown_2()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(37, this->unknown_2(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.LogCommonInfo_1)
}

int LogCommonInfo_1::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 unknown_1 = 34;
    if (has_unknown_1()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_1());
    }

    // required uint32 unknown_2 = 37;
    if (has_unknown_2()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_2());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LogCommonInfo_1::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const LogCommonInfo_1*>(&from));
}

void LogCommonInfo_1::MergeFrom(const LogCommonInfo_1& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_unknown_1()) {
      set_unknown_1(from.unknown_1());
    }
    if (from.has_unknown_2()) {
      set_unknown_2(from.unknown_2());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void LogCommonInfo_1::CopyFrom(const LogCommonInfo_1& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LogCommonInfo_1::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void LogCommonInfo_1::Swap(LogCommonInfo_1* other) {
  if (other != this) {
    std::swap(unknown_1_, other->unknown_1_);
    std::swap(unknown_2_, other->unknown_2_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string LogCommonInfo_1::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.LogCommonInfo_1";
}


// ===================================================================

#ifndef _MSC_VER
const int LogCommonInfo::kUnknown1FieldNumber;
const int LogCommonInfo::kUnknown2FieldNumber;
#endif  // !_MSC_VER

LogCommonInfo::LogCommonInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.LogCommonInfo)
}

void LogCommonInfo::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  unknown_1_ = const_cast< ::DS3_Frpg2RequestMessage::LogCommonInfo_1*>(
      ::DS3_Frpg2RequestMessage::LogCommonInfo_1::internal_default_instance());
#else
  unknown_1_ = const_cast< ::DS3_Frpg2RequestMessage::LogCommonInfo_1*>(&::DS3_Frpg2RequestMessage::LogCommonInfo_1::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  unknown_2_ = const_cast< ::DS3_Frpg2PlayerData::UnknownStruct1*>(
      ::DS3_Frpg2PlayerData::UnknownStruct1::internal_default_instance());
#else
  unknown_2_ = const_cast< ::DS3_Frpg2PlayerData::UnknownStruct1*>(&::DS3_Frpg2PlayerData::UnknownStruct1::default_instance());
#endif
}

LogCommonInfo::LogCommonInfo(const LogCommonInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.LogCommonInfo)
}

void LogCommonInfo::SharedCtor() {
  _cached_size_ = 0;
  unknown_1_ = NULL;
  unknown_2_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LogCommonInfo::~LogCommonInfo() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.LogCommonInfo)
  SharedDtor();
}

void LogCommonInfo::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete unknown_1_;
    delete unknown_2_;
  }
}

void LogCommonInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const LogCommonInfo& LogCommonInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

LogCommonInfo* LogCommonInfo::default_instance_ = NULL;

LogCommonInfo* LogCommonInfo::New() const {
  return new LogCommonInfo;
}

void LogCommonInfo::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_unknown_1()) {
      if (unknown_1_ != NULL) unknown_1_->::DS3_Frpg2RequestMessage::LogCommonInfo_1::Clear();
    }
    if (has_unknown_2()) {
      if (unknown_2_ != NULL) unknown_2_->::DS3_Frpg2PlayerData::UnknownStruct1::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool LogCommonInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.LogCommonInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .DS3_Frpg2RequestMessage.LogCommonInfo_1 unknown_1 = 3;
      case 3: {
        if (tag == 26) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_unknown_1()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_unknown_2;
        break;
      }

      // required .DS3_Frpg2PlayerData.UnknownStruct1 unknown_2 = 7;
      case 7: {
        if (tag == 58) {
         parse_unknown_2:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_unknown_2()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.LogCommonInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.LogCommonInfo)
  return false;
#undef DO_
}

void LogCommonInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.LogCommonInfo)
  // required .DS3_Frpg2RequestMessage.LogCommonInfo_1 unknown_1 = 3;
  if (has_unknown_1()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->unknown_1(), output);
  }

  // required .DS3_Frpg2PlayerData.UnknownStruct1 unknown_2 = 7;
  if (has_unknown_2()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      7, this->unknown_2(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.LogCommonInfo)
}

int LogCommonInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .DS3_Frpg2RequestMessage.LogCommonInfo_1 unknown_1 = 3;
    if (has_unknown_1()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->unknown_1());
    }

    // required .DS3_Frpg2PlayerData.UnknownStruct1 unknown_2 = 7;
    if (has_unknown_2()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->unknown_2());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LogCommonInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const LogCommonInfo*>(&from));
}

void LogCommonInfo::MergeFrom(const LogCommonInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_unknown_1()) {
      mutable_unknown_1()->::DS3_Frpg2RequestMessage::LogCommonInfo_1::MergeFrom(from.unknown_1());
    }
    if (from.has_unknown_2()) {
      mutable_unknown_2()->::DS3_Frpg2PlayerData::UnknownStruct1::MergeFrom(from.unknown_2());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void LogCommonInfo::CopyFrom(const LogCommonInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LogCommonInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_unknown_1()) {
    if (!this->unknown_1().IsInitialized()) return false;
  }
  return true;
}

void LogCommonInfo::Swap(LogCommonInfo* other) {
  if (other != this) {
    std::swap(unknown_1_, other->unknown_1_);
    std::swap(unknown_2_, other->unknown_2_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string LogCommonInfo::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.LogCommonInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int DomainLimitData::kOnlineAreaIdFieldNumber;
const int DomainLimitData::kMaxItemsFieldNumber;
#endif  // !_MSC_VER

DomainLimitData::DomainLimitData()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.DomainLimitData)
}

void DomainLimitData::InitAsDefaultInstance() {
}

DomainLimitData::DomainLimitData(const DomainLimitData& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.DomainLimitData)
}

void DomainLimitData::SharedCtor() {
  _cached_size_ = 0;
  online_area_id_ = 0u;
  max_items_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DomainLimitData::~DomainLimitData() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.DomainLimitData)
  SharedDtor();
}

void DomainLimitData::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void DomainLimitData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DomainLimitData& DomainLimitData::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

DomainLimitData* DomainLimitData::default_instance_ = NULL;

DomainLimitData* DomainLimitData::New() const {
  return new DomainLimitData;
}

void DomainLimitData::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<DomainLimitData*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(online_area_id_, max_items_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool DomainLimitData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.DomainLimitData)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 online_area_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &online_area_id_)));
          set_has_online_area_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_max_items;
        break;
      }

      // required uint32 max_items = 2;
      case 2: {
        if (tag == 16) {
         parse_max_items:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &max_items_)));
          set_has_max_items();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.DomainLimitData)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.DomainLimitData)
  return false;
#undef DO_
}

void DomainLimitData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.DomainLimitData)
  // required uint32 online_area_id = 1;
  if (has_online_area_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->online_area_id(), output);
  }

  // required uint32 max_items = 2;
  if (has_max_items()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->max_items(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.DomainLimitData)
}

int DomainLimitData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 online_area_id = 1;
    if (has_online_area_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->online_area_id());
    }

    // required uint32 max_items = 2;
    if (has_max_items()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->max_items());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DomainLimitData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DomainLimitData*>(&from));
}

void DomainLimitData::MergeFrom(const DomainLimitData& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_online_area_id()) {
      set_online_area_id(from.online_area_id());
    }
    if (from.has_max_items()) {
      set_max_items(from.max_items());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void DomainLimitData::CopyFrom(const DomainLimitData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DomainLimitData::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void DomainLimitData::Swap(DomainLimitData* other) {
  if (other != this) {
    std::swap(online_area_id_, other->online_area_id_);
    std::swap(max_items_, other->max_items_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string DomainLimitData::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.DomainLimitData";
}


// ===================================================================

#ifndef _MSC_VER
const int KillerInfo::kKillerPlayerIdFieldNumber;
const int KillerInfo::kUnknown2FieldNumber;
const int KillerInfo::kUnknown3FieldNumber;
const int KillerInfo::kUnknown4FieldNumber;
#endif  // !_MSC_VER

KillerInfo::KillerInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.KillerInfo)
}

void KillerInfo::InitAsDefaultInstance() {
}

KillerInfo::KillerInfo(const KillerInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.KillerInfo)
}

void KillerInfo::SharedCtor() {
  _cached_size_ = 0;
  killer_player_id_ = 0u;
  unknown_2_ = 0u;
  unknown_3_ = 0u;
  unknown_4_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

KillerInfo::~KillerInfo() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.KillerInfo)
  SharedDtor();
}

void KillerInfo::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void KillerInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const KillerInfo& KillerInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

KillerInfo* KillerInfo::default_instance_ = NULL;

KillerInfo* KillerInfo::New() const {
  return new KillerInfo;
}

void KillerInfo::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<KillerInfo*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(killer_player_id_, unknown_4_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool KillerInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.KillerInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 killer_player_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &killer_player_id_)));
          set_has_killer_player_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_unknown_2;
        break;
      }

      // required uint32 unknown_2 = 2;
      case 2: {
        if (tag == 16) {
         parse_unknown_2:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_2_)));
          set_has_unknown_2();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_unknown_3;
        break;
      }

      // required uint32 unknown_3 = 3;
      case 3: {
        if (tag == 24) {
         parse_unknown_3:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_3_)));
          set_has_unknown_3();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_unknown_4;
        break;
      }

      // required uint32 unknown_4 = 4;
      case 4: {
        if (tag == 32) {
         parse_unknown_4:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_4_)));
          set_has_unknown_4();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.KillerInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.KillerInfo)
  return false;
#undef DO_
}

void KillerInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.KillerInfo)
  // required uint32 killer_player_id = 1;
  if (has_killer_player_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->killer_player_id(), output);
  }

  // required uint32 unknown_2 = 2;
  if (has_unknown_2()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->unknown_2(), output);
  }

  // required uint32 unknown_3 = 3;
  if (has_unknown_3()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->unknown_3(), output);
  }

  // required uint32 unknown_4 = 4;
  if (has_unknown_4()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->unknown_4(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.KillerInfo)
}

int KillerInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 killer_player_id = 1;
    if (has_killer_player_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->killer_player_id());
    }

    // required uint32 unknown_2 = 2;
    if (has_unknown_2()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_2());
    }

    // required uint32 unknown_3 = 3;
    if (has_unknown_3()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_3());
    }

    // required uint32 unknown_4 = 4;
    if (has_unknown_4()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_4());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void KillerInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const KillerInfo*>(&from));
}

void KillerInfo::MergeFrom(const KillerInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_killer_player_id()) {
      set_killer_player_id(from.killer_player_id());
    }
    if (from.has_unknown_2()) {
      set_unknown_2(from.unknown_2());
    }
    if (from.has_unknown_3()) {
      set_unknown_3(from.unknown_3());
    }
    if (from.has_unknown_4()) {
      set_unknown_4(from.unknown_4());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void KillerInfo::CopyFrom(const KillerInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KillerInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void KillerInfo::Swap(KillerInfo* other) {
  if (other != this) {
    std::swap(killer_player_id_, other->killer_player_id_);
    std::swap(unknown_2_, other->unknown_2_);
    std::swap(unknown_3_, other->unknown_3_);
    std::swap(unknown_4_, other->unknown_4_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string KillerInfo::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.KillerInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int KillEnemyInfo::kEnemyTypeIdFieldNumber;
const int KillEnemyInfo::kCountFieldNumber;
#endif  // !_MSC_VER

KillEnemyInfo::KillEnemyInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.KillEnemyInfo)
}

void KillEnemyInfo::InitAsDefaultInstance() {
}

KillEnemyInfo::KillEnemyInfo(const KillEnemyInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.KillEnemyInfo)
}

void KillEnemyInfo::SharedCtor() {
  _cached_size_ = 0;
  enemy_type_id_ = 0u;
  count_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

KillEnemyInfo::~KillEnemyInfo() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.KillEnemyInfo)
  SharedDtor();
}

void KillEnemyInfo::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void KillEnemyInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const KillEnemyInfo& KillEnemyInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

KillEnemyInfo* KillEnemyInfo::default_instance_ = NULL;

KillEnemyInfo* KillEnemyInfo::New() const {
  return new KillEnemyInfo;
}

void KillEnemyInfo::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<KillEnemyInfo*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(enemy_type_id_, count_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool KillEnemyInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.KillEnemyInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 enemy_type_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &enemy_type_id_)));
          set_has_enemy_type_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_count;
        break;
      }

      // required uint32 count = 2;
      case 2: {
        if (tag == 16) {
         parse_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &count_)));
          set_has_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.KillEnemyInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.KillEnemyInfo)
  return false;
#undef DO_
}

void KillEnemyInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.KillEnemyInfo)
  // required uint32 enemy_type_id = 1;
  if (has_enemy_type_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->enemy_type_id(), output);
  }

  // required uint32 count = 2;
  if (has_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->count(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.KillEnemyInfo)
}

int KillEnemyInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 enemy_type_id = 1;
    if (has_enemy_type_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->enemy_type_id());
    }

    // required uint32 count = 2;
    if (has_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->count());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void KillEnemyInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const KillEnemyInfo*>(&from));
}

void KillEnemyInfo::MergeFrom(const KillEnemyInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_enemy_type_id()) {
      set_enemy_type_id(from.enemy_type_id());
    }
    if (from.has_count()) {
      set_count(from.count());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void KillEnemyInfo::CopyFrom(const KillEnemyInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KillEnemyInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void KillEnemyInfo::Swap(KillEnemyInfo* other) {
  if (other != this) {
    std::swap(enemy_type_id_, other->enemy_type_id_);
    std::swap(count_, other->count_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string KillEnemyInfo::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.KillEnemyInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int PartyMemberInfo::kPlayerIdFieldNumber;
const int PartyMemberInfo::kCharIdFieldNumber;
const int PartyMemberInfo::kUnknown2FieldNumber;
const int PartyMemberInfo::kUnknown4FieldNumber;
const int PartyMemberInfo::kUnknown5FieldNumber;
const int PartyMemberInfo::kUnknown6FieldNumber;
const int PartyMemberInfo::kUnknown7FieldNumber;
#endif  // !_MSC_VER

PartyMemberInfo::PartyMemberInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.PartyMemberInfo)
}

void PartyMemberInfo::InitAsDefaultInstance() {
}

PartyMemberInfo::PartyMemberInfo(const PartyMemberInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.PartyMemberInfo)
}

void PartyMemberInfo::SharedCtor() {
  _cached_size_ = 0;
  player_id_ = 0u;
  char_id_ = 0u;
  unknown_2_ = 0u;
  unknown_4_ = 0u;
  unknown_5_ = 0u;
  unknown_6_ = 0u;
  unknown_7_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PartyMemberInfo::~PartyMemberInfo() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.PartyMemberInfo)
  SharedDtor();
}

void PartyMemberInfo::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void PartyMemberInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PartyMemberInfo& PartyMemberInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

PartyMemberInfo* PartyMemberInfo::default_instance_ = NULL;

PartyMemberInfo* PartyMemberInfo::New() const {
  return new PartyMemberInfo;
}

void PartyMemberInfo::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<PartyMemberInfo*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 127) {
    ZR_(player_id_, unknown_7_);
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool PartyMemberInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.PartyMemberInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 player_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &player_id_)));
          set_has_player_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_char_id;
        break;
      }

      // required uint32 char_id = 2;
      case 2: {
        if (tag == 16) {
         parse_char_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &char_id_)));
          set_has_char_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_unknown_2;
        break;
      }

      // required uint32 unknown_2 = 3;
      case 3: {
        if (tag == 24) {
         parse_unknown_2:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_2_)));
          set_has_unknown_2();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_unknown_4;
        break;
      }

      // required uint32 unknown_4 = 4;
      case 4: {
        if (tag == 32) {
         parse_unknown_4:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_4_)));
          set_has_unknown_4();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_unknown_5;
        break;
      }

      // required uint32 unknown_5 = 5;
      case 5: {
        if (tag == 40) {
         parse_unknown_5:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_5_)));
          set_has_unknown_5();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_unknown_6;
        break;
      }

      // required uint32 unknown_6 = 6;
      case 6: {
        if (tag == 48) {
         parse_unknown_6:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_6_)));
          set_has_unknown_6();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_unknown_7;
        break;
      }

      // optional uint32 unknown_7 = 7;
      case 7: {
        if (tag == 56) {
         parse_unknown_7:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_7_)));
          set_has_unknown_7();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.PartyMemberInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.PartyMemberInfo)
  return false;
#undef DO_
}

void PartyMemberInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.PartyMemberInfo)
  // required uint32 player_id = 1;
  if (has_player_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->player_id(), output);
  }

  // required uint32 char_id = 2;
  if (has_char_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->char_id(), output);
  }

  // required uint32 unknown_2 = 3;
  if (has_unknown_2()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->unknown_2(), output);
  }

  // required uint32 unknown_4 = 4;
  if (has_unknown_4()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->unknown_4(), output);
  }

  // required uint32 unknown_5 = 5;
  if (has_unknown_5()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->unknown_5(), output);
  }

  // required uint32 unknown_6 = 6;
  if (has_unknown_6()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->unknown_6(), output);
  }

  // optional uint32 unknown_7 = 7;
  if (has_unknown_7()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->unknown_7(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.PartyMemberInfo)
}

int PartyMemberInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 player_id = 1;
    if (has_player_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->player_id());
    }

    // required uint32 char_id = 2;
    if (has_char_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->char_id());
    }

    // required uint32 unknown_2 = 3;
    if (has_unknown_2()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_2());
    }

    // required uint32 unknown_4 = 4;
    if (has_unknown_4()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_4());
    }

    // required uint32 unknown_5 = 5;
    if (has_unknown_5()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_5());
    }

    // required uint32 unknown_6 = 6;
    if (has_unknown_6()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_6());
    }

    // optional uint32 unknown_7 = 7;
    if (has_unknown_7()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_7());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PartyMemberInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PartyMemberInfo*>(&from));
}

void PartyMemberInfo::MergeFrom(const PartyMemberInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_player_id()) {
      set_player_id(from.player_id());
    }
    if (from.has_char_id()) {
      set_char_id(from.char_id());
    }
    if (from.has_unknown_2()) {
      set_unknown_2(from.unknown_2());
    }
    if (from.has_unknown_4()) {
      set_unknown_4(from.unknown_4());
    }
    if (from.has_unknown_5()) {
      set_unknown_5(from.unknown_5());
    }
    if (from.has_unknown_6()) {
      set_unknown_6(from.unknown_6());
    }
    if (from.has_unknown_7()) {
      set_unknown_7(from.unknown_7());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void PartyMemberInfo::CopyFrom(const PartyMemberInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PartyMemberInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003f) != 0x0000003f) return false;

  return true;
}

void PartyMemberInfo::Swap(PartyMemberInfo* other) {
  if (other != this) {
    std::swap(player_id_, other->player_id_);
    std::swap(char_id_, other->char_id_);
    std::swap(unknown_2_, other->unknown_2_);
    std::swap(unknown_4_, other->unknown_4_);
    std::swap(unknown_5_, other->unknown_5_);
    std::swap(unknown_6_, other->unknown_6_);
    std::swap(unknown_7_, other->unknown_7_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PartyMemberInfo::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.PartyMemberInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestNotifyProtoBufLog::kTypeFieldNumber;
const int RequestNotifyProtoBufLog::kCommonFieldNumber;
const int RequestNotifyProtoBufLog::kDataFieldNumber;
#endif  // !_MSC_VER

RequestNotifyProtoBufLog::RequestNotifyProtoBufLog()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestNotifyProtoBufLog)
}

void RequestNotifyProtoBufLog::InitAsDefaultInstance() {
}

RequestNotifyProtoBufLog::RequestNotifyProtoBufLog(const RequestNotifyProtoBufLog& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestNotifyProtoBufLog)
}

void RequestNotifyProtoBufLog::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  type_ = 2020;
  common_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestNotifyProtoBufLog::~RequestNotifyProtoBufLog() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestNotifyProtoBufLog)
  SharedDtor();
}

void RequestNotifyProtoBufLog::SharedDtor() {
  if (common_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete common_;
  }
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestNotifyProtoBufLog::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestNotifyProtoBufLog& RequestNotifyProtoBufLog::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestNotifyProtoBufLog* RequestNotifyProtoBufLog::default_instance_ = NULL;

RequestNotifyProtoBufLog* RequestNotifyProtoBufLog::New() const {
  return new RequestNotifyProtoBufLog;
}

void RequestNotifyProtoBufLog::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    type_ = 2020;
    if (has_common()) {
      if (common_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        common_->clear();
      }
    }
    if (has_data()) {
      if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        data_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestNotifyProtoBufLog::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestNotifyProtoBufLog)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .DS3_Frpg2RequestMessage.LogType type = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::DS3_Frpg2RequestMessage::LogType_IsValid(value)) {
            set_type(static_cast< ::DS3_Frpg2RequestMessage::LogType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_common;
        break;
      }

      // required bytes common = 2;
      case 2: {
        if (tag == 18) {
         parse_common:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_common()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_data;
        break;
      }

      // required bytes data = 3;
      case 3: {
        if (tag == 26) {
         parse_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestNotifyProtoBufLog)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestNotifyProtoBufLog)
  return false;
#undef DO_
}

void RequestNotifyProtoBufLog::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestNotifyProtoBufLog)
  // required .DS3_Frpg2RequestMessage.LogType type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // required bytes common = 2;
  if (has_common()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->common(), output);
  }

  // required bytes data = 3;
  if (has_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestNotifyProtoBufLog)
}

int RequestNotifyProtoBufLog::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .DS3_Frpg2RequestMessage.LogType type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // required bytes common = 2;
    if (has_common()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->common());
    }

    // required bytes data = 3;
    if (has_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->data());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestNotifyProtoBufLog::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestNotifyProtoBufLog*>(&from));
}

void RequestNotifyProtoBufLog::MergeFrom(const RequestNotifyProtoBufLog& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_common()) {
      set_common(from.common());
    }
    if (from.has_data()) {
      set_data(from.data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestNotifyProtoBufLog::CopyFrom(const RequestNotifyProtoBufLog& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestNotifyProtoBufLog::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void RequestNotifyProtoBufLog::Swap(RequestNotifyProtoBufLog* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(common_, other->common_);
    std::swap(data_, other->data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestNotifyProtoBufLog::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestNotifyProtoBufLog";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestNotifyDie::kUnknown1FieldNumber;
const int RequestNotifyDie::kMapIdFieldNumber;
const int RequestNotifyDie::kLocationFieldNumber;
const int RequestNotifyDie::kCauseOfDeathFieldNumber;
const int RequestNotifyDie::kSoulsDroppedFieldNumber;
const int RequestNotifyDie::kSoulsLostFieldNumber;
const int RequestNotifyDie::kActorIdFieldNumber;
const int RequestNotifyDie::kKillerInfoFieldNumber;
#endif  // !_MSC_VER

RequestNotifyDie::RequestNotifyDie()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestNotifyDie)
}

void RequestNotifyDie::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  location_ = const_cast< ::DS3_Frpg2PlayerData::Vector*>(
      ::DS3_Frpg2PlayerData::Vector::internal_default_instance());
#else
  location_ = const_cast< ::DS3_Frpg2PlayerData::Vector*>(&::DS3_Frpg2PlayerData::Vector::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  killer_info_ = const_cast< ::DS3_Frpg2RequestMessage::KillerInfo*>(
      ::DS3_Frpg2RequestMessage::KillerInfo::internal_default_instance());
#else
  killer_info_ = const_cast< ::DS3_Frpg2RequestMessage::KillerInfo*>(&::DS3_Frpg2RequestMessage::KillerInfo::default_instance());
#endif
}

RequestNotifyDie::RequestNotifyDie(const RequestNotifyDie& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestNotifyDie)
}

void RequestNotifyDie::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  unknown_1_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  map_id_ = 0u;
  location_ = NULL;
  cause_of_death_ = 0;
  souls_dropped_ = 0u;
  souls_lost_ = 0u;
  actor_id_ = 0u;
  killer_info_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestNotifyDie::~RequestNotifyDie() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestNotifyDie)
  SharedDtor();
}

void RequestNotifyDie::SharedDtor() {
  if (unknown_1_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete unknown_1_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete location_;
    delete killer_info_;
  }
}

void RequestNotifyDie::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestNotifyDie& RequestNotifyDie::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestNotifyDie* RequestNotifyDie::default_instance_ = NULL;

RequestNotifyDie* RequestNotifyDie::New() const {
  return new RequestNotifyDie;
}

void RequestNotifyDie::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<RequestNotifyDie*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(map_id_, souls_lost_);
    if (has_unknown_1()) {
      if (unknown_1_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        unknown_1_->clear();
      }
    }
    if (has_location()) {
      if (location_ != NULL) location_->::DS3_Frpg2PlayerData::Vector::Clear();
    }
    actor_id_ = 0u;
    if (has_killer_info()) {
      if (killer_info_ != NULL) killer_info_->::DS3_Frpg2RequestMessage::KillerInfo::Clear();
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestNotifyDie::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestNotifyDie)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string unknown_1 = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_unknown_1()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_map_id;
        break;
      }

      // required uint32 map_id = 2;
      case 2: {
        if (tag == 16) {
         parse_map_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &map_id_)));
          set_has_map_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_location;
        break;
      }

      // required .DS3_Frpg2PlayerData.Vector location = 3;
      case 3: {
        if (tag == 26) {
         parse_location:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_location()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_cause_of_death;
        break;
      }

      // required .DS3_Frpg2RequestMessage.CauseOfDeath cause_of_death = 4;
      case 4: {
        if (tag == 32) {
         parse_cause_of_death:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::DS3_Frpg2RequestMessage::CauseOfDeath_IsValid(value)) {
            set_cause_of_death(static_cast< ::DS3_Frpg2RequestMessage::CauseOfDeath >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_souls_dropped;
        break;
      }

      // required uint32 souls_dropped = 5;
      case 5: {
        if (tag == 40) {
         parse_souls_dropped:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &souls_dropped_)));
          set_has_souls_dropped();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_souls_lost;
        break;
      }

      // required uint32 souls_lost = 6;
      case 6: {
        if (tag == 48) {
         parse_souls_lost:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &souls_lost_)));
          set_has_souls_lost();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_actor_id;
        break;
      }

      // required uint32 actor_id = 7;
      case 7: {
        if (tag == 56) {
         parse_actor_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &actor_id_)));
          set_has_actor_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_killer_info;
        break;
      }

      // required .DS3_Frpg2RequestMessage.KillerInfo killer_info = 8;
      case 8: {
        if (tag == 66) {
         parse_killer_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_killer_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestNotifyDie)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestNotifyDie)
  return false;
#undef DO_
}

void RequestNotifyDie::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestNotifyDie)
  // required string unknown_1 = 1;
  if (has_unknown_1()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->unknown_1(), output);
  }

  // required uint32 map_id = 2;
  if (has_map_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->map_id(), output);
  }

  // required .DS3_Frpg2PlayerData.Vector location = 3;
  if (has_location()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->location(), output);
  }

  // required .DS3_Frpg2RequestMessage.CauseOfDeath cause_of_death = 4;
  if (has_cause_of_death()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->cause_of_death(), output);
  }

  // required uint32 souls_dropped = 5;
  if (has_souls_dropped()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->souls_dropped(), output);
  }

  // required uint32 souls_lost = 6;
  if (has_souls_lost()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->souls_lost(), output);
  }

  // required uint32 actor_id = 7;
  if (has_actor_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->actor_id(), output);
  }

  // required .DS3_Frpg2RequestMessage.KillerInfo killer_info = 8;
  if (has_killer_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      8, this->killer_info(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestNotifyDie)
}

int RequestNotifyDie::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string unknown_1 = 1;
    if (has_unknown_1()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->unknown_1());
    }

    // required uint32 map_id = 2;
    if (has_map_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->map_id());
    }

    // required .DS3_Frpg2PlayerData.Vector location = 3;
    if (has_location()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->location());
    }

    // required .DS3_Frpg2RequestMessage.CauseOfDeath cause_of_death = 4;
    if (has_cause_of_death()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->cause_of_death());
    }

    // required uint32 souls_dropped = 5;
    if (has_souls_dropped()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->souls_dropped());
    }

    // required uint32 souls_lost = 6;
    if (has_souls_lost()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->souls_lost());
    }

    // required uint32 actor_id = 7;
    if (has_actor_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->actor_id());
    }

    // required .DS3_Frpg2RequestMessage.KillerInfo killer_info = 8;
    if (has_killer_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->killer_info());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestNotifyDie::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestNotifyDie*>(&from));
}

void RequestNotifyDie::MergeFrom(const RequestNotifyDie& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_unknown_1()) {
      set_unknown_1(from.unknown_1());
    }
    if (from.has_map_id()) {
      set_map_id(from.map_id());
    }
    if (from.has_location()) {
      mutable_location()->::DS3_Frpg2PlayerData::Vector::MergeFrom(from.location());
    }
    if (from.has_cause_of_death()) {
      set_cause_of_death(from.cause_of_death());
    }
    if (from.has_souls_dropped()) {
      set_souls_dropped(from.souls_dropped());
    }
    if (from.has_souls_lost()) {
      set_souls_lost(from.souls_lost());
    }
    if (from.has_actor_id()) {
      set_actor_id(from.actor_id());
    }
    if (from.has_killer_info()) {
      mutable_killer_info()->::DS3_Frpg2RequestMessage::KillerInfo::MergeFrom(from.killer_info());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestNotifyDie::CopyFrom(const RequestNotifyDie& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestNotifyDie::IsInitialized() const {
  if ((_has_bits_[0] & 0x000000ff) != 0x000000ff) return false;

  if (has_location()) {
    if (!this->location().IsInitialized()) return false;
  }
  if (has_killer_info()) {
    if (!this->killer_info().IsInitialized()) return false;
  }
  return true;
}

void RequestNotifyDie::Swap(RequestNotifyDie* other) {
  if (other != this) {
    std::swap(unknown_1_, other->unknown_1_);
    std::swap(map_id_, other->map_id_);
    std::swap(location_, other->location_);
    std::swap(cause_of_death_, other->cause_of_death_);
    std::swap(souls_dropped_, other->souls_dropped_);
    std::swap(souls_lost_, other->souls_lost_);
    std::swap(actor_id_, other->actor_id_);
    std::swap(killer_info_, other->killer_info_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestNotifyDie::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestNotifyDie";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestNotifyKillEnemy::kInfoFieldNumber;
const int RequestNotifyKillEnemy::kEnemysFieldNumber;
const int RequestNotifyKillEnemy::kMapIdFieldNumber;
const int RequestNotifyKillEnemy::kLocationFieldNumber;
#endif  // !_MSC_VER

RequestNotifyKillEnemy::RequestNotifyKillEnemy()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestNotifyKillEnemy)
}

void RequestNotifyKillEnemy::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  info_ = const_cast< ::DS3_Frpg2RequestMessage::LogCommonInfo*>(
      ::DS3_Frpg2RequestMessage::LogCommonInfo::internal_default_instance());
#else
  info_ = const_cast< ::DS3_Frpg2RequestMessage::LogCommonInfo*>(&::DS3_Frpg2RequestMessage::LogCommonInfo::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  location_ = const_cast< ::DS3_Frpg2PlayerData::Vector*>(
      ::DS3_Frpg2PlayerData::Vector::internal_default_instance());
#else
  location_ = const_cast< ::DS3_Frpg2PlayerData::Vector*>(&::DS3_Frpg2PlayerData::Vector::default_instance());
#endif
}

RequestNotifyKillEnemy::RequestNotifyKillEnemy(const RequestNotifyKillEnemy& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestNotifyKillEnemy)
}

void RequestNotifyKillEnemy::SharedCtor() {
  _cached_size_ = 0;
  info_ = NULL;
  map_id_ = 0u;
  location_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestNotifyKillEnemy::~RequestNotifyKillEnemy() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestNotifyKillEnemy)
  SharedDtor();
}

void RequestNotifyKillEnemy::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete info_;
    delete location_;
  }
}

void RequestNotifyKillEnemy::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestNotifyKillEnemy& RequestNotifyKillEnemy::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestNotifyKillEnemy* RequestNotifyKillEnemy::default_instance_ = NULL;

RequestNotifyKillEnemy* RequestNotifyKillEnemy::New() const {
  return new RequestNotifyKillEnemy;
}

void RequestNotifyKillEnemy::Clear() {
  if (_has_bits_[0 / 32] & 13) {
    if (has_info()) {
      if (info_ != NULL) info_->::DS3_Frpg2RequestMessage::LogCommonInfo::Clear();
    }
    map_id_ = 0u;
    if (has_location()) {
      if (location_ != NULL) location_->::DS3_Frpg2PlayerData::Vector::Clear();
    }
  }
  enemys_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestNotifyKillEnemy::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestNotifyKillEnemy)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .DS3_Frpg2RequestMessage.LogCommonInfo info = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_enemys;
        break;
      }

      // repeated .DS3_Frpg2RequestMessage.KillEnemyInfo enemys = 2;
      case 2: {
        if (tag == 18) {
         parse_enemys:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_enemys()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_enemys;
        if (input->ExpectTag(24)) goto parse_map_id;
        break;
      }

      // required uint32 map_id = 3;
      case 3: {
        if (tag == 24) {
         parse_map_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &map_id_)));
          set_has_map_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_location;
        break;
      }

      // required .DS3_Frpg2PlayerData.Vector location = 4;
      case 4: {
        if (tag == 34) {
         parse_location:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_location()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestNotifyKillEnemy)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestNotifyKillEnemy)
  return false;
#undef DO_
}

void RequestNotifyKillEnemy::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestNotifyKillEnemy)
  // required .DS3_Frpg2RequestMessage.LogCommonInfo info = 1;
  if (has_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->info(), output);
  }

  // repeated .DS3_Frpg2RequestMessage.KillEnemyInfo enemys = 2;
  for (int i = 0; i < this->enemys_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->enemys(i), output);
  }

  // required uint32 map_id = 3;
  if (has_map_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->map_id(), output);
  }

  // required .DS3_Frpg2PlayerData.Vector location = 4;
  if (has_location()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->location(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestNotifyKillEnemy)
}

int RequestNotifyKillEnemy::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .DS3_Frpg2RequestMessage.LogCommonInfo info = 1;
    if (has_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->info());
    }

    // required uint32 map_id = 3;
    if (has_map_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->map_id());
    }

    // required .DS3_Frpg2PlayerData.Vector location = 4;
    if (has_location()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->location());
    }

  }
  // repeated .DS3_Frpg2RequestMessage.KillEnemyInfo enemys = 2;
  total_size += 1 * this->enemys_size();
  for (int i = 0; i < this->enemys_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->enemys(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestNotifyKillEnemy::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestNotifyKillEnemy*>(&from));
}

void RequestNotifyKillEnemy::MergeFrom(const RequestNotifyKillEnemy& from) {
  GOOGLE_CHECK_NE(&from, this);
  enemys_.MergeFrom(from.enemys_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_info()) {
      mutable_info()->::DS3_Frpg2RequestMessage::LogCommonInfo::MergeFrom(from.info());
    }
    if (from.has_map_id()) {
      set_map_id(from.map_id());
    }
    if (from.has_location()) {
      mutable_location()->::DS3_Frpg2PlayerData::Vector::MergeFrom(from.location());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestNotifyKillEnemy::CopyFrom(const RequestNotifyKillEnemy& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestNotifyKillEnemy::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000d) != 0x0000000d) return false;

  if (has_info()) {
    if (!this->info().IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->enemys())) return false;
  if (has_location()) {
    if (!this->location().IsInitialized()) return false;
  }
  return true;
}

void RequestNotifyKillEnemy::Swap(RequestNotifyKillEnemy* other) {
  if (other != this) {
    std::swap(info_, other->info_);
    enemys_.Swap(&other->enemys_);
    std::swap(map_id_, other->map_id_);
    std::swap(location_, other->location_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestNotifyKillEnemy::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestNotifyKillEnemy";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestNotifyKillBoss::kUnknown1FieldNumber;
const int RequestNotifyKillBoss::kBossIdFieldNumber;
const int RequestNotifyKillBoss::kInCoopFieldNumber;
const int RequestNotifyKillBoss::kBossDiedFieldNumber;
const int RequestNotifyKillBoss::kCooperatorCountFieldNumber;
const int RequestNotifyKillBoss::kFightDurationFieldNumber;
const int RequestNotifyKillBoss::kMapIdFieldNumber;
#endif  // !_MSC_VER

RequestNotifyKillBoss::RequestNotifyKillBoss()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestNotifyKillBoss)
}

void RequestNotifyKillBoss::InitAsDefaultInstance() {
}

RequestNotifyKillBoss::RequestNotifyKillBoss(const RequestNotifyKillBoss& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestNotifyKillBoss)
}

void RequestNotifyKillBoss::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  unknown_1_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  boss_id_ = 0u;
  in_coop_ = 0u;
  boss_died_ = 0u;
  cooperator_count_ = 0u;
  fight_duration_ = 0u;
  map_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestNotifyKillBoss::~RequestNotifyKillBoss() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestNotifyKillBoss)
  SharedDtor();
}

void RequestNotifyKillBoss::SharedDtor() {
  if (unknown_1_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete unknown_1_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestNotifyKillBoss::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestNotifyKillBoss& RequestNotifyKillBoss::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestNotifyKillBoss* RequestNotifyKillBoss::default_instance_ = NULL;

RequestNotifyKillBoss* RequestNotifyKillBoss::New() const {
  return new RequestNotifyKillBoss;
}

void RequestNotifyKillBoss::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<RequestNotifyKillBoss*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 127) {
    ZR_(boss_id_, map_id_);
    if (has_unknown_1()) {
      if (unknown_1_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        unknown_1_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestNotifyKillBoss::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestNotifyKillBoss)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string unknown_1 = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_unknown_1()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_boss_id;
        break;
      }

      // required uint32 boss_id = 2;
      case 2: {
        if (tag == 16) {
         parse_boss_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &boss_id_)));
          set_has_boss_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_in_coop;
        break;
      }

      // required uint32 in_coop = 3;
      case 3: {
        if (tag == 24) {
         parse_in_coop:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &in_coop_)));
          set_has_in_coop();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_boss_died;
        break;
      }

      // required uint32 boss_died = 4;
      case 4: {
        if (tag == 32) {
         parse_boss_died:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &boss_died_)));
          set_has_boss_died();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_cooperator_count;
        break;
      }

      // required uint32 cooperator_count = 5;
      case 5: {
        if (tag == 40) {
         parse_cooperator_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &cooperator_count_)));
          set_has_cooperator_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_fight_duration;
        break;
      }

      // required uint32 fight_duration = 6;
      case 6: {
        if (tag == 48) {
         parse_fight_duration:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &fight_duration_)));
          set_has_fight_duration();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_map_id;
        break;
      }

      // required uint32 map_id = 8;
      case 8: {
        if (tag == 64) {
         parse_map_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &map_id_)));
          set_has_map_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestNotifyKillBoss)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestNotifyKillBoss)
  return false;
#undef DO_
}

void RequestNotifyKillBoss::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestNotifyKillBoss)
  // required string unknown_1 = 1;
  if (has_unknown_1()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->unknown_1(), output);
  }

  // required uint32 boss_id = 2;
  if (has_boss_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->boss_id(), output);
  }

  // required uint32 in_coop = 3;
  if (has_in_coop()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->in_coop(), output);
  }

  // required uint32 boss_died = 4;
  if (has_boss_died()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->boss_died(), output);
  }

  // required uint32 cooperator_count = 5;
  if (has_cooperator_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->cooperator_count(), output);
  }

  // required uint32 fight_duration = 6;
  if (has_fight_duration()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->fight_duration(), output);
  }

  // required uint32 map_id = 8;
  if (has_map_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->map_id(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestNotifyKillBoss)
}

int RequestNotifyKillBoss::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string unknown_1 = 1;
    if (has_unknown_1()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->unknown_1());
    }

    // required uint32 boss_id = 2;
    if (has_boss_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->boss_id());
    }

    // required uint32 in_coop = 3;
    if (has_in_coop()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->in_coop());
    }

    // required uint32 boss_died = 4;
    if (has_boss_died()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->boss_died());
    }

    // required uint32 cooperator_count = 5;
    if (has_cooperator_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->cooperator_count());
    }

    // required uint32 fight_duration = 6;
    if (has_fight_duration()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->fight_duration());
    }

    // required uint32 map_id = 8;
    if (has_map_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->map_id());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestNotifyKillBoss::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestNotifyKillBoss*>(&from));
}

void RequestNotifyKillBoss::MergeFrom(const RequestNotifyKillBoss& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_unknown_1()) {
      set_unknown_1(from.unknown_1());
    }
    if (from.has_boss_id()) {
      set_boss_id(from.boss_id());
    }
    if (from.has_in_coop()) {
      set_in_coop(from.in_coop());
    }
    if (from.has_boss_died()) {
      set_boss_died(from.boss_died());
    }
    if (from.has_cooperator_count()) {
      set_cooperator_count(from.cooperator_count());
    }
    if (from.has_fight_duration()) {
      set_fight_duration(from.fight_duration());
    }
    if (from.has_map_id()) {
      set_map_id(from.map_id());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestNotifyKillBoss::CopyFrom(const RequestNotifyKillBoss& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestNotifyKillBoss::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000007f) != 0x0000007f) return false;

  return true;
}

void RequestNotifyKillBoss::Swap(RequestNotifyKillBoss* other) {
  if (other != this) {
    std::swap(unknown_1_, other->unknown_1_);
    std::swap(boss_id_, other->boss_id_);
    std::swap(in_coop_, other->in_coop_);
    std::swap(boss_died_, other->boss_died_);
    std::swap(cooperator_count_, other->cooperator_count_);
    std::swap(fight_duration_, other->fight_duration_);
    std::swap(map_id_, other->map_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestNotifyKillBoss::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestNotifyKillBoss";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestNotifyJoinMultiplay::kAllStatusFieldNumber;
const int RequestNotifyJoinMultiplay::kMapIdFieldNumber;
const int RequestNotifyJoinMultiplay::kOnlineAreaIdFieldNumber;
const int RequestNotifyJoinMultiplay::kUnknown2FieldNumber;
const int RequestNotifyJoinMultiplay::kUnknown3FieldNumber;
const int RequestNotifyJoinMultiplay::kPartyMemberInfoFieldNumber;
#endif  // !_MSC_VER

RequestNotifyJoinMultiplay::RequestNotifyJoinMultiplay()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestNotifyJoinMultiplay)
}

void RequestNotifyJoinMultiplay::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  all_status_ = const_cast< ::DS3_Frpg2PlayerData::AllStatus*>(
      ::DS3_Frpg2PlayerData::AllStatus::internal_default_instance());
#else
  all_status_ = const_cast< ::DS3_Frpg2PlayerData::AllStatus*>(&::DS3_Frpg2PlayerData::AllStatus::default_instance());
#endif
}

RequestNotifyJoinMultiplay::RequestNotifyJoinMultiplay(const RequestNotifyJoinMultiplay& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestNotifyJoinMultiplay)
}

void RequestNotifyJoinMultiplay::SharedCtor() {
  _cached_size_ = 0;
  all_status_ = NULL;
  map_id_ = 0u;
  online_area_id_ = 0u;
  unknown_2_ = 0u;
  unknown_3_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestNotifyJoinMultiplay::~RequestNotifyJoinMultiplay() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestNotifyJoinMultiplay)
  SharedDtor();
}

void RequestNotifyJoinMultiplay::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete all_status_;
  }
}

void RequestNotifyJoinMultiplay::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestNotifyJoinMultiplay& RequestNotifyJoinMultiplay::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestNotifyJoinMultiplay* RequestNotifyJoinMultiplay::default_instance_ = NULL;

RequestNotifyJoinMultiplay* RequestNotifyJoinMultiplay::New() const {
  return new RequestNotifyJoinMultiplay;
}

void RequestNotifyJoinMultiplay::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<RequestNotifyJoinMultiplay*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 31) {
    ZR_(map_id_, unknown_3_);
    if (has_all_status()) {
      if (all_status_ != NULL) all_status_->::DS3_Frpg2PlayerData::AllStatus::Clear();
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  party_member_info_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestNotifyJoinMultiplay::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestNotifyJoinMultiplay)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .DS3_Frpg2PlayerData.AllStatus all_status = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_all_status()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_map_id;
        break;
      }

      // required uint32 map_id = 2;
      case 2: {
        if (tag == 16) {
         parse_map_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &map_id_)));
          set_has_map_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_online_area_id;
        break;
      }

      // required uint32 online_area_id = 3;
      case 3: {
        if (tag == 24) {
         parse_online_area_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &online_area_id_)));
          set_has_online_area_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_unknown_2;
        break;
      }

      // required uint32 unknown_2 = 4;
      case 4: {
        if (tag == 32) {
         parse_unknown_2:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_2_)));
          set_has_unknown_2();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_unknown_3;
        break;
      }

      // required uint32 unknown_3 = 5;
      case 5: {
        if (tag == 40) {
         parse_unknown_3:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_3_)));
          set_has_unknown_3();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_party_member_info;
        break;
      }

      // repeated .DS3_Frpg2RequestMessage.PartyMemberInfo party_member_info = 6;
      case 6: {
        if (tag == 50) {
         parse_party_member_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_party_member_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_party_member_info;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestNotifyJoinMultiplay)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestNotifyJoinMultiplay)
  return false;
#undef DO_
}

void RequestNotifyJoinMultiplay::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestNotifyJoinMultiplay)
  // required .DS3_Frpg2PlayerData.AllStatus all_status = 1;
  if (has_all_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->all_status(), output);
  }

  // required uint32 map_id = 2;
  if (has_map_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->map_id(), output);
  }

  // required uint32 online_area_id = 3;
  if (has_online_area_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->online_area_id(), output);
  }

  // required uint32 unknown_2 = 4;
  if (has_unknown_2()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->unknown_2(), output);
  }

  // required uint32 unknown_3 = 5;
  if (has_unknown_3()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->unknown_3(), output);
  }

  // repeated .DS3_Frpg2RequestMessage.PartyMemberInfo party_member_info = 6;
  for (int i = 0; i < this->party_member_info_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, this->party_member_info(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestNotifyJoinMultiplay)
}

int RequestNotifyJoinMultiplay::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .DS3_Frpg2PlayerData.AllStatus all_status = 1;
    if (has_all_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->all_status());
    }

    // required uint32 map_id = 2;
    if (has_map_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->map_id());
    }

    // required uint32 online_area_id = 3;
    if (has_online_area_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->online_area_id());
    }

    // required uint32 unknown_2 = 4;
    if (has_unknown_2()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_2());
    }

    // required uint32 unknown_3 = 5;
    if (has_unknown_3()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_3());
    }

  }
  // repeated .DS3_Frpg2RequestMessage.PartyMemberInfo party_member_info = 6;
  total_size += 1 * this->party_member_info_size();
  for (int i = 0; i < this->party_member_info_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->party_member_info(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestNotifyJoinMultiplay::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestNotifyJoinMultiplay*>(&from));
}

void RequestNotifyJoinMultiplay::MergeFrom(const RequestNotifyJoinMultiplay& from) {
  GOOGLE_CHECK_NE(&from, this);
  party_member_info_.MergeFrom(from.party_member_info_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_all_status()) {
      mutable_all_status()->::DS3_Frpg2PlayerData::AllStatus::MergeFrom(from.all_status());
    }
    if (from.has_map_id()) {
      set_map_id(from.map_id());
    }
    if (from.has_online_area_id()) {
      set_online_area_id(from.online_area_id());
    }
    if (from.has_unknown_2()) {
      set_unknown_2(from.unknown_2());
    }
    if (from.has_unknown_3()) {
      set_unknown_3(from.unknown_3());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestNotifyJoinMultiplay::CopyFrom(const RequestNotifyJoinMultiplay& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestNotifyJoinMultiplay::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;

  if (has_all_status()) {
    if (!this->all_status().IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->party_member_info())) return false;
  return true;
}

void RequestNotifyJoinMultiplay::Swap(RequestNotifyJoinMultiplay* other) {
  if (other != this) {
    std::swap(all_status_, other->all_status_);
    std::swap(map_id_, other->map_id_);
    std::swap(online_area_id_, other->online_area_id_);
    std::swap(unknown_2_, other->unknown_2_);
    std::swap(unknown_3_, other->unknown_3_);
    party_member_info_.Swap(&other->party_member_info_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestNotifyJoinMultiplay::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestNotifyJoinMultiplay";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestNotifyLeaveMultiplay::kAllStatusFieldNumber;
const int RequestNotifyLeaveMultiplay::kMapIdFieldNumber;
const int RequestNotifyLeaveMultiplay::kOnlineAreaIdFieldNumber;
const int RequestNotifyLeaveMultiplay::kUnknown2FieldNumber;
const int RequestNotifyLeaveMultiplay::kUnknown3FieldNumber;
const int RequestNotifyLeaveMultiplay::kUnknown4FieldNumber;
const int RequestNotifyLeaveMultiplay::kPartyMemberInfoFieldNumber;
#endif  // !_MSC_VER

RequestNotifyLeaveMultiplay::RequestNotifyLeaveMultiplay()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestNotifyLeaveMultiplay)
}

void RequestNotifyLeaveMultiplay::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  all_status_ = const_cast< ::DS3_Frpg2PlayerData::AllStatus*>(
      ::DS3_Frpg2PlayerData::AllStatus::internal_default_instance());
#else
  all_status_ = const_cast< ::DS3_Frpg2PlayerData::AllStatus*>(&::DS3_Frpg2PlayerData::AllStatus::default_instance());
#endif
}

RequestNotifyLeaveMultiplay::RequestNotifyLeaveMultiplay(const RequestNotifyLeaveMultiplay& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestNotifyLeaveMultiplay)
}

void RequestNotifyLeaveMultiplay::SharedCtor() {
  _cached_size_ = 0;
  all_status_ = NULL;
  map_id_ = 0u;
  online_area_id_ = 0u;
  unknown_2_ = 0u;
  unknown_3_ = 0u;
  unknown_4_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestNotifyLeaveMultiplay::~RequestNotifyLeaveMultiplay() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestNotifyLeaveMultiplay)
  SharedDtor();
}

void RequestNotifyLeaveMultiplay::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete all_status_;
  }
}

void RequestNotifyLeaveMultiplay::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestNotifyLeaveMultiplay& RequestNotifyLeaveMultiplay::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestNotifyLeaveMultiplay* RequestNotifyLeaveMultiplay::default_instance_ = NULL;

RequestNotifyLeaveMultiplay* RequestNotifyLeaveMultiplay::New() const {
  return new RequestNotifyLeaveMultiplay;
}

void RequestNotifyLeaveMultiplay::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<RequestNotifyLeaveMultiplay*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 63) {
    ZR_(map_id_, unknown_3_);
    if (has_all_status()) {
      if (all_status_ != NULL) all_status_->::DS3_Frpg2PlayerData::AllStatus::Clear();
    }
    unknown_4_ = 0u;
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  party_member_info_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestNotifyLeaveMultiplay::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestNotifyLeaveMultiplay)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .DS3_Frpg2PlayerData.AllStatus all_status = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_all_status()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_map_id;
        break;
      }

      // required uint32 map_id = 2;
      case 2: {
        if (tag == 16) {
         parse_map_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &map_id_)));
          set_has_map_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_online_area_id;
        break;
      }

      // required uint32 online_area_id = 3;
      case 3: {
        if (tag == 24) {
         parse_online_area_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &online_area_id_)));
          set_has_online_area_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_unknown_2;
        break;
      }

      // required uint32 unknown_2 = 4;
      case 4: {
        if (tag == 32) {
         parse_unknown_2:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_2_)));
          set_has_unknown_2();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_unknown_3;
        break;
      }

      // required uint32 unknown_3 = 5;
      case 5: {
        if (tag == 40) {
         parse_unknown_3:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_3_)));
          set_has_unknown_3();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_unknown_4;
        break;
      }

      // required uint32 unknown_4 = 6;
      case 6: {
        if (tag == 48) {
         parse_unknown_4:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_4_)));
          set_has_unknown_4();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_party_member_info;
        break;
      }

      // repeated .DS3_Frpg2RequestMessage.PartyMemberInfo party_member_info = 7;
      case 7: {
        if (tag == 58) {
         parse_party_member_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_party_member_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_party_member_info;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestNotifyLeaveMultiplay)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestNotifyLeaveMultiplay)
  return false;
#undef DO_
}

void RequestNotifyLeaveMultiplay::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestNotifyLeaveMultiplay)
  // required .DS3_Frpg2PlayerData.AllStatus all_status = 1;
  if (has_all_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->all_status(), output);
  }

  // required uint32 map_id = 2;
  if (has_map_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->map_id(), output);
  }

  // required uint32 online_area_id = 3;
  if (has_online_area_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->online_area_id(), output);
  }

  // required uint32 unknown_2 = 4;
  if (has_unknown_2()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->unknown_2(), output);
  }

  // required uint32 unknown_3 = 5;
  if (has_unknown_3()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->unknown_3(), output);
  }

  // required uint32 unknown_4 = 6;
  if (has_unknown_4()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->unknown_4(), output);
  }

  // repeated .DS3_Frpg2RequestMessage.PartyMemberInfo party_member_info = 7;
  for (int i = 0; i < this->party_member_info_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      7, this->party_member_info(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestNotifyLeaveMultiplay)
}

int RequestNotifyLeaveMultiplay::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .DS3_Frpg2PlayerData.AllStatus all_status = 1;
    if (has_all_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->all_status());
    }

    // required uint32 map_id = 2;
    if (has_map_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->map_id());
    }

    // required uint32 online_area_id = 3;
    if (has_online_area_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->online_area_id());
    }

    // required uint32 unknown_2 = 4;
    if (has_unknown_2()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_2());
    }

    // required uint32 unknown_3 = 5;
    if (has_unknown_3()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_3());
    }

    // required uint32 unknown_4 = 6;
    if (has_unknown_4()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_4());
    }

  }
  // repeated .DS3_Frpg2RequestMessage.PartyMemberInfo party_member_info = 7;
  total_size += 1 * this->party_member_info_size();
  for (int i = 0; i < this->party_member_info_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->party_member_info(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestNotifyLeaveMultiplay::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestNotifyLeaveMultiplay*>(&from));
}

void RequestNotifyLeaveMultiplay::MergeFrom(const RequestNotifyLeaveMultiplay& from) {
  GOOGLE_CHECK_NE(&from, this);
  party_member_info_.MergeFrom(from.party_member_info_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_all_status()) {
      mutable_all_status()->::DS3_Frpg2PlayerData::AllStatus::MergeFrom(from.all_status());
    }
    if (from.has_map_id()) {
      set_map_id(from.map_id());
    }
    if (from.has_online_area_id()) {
      set_online_area_id(from.online_area_id());
    }
    if (from.has_unknown_2()) {
      set_unknown_2(from.unknown_2());
    }
    if (from.has_unknown_3()) {
      set_unknown_3(from.unknown_3());
    }
    if (from.has_unknown_4()) {
      set_unknown_4(from.unknown_4());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestNotifyLeaveMultiplay::CopyFrom(const RequestNotifyLeaveMultiplay& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestNotifyLeaveMultiplay::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003f) != 0x0000003f) return false;

  if (has_all_status()) {
    if (!this->all_status().IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->party_member_info())) return false;
  return true;
}

void RequestNotifyLeaveMultiplay::Swap(RequestNotifyLeaveMultiplay* other) {
  if (other != this) {
    std::swap(all_status_, other->all_status_);
    std::swap(map_id_, other->map_id_);
    std::swap(online_area_id_, other->online_area_id_);
    std::swap(unknown_2_, other->unknown_2_);
    std::swap(unknown_3_, other->unknown_3_);
    std::swap(unknown_4_, other->unknown_4_);
    party_member_info_.Swap(&other->party_member_info_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestNotifyLeaveMultiplay::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestNotifyLeaveMultiplay";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestNotifyCreateSignResult::kAllStatusFieldNumber;
const int RequestNotifyCreateSignResult::kMapIdFieldNumber;
const int RequestNotifyCreateSignResult::kOnlineAreaIdFieldNumber;
const int RequestNotifyCreateSignResult::kLocationFieldNumber;
const int RequestNotifyCreateSignResult::kSignUniqueNumberFieldNumber;
const int RequestNotifyCreateSignResult::kUnknown2FieldNumber;
const int RequestNotifyCreateSignResult::kUnknown3FieldNumber;
const int RequestNotifyCreateSignResult::kUnknown4FieldNumber;
#endif  // !_MSC_VER

RequestNotifyCreateSignResult::RequestNotifyCreateSignResult()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestNotifyCreateSignResult)
}

void RequestNotifyCreateSignResult::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  all_status_ = const_cast< ::DS3_Frpg2PlayerData::AllStatus*>(
      ::DS3_Frpg2PlayerData::AllStatus::internal_default_instance());
#else
  all_status_ = const_cast< ::DS3_Frpg2PlayerData::AllStatus*>(&::DS3_Frpg2PlayerData::AllStatus::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  location_ = const_cast< ::DS3_Frpg2PlayerData::Vector*>(
      ::DS3_Frpg2PlayerData::Vector::internal_default_instance());
#else
  location_ = const_cast< ::DS3_Frpg2PlayerData::Vector*>(&::DS3_Frpg2PlayerData::Vector::default_instance());
#endif
}

RequestNotifyCreateSignResult::RequestNotifyCreateSignResult(const RequestNotifyCreateSignResult& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestNotifyCreateSignResult)
}

void RequestNotifyCreateSignResult::SharedCtor() {
  _cached_size_ = 0;
  all_status_ = NULL;
  map_id_ = 0u;
  online_area_id_ = 0u;
  location_ = NULL;
  sign_unique_number_ = 0u;
  unknown_2_ = 0u;
  unknown_3_ = 0u;
  unknown_4_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestNotifyCreateSignResult::~RequestNotifyCreateSignResult() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestNotifyCreateSignResult)
  SharedDtor();
}

void RequestNotifyCreateSignResult::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete all_status_;
    delete location_;
  }
}

void RequestNotifyCreateSignResult::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestNotifyCreateSignResult& RequestNotifyCreateSignResult::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestNotifyCreateSignResult* RequestNotifyCreateSignResult::default_instance_ = NULL;

RequestNotifyCreateSignResult* RequestNotifyCreateSignResult::New() const {
  return new RequestNotifyCreateSignResult;
}

void RequestNotifyCreateSignResult::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<RequestNotifyCreateSignResult*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(map_id_, online_area_id_);
    ZR_(sign_unique_number_, unknown_4_);
    if (has_all_status()) {
      if (all_status_ != NULL) all_status_->::DS3_Frpg2PlayerData::AllStatus::Clear();
    }
    if (has_location()) {
      if (location_ != NULL) location_->::DS3_Frpg2PlayerData::Vector::Clear();
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestNotifyCreateSignResult::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestNotifyCreateSignResult)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .DS3_Frpg2PlayerData.AllStatus all_status = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_all_status()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_map_id;
        break;
      }

      // required uint32 map_id = 2;
      case 2: {
        if (tag == 16) {
         parse_map_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &map_id_)));
          set_has_map_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_online_area_id;
        break;
      }

      // required uint32 online_area_id = 3;
      case 3: {
        if (tag == 24) {
         parse_online_area_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &online_area_id_)));
          set_has_online_area_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_location;
        break;
      }

      // required .DS3_Frpg2PlayerData.Vector location = 4;
      case 4: {
        if (tag == 34) {
         parse_location:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_location()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_sign_unique_number;
        break;
      }

      // required uint32 sign_unique_number = 5;
      case 5: {
        if (tag == 40) {
         parse_sign_unique_number:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &sign_unique_number_)));
          set_has_sign_unique_number();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_unknown_2;
        break;
      }

      // required uint32 unknown_2 = 6;
      case 6: {
        if (tag == 48) {
         parse_unknown_2:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_2_)));
          set_has_unknown_2();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_unknown_3;
        break;
      }

      // required uint32 unknown_3 = 7;
      case 7: {
        if (tag == 56) {
         parse_unknown_3:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_3_)));
          set_has_unknown_3();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_unknown_4;
        break;
      }

      // required uint32 unknown_4 = 8;
      case 8: {
        if (tag == 64) {
         parse_unknown_4:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_4_)));
          set_has_unknown_4();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestNotifyCreateSignResult)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestNotifyCreateSignResult)
  return false;
#undef DO_
}

void RequestNotifyCreateSignResult::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestNotifyCreateSignResult)
  // required .DS3_Frpg2PlayerData.AllStatus all_status = 1;
  if (has_all_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->all_status(), output);
  }

  // required uint32 map_id = 2;
  if (has_map_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->map_id(), output);
  }

  // required uint32 online_area_id = 3;
  if (has_online_area_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->online_area_id(), output);
  }

  // required .DS3_Frpg2PlayerData.Vector location = 4;
  if (has_location()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->location(), output);
  }

  // required uint32 sign_unique_number = 5;
  if (has_sign_unique_number()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->sign_unique_number(), output);
  }

  // required uint32 unknown_2 = 6;
  if (has_unknown_2()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->unknown_2(), output);
  }

  // required uint32 unknown_3 = 7;
  if (has_unknown_3()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->unknown_3(), output);
  }

  // required uint32 unknown_4 = 8;
  if (has_unknown_4()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->unknown_4(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestNotifyCreateSignResult)
}

int RequestNotifyCreateSignResult::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .DS3_Frpg2PlayerData.AllStatus all_status = 1;
    if (has_all_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->all_status());
    }

    // required uint32 map_id = 2;
    if (has_map_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->map_id());
    }

    // required uint32 online_area_id = 3;
    if (has_online_area_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->online_area_id());
    }

    // required .DS3_Frpg2PlayerData.Vector location = 4;
    if (has_location()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->location());
    }

    // required uint32 sign_unique_number = 5;
    if (has_sign_unique_number()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->sign_unique_number());
    }

    // required uint32 unknown_2 = 6;
    if (has_unknown_2()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_2());
    }

    // required uint32 unknown_3 = 7;
    if (has_unknown_3()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_3());
    }

    // required uint32 unknown_4 = 8;
    if (has_unknown_4()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_4());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestNotifyCreateSignResult::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestNotifyCreateSignResult*>(&from));
}

void RequestNotifyCreateSignResult::MergeFrom(const RequestNotifyCreateSignResult& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_all_status()) {
      mutable_all_status()->::DS3_Frpg2PlayerData::AllStatus::MergeFrom(from.all_status());
    }
    if (from.has_map_id()) {
      set_map_id(from.map_id());
    }
    if (from.has_online_area_id()) {
      set_online_area_id(from.online_area_id());
    }
    if (from.has_location()) {
      mutable_location()->::DS3_Frpg2PlayerData::Vector::MergeFrom(from.location());
    }
    if (from.has_sign_unique_number()) {
      set_sign_unique_number(from.sign_unique_number());
    }
    if (from.has_unknown_2()) {
      set_unknown_2(from.unknown_2());
    }
    if (from.has_unknown_3()) {
      set_unknown_3(from.unknown_3());
    }
    if (from.has_unknown_4()) {
      set_unknown_4(from.unknown_4());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestNotifyCreateSignResult::CopyFrom(const RequestNotifyCreateSignResult& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestNotifyCreateSignResult::IsInitialized() const {
  if ((_has_bits_[0] & 0x000000ff) != 0x000000ff) return false;

  if (has_all_status()) {
    if (!this->all_status().IsInitialized()) return false;
  }
  if (has_location()) {
    if (!this->location().IsInitialized()) return false;
  }
  return true;
}

void RequestNotifyCreateSignResult::Swap(RequestNotifyCreateSignResult* other) {
  if (other != this) {
    std::swap(all_status_, other->all_status_);
    std::swap(map_id_, other->map_id_);
    std::swap(online_area_id_, other->online_area_id_);
    std::swap(location_, other->location_);
    std::swap(sign_unique_number_, other->sign_unique_number_);
    std::swap(unknown_2_, other->unknown_2_);
    std::swap(unknown_3_, other->unknown_3_);
    std::swap(unknown_4_, other->unknown_4_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestNotifyCreateSignResult::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestNotifyCreateSignResult";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestNotifySummonSignResult::kUnknown1FieldNumber;
const int RequestNotifySummonSignResult::kMapIdFieldNumber;
const int RequestNotifySummonSignResult::kOnlineAreaIdFieldNumber;
const int RequestNotifySummonSignResult::kLocationFieldNumber;
const int RequestNotifySummonSignResult::kSignInfoFieldNumber;
const int RequestNotifySummonSignResult::kUnknown6FieldNumber;
const int RequestNotifySummonSignResult::kUnknown7FieldNumber;
const int RequestNotifySummonSignResult::kUnknown8FieldNumber;
#endif  // !_MSC_VER

RequestNotifySummonSignResult::RequestNotifySummonSignResult()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestNotifySummonSignResult)
}

void RequestNotifySummonSignResult::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  location_ = const_cast< ::DS3_Frpg2PlayerData::Vector*>(
      ::DS3_Frpg2PlayerData::Vector::internal_default_instance());
#else
  location_ = const_cast< ::DS3_Frpg2PlayerData::Vector*>(&::DS3_Frpg2PlayerData::Vector::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  sign_info_ = const_cast< ::DS3_Frpg2RequestMessage::SignInfo*>(
      ::DS3_Frpg2RequestMessage::SignInfo::internal_default_instance());
#else
  sign_info_ = const_cast< ::DS3_Frpg2RequestMessage::SignInfo*>(&::DS3_Frpg2RequestMessage::SignInfo::default_instance());
#endif
}

RequestNotifySummonSignResult::RequestNotifySummonSignResult(const RequestNotifySummonSignResult& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestNotifySummonSignResult)
}

void RequestNotifySummonSignResult::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  unknown_1_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  map_id_ = 0u;
  online_area_id_ = 0u;
  location_ = NULL;
  sign_info_ = NULL;
  unknown_6_ = 0u;
  unknown_7_ = 0u;
  unknown_8_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestNotifySummonSignResult::~RequestNotifySummonSignResult() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestNotifySummonSignResult)
  SharedDtor();
}

void RequestNotifySummonSignResult::SharedDtor() {
  if (unknown_1_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete unknown_1_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete location_;
    delete sign_info_;
  }
}

void RequestNotifySummonSignResult::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestNotifySummonSignResult& RequestNotifySummonSignResult::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestNotifySummonSignResult* RequestNotifySummonSignResult::default_instance_ = NULL;

RequestNotifySummonSignResult* RequestNotifySummonSignResult::New() const {
  return new RequestNotifySummonSignResult;
}

void RequestNotifySummonSignResult::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<RequestNotifySummonSignResult*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(map_id_, online_area_id_);
    ZR_(unknown_6_, unknown_8_);
    if (has_unknown_1()) {
      if (unknown_1_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        unknown_1_->clear();
      }
    }
    if (has_location()) {
      if (location_ != NULL) location_->::DS3_Frpg2PlayerData::Vector::Clear();
    }
    if (has_sign_info()) {
      if (sign_info_ != NULL) sign_info_->::DS3_Frpg2RequestMessage::SignInfo::Clear();
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestNotifySummonSignResult::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestNotifySummonSignResult)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string unknown_1 = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_unknown_1()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_map_id;
        break;
      }

      // required uint32 map_id = 2;
      case 2: {
        if (tag == 16) {
         parse_map_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &map_id_)));
          set_has_map_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_online_area_id;
        break;
      }

      // required uint32 online_area_id = 3;
      case 3: {
        if (tag == 24) {
         parse_online_area_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &online_area_id_)));
          set_has_online_area_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_location;
        break;
      }

      // required .DS3_Frpg2PlayerData.Vector location = 4;
      case 4: {
        if (tag == 34) {
         parse_location:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_location()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_sign_info;
        break;
      }

      // required .DS3_Frpg2RequestMessage.SignInfo sign_info = 5;
      case 5: {
        if (tag == 42) {
         parse_sign_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_sign_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_unknown_6;
        break;
      }

      // required uint32 unknown_6 = 6;
      case 6: {
        if (tag == 48) {
         parse_unknown_6:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_6_)));
          set_has_unknown_6();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_unknown_7;
        break;
      }

      // required uint32 unknown_7 = 7;
      case 7: {
        if (tag == 56) {
         parse_unknown_7:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_7_)));
          set_has_unknown_7();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_unknown_8;
        break;
      }

      // required uint32 unknown_8 = 8;
      case 8: {
        if (tag == 64) {
         parse_unknown_8:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_8_)));
          set_has_unknown_8();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestNotifySummonSignResult)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestNotifySummonSignResult)
  return false;
#undef DO_
}

void RequestNotifySummonSignResult::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestNotifySummonSignResult)
  // required string unknown_1 = 1;
  if (has_unknown_1()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->unknown_1(), output);
  }

  // required uint32 map_id = 2;
  if (has_map_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->map_id(), output);
  }

  // required uint32 online_area_id = 3;
  if (has_online_area_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->online_area_id(), output);
  }

  // required .DS3_Frpg2PlayerData.Vector location = 4;
  if (has_location()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->location(), output);
  }

  // required .DS3_Frpg2RequestMessage.SignInfo sign_info = 5;
  if (has_sign_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, this->sign_info(), output);
  }

  // required uint32 unknown_6 = 6;
  if (has_unknown_6()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->unknown_6(), output);
  }

  // required uint32 unknown_7 = 7;
  if (has_unknown_7()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->unknown_7(), output);
  }

  // required uint32 unknown_8 = 8;
  if (has_unknown_8()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->unknown_8(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestNotifySummonSignResult)
}

int RequestNotifySummonSignResult::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string unknown_1 = 1;
    if (has_unknown_1()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->unknown_1());
    }

    // required uint32 map_id = 2;
    if (has_map_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->map_id());
    }

    // required uint32 online_area_id = 3;
    if (has_online_area_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->online_area_id());
    }

    // required .DS3_Frpg2PlayerData.Vector location = 4;
    if (has_location()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->location());
    }

    // required .DS3_Frpg2RequestMessage.SignInfo sign_info = 5;
    if (has_sign_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->sign_info());
    }

    // required uint32 unknown_6 = 6;
    if (has_unknown_6()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_6());
    }

    // required uint32 unknown_7 = 7;
    if (has_unknown_7()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_7());
    }

    // required uint32 unknown_8 = 8;
    if (has_unknown_8()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_8());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestNotifySummonSignResult::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestNotifySummonSignResult*>(&from));
}

void RequestNotifySummonSignResult::MergeFrom(const RequestNotifySummonSignResult& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_unknown_1()) {
      set_unknown_1(from.unknown_1());
    }
    if (from.has_map_id()) {
      set_map_id(from.map_id());
    }
    if (from.has_online_area_id()) {
      set_online_area_id(from.online_area_id());
    }
    if (from.has_location()) {
      mutable_location()->::DS3_Frpg2PlayerData::Vector::MergeFrom(from.location());
    }
    if (from.has_sign_info()) {
      mutable_sign_info()->::DS3_Frpg2RequestMessage::SignInfo::MergeFrom(from.sign_info());
    }
    if (from.has_unknown_6()) {
      set_unknown_6(from.unknown_6());
    }
    if (from.has_unknown_7()) {
      set_unknown_7(from.unknown_7());
    }
    if (from.has_unknown_8()) {
      set_unknown_8(from.unknown_8());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestNotifySummonSignResult::CopyFrom(const RequestNotifySummonSignResult& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestNotifySummonSignResult::IsInitialized() const {
  if ((_has_bits_[0] & 0x000000ff) != 0x000000ff) return false;

  if (has_location()) {
    if (!this->location().IsInitialized()) return false;
  }
  if (has_sign_info()) {
    if (!this->sign_info().IsInitialized()) return false;
  }
  return true;
}

void RequestNotifySummonSignResult::Swap(RequestNotifySummonSignResult* other) {
  if (other != this) {
    std::swap(unknown_1_, other->unknown_1_);
    std::swap(map_id_, other->map_id_);
    std::swap(online_area_id_, other->online_area_id_);
    std::swap(location_, other->location_);
    std::swap(sign_info_, other->sign_info_);
    std::swap(unknown_6_, other->unknown_6_);
    std::swap(unknown_7_, other->unknown_7_);
    std::swap(unknown_8_, other->unknown_8_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestNotifySummonSignResult::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestNotifySummonSignResult";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RequestNotifyBreakInResult::RequestNotifyBreakInResult()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestNotifyBreakInResult)
}

void RequestNotifyBreakInResult::InitAsDefaultInstance() {
}

RequestNotifyBreakInResult::RequestNotifyBreakInResult(const RequestNotifyBreakInResult& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestNotifyBreakInResult)
}

void RequestNotifyBreakInResult::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestNotifyBreakInResult::~RequestNotifyBreakInResult() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestNotifyBreakInResult)
  SharedDtor();
}

void RequestNotifyBreakInResult::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestNotifyBreakInResult::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestNotifyBreakInResult& RequestNotifyBreakInResult::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestNotifyBreakInResult* RequestNotifyBreakInResult::default_instance_ = NULL;

RequestNotifyBreakInResult* RequestNotifyBreakInResult::New() const {
  return new RequestNotifyBreakInResult;
}

void RequestNotifyBreakInResult::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestNotifyBreakInResult::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestNotifyBreakInResult)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestNotifyBreakInResult)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestNotifyBreakInResult)
  return false;
#undef DO_
}

void RequestNotifyBreakInResult::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestNotifyBreakInResult)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestNotifyBreakInResult)
}

int RequestNotifyBreakInResult::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestNotifyBreakInResult::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestNotifyBreakInResult*>(&from));
}

void RequestNotifyBreakInResult::MergeFrom(const RequestNotifyBreakInResult& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestNotifyBreakInResult::CopyFrom(const RequestNotifyBreakInResult& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestNotifyBreakInResult::IsInitialized() const {

  return true;
}

void RequestNotifyBreakInResult::Swap(RequestNotifyBreakInResult* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestNotifyBreakInResult::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestNotifyBreakInResult";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RequestNotifyDisconnectSession::RequestNotifyDisconnectSession()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestNotifyDisconnectSession)
}

void RequestNotifyDisconnectSession::InitAsDefaultInstance() {
}

RequestNotifyDisconnectSession::RequestNotifyDisconnectSession(const RequestNotifyDisconnectSession& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestNotifyDisconnectSession)
}

void RequestNotifyDisconnectSession::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestNotifyDisconnectSession::~RequestNotifyDisconnectSession() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestNotifyDisconnectSession)
  SharedDtor();
}

void RequestNotifyDisconnectSession::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestNotifyDisconnectSession::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestNotifyDisconnectSession& RequestNotifyDisconnectSession::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestNotifyDisconnectSession* RequestNotifyDisconnectSession::default_instance_ = NULL;

RequestNotifyDisconnectSession* RequestNotifyDisconnectSession::New() const {
  return new RequestNotifyDisconnectSession;
}

void RequestNotifyDisconnectSession::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestNotifyDisconnectSession::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestNotifyDisconnectSession)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestNotifyDisconnectSession)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestNotifyDisconnectSession)
  return false;
#undef DO_
}

void RequestNotifyDisconnectSession::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestNotifyDisconnectSession)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestNotifyDisconnectSession)
}

int RequestNotifyDisconnectSession::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestNotifyDisconnectSession::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestNotifyDisconnectSession*>(&from));
}

void RequestNotifyDisconnectSession::MergeFrom(const RequestNotifyDisconnectSession& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestNotifyDisconnectSession::CopyFrom(const RequestNotifyDisconnectSession& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestNotifyDisconnectSession::IsInitialized() const {

  return true;
}

void RequestNotifyDisconnectSession::Swap(RequestNotifyDisconnectSession* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestNotifyDisconnectSession::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestNotifyDisconnectSession";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RequestNotifyDisconnectSessionResponse::RequestNotifyDisconnectSessionResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestNotifyDisconnectSessionResponse)
}

void RequestNotifyDisconnectSessionResponse::InitAsDefaultInstance() {
}

RequestNotifyDisconnectSessionResponse::RequestNotifyDisconnectSessionResponse(const RequestNotifyDisconnectSessionResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestNotifyDisconnectSessionResponse)
}

void RequestNotifyDisconnectSessionResponse::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestNotifyDisconnectSessionResponse::~RequestNotifyDisconnectSessionResponse() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestNotifyDisconnectSessionResponse)
  SharedDtor();
}

void RequestNotifyDisconnectSessionResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestNotifyDisconnectSessionResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestNotifyDisconnectSessionResponse& RequestNotifyDisconnectSessionResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestNotifyDisconnectSessionResponse* RequestNotifyDisconnectSessionResponse::default_instance_ = NULL;

RequestNotifyDisconnectSessionResponse* RequestNotifyDisconnectSessionResponse::New() const {
  return new RequestNotifyDisconnectSessionResponse;
}

void RequestNotifyDisconnectSessionResponse::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestNotifyDisconnectSessionResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestNotifyDisconnectSessionResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestNotifyDisconnectSessionResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestNotifyDisconnectSessionResponse)
  return false;
#undef DO_
}

void RequestNotifyDisconnectSessionResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestNotifyDisconnectSessionResponse)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestNotifyDisconnectSessionResponse)
}

int RequestNotifyDisconnectSessionResponse::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestNotifyDisconnectSessionResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestNotifyDisconnectSessionResponse*>(&from));
}

void RequestNotifyDisconnectSessionResponse::MergeFrom(const RequestNotifyDisconnectSessionResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestNotifyDisconnectSessionResponse::CopyFrom(const RequestNotifyDisconnectSessionResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestNotifyDisconnectSessionResponse::IsInitialized() const {

  return true;
}

void RequestNotifyDisconnectSessionResponse::Swap(RequestNotifyDisconnectSessionResponse* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestNotifyDisconnectSessionResponse::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestNotifyDisconnectSessionResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestNotifyRegisterCharacter::kStatusFieldNumber;
const int RequestNotifyRegisterCharacter::kUnknown2FieldNumber;
const int RequestNotifyRegisterCharacter::kUnknown3FieldNumber;
const int RequestNotifyRegisterCharacter::kUnknown4FieldNumber;
const int RequestNotifyRegisterCharacter::kUnknown5FieldNumber;
const int RequestNotifyRegisterCharacter::kUnknown6FieldNumber;
const int RequestNotifyRegisterCharacter::kUnknown7FieldNumber;
const int RequestNotifyRegisterCharacter::kUnknown8FieldNumber;
const int RequestNotifyRegisterCharacter::kUnknown9FieldNumber;
const int RequestNotifyRegisterCharacter::kUnknown10FieldNumber;
#endif  // !_MSC_VER

RequestNotifyRegisterCharacter::RequestNotifyRegisterCharacter()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestNotifyRegisterCharacter)
}

void RequestNotifyRegisterCharacter::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  status_ = const_cast< ::DS3_Frpg2PlayerData::AllStatus*>(
      ::DS3_Frpg2PlayerData::AllStatus::internal_default_instance());
#else
  status_ = const_cast< ::DS3_Frpg2PlayerData::AllStatus*>(&::DS3_Frpg2PlayerData::AllStatus::default_instance());
#endif
}

RequestNotifyRegisterCharacter::RequestNotifyRegisterCharacter(const RequestNotifyRegisterCharacter& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestNotifyRegisterCharacter)
}

void RequestNotifyRegisterCharacter::SharedCtor() {
  _cached_size_ = 0;
  status_ = NULL;
  unknown_2_ = 0u;
  unknown_3_ = 0u;
  unknown_4_ = 0u;
  unknown_5_ = 0u;
  unknown_6_ = 0u;
  unknown_7_ = 0u;
  unknown_8_ = 0u;
  unknown_9_ = 0u;
  unknown_10_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestNotifyRegisterCharacter::~RequestNotifyRegisterCharacter() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestNotifyRegisterCharacter)
  SharedDtor();
}

void RequestNotifyRegisterCharacter::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete status_;
  }
}

void RequestNotifyRegisterCharacter::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestNotifyRegisterCharacter& RequestNotifyRegisterCharacter::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestNotifyRegisterCharacter* RequestNotifyRegisterCharacter::default_instance_ = NULL;

RequestNotifyRegisterCharacter* RequestNotifyRegisterCharacter::New() const {
  return new RequestNotifyRegisterCharacter;
}

void RequestNotifyRegisterCharacter::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<RequestNotifyRegisterCharacter*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(unknown_2_, unknown_8_);
    if (has_status()) {
      if (status_ != NULL) status_->::DS3_Frpg2PlayerData::AllStatus::Clear();
    }
  }
  ZR_(unknown_9_, unknown_10_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestNotifyRegisterCharacter::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestNotifyRegisterCharacter)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .DS3_Frpg2PlayerData.AllStatus status = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_status()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_unknown_2;
        break;
      }

      // required uint32 unknown_2 = 2;
      case 2: {
        if (tag == 16) {
         parse_unknown_2:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_2_)));
          set_has_unknown_2();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_unknown_3;
        break;
      }

      // required uint32 unknown_3 = 3;
      case 3: {
        if (tag == 24) {
         parse_unknown_3:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_3_)));
          set_has_unknown_3();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_unknown_4;
        break;
      }

      // required uint32 unknown_4 = 4;
      case 4: {
        if (tag == 32) {
         parse_unknown_4:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_4_)));
          set_has_unknown_4();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_unknown_5;
        break;
      }

      // required uint32 unknown_5 = 5;
      case 5: {
        if (tag == 40) {
         parse_unknown_5:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_5_)));
          set_has_unknown_5();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_unknown_6;
        break;
      }

      // required uint32 unknown_6 = 6;
      case 6: {
        if (tag == 48) {
         parse_unknown_6:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_6_)));
          set_has_unknown_6();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_unknown_7;
        break;
      }

      // required uint32 unknown_7 = 7;
      case 7: {
        if (tag == 56) {
         parse_unknown_7:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_7_)));
          set_has_unknown_7();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_unknown_8;
        break;
      }

      // required uint32 unknown_8 = 8;
      case 8: {
        if (tag == 64) {
         parse_unknown_8:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_8_)));
          set_has_unknown_8();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_unknown_9;
        break;
      }

      // required uint32 unknown_9 = 9;
      case 9: {
        if (tag == 72) {
         parse_unknown_9:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_9_)));
          set_has_unknown_9();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_unknown_10;
        break;
      }

      // required uint32 unknown_10 = 10;
      case 10: {
        if (tag == 80) {
         parse_unknown_10:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_10_)));
          set_has_unknown_10();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestNotifyRegisterCharacter)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestNotifyRegisterCharacter)
  return false;
#undef DO_
}

void RequestNotifyRegisterCharacter::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestNotifyRegisterCharacter)
  // required .DS3_Frpg2PlayerData.AllStatus status = 1;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->status(), output);
  }

  // required uint32 unknown_2 = 2;
  if (has_unknown_2()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->unknown_2(), output);
  }

  // required uint32 unknown_3 = 3;
  if (has_unknown_3()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->unknown_3(), output);
  }

  // required uint32 unknown_4 = 4;
  if (has_unknown_4()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->unknown_4(), output);
  }

  // required uint32 unknown_5 = 5;
  if (has_unknown_5()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->unknown_5(), output);
  }

  // required uint32 unknown_6 = 6;
  if (has_unknown_6()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->unknown_6(), output);
  }

  // required uint32 unknown_7 = 7;
  if (has_unknown_7()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->unknown_7(), output);
  }

  // required uint32 unknown_8 = 8;
  if (has_unknown_8()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->unknown_8(), output);
  }

  // required uint32 unknown_9 = 9;
  if (has_unknown_9()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->unknown_9(), output);
  }

  // required uint32 unknown_10 = 10;
  if (has_unknown_10()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(10, this->unknown_10(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestNotifyRegisterCharacter)
}

int RequestNotifyRegisterCharacter::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .DS3_Frpg2PlayerData.AllStatus status = 1;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->status());
    }

    // required uint32 unknown_2 = 2;
    if (has_unknown_2()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_2());
    }

    // required uint32 unknown_3 = 3;
    if (has_unknown_3()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_3());
    }

    // required uint32 unknown_4 = 4;
    if (has_unknown_4()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_4());
    }

    // required uint32 unknown_5 = 5;
    if (has_unknown_5()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_5());
    }

    // required uint32 unknown_6 = 6;
    if (has_unknown_6()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_6());
    }

    // required uint32 unknown_7 = 7;
    if (has_unknown_7()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_7());
    }

    // required uint32 unknown_8 = 8;
    if (has_unknown_8()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_8());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // required uint32 unknown_9 = 9;
    if (has_unknown_9()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_9());
    }

    // required uint32 unknown_10 = 10;
    if (has_unknown_10()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_10());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestNotifyRegisterCharacter::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestNotifyRegisterCharacter*>(&from));
}

void RequestNotifyRegisterCharacter::MergeFrom(const RequestNotifyRegisterCharacter& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_status()) {
      mutable_status()->::DS3_Frpg2PlayerData::AllStatus::MergeFrom(from.status());
    }
    if (from.has_unknown_2()) {
      set_unknown_2(from.unknown_2());
    }
    if (from.has_unknown_3()) {
      set_unknown_3(from.unknown_3());
    }
    if (from.has_unknown_4()) {
      set_unknown_4(from.unknown_4());
    }
    if (from.has_unknown_5()) {
      set_unknown_5(from.unknown_5());
    }
    if (from.has_unknown_6()) {
      set_unknown_6(from.unknown_6());
    }
    if (from.has_unknown_7()) {
      set_unknown_7(from.unknown_7());
    }
    if (from.has_unknown_8()) {
      set_unknown_8(from.unknown_8());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_unknown_9()) {
      set_unknown_9(from.unknown_9());
    }
    if (from.has_unknown_10()) {
      set_unknown_10(from.unknown_10());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestNotifyRegisterCharacter::CopyFrom(const RequestNotifyRegisterCharacter& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestNotifyRegisterCharacter::IsInitialized() const {
  if ((_has_bits_[0] & 0x000003ff) != 0x000003ff) return false;

  if (has_status()) {
    if (!this->status().IsInitialized()) return false;
  }
  return true;
}

void RequestNotifyRegisterCharacter::Swap(RequestNotifyRegisterCharacter* other) {
  if (other != this) {
    std::swap(status_, other->status_);
    std::swap(unknown_2_, other->unknown_2_);
    std::swap(unknown_3_, other->unknown_3_);
    std::swap(unknown_4_, other->unknown_4_);
    std::swap(unknown_5_, other->unknown_5_);
    std::swap(unknown_6_, other->unknown_6_);
    std::swap(unknown_7_, other->unknown_7_);
    std::swap(unknown_8_, other->unknown_8_);
    std::swap(unknown_9_, other->unknown_9_);
    std::swap(unknown_10_, other->unknown_10_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestNotifyRegisterCharacter::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestNotifyRegisterCharacter";
}


// ===================================================================

#ifndef _MSC_VER
const int SummonSignMessage::kPlayerIdFieldNumber;
const int SummonSignMessage::kSteamIdFieldNumber;
const int SummonSignMessage::kSignInfoFieldNumber;
const int SummonSignMessage::kPlayerStructFieldNumber;
#endif  // !_MSC_VER

SummonSignMessage::SummonSignMessage()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.SummonSignMessage)
}

void SummonSignMessage::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  sign_info_ = const_cast< ::DS3_Frpg2RequestMessage::SignInfo*>(
      ::DS3_Frpg2RequestMessage::SignInfo::internal_default_instance());
#else
  sign_info_ = const_cast< ::DS3_Frpg2RequestMessage::SignInfo*>(&::DS3_Frpg2RequestMessage::SignInfo::default_instance());
#endif
}

SummonSignMessage::SummonSignMessage(const SummonSignMessage& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.SummonSignMessage)
}

void SummonSignMessage::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  player_id_ = 0u;
  steam_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  sign_info_ = NULL;
  player_struct_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SummonSignMessage::~SummonSignMessage() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.SummonSignMessage)
  SharedDtor();
}

void SummonSignMessage::SharedDtor() {
  if (steam_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete steam_id_;
  }
  if (player_struct_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete player_struct_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete sign_info_;
  }
}

void SummonSignMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SummonSignMessage& SummonSignMessage::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

SummonSignMessage* SummonSignMessage::default_instance_ = NULL;

SummonSignMessage* SummonSignMessage::New() const {
  return new SummonSignMessage;
}

void SummonSignMessage::Clear() {
  if (_has_bits_[0 / 32] & 15) {
    player_id_ = 0u;
    if (has_steam_id()) {
      if (steam_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        steam_id_->clear();
      }
    }
    if (has_sign_info()) {
      if (sign_info_ != NULL) sign_info_->::DS3_Frpg2RequestMessage::SignInfo::Clear();
    }
    if (has_player_struct()) {
      if (player_struct_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        player_struct_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool SummonSignMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.SummonSignMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 player_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &player_id_)));
          set_has_player_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_steam_id;
        break;
      }

      // required string steam_id = 2;
      case 2: {
        if (tag == 18) {
         parse_steam_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_steam_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_sign_info;
        break;
      }

      // required .DS3_Frpg2RequestMessage.SignInfo sign_info = 3;
      case 3: {
        if (tag == 26) {
         parse_sign_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_sign_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_player_struct;
        break;
      }

      // required bytes player_struct = 4;
      case 4: {
        if (tag == 34) {
         parse_player_struct:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_player_struct()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.SummonSignMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.SummonSignMessage)
  return false;
#undef DO_
}

void SummonSignMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.SummonSignMessage)
  // required uint32 player_id = 1;
  if (has_player_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->player_id(), output);
  }

  // required string steam_id = 2;
  if (has_steam_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->steam_id(), output);
  }

  // required .DS3_Frpg2RequestMessage.SignInfo sign_info = 3;
  if (has_sign_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->sign_info(), output);
  }

  // required bytes player_struct = 4;
  if (has_player_struct()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      4, this->player_struct(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.SummonSignMessage)
}

int SummonSignMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 player_id = 1;
    if (has_player_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->player_id());
    }

    // required string steam_id = 2;
    if (has_steam_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->steam_id());
    }

    // required .DS3_Frpg2RequestMessage.SignInfo sign_info = 3;
    if (has_sign_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->sign_info());
    }

    // required bytes player_struct = 4;
    if (has_player_struct()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->player_struct());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SummonSignMessage::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SummonSignMessage*>(&from));
}

void SummonSignMessage::MergeFrom(const SummonSignMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_player_id()) {
      set_player_id(from.player_id());
    }
    if (from.has_steam_id()) {
      set_steam_id(from.steam_id());
    }
    if (from.has_sign_info()) {
      mutable_sign_info()->::DS3_Frpg2RequestMessage::SignInfo::MergeFrom(from.sign_info());
    }
    if (from.has_player_struct()) {
      set_player_struct(from.player_struct());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void SummonSignMessage::CopyFrom(const SummonSignMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SummonSignMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  if (has_sign_info()) {
    if (!this->sign_info().IsInitialized()) return false;
  }
  return true;
}

void SummonSignMessage::Swap(SummonSignMessage* other) {
  if (other != this) {
    std::swap(player_id_, other->player_id_);
    std::swap(steam_id_, other->steam_id_);
    std::swap(sign_info_, other->sign_info_);
    std::swap(player_struct_, other->player_struct_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SummonSignMessage::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.SummonSignMessage";
}


// ===================================================================

#ifndef _MSC_VER
const int RemoveSignMessage::kPlayerIdFieldNumber;
const int RemoveSignMessage::kSignIdFieldNumber;
#endif  // !_MSC_VER

RemoveSignMessage::RemoveSignMessage()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RemoveSignMessage)
}

void RemoveSignMessage::InitAsDefaultInstance() {
}

RemoveSignMessage::RemoveSignMessage(const RemoveSignMessage& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RemoveSignMessage)
}

void RemoveSignMessage::SharedCtor() {
  _cached_size_ = 0;
  player_id_ = 0u;
  sign_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RemoveSignMessage::~RemoveSignMessage() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RemoveSignMessage)
  SharedDtor();
}

void RemoveSignMessage::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RemoveSignMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RemoveSignMessage& RemoveSignMessage::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RemoveSignMessage* RemoveSignMessage::default_instance_ = NULL;

RemoveSignMessage* RemoveSignMessage::New() const {
  return new RemoveSignMessage;
}

void RemoveSignMessage::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<RemoveSignMessage*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(player_id_, sign_id_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RemoveSignMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RemoveSignMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 player_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &player_id_)));
          set_has_player_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_sign_id;
        break;
      }

      // required uint32 sign_id = 2;
      case 2: {
        if (tag == 16) {
         parse_sign_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &sign_id_)));
          set_has_sign_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RemoveSignMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RemoveSignMessage)
  return false;
#undef DO_
}

void RemoveSignMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RemoveSignMessage)
  // required uint32 player_id = 1;
  if (has_player_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->player_id(), output);
  }

  // required uint32 sign_id = 2;
  if (has_sign_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->sign_id(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RemoveSignMessage)
}

int RemoveSignMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 player_id = 1;
    if (has_player_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->player_id());
    }

    // required uint32 sign_id = 2;
    if (has_sign_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->sign_id());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RemoveSignMessage::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RemoveSignMessage*>(&from));
}

void RemoveSignMessage::MergeFrom(const RemoveSignMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_player_id()) {
      set_player_id(from.player_id());
    }
    if (from.has_sign_id()) {
      set_sign_id(from.sign_id());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RemoveSignMessage::CopyFrom(const RemoveSignMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RemoveSignMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void RemoveSignMessage::Swap(RemoveSignMessage* other) {
  if (other != this) {
    std::swap(player_id_, other->player_id_);
    std::swap(sign_id_, other->sign_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RemoveSignMessage::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RemoveSignMessage";
}


// ===================================================================

#ifndef _MSC_VER
const int RejectSignMessage::kSignIdFieldNumber;
const int RejectSignMessage::kUnknown2FieldNumber;
#endif  // !_MSC_VER

RejectSignMessage::RejectSignMessage()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RejectSignMessage)
}

void RejectSignMessage::InitAsDefaultInstance() {
}

RejectSignMessage::RejectSignMessage(const RejectSignMessage& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RejectSignMessage)
}

void RejectSignMessage::SharedCtor() {
  _cached_size_ = 0;
  sign_id_ = 0u;
  unknown_2_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RejectSignMessage::~RejectSignMessage() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RejectSignMessage)
  SharedDtor();
}

void RejectSignMessage::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RejectSignMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RejectSignMessage& RejectSignMessage::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RejectSignMessage* RejectSignMessage::default_instance_ = NULL;

RejectSignMessage* RejectSignMessage::New() const {
  return new RejectSignMessage;
}

void RejectSignMessage::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<RejectSignMessage*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(sign_id_, unknown_2_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RejectSignMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RejectSignMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 sign_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &sign_id_)));
          set_has_sign_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_unknown_2;
        break;
      }

      // required uint32 unknown_2 = 2;
      case 2: {
        if (tag == 16) {
         parse_unknown_2:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_2_)));
          set_has_unknown_2();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RejectSignMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RejectSignMessage)
  return false;
#undef DO_
}

void RejectSignMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RejectSignMessage)
  // required uint32 sign_id = 1;
  if (has_sign_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->sign_id(), output);
  }

  // required uint32 unknown_2 = 2;
  if (has_unknown_2()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->unknown_2(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RejectSignMessage)
}

int RejectSignMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 sign_id = 1;
    if (has_sign_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->sign_id());
    }

    // required uint32 unknown_2 = 2;
    if (has_unknown_2()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_2());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RejectSignMessage::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RejectSignMessage*>(&from));
}

void RejectSignMessage::MergeFrom(const RejectSignMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_sign_id()) {
      set_sign_id(from.sign_id());
    }
    if (from.has_unknown_2()) {
      set_unknown_2(from.unknown_2());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RejectSignMessage::CopyFrom(const RejectSignMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RejectSignMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void RejectSignMessage::Swap(RejectSignMessage* other) {
  if (other != this) {
    std::swap(sign_id_, other->sign_id_);
    std::swap(unknown_2_, other->unknown_2_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RejectSignMessage::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RejectSignMessage";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

CachedSign::CachedSign()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.CachedSign)
}

void CachedSign::InitAsDefaultInstance() {
}

CachedSign::CachedSign(const CachedSign& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.CachedSign)
}

void CachedSign::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CachedSign::~CachedSign() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.CachedSign)
  SharedDtor();
}

void CachedSign::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CachedSign::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CachedSign& CachedSign::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

CachedSign* CachedSign::default_instance_ = NULL;

CachedSign* CachedSign::New() const {
  return new CachedSign;
}

void CachedSign::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CachedSign::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.CachedSign)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.CachedSign)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.CachedSign)
  return false;
#undef DO_
}

void CachedSign::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.CachedSign)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.CachedSign)
}

int CachedSign::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CachedSign::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CachedSign*>(&from));
}

void CachedSign::MergeFrom(const CachedSign& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CachedSign::CopyFrom(const CachedSign& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CachedSign::IsInitialized() const {

  return true;
}

void CachedSign::Swap(CachedSign* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CachedSign::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.CachedSign";
}


// ===================================================================

#ifndef _MSC_VER
const int GetSignResult::kSignInfoWithoutDataFieldNumber;
const int GetSignResult::kSignDataFieldNumber;
#endif  // !_MSC_VER

GetSignResult::GetSignResult()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.GetSignResult)
}

void GetSignResult::InitAsDefaultInstance() {
}

GetSignResult::GetSignResult(const GetSignResult& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.GetSignResult)
}

void GetSignResult::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetSignResult::~GetSignResult() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.GetSignResult)
  SharedDtor();
}

void GetSignResult::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GetSignResult::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GetSignResult& GetSignResult::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

GetSignResult* GetSignResult::default_instance_ = NULL;

GetSignResult* GetSignResult::New() const {
  return new GetSignResult;
}

void GetSignResult::Clear() {
  sign_info_without_data_.Clear();
  sign_data_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool GetSignResult::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.GetSignResult)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .DS3_Frpg2RequestMessage.SignInfo sign_info_without_data = 1;
      case 1: {
        if (tag == 10) {
         parse_sign_info_without_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_sign_info_without_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_sign_info_without_data;
        if (input->ExpectTag(18)) goto parse_sign_data;
        break;
      }

      // repeated .DS3_Frpg2RequestMessage.SignData sign_data = 2;
      case 2: {
        if (tag == 18) {
         parse_sign_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_sign_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_sign_data;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.GetSignResult)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.GetSignResult)
  return false;
#undef DO_
}

void GetSignResult::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.GetSignResult)
  // repeated .DS3_Frpg2RequestMessage.SignInfo sign_info_without_data = 1;
  for (int i = 0; i < this->sign_info_without_data_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->sign_info_without_data(i), output);
  }

  // repeated .DS3_Frpg2RequestMessage.SignData sign_data = 2;
  for (int i = 0; i < this->sign_data_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->sign_data(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.GetSignResult)
}

int GetSignResult::ByteSize() const {
  int total_size = 0;

  // repeated .DS3_Frpg2RequestMessage.SignInfo sign_info_without_data = 1;
  total_size += 1 * this->sign_info_without_data_size();
  for (int i = 0; i < this->sign_info_without_data_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->sign_info_without_data(i));
  }

  // repeated .DS3_Frpg2RequestMessage.SignData sign_data = 2;
  total_size += 1 * this->sign_data_size();
  for (int i = 0; i < this->sign_data_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->sign_data(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetSignResult::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GetSignResult*>(&from));
}

void GetSignResult::MergeFrom(const GetSignResult& from) {
  GOOGLE_CHECK_NE(&from, this);
  sign_info_without_data_.MergeFrom(from.sign_info_without_data_);
  sign_data_.MergeFrom(from.sign_data_);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void GetSignResult::CopyFrom(const GetSignResult& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetSignResult::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->sign_info_without_data())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->sign_data())) return false;
  return true;
}

void GetSignResult::Swap(GetSignResult* other) {
  if (other != this) {
    sign_info_without_data_.Swap(&other->sign_info_without_data_);
    sign_data_.Swap(&other->sign_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GetSignResult::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.GetSignResult";
}


// ===================================================================

#ifndef _MSC_VER
const int SignInfo::kPlayerIdFieldNumber;
const int SignInfo::kSignIdFieldNumber;
#endif  // !_MSC_VER

SignInfo::SignInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.SignInfo)
}

void SignInfo::InitAsDefaultInstance() {
}

SignInfo::SignInfo(const SignInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.SignInfo)
}

void SignInfo::SharedCtor() {
  _cached_size_ = 0;
  player_id_ = 0u;
  sign_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SignInfo::~SignInfo() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.SignInfo)
  SharedDtor();
}

void SignInfo::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void SignInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SignInfo& SignInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

SignInfo* SignInfo::default_instance_ = NULL;

SignInfo* SignInfo::New() const {
  return new SignInfo;
}

void SignInfo::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<SignInfo*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(player_id_, sign_id_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool SignInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.SignInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 player_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &player_id_)));
          set_has_player_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_sign_id;
        break;
      }

      // required uint32 sign_id = 2;
      case 2: {
        if (tag == 16) {
         parse_sign_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &sign_id_)));
          set_has_sign_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.SignInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.SignInfo)
  return false;
#undef DO_
}

void SignInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.SignInfo)
  // required uint32 player_id = 1;
  if (has_player_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->player_id(), output);
  }

  // required uint32 sign_id = 2;
  if (has_sign_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->sign_id(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.SignInfo)
}

int SignInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 player_id = 1;
    if (has_player_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->player_id());
    }

    // required uint32 sign_id = 2;
    if (has_sign_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->sign_id());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SignInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SignInfo*>(&from));
}

void SignInfo::MergeFrom(const SignInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_player_id()) {
      set_player_id(from.player_id());
    }
    if (from.has_sign_id()) {
      set_sign_id(from.sign_id());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void SignInfo::CopyFrom(const SignInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SignInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void SignInfo::Swap(SignInfo* other) {
  if (other != this) {
    std::swap(player_id_, other->player_id_);
    std::swap(sign_id_, other->sign_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SignInfo::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.SignInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int SignData::kSignInfoFieldNumber;
const int SignData::kOnlineAreaIdFieldNumber;
const int SignData::kMatchingParameterFieldNumber;
const int SignData::kPlayerStructFieldNumber;
const int SignData::kSteamIdFieldNumber;
const int SignData::kSignTypeFieldNumber;
#endif  // !_MSC_VER

SignData::SignData()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.SignData)
}

void SignData::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  sign_info_ = const_cast< ::DS3_Frpg2RequestMessage::SignInfo*>(
      ::DS3_Frpg2RequestMessage::SignInfo::internal_default_instance());
#else
  sign_info_ = const_cast< ::DS3_Frpg2RequestMessage::SignInfo*>(&::DS3_Frpg2RequestMessage::SignInfo::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  matching_parameter_ = const_cast< ::DS3_Frpg2RequestMessage::MatchingParameter*>(
      ::DS3_Frpg2RequestMessage::MatchingParameter::internal_default_instance());
#else
  matching_parameter_ = const_cast< ::DS3_Frpg2RequestMessage::MatchingParameter*>(&::DS3_Frpg2RequestMessage::MatchingParameter::default_instance());
#endif
}

SignData::SignData(const SignData& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.SignData)
}

void SignData::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  sign_info_ = NULL;
  online_area_id_ = 0u;
  matching_parameter_ = NULL;
  player_struct_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  steam_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  sign_type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SignData::~SignData() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.SignData)
  SharedDtor();
}

void SignData::SharedDtor() {
  if (player_struct_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete player_struct_;
  }
  if (steam_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete steam_id_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete sign_info_;
    delete matching_parameter_;
  }
}

void SignData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SignData& SignData::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

SignData* SignData::default_instance_ = NULL;

SignData* SignData::New() const {
  return new SignData;
}

void SignData::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<SignData*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 63) {
    ZR_(online_area_id_, sign_type_);
    if (has_sign_info()) {
      if (sign_info_ != NULL) sign_info_->::DS3_Frpg2RequestMessage::SignInfo::Clear();
    }
    if (has_matching_parameter()) {
      if (matching_parameter_ != NULL) matching_parameter_->::DS3_Frpg2RequestMessage::MatchingParameter::Clear();
    }
    if (has_player_struct()) {
      if (player_struct_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        player_struct_->clear();
      }
    }
    if (has_steam_id()) {
      if (steam_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        steam_id_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool SignData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.SignData)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .DS3_Frpg2RequestMessage.SignInfo sign_info = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_sign_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_online_area_id;
        break;
      }

      // required uint32 online_area_id = 2;
      case 2: {
        if (tag == 16) {
         parse_online_area_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &online_area_id_)));
          set_has_online_area_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_matching_parameter;
        break;
      }

      // required .DS3_Frpg2RequestMessage.MatchingParameter matching_parameter = 3;
      case 3: {
        if (tag == 26) {
         parse_matching_parameter:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_matching_parameter()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_player_struct;
        break;
      }

      // required bytes player_struct = 4;
      case 4: {
        if (tag == 34) {
         parse_player_struct:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_player_struct()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_steam_id;
        break;
      }

      // required string steam_id = 5;
      case 5: {
        if (tag == 42) {
         parse_steam_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_steam_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_sign_type;
        break;
      }

      // required .DS3_Frpg2RequestMessage.SignType sign_type = 6;
      case 6: {
        if (tag == 48) {
         parse_sign_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::DS3_Frpg2RequestMessage::SignType_IsValid(value)) {
            set_sign_type(static_cast< ::DS3_Frpg2RequestMessage::SignType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.SignData)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.SignData)
  return false;
#undef DO_
}

void SignData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.SignData)
  // required .DS3_Frpg2RequestMessage.SignInfo sign_info = 1;
  if (has_sign_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->sign_info(), output);
  }

  // required uint32 online_area_id = 2;
  if (has_online_area_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->online_area_id(), output);
  }

  // required .DS3_Frpg2RequestMessage.MatchingParameter matching_parameter = 3;
  if (has_matching_parameter()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->matching_parameter(), output);
  }

  // required bytes player_struct = 4;
  if (has_player_struct()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      4, this->player_struct(), output);
  }

  // required string steam_id = 5;
  if (has_steam_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->steam_id(), output);
  }

  // required .DS3_Frpg2RequestMessage.SignType sign_type = 6;
  if (has_sign_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      6, this->sign_type(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.SignData)
}

int SignData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .DS3_Frpg2RequestMessage.SignInfo sign_info = 1;
    if (has_sign_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->sign_info());
    }

    // required uint32 online_area_id = 2;
    if (has_online_area_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->online_area_id());
    }

    // required .DS3_Frpg2RequestMessage.MatchingParameter matching_parameter = 3;
    if (has_matching_parameter()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->matching_parameter());
    }

    // required bytes player_struct = 4;
    if (has_player_struct()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->player_struct());
    }

    // required string steam_id = 5;
    if (has_steam_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->steam_id());
    }

    // required .DS3_Frpg2RequestMessage.SignType sign_type = 6;
    if (has_sign_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->sign_type());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SignData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SignData*>(&from));
}

void SignData::MergeFrom(const SignData& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_sign_info()) {
      mutable_sign_info()->::DS3_Frpg2RequestMessage::SignInfo::MergeFrom(from.sign_info());
    }
    if (from.has_online_area_id()) {
      set_online_area_id(from.online_area_id());
    }
    if (from.has_matching_parameter()) {
      mutable_matching_parameter()->::DS3_Frpg2RequestMessage::MatchingParameter::MergeFrom(from.matching_parameter());
    }
    if (from.has_player_struct()) {
      set_player_struct(from.player_struct());
    }
    if (from.has_steam_id()) {
      set_steam_id(from.steam_id());
    }
    if (from.has_sign_type()) {
      set_sign_type(from.sign_type());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void SignData::CopyFrom(const SignData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SignData::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003f) != 0x0000003f) return false;

  if (has_sign_info()) {
    if (!this->sign_info().IsInitialized()) return false;
  }
  if (has_matching_parameter()) {
    if (!this->matching_parameter().IsInitialized()) return false;
  }
  return true;
}

void SignData::Swap(SignData* other) {
  if (other != this) {
    std::swap(sign_info_, other->sign_info_);
    std::swap(online_area_id_, other->online_area_id_);
    std::swap(matching_parameter_, other->matching_parameter_);
    std::swap(player_struct_, other->player_struct_);
    std::swap(steam_id_, other->steam_id_);
    std::swap(sign_type_, other->sign_type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SignData::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.SignData";
}


// ===================================================================

#ifndef _MSC_VER
const int MatchingParameter::kRegulationVersionFieldNumber;
const int MatchingParameter::kUnknownId2FieldNumber;
const int MatchingParameter::kAllowCrossRegionFieldNumber;
const int MatchingParameter::kNatTypeFieldNumber;
const int MatchingParameter::kUnknownId5FieldNumber;
const int MatchingParameter::kSoulLevelFieldNumber;
const int MatchingParameter::kSoulMemoryFieldNumber;
const int MatchingParameter::kUnknownStringFieldNumber;
const int MatchingParameter::kClearCountFieldNumber;
const int MatchingParameter::kPasswordFieldNumber;
const int MatchingParameter::kCovenantFieldNumber;
const int MatchingParameter::kWeaponLevelFieldNumber;
const int MatchingParameter::kUnknownId15FieldNumber;
#endif  // !_MSC_VER

MatchingParameter::MatchingParameter()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.MatchingParameter)
}

void MatchingParameter::InitAsDefaultInstance() {
}

MatchingParameter::MatchingParameter(const MatchingParameter& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.MatchingParameter)
}

void MatchingParameter::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  regulation_version_ = 0u;
  unknown_id_2_ = 0u;
  allow_cross_region_ = 0u;
  nat_type_ = 0u;
  unknown_id_5_ = 0u;
  soul_level_ = 0u;
  soul_memory_ = 0u;
  unknown_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_count_ = 0u;
  password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  covenant_ = 0;
  weapon_level_ = 0u;
  unknown_id_15_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MatchingParameter::~MatchingParameter() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.MatchingParameter)
  SharedDtor();
}

void MatchingParameter::SharedDtor() {
  if (unknown_string_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete unknown_string_;
  }
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete password_;
  }
  if (unknown_id_15_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete unknown_id_15_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void MatchingParameter::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const MatchingParameter& MatchingParameter::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

MatchingParameter* MatchingParameter::default_instance_ = NULL;

MatchingParameter* MatchingParameter::New() const {
  return new MatchingParameter;
}

void MatchingParameter::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<MatchingParameter*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(regulation_version_, soul_level_);
    soul_memory_ = 0u;
    if (has_unknown_string()) {
      if (unknown_string_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        unknown_string_->clear();
      }
    }
  }
  if (_has_bits_[8 / 32] & 7936) {
    ZR_(covenant_, weapon_level_);
    clear_count_ = 0u;
    if (has_password()) {
      if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        password_->clear();
      }
    }
    if (has_unknown_id_15()) {
      if (unknown_id_15_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        unknown_id_15_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool MatchingParameter::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.MatchingParameter)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 regulation_version = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &regulation_version_)));
          set_has_regulation_version();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_unknown_id_2;
        break;
      }

      // required uint32 unknown_id_2 = 2;
      case 2: {
        if (tag == 16) {
         parse_unknown_id_2:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_id_2_)));
          set_has_unknown_id_2();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_allow_cross_region;
        break;
      }

      // required uint32 allow_cross_region = 3;
      case 3: {
        if (tag == 24) {
         parse_allow_cross_region:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &allow_cross_region_)));
          set_has_allow_cross_region();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_nat_type;
        break;
      }

      // required uint32 nat_type = 4;
      case 4: {
        if (tag == 32) {
         parse_nat_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &nat_type_)));
          set_has_nat_type();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_unknown_id_5;
        break;
      }

      // required uint32 unknown_id_5 = 5;
      case 5: {
        if (tag == 40) {
         parse_unknown_id_5:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_id_5_)));
          set_has_unknown_id_5();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_soul_level;
        break;
      }

      // required uint32 soul_level = 6;
      case 6: {
        if (tag == 48) {
         parse_soul_level:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &soul_level_)));
          set_has_soul_level();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_soul_memory;
        break;
      }

      // required uint32 soul_memory = 7;
      case 7: {
        if (tag == 56) {
         parse_soul_memory:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &soul_memory_)));
          set_has_soul_memory();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_unknown_string;
        break;
      }

      // optional string unknown_string = 8;
      case 8: {
        if (tag == 66) {
         parse_unknown_string:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_unknown_string()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_clear_count;
        break;
      }

      // required uint32 clear_count = 9;
      case 9: {
        if (tag == 72) {
         parse_clear_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &clear_count_)));
          set_has_clear_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(82)) goto parse_password;
        break;
      }

      // required string password = 10;
      case 10: {
        if (tag == 82) {
         parse_password:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_password()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(88)) goto parse_covenant;
        break;
      }

      // required .DS3_Frpg2RequestMessage.Covenant covenant = 11;
      case 11: {
        if (tag == 88) {
         parse_covenant:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::DS3_Frpg2RequestMessage::Covenant_IsValid(value)) {
            set_covenant(static_cast< ::DS3_Frpg2RequestMessage::Covenant >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(112)) goto parse_weapon_level;
        break;
      }

      // required uint32 weapon_level = 14;
      case 14: {
        if (tag == 112) {
         parse_weapon_level:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &weapon_level_)));
          set_has_weapon_level();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(122)) goto parse_unknown_id_15;
        break;
      }

      // optional string unknown_id_15 = 15;
      case 15: {
        if (tag == 122) {
         parse_unknown_id_15:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_unknown_id_15()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.MatchingParameter)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.MatchingParameter)
  return false;
#undef DO_
}

void MatchingParameter::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.MatchingParameter)
  // required uint32 regulation_version = 1;
  if (has_regulation_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->regulation_version(), output);
  }

  // required uint32 unknown_id_2 = 2;
  if (has_unknown_id_2()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->unknown_id_2(), output);
  }

  // required uint32 allow_cross_region = 3;
  if (has_allow_cross_region()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->allow_cross_region(), output);
  }

  // required uint32 nat_type = 4;
  if (has_nat_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->nat_type(), output);
  }

  // required uint32 unknown_id_5 = 5;
  if (has_unknown_id_5()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->unknown_id_5(), output);
  }

  // required uint32 soul_level = 6;
  if (has_soul_level()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->soul_level(), output);
  }

  // required uint32 soul_memory = 7;
  if (has_soul_memory()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->soul_memory(), output);
  }

  // optional string unknown_string = 8;
  if (has_unknown_string()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      8, this->unknown_string(), output);
  }

  // required uint32 clear_count = 9;
  if (has_clear_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->clear_count(), output);
  }

  // required string password = 10;
  if (has_password()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      10, this->password(), output);
  }

  // required .DS3_Frpg2RequestMessage.Covenant covenant = 11;
  if (has_covenant()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      11, this->covenant(), output);
  }

  // required uint32 weapon_level = 14;
  if (has_weapon_level()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(14, this->weapon_level(), output);
  }

  // optional string unknown_id_15 = 15;
  if (has_unknown_id_15()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      15, this->unknown_id_15(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.MatchingParameter)
}

int MatchingParameter::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 regulation_version = 1;
    if (has_regulation_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->regulation_version());
    }

    // required uint32 unknown_id_2 = 2;
    if (has_unknown_id_2()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_id_2());
    }

    // required uint32 allow_cross_region = 3;
    if (has_allow_cross_region()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->allow_cross_region());
    }

    // required uint32 nat_type = 4;
    if (has_nat_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->nat_type());
    }

    // required uint32 unknown_id_5 = 5;
    if (has_unknown_id_5()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_id_5());
    }

    // required uint32 soul_level = 6;
    if (has_soul_level()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->soul_level());
    }

    // required uint32 soul_memory = 7;
    if (has_soul_memory()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->soul_memory());
    }

    // optional string unknown_string = 8;
    if (has_unknown_string()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->unknown_string());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // required uint32 clear_count = 9;
    if (has_clear_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->clear_count());
    }

    // required string password = 10;
    if (has_password()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->password());
    }

    // required .DS3_Frpg2RequestMessage.Covenant covenant = 11;
    if (has_covenant()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->covenant());
    }

    // required uint32 weapon_level = 14;
    if (has_weapon_level()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->weapon_level());
    }

    // optional string unknown_id_15 = 15;
    if (has_unknown_id_15()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->unknown_id_15());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MatchingParameter::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const MatchingParameter*>(&from));
}

void MatchingParameter::MergeFrom(const MatchingParameter& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_regulation_version()) {
      set_regulation_version(from.regulation_version());
    }
    if (from.has_unknown_id_2()) {
      set_unknown_id_2(from.unknown_id_2());
    }
    if (from.has_allow_cross_region()) {
      set_allow_cross_region(from.allow_cross_region());
    }
    if (from.has_nat_type()) {
      set_nat_type(from.nat_type());
    }
    if (from.has_unknown_id_5()) {
      set_unknown_id_5(from.unknown_id_5());
    }
    if (from.has_soul_level()) {
      set_soul_level(from.soul_level());
    }
    if (from.has_soul_memory()) {
      set_soul_memory(from.soul_memory());
    }
    if (from.has_unknown_string()) {
      set_unknown_string(from.unknown_string());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_clear_count()) {
      set_clear_count(from.clear_count());
    }
    if (from.has_password()) {
      set_password(from.password());
    }
    if (from.has_covenant()) {
      set_covenant(from.covenant());
    }
    if (from.has_weapon_level()) {
      set_weapon_level(from.weapon_level());
    }
    if (from.has_unknown_id_15()) {
      set_unknown_id_15(from.unknown_id_15());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void MatchingParameter::CopyFrom(const MatchingParameter& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MatchingParameter::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000f7f) != 0x00000f7f) return false;

  return true;
}

void MatchingParameter::Swap(MatchingParameter* other) {
  if (other != this) {
    std::swap(regulation_version_, other->regulation_version_);
    std::swap(unknown_id_2_, other->unknown_id_2_);
    std::swap(allow_cross_region_, other->allow_cross_region_);
    std::swap(nat_type_, other->nat_type_);
    std::swap(unknown_id_5_, other->unknown_id_5_);
    std::swap(soul_level_, other->soul_level_);
    std::swap(soul_memory_, other->soul_memory_);
    std::swap(unknown_string_, other->unknown_string_);
    std::swap(clear_count_, other->clear_count_);
    std::swap(password_, other->password_);
    std::swap(covenant_, other->covenant_);
    std::swap(weapon_level_, other->weapon_level_);
    std::swap(unknown_id_15_, other->unknown_id_15_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string MatchingParameter::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.MatchingParameter";
}


// ===================================================================

#ifndef _MSC_VER
const int SignGetFlags::kUnknownId1FieldNumber;
const int SignGetFlags::kUnknownId2FieldNumber;
const int SignGetFlags::kUnknownId3FieldNumber;
#endif  // !_MSC_VER

SignGetFlags::SignGetFlags()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.SignGetFlags)
}

void SignGetFlags::InitAsDefaultInstance() {
}

SignGetFlags::SignGetFlags(const SignGetFlags& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.SignGetFlags)
}

void SignGetFlags::SharedCtor() {
  _cached_size_ = 0;
  unknown_id_1_ = 0u;
  unknown_id_2_ = 0u;
  unknown_id_3_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SignGetFlags::~SignGetFlags() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.SignGetFlags)
  SharedDtor();
}

void SignGetFlags::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void SignGetFlags::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SignGetFlags& SignGetFlags::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

SignGetFlags* SignGetFlags::default_instance_ = NULL;

SignGetFlags* SignGetFlags::New() const {
  return new SignGetFlags;
}

void SignGetFlags::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<SignGetFlags*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(unknown_id_1_, unknown_id_3_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool SignGetFlags::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.SignGetFlags)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 unknown_id_1 = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_id_1_)));
          set_has_unknown_id_1();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_unknown_id_2;
        break;
      }

      // required uint32 unknown_id_2 = 2;
      case 2: {
        if (tag == 16) {
         parse_unknown_id_2:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_id_2_)));
          set_has_unknown_id_2();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_unknown_id_3;
        break;
      }

      // required uint32 unknown_id_3 = 3;
      case 3: {
        if (tag == 24) {
         parse_unknown_id_3:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_id_3_)));
          set_has_unknown_id_3();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.SignGetFlags)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.SignGetFlags)
  return false;
#undef DO_
}

void SignGetFlags::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.SignGetFlags)
  // required uint32 unknown_id_1 = 1;
  if (has_unknown_id_1()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->unknown_id_1(), output);
  }

  // required uint32 unknown_id_2 = 2;
  if (has_unknown_id_2()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->unknown_id_2(), output);
  }

  // required uint32 unknown_id_3 = 3;
  if (has_unknown_id_3()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->unknown_id_3(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.SignGetFlags)
}

int SignGetFlags::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 unknown_id_1 = 1;
    if (has_unknown_id_1()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_id_1());
    }

    // required uint32 unknown_id_2 = 2;
    if (has_unknown_id_2()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_id_2());
    }

    // required uint32 unknown_id_3 = 3;
    if (has_unknown_id_3()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_id_3());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SignGetFlags::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SignGetFlags*>(&from));
}

void SignGetFlags::MergeFrom(const SignGetFlags& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_unknown_id_1()) {
      set_unknown_id_1(from.unknown_id_1());
    }
    if (from.has_unknown_id_2()) {
      set_unknown_id_2(from.unknown_id_2());
    }
    if (from.has_unknown_id_3()) {
      set_unknown_id_3(from.unknown_id_3());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void SignGetFlags::CopyFrom(const SignGetFlags& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SignGetFlags::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void SignGetFlags::Swap(SignGetFlags* other) {
  if (other != this) {
    std::swap(unknown_id_1_, other->unknown_id_1_);
    std::swap(unknown_id_2_, other->unknown_id_2_);
    std::swap(unknown_id_3_, other->unknown_id_3_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SignGetFlags::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.SignGetFlags";
}


// ===================================================================

#ifndef _MSC_VER
const int SignDomainGetInfo::kOnlineAreaIdFieldNumber;
const int SignDomainGetInfo::kMaxSignsFieldNumber;
const int SignDomainGetInfo::kAlreadyHaveSignsFieldNumber;
#endif  // !_MSC_VER

SignDomainGetInfo::SignDomainGetInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.SignDomainGetInfo)
}

void SignDomainGetInfo::InitAsDefaultInstance() {
}

SignDomainGetInfo::SignDomainGetInfo(const SignDomainGetInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.SignDomainGetInfo)
}

void SignDomainGetInfo::SharedCtor() {
  _cached_size_ = 0;
  online_area_id_ = 0u;
  max_signs_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SignDomainGetInfo::~SignDomainGetInfo() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.SignDomainGetInfo)
  SharedDtor();
}

void SignDomainGetInfo::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void SignDomainGetInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SignDomainGetInfo& SignDomainGetInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

SignDomainGetInfo* SignDomainGetInfo::default_instance_ = NULL;

SignDomainGetInfo* SignDomainGetInfo::New() const {
  return new SignDomainGetInfo;
}

void SignDomainGetInfo::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<SignDomainGetInfo*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(online_area_id_, max_signs_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  already_have_signs_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool SignDomainGetInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.SignDomainGetInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 online_area_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &online_area_id_)));
          set_has_online_area_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_max_signs;
        break;
      }

      // required uint32 max_signs = 2;
      case 2: {
        if (tag == 16) {
         parse_max_signs:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &max_signs_)));
          set_has_max_signs();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_already_have_signs;
        break;
      }

      // repeated .DS3_Frpg2RequestMessage.SignInfo already_have_signs = 3;
      case 3: {
        if (tag == 26) {
         parse_already_have_signs:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_already_have_signs()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_already_have_signs;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.SignDomainGetInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.SignDomainGetInfo)
  return false;
#undef DO_
}

void SignDomainGetInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.SignDomainGetInfo)
  // required uint32 online_area_id = 1;
  if (has_online_area_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->online_area_id(), output);
  }

  // required uint32 max_signs = 2;
  if (has_max_signs()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->max_signs(), output);
  }

  // repeated .DS3_Frpg2RequestMessage.SignInfo already_have_signs = 3;
  for (int i = 0; i < this->already_have_signs_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->already_have_signs(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.SignDomainGetInfo)
}

int SignDomainGetInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 online_area_id = 1;
    if (has_online_area_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->online_area_id());
    }

    // required uint32 max_signs = 2;
    if (has_max_signs()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->max_signs());
    }

  }
  // repeated .DS3_Frpg2RequestMessage.SignInfo already_have_signs = 3;
  total_size += 1 * this->already_have_signs_size();
  for (int i = 0; i < this->already_have_signs_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->already_have_signs(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SignDomainGetInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SignDomainGetInfo*>(&from));
}

void SignDomainGetInfo::MergeFrom(const SignDomainGetInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  already_have_signs_.MergeFrom(from.already_have_signs_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_online_area_id()) {
      set_online_area_id(from.online_area_id());
    }
    if (from.has_max_signs()) {
      set_max_signs(from.max_signs());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void SignDomainGetInfo::CopyFrom(const SignDomainGetInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SignDomainGetInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->already_have_signs())) return false;
  return true;
}

void SignDomainGetInfo::Swap(SignDomainGetInfo* other) {
  if (other != this) {
    std::swap(online_area_id_, other->online_area_id_);
    std::swap(max_signs_, other->max_signs_);
    already_have_signs_.Swap(&other->already_have_signs_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SignDomainGetInfo::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.SignDomainGetInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestGetSignList::kUnknownId1FieldNumber;
const int RequestGetSignList::kSearchAreasFieldNumber;
const int RequestGetSignList::kMaxSignsFieldNumber;
const int RequestGetSignList::kMatchingParameterFieldNumber;
const int RequestGetSignList::kSignGetFlagsFieldNumber;
#endif  // !_MSC_VER

RequestGetSignList::RequestGetSignList()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestGetSignList)
}

void RequestGetSignList::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  matching_parameter_ = const_cast< ::DS3_Frpg2RequestMessage::MatchingParameter*>(
      ::DS3_Frpg2RequestMessage::MatchingParameter::internal_default_instance());
#else
  matching_parameter_ = const_cast< ::DS3_Frpg2RequestMessage::MatchingParameter*>(&::DS3_Frpg2RequestMessage::MatchingParameter::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  sign_get_flags_ = const_cast< ::DS3_Frpg2RequestMessage::SignGetFlags*>(
      ::DS3_Frpg2RequestMessage::SignGetFlags::internal_default_instance());
#else
  sign_get_flags_ = const_cast< ::DS3_Frpg2RequestMessage::SignGetFlags*>(&::DS3_Frpg2RequestMessage::SignGetFlags::default_instance());
#endif
}

RequestGetSignList::RequestGetSignList(const RequestGetSignList& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestGetSignList)
}

void RequestGetSignList::SharedCtor() {
  _cached_size_ = 0;
  unknown_id_1_ = 0u;
  max_signs_ = 0u;
  matching_parameter_ = NULL;
  sign_get_flags_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestGetSignList::~RequestGetSignList() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestGetSignList)
  SharedDtor();
}

void RequestGetSignList::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete matching_parameter_;
    delete sign_get_flags_;
  }
}

void RequestGetSignList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestGetSignList& RequestGetSignList::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestGetSignList* RequestGetSignList::default_instance_ = NULL;

RequestGetSignList* RequestGetSignList::New() const {
  return new RequestGetSignList;
}

void RequestGetSignList::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<RequestGetSignList*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 29) {
    ZR_(unknown_id_1_, max_signs_);
    if (has_matching_parameter()) {
      if (matching_parameter_ != NULL) matching_parameter_->::DS3_Frpg2RequestMessage::MatchingParameter::Clear();
    }
    if (has_sign_get_flags()) {
      if (sign_get_flags_ != NULL) sign_get_flags_->::DS3_Frpg2RequestMessage::SignGetFlags::Clear();
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  search_areas_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestGetSignList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestGetSignList)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 unknown_id_1 = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_id_1_)));
          set_has_unknown_id_1();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_search_areas;
        break;
      }

      // repeated .DS3_Frpg2RequestMessage.SignDomainGetInfo search_areas = 2;
      case 2: {
        if (tag == 18) {
         parse_search_areas:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_search_areas()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_search_areas;
        if (input->ExpectTag(24)) goto parse_max_signs;
        break;
      }

      // required uint32 max_signs = 3;
      case 3: {
        if (tag == 24) {
         parse_max_signs:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &max_signs_)));
          set_has_max_signs();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_matching_parameter;
        break;
      }

      // required .DS3_Frpg2RequestMessage.MatchingParameter matching_parameter = 4;
      case 4: {
        if (tag == 34) {
         parse_matching_parameter:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_matching_parameter()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_sign_get_flags;
        break;
      }

      // required .DS3_Frpg2RequestMessage.SignGetFlags sign_get_flags = 5;
      case 5: {
        if (tag == 42) {
         parse_sign_get_flags:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_sign_get_flags()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestGetSignList)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestGetSignList)
  return false;
#undef DO_
}

void RequestGetSignList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestGetSignList)
  // required uint32 unknown_id_1 = 1;
  if (has_unknown_id_1()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->unknown_id_1(), output);
  }

  // repeated .DS3_Frpg2RequestMessage.SignDomainGetInfo search_areas = 2;
  for (int i = 0; i < this->search_areas_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->search_areas(i), output);
  }

  // required uint32 max_signs = 3;
  if (has_max_signs()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->max_signs(), output);
  }

  // required .DS3_Frpg2RequestMessage.MatchingParameter matching_parameter = 4;
  if (has_matching_parameter()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->matching_parameter(), output);
  }

  // required .DS3_Frpg2RequestMessage.SignGetFlags sign_get_flags = 5;
  if (has_sign_get_flags()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, this->sign_get_flags(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestGetSignList)
}

int RequestGetSignList::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 unknown_id_1 = 1;
    if (has_unknown_id_1()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_id_1());
    }

    // required uint32 max_signs = 3;
    if (has_max_signs()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->max_signs());
    }

    // required .DS3_Frpg2RequestMessage.MatchingParameter matching_parameter = 4;
    if (has_matching_parameter()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->matching_parameter());
    }

    // required .DS3_Frpg2RequestMessage.SignGetFlags sign_get_flags = 5;
    if (has_sign_get_flags()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->sign_get_flags());
    }

  }
  // repeated .DS3_Frpg2RequestMessage.SignDomainGetInfo search_areas = 2;
  total_size += 1 * this->search_areas_size();
  for (int i = 0; i < this->search_areas_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->search_areas(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestGetSignList::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestGetSignList*>(&from));
}

void RequestGetSignList::MergeFrom(const RequestGetSignList& from) {
  GOOGLE_CHECK_NE(&from, this);
  search_areas_.MergeFrom(from.search_areas_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_unknown_id_1()) {
      set_unknown_id_1(from.unknown_id_1());
    }
    if (from.has_max_signs()) {
      set_max_signs(from.max_signs());
    }
    if (from.has_matching_parameter()) {
      mutable_matching_parameter()->::DS3_Frpg2RequestMessage::MatchingParameter::MergeFrom(from.matching_parameter());
    }
    if (from.has_sign_get_flags()) {
      mutable_sign_get_flags()->::DS3_Frpg2RequestMessage::SignGetFlags::MergeFrom(from.sign_get_flags());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestGetSignList::CopyFrom(const RequestGetSignList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestGetSignList::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001d) != 0x0000001d) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->search_areas())) return false;
  if (has_matching_parameter()) {
    if (!this->matching_parameter().IsInitialized()) return false;
  }
  if (has_sign_get_flags()) {
    if (!this->sign_get_flags().IsInitialized()) return false;
  }
  return true;
}

void RequestGetSignList::Swap(RequestGetSignList* other) {
  if (other != this) {
    std::swap(unknown_id_1_, other->unknown_id_1_);
    search_areas_.Swap(&other->search_areas_);
    std::swap(max_signs_, other->max_signs_);
    std::swap(matching_parameter_, other->matching_parameter_);
    std::swap(sign_get_flags_, other->sign_get_flags_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestGetSignList::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestGetSignList";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestGetSignListResponse::kGetSignResultFieldNumber;
#endif  // !_MSC_VER

RequestGetSignListResponse::RequestGetSignListResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestGetSignListResponse)
}

void RequestGetSignListResponse::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  get_sign_result_ = const_cast< ::DS3_Frpg2RequestMessage::GetSignResult*>(
      ::DS3_Frpg2RequestMessage::GetSignResult::internal_default_instance());
#else
  get_sign_result_ = const_cast< ::DS3_Frpg2RequestMessage::GetSignResult*>(&::DS3_Frpg2RequestMessage::GetSignResult::default_instance());
#endif
}

RequestGetSignListResponse::RequestGetSignListResponse(const RequestGetSignListResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestGetSignListResponse)
}

void RequestGetSignListResponse::SharedCtor() {
  _cached_size_ = 0;
  get_sign_result_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestGetSignListResponse::~RequestGetSignListResponse() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestGetSignListResponse)
  SharedDtor();
}

void RequestGetSignListResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete get_sign_result_;
  }
}

void RequestGetSignListResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestGetSignListResponse& RequestGetSignListResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestGetSignListResponse* RequestGetSignListResponse::default_instance_ = NULL;

RequestGetSignListResponse* RequestGetSignListResponse::New() const {
  return new RequestGetSignListResponse;
}

void RequestGetSignListResponse::Clear() {
  if (has_get_sign_result()) {
    if (get_sign_result_ != NULL) get_sign_result_->::DS3_Frpg2RequestMessage::GetSignResult::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestGetSignListResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestGetSignListResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .DS3_Frpg2RequestMessage.GetSignResult get_sign_result = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_get_sign_result()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestGetSignListResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestGetSignListResponse)
  return false;
#undef DO_
}

void RequestGetSignListResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestGetSignListResponse)
  // required .DS3_Frpg2RequestMessage.GetSignResult get_sign_result = 1;
  if (has_get_sign_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->get_sign_result(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestGetSignListResponse)
}

int RequestGetSignListResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .DS3_Frpg2RequestMessage.GetSignResult get_sign_result = 1;
    if (has_get_sign_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->get_sign_result());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestGetSignListResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestGetSignListResponse*>(&from));
}

void RequestGetSignListResponse::MergeFrom(const RequestGetSignListResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_get_sign_result()) {
      mutable_get_sign_result()->::DS3_Frpg2RequestMessage::GetSignResult::MergeFrom(from.get_sign_result());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestGetSignListResponse::CopyFrom(const RequestGetSignListResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestGetSignListResponse::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_get_sign_result()) {
    if (!this->get_sign_result().IsInitialized()) return false;
  }
  return true;
}

void RequestGetSignListResponse::Swap(RequestGetSignListResponse* other) {
  if (other != this) {
    std::swap(get_sign_result_, other->get_sign_result_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestGetSignListResponse::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestGetSignListResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestCreateSign::kMapIdFieldNumber;
const int RequestCreateSign::kOnlineAreaIdFieldNumber;
const int RequestCreateSign::kMatchingParameterFieldNumber;
const int RequestCreateSign::kSignTypeFieldNumber;
const int RequestCreateSign::kPlayerStructFieldNumber;
#endif  // !_MSC_VER

RequestCreateSign::RequestCreateSign()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestCreateSign)
}

void RequestCreateSign::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  matching_parameter_ = const_cast< ::DS3_Frpg2RequestMessage::MatchingParameter*>(
      ::DS3_Frpg2RequestMessage::MatchingParameter::internal_default_instance());
#else
  matching_parameter_ = const_cast< ::DS3_Frpg2RequestMessage::MatchingParameter*>(&::DS3_Frpg2RequestMessage::MatchingParameter::default_instance());
#endif
}

RequestCreateSign::RequestCreateSign(const RequestCreateSign& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestCreateSign)
}

void RequestCreateSign::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  map_id_ = 0u;
  online_area_id_ = 0u;
  matching_parameter_ = NULL;
  sign_type_ = 0u;
  player_struct_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestCreateSign::~RequestCreateSign() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestCreateSign)
  SharedDtor();
}

void RequestCreateSign::SharedDtor() {
  if (player_struct_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete player_struct_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete matching_parameter_;
  }
}

void RequestCreateSign::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestCreateSign& RequestCreateSign::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestCreateSign* RequestCreateSign::default_instance_ = NULL;

RequestCreateSign* RequestCreateSign::New() const {
  return new RequestCreateSign;
}

void RequestCreateSign::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<RequestCreateSign*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 31) {
    ZR_(map_id_, online_area_id_);
    if (has_matching_parameter()) {
      if (matching_parameter_ != NULL) matching_parameter_->::DS3_Frpg2RequestMessage::MatchingParameter::Clear();
    }
    sign_type_ = 0u;
    if (has_player_struct()) {
      if (player_struct_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        player_struct_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestCreateSign::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestCreateSign)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 map_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &map_id_)));
          set_has_map_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_online_area_id;
        break;
      }

      // required uint32 online_area_id = 2;
      case 2: {
        if (tag == 16) {
         parse_online_area_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &online_area_id_)));
          set_has_online_area_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_matching_parameter;
        break;
      }

      // required .DS3_Frpg2RequestMessage.MatchingParameter matching_parameter = 3;
      case 3: {
        if (tag == 26) {
         parse_matching_parameter:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_matching_parameter()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_sign_type;
        break;
      }

      // required uint32 sign_type = 4;
      case 4: {
        if (tag == 32) {
         parse_sign_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &sign_type_)));
          set_has_sign_type();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_player_struct;
        break;
      }

      // required bytes player_struct = 5;
      case 5: {
        if (tag == 42) {
         parse_player_struct:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_player_struct()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestCreateSign)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestCreateSign)
  return false;
#undef DO_
}

void RequestCreateSign::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestCreateSign)
  // required uint32 map_id = 1;
  if (has_map_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->map_id(), output);
  }

  // required uint32 online_area_id = 2;
  if (has_online_area_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->online_area_id(), output);
  }

  // required .DS3_Frpg2RequestMessage.MatchingParameter matching_parameter = 3;
  if (has_matching_parameter()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->matching_parameter(), output);
  }

  // required uint32 sign_type = 4;
  if (has_sign_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->sign_type(), output);
  }

  // required bytes player_struct = 5;
  if (has_player_struct()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      5, this->player_struct(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestCreateSign)
}

int RequestCreateSign::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 map_id = 1;
    if (has_map_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->map_id());
    }

    // required uint32 online_area_id = 2;
    if (has_online_area_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->online_area_id());
    }

    // required .DS3_Frpg2RequestMessage.MatchingParameter matching_parameter = 3;
    if (has_matching_parameter()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->matching_parameter());
    }

    // required uint32 sign_type = 4;
    if (has_sign_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->sign_type());
    }

    // required bytes player_struct = 5;
    if (has_player_struct()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->player_struct());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestCreateSign::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestCreateSign*>(&from));
}

void RequestCreateSign::MergeFrom(const RequestCreateSign& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_map_id()) {
      set_map_id(from.map_id());
    }
    if (from.has_online_area_id()) {
      set_online_area_id(from.online_area_id());
    }
    if (from.has_matching_parameter()) {
      mutable_matching_parameter()->::DS3_Frpg2RequestMessage::MatchingParameter::MergeFrom(from.matching_parameter());
    }
    if (from.has_sign_type()) {
      set_sign_type(from.sign_type());
    }
    if (from.has_player_struct()) {
      set_player_struct(from.player_struct());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestCreateSign::CopyFrom(const RequestCreateSign& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestCreateSign::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;

  if (has_matching_parameter()) {
    if (!this->matching_parameter().IsInitialized()) return false;
  }
  return true;
}

void RequestCreateSign::Swap(RequestCreateSign* other) {
  if (other != this) {
    std::swap(map_id_, other->map_id_);
    std::swap(online_area_id_, other->online_area_id_);
    std::swap(matching_parameter_, other->matching_parameter_);
    std::swap(sign_type_, other->sign_type_);
    std::swap(player_struct_, other->player_struct_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestCreateSign::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestCreateSign";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestCreateSignResponse::kSignIdFieldNumber;
#endif  // !_MSC_VER

RequestCreateSignResponse::RequestCreateSignResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestCreateSignResponse)
}

void RequestCreateSignResponse::InitAsDefaultInstance() {
}

RequestCreateSignResponse::RequestCreateSignResponse(const RequestCreateSignResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestCreateSignResponse)
}

void RequestCreateSignResponse::SharedCtor() {
  _cached_size_ = 0;
  sign_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestCreateSignResponse::~RequestCreateSignResponse() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestCreateSignResponse)
  SharedDtor();
}

void RequestCreateSignResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestCreateSignResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestCreateSignResponse& RequestCreateSignResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestCreateSignResponse* RequestCreateSignResponse::default_instance_ = NULL;

RequestCreateSignResponse* RequestCreateSignResponse::New() const {
  return new RequestCreateSignResponse;
}

void RequestCreateSignResponse::Clear() {
  sign_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestCreateSignResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestCreateSignResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 sign_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &sign_id_)));
          set_has_sign_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestCreateSignResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestCreateSignResponse)
  return false;
#undef DO_
}

void RequestCreateSignResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestCreateSignResponse)
  // required uint32 sign_id = 1;
  if (has_sign_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->sign_id(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestCreateSignResponse)
}

int RequestCreateSignResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 sign_id = 1;
    if (has_sign_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->sign_id());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestCreateSignResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestCreateSignResponse*>(&from));
}

void RequestCreateSignResponse::MergeFrom(const RequestCreateSignResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_sign_id()) {
      set_sign_id(from.sign_id());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestCreateSignResponse::CopyFrom(const RequestCreateSignResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestCreateSignResponse::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void RequestCreateSignResponse::Swap(RequestCreateSignResponse* other) {
  if (other != this) {
    std::swap(sign_id_, other->sign_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestCreateSignResponse::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestCreateSignResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestSummonSign::kMapIdFieldNumber;
const int RequestSummonSign::kOnlineAreaIdFieldNumber;
const int RequestSummonSign::kSignInfoFieldNumber;
const int RequestSummonSign::kPlayerStructFieldNumber;
#endif  // !_MSC_VER

RequestSummonSign::RequestSummonSign()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestSummonSign)
}

void RequestSummonSign::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  sign_info_ = const_cast< ::DS3_Frpg2RequestMessage::SignInfo*>(
      ::DS3_Frpg2RequestMessage::SignInfo::internal_default_instance());
#else
  sign_info_ = const_cast< ::DS3_Frpg2RequestMessage::SignInfo*>(&::DS3_Frpg2RequestMessage::SignInfo::default_instance());
#endif
}

RequestSummonSign::RequestSummonSign(const RequestSummonSign& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestSummonSign)
}

void RequestSummonSign::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  map_id_ = 0u;
  online_area_id_ = 0u;
  sign_info_ = NULL;
  player_struct_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestSummonSign::~RequestSummonSign() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestSummonSign)
  SharedDtor();
}

void RequestSummonSign::SharedDtor() {
  if (player_struct_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete player_struct_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete sign_info_;
  }
}

void RequestSummonSign::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestSummonSign& RequestSummonSign::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestSummonSign* RequestSummonSign::default_instance_ = NULL;

RequestSummonSign* RequestSummonSign::New() const {
  return new RequestSummonSign;
}

void RequestSummonSign::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<RequestSummonSign*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 15) {
    ZR_(map_id_, online_area_id_);
    if (has_sign_info()) {
      if (sign_info_ != NULL) sign_info_->::DS3_Frpg2RequestMessage::SignInfo::Clear();
    }
    if (has_player_struct()) {
      if (player_struct_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        player_struct_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestSummonSign::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestSummonSign)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 map_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &map_id_)));
          set_has_map_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_online_area_id;
        break;
      }

      // required uint32 online_area_id = 2;
      case 2: {
        if (tag == 16) {
         parse_online_area_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &online_area_id_)));
          set_has_online_area_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_sign_info;
        break;
      }

      // required .DS3_Frpg2RequestMessage.SignInfo sign_info = 3;
      case 3: {
        if (tag == 26) {
         parse_sign_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_sign_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_player_struct;
        break;
      }

      // required bytes player_struct = 4;
      case 4: {
        if (tag == 34) {
         parse_player_struct:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_player_struct()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestSummonSign)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestSummonSign)
  return false;
#undef DO_
}

void RequestSummonSign::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestSummonSign)
  // required uint32 map_id = 1;
  if (has_map_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->map_id(), output);
  }

  // required uint32 online_area_id = 2;
  if (has_online_area_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->online_area_id(), output);
  }

  // required .DS3_Frpg2RequestMessage.SignInfo sign_info = 3;
  if (has_sign_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->sign_info(), output);
  }

  // required bytes player_struct = 4;
  if (has_player_struct()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      4, this->player_struct(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestSummonSign)
}

int RequestSummonSign::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 map_id = 1;
    if (has_map_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->map_id());
    }

    // required uint32 online_area_id = 2;
    if (has_online_area_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->online_area_id());
    }

    // required .DS3_Frpg2RequestMessage.SignInfo sign_info = 3;
    if (has_sign_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->sign_info());
    }

    // required bytes player_struct = 4;
    if (has_player_struct()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->player_struct());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestSummonSign::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestSummonSign*>(&from));
}

void RequestSummonSign::MergeFrom(const RequestSummonSign& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_map_id()) {
      set_map_id(from.map_id());
    }
    if (from.has_online_area_id()) {
      set_online_area_id(from.online_area_id());
    }
    if (from.has_sign_info()) {
      mutable_sign_info()->::DS3_Frpg2RequestMessage::SignInfo::MergeFrom(from.sign_info());
    }
    if (from.has_player_struct()) {
      set_player_struct(from.player_struct());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestSummonSign::CopyFrom(const RequestSummonSign& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestSummonSign::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  if (has_sign_info()) {
    if (!this->sign_info().IsInitialized()) return false;
  }
  return true;
}

void RequestSummonSign::Swap(RequestSummonSign* other) {
  if (other != this) {
    std::swap(map_id_, other->map_id_);
    std::swap(online_area_id_, other->online_area_id_);
    std::swap(sign_info_, other->sign_info_);
    std::swap(player_struct_, other->player_struct_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestSummonSign::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestSummonSign";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RequestSummonSignResponse::RequestSummonSignResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestSummonSignResponse)
}

void RequestSummonSignResponse::InitAsDefaultInstance() {
}

RequestSummonSignResponse::RequestSummonSignResponse(const RequestSummonSignResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestSummonSignResponse)
}

void RequestSummonSignResponse::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestSummonSignResponse::~RequestSummonSignResponse() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestSummonSignResponse)
  SharedDtor();
}

void RequestSummonSignResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestSummonSignResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestSummonSignResponse& RequestSummonSignResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestSummonSignResponse* RequestSummonSignResponse::default_instance_ = NULL;

RequestSummonSignResponse* RequestSummonSignResponse::New() const {
  return new RequestSummonSignResponse;
}

void RequestSummonSignResponse::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestSummonSignResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestSummonSignResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestSummonSignResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestSummonSignResponse)
  return false;
#undef DO_
}

void RequestSummonSignResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestSummonSignResponse)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestSummonSignResponse)
}

int RequestSummonSignResponse::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestSummonSignResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestSummonSignResponse*>(&from));
}

void RequestSummonSignResponse::MergeFrom(const RequestSummonSignResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestSummonSignResponse::CopyFrom(const RequestSummonSignResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestSummonSignResponse::IsInitialized() const {

  return true;
}

void RequestSummonSignResponse::Swap(RequestSummonSignResponse* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestSummonSignResponse::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestSummonSignResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestRemoveSign::kMapIdFieldNumber;
const int RequestRemoveSign::kOnlineAreaIdFieldNumber;
const int RequestRemoveSign::kSignIdFieldNumber;
#endif  // !_MSC_VER

RequestRemoveSign::RequestRemoveSign()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestRemoveSign)
}

void RequestRemoveSign::InitAsDefaultInstance() {
}

RequestRemoveSign::RequestRemoveSign(const RequestRemoveSign& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestRemoveSign)
}

void RequestRemoveSign::SharedCtor() {
  _cached_size_ = 0;
  map_id_ = 0u;
  online_area_id_ = 0u;
  sign_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestRemoveSign::~RequestRemoveSign() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestRemoveSign)
  SharedDtor();
}

void RequestRemoveSign::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestRemoveSign::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestRemoveSign& RequestRemoveSign::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestRemoveSign* RequestRemoveSign::default_instance_ = NULL;

RequestRemoveSign* RequestRemoveSign::New() const {
  return new RequestRemoveSign;
}

void RequestRemoveSign::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<RequestRemoveSign*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(map_id_, sign_id_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestRemoveSign::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestRemoveSign)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 map_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &map_id_)));
          set_has_map_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_online_area_id;
        break;
      }

      // required uint32 online_area_id = 2;
      case 2: {
        if (tag == 16) {
         parse_online_area_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &online_area_id_)));
          set_has_online_area_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_sign_id;
        break;
      }

      // required uint32 sign_id = 3;
      case 3: {
        if (tag == 24) {
         parse_sign_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &sign_id_)));
          set_has_sign_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestRemoveSign)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestRemoveSign)
  return false;
#undef DO_
}

void RequestRemoveSign::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestRemoveSign)
  // required uint32 map_id = 1;
  if (has_map_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->map_id(), output);
  }

  // required uint32 online_area_id = 2;
  if (has_online_area_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->online_area_id(), output);
  }

  // required uint32 sign_id = 3;
  if (has_sign_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->sign_id(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestRemoveSign)
}

int RequestRemoveSign::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 map_id = 1;
    if (has_map_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->map_id());
    }

    // required uint32 online_area_id = 2;
    if (has_online_area_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->online_area_id());
    }

    // required uint32 sign_id = 3;
    if (has_sign_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->sign_id());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestRemoveSign::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestRemoveSign*>(&from));
}

void RequestRemoveSign::MergeFrom(const RequestRemoveSign& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_map_id()) {
      set_map_id(from.map_id());
    }
    if (from.has_online_area_id()) {
      set_online_area_id(from.online_area_id());
    }
    if (from.has_sign_id()) {
      set_sign_id(from.sign_id());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestRemoveSign::CopyFrom(const RequestRemoveSign& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestRemoveSign::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void RequestRemoveSign::Swap(RequestRemoveSign* other) {
  if (other != this) {
    std::swap(map_id_, other->map_id_);
    std::swap(online_area_id_, other->online_area_id_);
    std::swap(sign_id_, other->sign_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestRemoveSign::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestRemoveSign";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RequestRemoveSignResponse::RequestRemoveSignResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestRemoveSignResponse)
}

void RequestRemoveSignResponse::InitAsDefaultInstance() {
}

RequestRemoveSignResponse::RequestRemoveSignResponse(const RequestRemoveSignResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestRemoveSignResponse)
}

void RequestRemoveSignResponse::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestRemoveSignResponse::~RequestRemoveSignResponse() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestRemoveSignResponse)
  SharedDtor();
}

void RequestRemoveSignResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestRemoveSignResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestRemoveSignResponse& RequestRemoveSignResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestRemoveSignResponse* RequestRemoveSignResponse::default_instance_ = NULL;

RequestRemoveSignResponse* RequestRemoveSignResponse::New() const {
  return new RequestRemoveSignResponse;
}

void RequestRemoveSignResponse::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestRemoveSignResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestRemoveSignResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestRemoveSignResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestRemoveSignResponse)
  return false;
#undef DO_
}

void RequestRemoveSignResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestRemoveSignResponse)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestRemoveSignResponse)
}

int RequestRemoveSignResponse::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestRemoveSignResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestRemoveSignResponse*>(&from));
}

void RequestRemoveSignResponse::MergeFrom(const RequestRemoveSignResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestRemoveSignResponse::CopyFrom(const RequestRemoveSignResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestRemoveSignResponse::IsInitialized() const {

  return true;
}

void RequestRemoveSignResponse::Swap(RequestRemoveSignResponse* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestRemoveSignResponse::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestRemoveSignResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestUpdateSign::kMapIdFieldNumber;
const int RequestUpdateSign::kOnlineAreaIdFieldNumber;
const int RequestUpdateSign::kSignIdFieldNumber;
#endif  // !_MSC_VER

RequestUpdateSign::RequestUpdateSign()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestUpdateSign)
}

void RequestUpdateSign::InitAsDefaultInstance() {
}

RequestUpdateSign::RequestUpdateSign(const RequestUpdateSign& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestUpdateSign)
}

void RequestUpdateSign::SharedCtor() {
  _cached_size_ = 0;
  map_id_ = 0u;
  online_area_id_ = 0u;
  sign_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestUpdateSign::~RequestUpdateSign() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestUpdateSign)
  SharedDtor();
}

void RequestUpdateSign::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestUpdateSign::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestUpdateSign& RequestUpdateSign::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestUpdateSign* RequestUpdateSign::default_instance_ = NULL;

RequestUpdateSign* RequestUpdateSign::New() const {
  return new RequestUpdateSign;
}

void RequestUpdateSign::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<RequestUpdateSign*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(map_id_, sign_id_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestUpdateSign::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestUpdateSign)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 map_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &map_id_)));
          set_has_map_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_online_area_id;
        break;
      }

      // required uint32 online_area_id = 2;
      case 2: {
        if (tag == 16) {
         parse_online_area_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &online_area_id_)));
          set_has_online_area_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_sign_id;
        break;
      }

      // required uint32 sign_id = 3;
      case 3: {
        if (tag == 24) {
         parse_sign_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &sign_id_)));
          set_has_sign_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestUpdateSign)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestUpdateSign)
  return false;
#undef DO_
}

void RequestUpdateSign::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestUpdateSign)
  // required uint32 map_id = 1;
  if (has_map_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->map_id(), output);
  }

  // required uint32 online_area_id = 2;
  if (has_online_area_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->online_area_id(), output);
  }

  // required uint32 sign_id = 3;
  if (has_sign_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->sign_id(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestUpdateSign)
}

int RequestUpdateSign::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 map_id = 1;
    if (has_map_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->map_id());
    }

    // required uint32 online_area_id = 2;
    if (has_online_area_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->online_area_id());
    }

    // required uint32 sign_id = 3;
    if (has_sign_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->sign_id());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestUpdateSign::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestUpdateSign*>(&from));
}

void RequestUpdateSign::MergeFrom(const RequestUpdateSign& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_map_id()) {
      set_map_id(from.map_id());
    }
    if (from.has_online_area_id()) {
      set_online_area_id(from.online_area_id());
    }
    if (from.has_sign_id()) {
      set_sign_id(from.sign_id());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestUpdateSign::CopyFrom(const RequestUpdateSign& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestUpdateSign::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void RequestUpdateSign::Swap(RequestUpdateSign* other) {
  if (other != this) {
    std::swap(map_id_, other->map_id_);
    std::swap(online_area_id_, other->online_area_id_);
    std::swap(sign_id_, other->sign_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestUpdateSign::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestUpdateSign";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RequestUpdateSignResponse::RequestUpdateSignResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestUpdateSignResponse)
}

void RequestUpdateSignResponse::InitAsDefaultInstance() {
}

RequestUpdateSignResponse::RequestUpdateSignResponse(const RequestUpdateSignResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestUpdateSignResponse)
}

void RequestUpdateSignResponse::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestUpdateSignResponse::~RequestUpdateSignResponse() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestUpdateSignResponse)
  SharedDtor();
}

void RequestUpdateSignResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestUpdateSignResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestUpdateSignResponse& RequestUpdateSignResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestUpdateSignResponse* RequestUpdateSignResponse::default_instance_ = NULL;

RequestUpdateSignResponse* RequestUpdateSignResponse::New() const {
  return new RequestUpdateSignResponse;
}

void RequestUpdateSignResponse::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestUpdateSignResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestUpdateSignResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestUpdateSignResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestUpdateSignResponse)
  return false;
#undef DO_
}

void RequestUpdateSignResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestUpdateSignResponse)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestUpdateSignResponse)
}

int RequestUpdateSignResponse::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestUpdateSignResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestUpdateSignResponse*>(&from));
}

void RequestUpdateSignResponse::MergeFrom(const RequestUpdateSignResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestUpdateSignResponse::CopyFrom(const RequestUpdateSignResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestUpdateSignResponse::IsInitialized() const {

  return true;
}

void RequestUpdateSignResponse::Swap(RequestUpdateSignResponse* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestUpdateSignResponse::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestUpdateSignResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestRejectSign::kUnknown1FieldNumber;
const int RequestRejectSign::kUnknown2FieldNumber;
const int RequestRejectSign::kSignIdFieldNumber;
const int RequestRejectSign::kUnknown4FieldNumber;
const int RequestRejectSign::kUnknown5FieldNumber;
#endif  // !_MSC_VER

RequestRejectSign::RequestRejectSign()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestRejectSign)
}

void RequestRejectSign::InitAsDefaultInstance() {
}

RequestRejectSign::RequestRejectSign(const RequestRejectSign& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestRejectSign)
}

void RequestRejectSign::SharedCtor() {
  _cached_size_ = 0;
  unknown_1_ = 0u;
  unknown_2_ = 0u;
  sign_id_ = 0u;
  unknown_4_ = false;
  unknown_5_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestRejectSign::~RequestRejectSign() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestRejectSign)
  SharedDtor();
}

void RequestRejectSign::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestRejectSign::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestRejectSign& RequestRejectSign::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestRejectSign* RequestRejectSign::default_instance_ = NULL;

RequestRejectSign* RequestRejectSign::New() const {
  return new RequestRejectSign;
}

void RequestRejectSign::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<RequestRejectSign*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 31) {
    ZR_(unknown_1_, unknown_5_);
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestRejectSign::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestRejectSign)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 unknown_1 = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_1_)));
          set_has_unknown_1();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_unknown_2;
        break;
      }

      // required uint32 unknown_2 = 2;
      case 2: {
        if (tag == 16) {
         parse_unknown_2:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_2_)));
          set_has_unknown_2();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_sign_id;
        break;
      }

      // required uint32 sign_id = 3;
      case 3: {
        if (tag == 24) {
         parse_sign_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &sign_id_)));
          set_has_sign_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_unknown_4;
        break;
      }

      // required bool unknown_4 = 4;
      case 4: {
        if (tag == 32) {
         parse_unknown_4:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &unknown_4_)));
          set_has_unknown_4();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_unknown_5;
        break;
      }

      // required bool unknown_5 = 5;
      case 5: {
        if (tag == 40) {
         parse_unknown_5:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &unknown_5_)));
          set_has_unknown_5();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestRejectSign)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestRejectSign)
  return false;
#undef DO_
}

void RequestRejectSign::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestRejectSign)
  // required uint32 unknown_1 = 1;
  if (has_unknown_1()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->unknown_1(), output);
  }

  // required uint32 unknown_2 = 2;
  if (has_unknown_2()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->unknown_2(), output);
  }

  // required uint32 sign_id = 3;
  if (has_sign_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->sign_id(), output);
  }

  // required bool unknown_4 = 4;
  if (has_unknown_4()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->unknown_4(), output);
  }

  // required bool unknown_5 = 5;
  if (has_unknown_5()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->unknown_5(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestRejectSign)
}

int RequestRejectSign::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 unknown_1 = 1;
    if (has_unknown_1()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_1());
    }

    // required uint32 unknown_2 = 2;
    if (has_unknown_2()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_2());
    }

    // required uint32 sign_id = 3;
    if (has_sign_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->sign_id());
    }

    // required bool unknown_4 = 4;
    if (has_unknown_4()) {
      total_size += 1 + 1;
    }

    // required bool unknown_5 = 5;
    if (has_unknown_5()) {
      total_size += 1 + 1;
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestRejectSign::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestRejectSign*>(&from));
}

void RequestRejectSign::MergeFrom(const RequestRejectSign& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_unknown_1()) {
      set_unknown_1(from.unknown_1());
    }
    if (from.has_unknown_2()) {
      set_unknown_2(from.unknown_2());
    }
    if (from.has_sign_id()) {
      set_sign_id(from.sign_id());
    }
    if (from.has_unknown_4()) {
      set_unknown_4(from.unknown_4());
    }
    if (from.has_unknown_5()) {
      set_unknown_5(from.unknown_5());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestRejectSign::CopyFrom(const RequestRejectSign& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestRejectSign::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;

  return true;
}

void RequestRejectSign::Swap(RequestRejectSign* other) {
  if (other != this) {
    std::swap(unknown_1_, other->unknown_1_);
    std::swap(unknown_2_, other->unknown_2_);
    std::swap(sign_id_, other->sign_id_);
    std::swap(unknown_4_, other->unknown_4_);
    std::swap(unknown_5_, other->unknown_5_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestRejectSign::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestRejectSign";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RequestRejectSignResponse::RequestRejectSignResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestRejectSignResponse)
}

void RequestRejectSignResponse::InitAsDefaultInstance() {
}

RequestRejectSignResponse::RequestRejectSignResponse(const RequestRejectSignResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestRejectSignResponse)
}

void RequestRejectSignResponse::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestRejectSignResponse::~RequestRejectSignResponse() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestRejectSignResponse)
  SharedDtor();
}

void RequestRejectSignResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestRejectSignResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestRejectSignResponse& RequestRejectSignResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestRejectSignResponse* RequestRejectSignResponse::default_instance_ = NULL;

RequestRejectSignResponse* RequestRejectSignResponse::New() const {
  return new RequestRejectSignResponse;
}

void RequestRejectSignResponse::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestRejectSignResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestRejectSignResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestRejectSignResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestRejectSignResponse)
  return false;
#undef DO_
}

void RequestRejectSignResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestRejectSignResponse)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestRejectSignResponse)
}

int RequestRejectSignResponse::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestRejectSignResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestRejectSignResponse*>(&from));
}

void RequestRejectSignResponse::MergeFrom(const RequestRejectSignResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestRejectSignResponse::CopyFrom(const RequestRejectSignResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestRejectSignResponse::IsInitialized() const {

  return true;
}

void RequestRejectSignResponse::Swap(RequestRejectSignResponse* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestRejectSignResponse::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestRejectSignResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestGetRightMatchingArea::kMatchingParameterFieldNumber;
const int RequestGetRightMatchingArea::kUnknownFieldNumber;
#endif  // !_MSC_VER

RequestGetRightMatchingArea::RequestGetRightMatchingArea()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestGetRightMatchingArea)
}

void RequestGetRightMatchingArea::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  matching_parameter_ = const_cast< ::DS3_Frpg2RequestMessage::MatchingParameter*>(
      ::DS3_Frpg2RequestMessage::MatchingParameter::internal_default_instance());
#else
  matching_parameter_ = const_cast< ::DS3_Frpg2RequestMessage::MatchingParameter*>(&::DS3_Frpg2RequestMessage::MatchingParameter::default_instance());
#endif
}

RequestGetRightMatchingArea::RequestGetRightMatchingArea(const RequestGetRightMatchingArea& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestGetRightMatchingArea)
}

void RequestGetRightMatchingArea::SharedCtor() {
  _cached_size_ = 0;
  matching_parameter_ = NULL;
  unknown_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestGetRightMatchingArea::~RequestGetRightMatchingArea() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestGetRightMatchingArea)
  SharedDtor();
}

void RequestGetRightMatchingArea::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete matching_parameter_;
  }
}

void RequestGetRightMatchingArea::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestGetRightMatchingArea& RequestGetRightMatchingArea::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestGetRightMatchingArea* RequestGetRightMatchingArea::default_instance_ = NULL;

RequestGetRightMatchingArea* RequestGetRightMatchingArea::New() const {
  return new RequestGetRightMatchingArea;
}

void RequestGetRightMatchingArea::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_matching_parameter()) {
      if (matching_parameter_ != NULL) matching_parameter_->::DS3_Frpg2RequestMessage::MatchingParameter::Clear();
    }
    unknown_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestGetRightMatchingArea::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestGetRightMatchingArea)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .DS3_Frpg2RequestMessage.MatchingParameter matching_parameter = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_matching_parameter()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_unknown;
        break;
      }

      // required uint32 unknown = 2;
      case 2: {
        if (tag == 16) {
         parse_unknown:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_)));
          set_has_unknown();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestGetRightMatchingArea)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestGetRightMatchingArea)
  return false;
#undef DO_
}

void RequestGetRightMatchingArea::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestGetRightMatchingArea)
  // required .DS3_Frpg2RequestMessage.MatchingParameter matching_parameter = 1;
  if (has_matching_parameter()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->matching_parameter(), output);
  }

  // required uint32 unknown = 2;
  if (has_unknown()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->unknown(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestGetRightMatchingArea)
}

int RequestGetRightMatchingArea::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .DS3_Frpg2RequestMessage.MatchingParameter matching_parameter = 1;
    if (has_matching_parameter()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->matching_parameter());
    }

    // required uint32 unknown = 2;
    if (has_unknown()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestGetRightMatchingArea::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestGetRightMatchingArea*>(&from));
}

void RequestGetRightMatchingArea::MergeFrom(const RequestGetRightMatchingArea& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_matching_parameter()) {
      mutable_matching_parameter()->::DS3_Frpg2RequestMessage::MatchingParameter::MergeFrom(from.matching_parameter());
    }
    if (from.has_unknown()) {
      set_unknown(from.unknown());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestGetRightMatchingArea::CopyFrom(const RequestGetRightMatchingArea& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestGetRightMatchingArea::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_matching_parameter()) {
    if (!this->matching_parameter().IsInitialized()) return false;
  }
  return true;
}

void RequestGetRightMatchingArea::Swap(RequestGetRightMatchingArea* other) {
  if (other != this) {
    std::swap(matching_parameter_, other->matching_parameter_);
    std::swap(unknown_, other->unknown_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestGetRightMatchingArea::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestGetRightMatchingArea";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestGetRightMatchingAreaResponse_Area_info::kOnlineAreaIdFieldNumber;
const int RequestGetRightMatchingAreaResponse_Area_info::kPopulationFieldNumber;
#endif  // !_MSC_VER

RequestGetRightMatchingAreaResponse_Area_info::RequestGetRightMatchingAreaResponse_Area_info()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestGetRightMatchingAreaResponse.Area_info)
}

void RequestGetRightMatchingAreaResponse_Area_info::InitAsDefaultInstance() {
}

RequestGetRightMatchingAreaResponse_Area_info::RequestGetRightMatchingAreaResponse_Area_info(const RequestGetRightMatchingAreaResponse_Area_info& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestGetRightMatchingAreaResponse.Area_info)
}

void RequestGetRightMatchingAreaResponse_Area_info::SharedCtor() {
  _cached_size_ = 0;
  online_area_id_ = 0u;
  population_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestGetRightMatchingAreaResponse_Area_info::~RequestGetRightMatchingAreaResponse_Area_info() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestGetRightMatchingAreaResponse.Area_info)
  SharedDtor();
}

void RequestGetRightMatchingAreaResponse_Area_info::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestGetRightMatchingAreaResponse_Area_info::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestGetRightMatchingAreaResponse_Area_info& RequestGetRightMatchingAreaResponse_Area_info::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestGetRightMatchingAreaResponse_Area_info* RequestGetRightMatchingAreaResponse_Area_info::default_instance_ = NULL;

RequestGetRightMatchingAreaResponse_Area_info* RequestGetRightMatchingAreaResponse_Area_info::New() const {
  return new RequestGetRightMatchingAreaResponse_Area_info;
}

void RequestGetRightMatchingAreaResponse_Area_info::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<RequestGetRightMatchingAreaResponse_Area_info*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(online_area_id_, population_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestGetRightMatchingAreaResponse_Area_info::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestGetRightMatchingAreaResponse.Area_info)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 online_area_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &online_area_id_)));
          set_has_online_area_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_population;
        break;
      }

      // required uint32 population = 2;
      case 2: {
        if (tag == 16) {
         parse_population:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &population_)));
          set_has_population();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestGetRightMatchingAreaResponse.Area_info)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestGetRightMatchingAreaResponse.Area_info)
  return false;
#undef DO_
}

void RequestGetRightMatchingAreaResponse_Area_info::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestGetRightMatchingAreaResponse.Area_info)
  // required uint32 online_area_id = 1;
  if (has_online_area_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->online_area_id(), output);
  }

  // required uint32 population = 2;
  if (has_population()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->population(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestGetRightMatchingAreaResponse.Area_info)
}

int RequestGetRightMatchingAreaResponse_Area_info::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 online_area_id = 1;
    if (has_online_area_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->online_area_id());
    }

    // required uint32 population = 2;
    if (has_population()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->population());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestGetRightMatchingAreaResponse_Area_info::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestGetRightMatchingAreaResponse_Area_info*>(&from));
}

void RequestGetRightMatchingAreaResponse_Area_info::MergeFrom(const RequestGetRightMatchingAreaResponse_Area_info& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_online_area_id()) {
      set_online_area_id(from.online_area_id());
    }
    if (from.has_population()) {
      set_population(from.population());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestGetRightMatchingAreaResponse_Area_info::CopyFrom(const RequestGetRightMatchingAreaResponse_Area_info& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestGetRightMatchingAreaResponse_Area_info::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void RequestGetRightMatchingAreaResponse_Area_info::Swap(RequestGetRightMatchingAreaResponse_Area_info* other) {
  if (other != this) {
    std::swap(online_area_id_, other->online_area_id_);
    std::swap(population_, other->population_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestGetRightMatchingAreaResponse_Area_info::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestGetRightMatchingAreaResponse.Area_info";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int RequestGetRightMatchingAreaResponse::kAreaInfoFieldNumber;
#endif  // !_MSC_VER

RequestGetRightMatchingAreaResponse::RequestGetRightMatchingAreaResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestGetRightMatchingAreaResponse)
}

void RequestGetRightMatchingAreaResponse::InitAsDefaultInstance() {
}

RequestGetRightMatchingAreaResponse::RequestGetRightMatchingAreaResponse(const RequestGetRightMatchingAreaResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestGetRightMatchingAreaResponse)
}

void RequestGetRightMatchingAreaResponse::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestGetRightMatchingAreaResponse::~RequestGetRightMatchingAreaResponse() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestGetRightMatchingAreaResponse)
  SharedDtor();
}

void RequestGetRightMatchingAreaResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestGetRightMatchingAreaResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestGetRightMatchingAreaResponse& RequestGetRightMatchingAreaResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestGetRightMatchingAreaResponse* RequestGetRightMatchingAreaResponse::default_instance_ = NULL;

RequestGetRightMatchingAreaResponse* RequestGetRightMatchingAreaResponse::New() const {
  return new RequestGetRightMatchingAreaResponse;
}

void RequestGetRightMatchingAreaResponse::Clear() {
  area_info_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestGetRightMatchingAreaResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestGetRightMatchingAreaResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated group Area_info = 1 {
      case 1: {
        if (tag == 11) {
         parse_area_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadGroupNoVirtual(
                1, input, add_area_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(11)) goto parse_area_info;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestGetRightMatchingAreaResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestGetRightMatchingAreaResponse)
  return false;
#undef DO_
}

void RequestGetRightMatchingAreaResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestGetRightMatchingAreaResponse)
  // repeated group Area_info = 1 {
  for (int i = 0; i < this->area_info_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteGroup(
      1, this->area_info(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestGetRightMatchingAreaResponse)
}

int RequestGetRightMatchingAreaResponse::ByteSize() const {
  int total_size = 0;

  // repeated group Area_info = 1 {
  total_size += 2 * this->area_info_size();
  for (int i = 0; i < this->area_info_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::GroupSizeNoVirtual(
        this->area_info(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestGetRightMatchingAreaResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestGetRightMatchingAreaResponse*>(&from));
}

void RequestGetRightMatchingAreaResponse::MergeFrom(const RequestGetRightMatchingAreaResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  area_info_.MergeFrom(from.area_info_);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestGetRightMatchingAreaResponse::CopyFrom(const RequestGetRightMatchingAreaResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestGetRightMatchingAreaResponse::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->area_info())) return false;
  return true;
}

void RequestGetRightMatchingAreaResponse::Swap(RequestGetRightMatchingAreaResponse* other) {
  if (other != this) {
    area_info_.Swap(&other->area_info_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestGetRightMatchingAreaResponse::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestGetRightMatchingAreaResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int PushRequestRemoveSign::kPushMessageIdFieldNumber;
const int PushRequestRemoveSign::kMessageFieldNumber;
#endif  // !_MSC_VER

PushRequestRemoveSign::PushRequestRemoveSign()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.PushRequestRemoveSign)
}

void PushRequestRemoveSign::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  message_ = const_cast< ::DS3_Frpg2RequestMessage::RemoveSignMessage*>(
      ::DS3_Frpg2RequestMessage::RemoveSignMessage::internal_default_instance());
#else
  message_ = const_cast< ::DS3_Frpg2RequestMessage::RemoveSignMessage*>(&::DS3_Frpg2RequestMessage::RemoveSignMessage::default_instance());
#endif
}

PushRequestRemoveSign::PushRequestRemoveSign(const PushRequestRemoveSign& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.PushRequestRemoveSign)
}

void PushRequestRemoveSign::SharedCtor() {
  _cached_size_ = 0;
  push_message_id_ = 829;
  message_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PushRequestRemoveSign::~PushRequestRemoveSign() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.PushRequestRemoveSign)
  SharedDtor();
}

void PushRequestRemoveSign::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete message_;
  }
}

void PushRequestRemoveSign::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PushRequestRemoveSign& PushRequestRemoveSign::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

PushRequestRemoveSign* PushRequestRemoveSign::default_instance_ = NULL;

PushRequestRemoveSign* PushRequestRemoveSign::New() const {
  return new PushRequestRemoveSign;
}

void PushRequestRemoveSign::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    push_message_id_ = 829;
    if (has_message()) {
      if (message_ != NULL) message_->::DS3_Frpg2RequestMessage::RemoveSignMessage::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool PushRequestRemoveSign::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.PushRequestRemoveSign)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::DS3_Frpg2RequestMessage::PushMessageId_IsValid(value)) {
            set_push_message_id(static_cast< ::DS3_Frpg2RequestMessage::PushMessageId >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_message;
        break;
      }

      // required .DS3_Frpg2RequestMessage.RemoveSignMessage message = 2;
      case 2: {
        if (tag == 18) {
         parse_message:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_message()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.PushRequestRemoveSign)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.PushRequestRemoveSign)
  return false;
#undef DO_
}

void PushRequestRemoveSign::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.PushRequestRemoveSign)
  // required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
  if (has_push_message_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->push_message_id(), output);
  }

  // required .DS3_Frpg2RequestMessage.RemoveSignMessage message = 2;
  if (has_message()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->message(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.PushRequestRemoveSign)
}

int PushRequestRemoveSign::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
    if (has_push_message_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->push_message_id());
    }

    // required .DS3_Frpg2RequestMessage.RemoveSignMessage message = 2;
    if (has_message()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->message());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PushRequestRemoveSign::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PushRequestRemoveSign*>(&from));
}

void PushRequestRemoveSign::MergeFrom(const PushRequestRemoveSign& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_push_message_id()) {
      set_push_message_id(from.push_message_id());
    }
    if (from.has_message()) {
      mutable_message()->::DS3_Frpg2RequestMessage::RemoveSignMessage::MergeFrom(from.message());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void PushRequestRemoveSign::CopyFrom(const PushRequestRemoveSign& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PushRequestRemoveSign::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_message()) {
    if (!this->message().IsInitialized()) return false;
  }
  return true;
}

void PushRequestRemoveSign::Swap(PushRequestRemoveSign* other) {
  if (other != this) {
    std::swap(push_message_id_, other->push_message_id_);
    std::swap(message_, other->message_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PushRequestRemoveSign::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.PushRequestRemoveSign";
}


// ===================================================================

#ifndef _MSC_VER
const int PushRequestSummonSign::kPushMessageIdFieldNumber;
const int PushRequestSummonSign::kMessageFieldNumber;
#endif  // !_MSC_VER

PushRequestSummonSign::PushRequestSummonSign()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.PushRequestSummonSign)
}

void PushRequestSummonSign::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  message_ = const_cast< ::DS3_Frpg2RequestMessage::SummonSignMessage*>(
      ::DS3_Frpg2RequestMessage::SummonSignMessage::internal_default_instance());
#else
  message_ = const_cast< ::DS3_Frpg2RequestMessage::SummonSignMessage*>(&::DS3_Frpg2RequestMessage::SummonSignMessage::default_instance());
#endif
}

PushRequestSummonSign::PushRequestSummonSign(const PushRequestSummonSign& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.PushRequestSummonSign)
}

void PushRequestSummonSign::SharedCtor() {
  _cached_size_ = 0;
  push_message_id_ = 829;
  message_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PushRequestSummonSign::~PushRequestSummonSign() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.PushRequestSummonSign)
  SharedDtor();
}

void PushRequestSummonSign::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete message_;
  }
}

void PushRequestSummonSign::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PushRequestSummonSign& PushRequestSummonSign::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

PushRequestSummonSign* PushRequestSummonSign::default_instance_ = NULL;

PushRequestSummonSign* PushRequestSummonSign::New() const {
  return new PushRequestSummonSign;
}

void PushRequestSummonSign::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    push_message_id_ = 829;
    if (has_message()) {
      if (message_ != NULL) message_->::DS3_Frpg2RequestMessage::SummonSignMessage::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool PushRequestSummonSign::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.PushRequestSummonSign)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::DS3_Frpg2RequestMessage::PushMessageId_IsValid(value)) {
            set_push_message_id(static_cast< ::DS3_Frpg2RequestMessage::PushMessageId >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_message;
        break;
      }

      // required .DS3_Frpg2RequestMessage.SummonSignMessage message = 2;
      case 2: {
        if (tag == 18) {
         parse_message:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_message()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.PushRequestSummonSign)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.PushRequestSummonSign)
  return false;
#undef DO_
}

void PushRequestSummonSign::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.PushRequestSummonSign)
  // required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
  if (has_push_message_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->push_message_id(), output);
  }

  // required .DS3_Frpg2RequestMessage.SummonSignMessage message = 2;
  if (has_message()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->message(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.PushRequestSummonSign)
}

int PushRequestSummonSign::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
    if (has_push_message_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->push_message_id());
    }

    // required .DS3_Frpg2RequestMessage.SummonSignMessage message = 2;
    if (has_message()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->message());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PushRequestSummonSign::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PushRequestSummonSign*>(&from));
}

void PushRequestSummonSign::MergeFrom(const PushRequestSummonSign& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_push_message_id()) {
      set_push_message_id(from.push_message_id());
    }
    if (from.has_message()) {
      mutable_message()->::DS3_Frpg2RequestMessage::SummonSignMessage::MergeFrom(from.message());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void PushRequestSummonSign::CopyFrom(const PushRequestSummonSign& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PushRequestSummonSign::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_message()) {
    if (!this->message().IsInitialized()) return false;
  }
  return true;
}

void PushRequestSummonSign::Swap(PushRequestSummonSign* other) {
  if (other != this) {
    std::swap(push_message_id_, other->push_message_id_);
    std::swap(message_, other->message_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PushRequestSummonSign::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.PushRequestSummonSign";
}


// ===================================================================

#ifndef _MSC_VER
const int PushRequestRejectSign::kPushMessageIdFieldNumber;
const int PushRequestRejectSign::kMessageFieldNumber;
#endif  // !_MSC_VER

PushRequestRejectSign::PushRequestRejectSign()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.PushRequestRejectSign)
}

void PushRequestRejectSign::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  message_ = const_cast< ::DS3_Frpg2RequestMessage::RejectSignMessage*>(
      ::DS3_Frpg2RequestMessage::RejectSignMessage::internal_default_instance());
#else
  message_ = const_cast< ::DS3_Frpg2RequestMessage::RejectSignMessage*>(&::DS3_Frpg2RequestMessage::RejectSignMessage::default_instance());
#endif
}

PushRequestRejectSign::PushRequestRejectSign(const PushRequestRejectSign& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.PushRequestRejectSign)
}

void PushRequestRejectSign::SharedCtor() {
  _cached_size_ = 0;
  push_message_id_ = 829;
  message_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PushRequestRejectSign::~PushRequestRejectSign() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.PushRequestRejectSign)
  SharedDtor();
}

void PushRequestRejectSign::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete message_;
  }
}

void PushRequestRejectSign::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PushRequestRejectSign& PushRequestRejectSign::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

PushRequestRejectSign* PushRequestRejectSign::default_instance_ = NULL;

PushRequestRejectSign* PushRequestRejectSign::New() const {
  return new PushRequestRejectSign;
}

void PushRequestRejectSign::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    push_message_id_ = 829;
    if (has_message()) {
      if (message_ != NULL) message_->::DS3_Frpg2RequestMessage::RejectSignMessage::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool PushRequestRejectSign::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.PushRequestRejectSign)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::DS3_Frpg2RequestMessage::PushMessageId_IsValid(value)) {
            set_push_message_id(static_cast< ::DS3_Frpg2RequestMessage::PushMessageId >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_message;
        break;
      }

      // required .DS3_Frpg2RequestMessage.RejectSignMessage message = 2;
      case 2: {
        if (tag == 18) {
         parse_message:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_message()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.PushRequestRejectSign)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.PushRequestRejectSign)
  return false;
#undef DO_
}

void PushRequestRejectSign::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.PushRequestRejectSign)
  // required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
  if (has_push_message_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->push_message_id(), output);
  }

  // required .DS3_Frpg2RequestMessage.RejectSignMessage message = 2;
  if (has_message()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->message(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.PushRequestRejectSign)
}

int PushRequestRejectSign::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
    if (has_push_message_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->push_message_id());
    }

    // required .DS3_Frpg2RequestMessage.RejectSignMessage message = 2;
    if (has_message()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->message());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PushRequestRejectSign::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PushRequestRejectSign*>(&from));
}

void PushRequestRejectSign::MergeFrom(const PushRequestRejectSign& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_push_message_id()) {
      set_push_message_id(from.push_message_id());
    }
    if (from.has_message()) {
      mutable_message()->::DS3_Frpg2RequestMessage::RejectSignMessage::MergeFrom(from.message());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void PushRequestRejectSign::CopyFrom(const PushRequestRejectSign& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PushRequestRejectSign::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_message()) {
    if (!this->message().IsInitialized()) return false;
  }
  return true;
}

void PushRequestRejectSign::Swap(PushRequestRejectSign* other) {
  if (other != this) {
    std::swap(push_message_id_, other->push_message_id_);
    std::swap(message_, other->message_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PushRequestRejectSign::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.PushRequestRejectSign";
}


// ===================================================================

#ifndef _MSC_VER
const int BreakInTargetData::kPlayerIdFieldNumber;
const int BreakInTargetData::kSteamIdFieldNumber;
#endif  // !_MSC_VER

BreakInTargetData::BreakInTargetData()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.BreakInTargetData)
}

void BreakInTargetData::InitAsDefaultInstance() {
}

BreakInTargetData::BreakInTargetData(const BreakInTargetData& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.BreakInTargetData)
}

void BreakInTargetData::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  player_id_ = 0u;
  steam_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BreakInTargetData::~BreakInTargetData() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.BreakInTargetData)
  SharedDtor();
}

void BreakInTargetData::SharedDtor() {
  if (steam_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete steam_id_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void BreakInTargetData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BreakInTargetData& BreakInTargetData::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

BreakInTargetData* BreakInTargetData::default_instance_ = NULL;

BreakInTargetData* BreakInTargetData::New() const {
  return new BreakInTargetData;
}

void BreakInTargetData::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    player_id_ = 0u;
    if (has_steam_id()) {
      if (steam_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        steam_id_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool BreakInTargetData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.BreakInTargetData)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 player_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &player_id_)));
          set_has_player_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_steam_id;
        break;
      }

      // required string steam_id = 2;
      case 2: {
        if (tag == 18) {
         parse_steam_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_steam_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.BreakInTargetData)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.BreakInTargetData)
  return false;
#undef DO_
}

void BreakInTargetData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.BreakInTargetData)
  // required uint32 player_id = 1;
  if (has_player_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->player_id(), output);
  }

  // required string steam_id = 2;
  if (has_steam_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->steam_id(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.BreakInTargetData)
}

int BreakInTargetData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 player_id = 1;
    if (has_player_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->player_id());
    }

    // required string steam_id = 2;
    if (has_steam_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->steam_id());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BreakInTargetData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BreakInTargetData*>(&from));
}

void BreakInTargetData::MergeFrom(const BreakInTargetData& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_player_id()) {
      set_player_id(from.player_id());
    }
    if (from.has_steam_id()) {
      set_steam_id(from.steam_id());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void BreakInTargetData::CopyFrom(const BreakInTargetData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BreakInTargetData::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void BreakInTargetData::Swap(BreakInTargetData* other) {
  if (other != this) {
    std::swap(player_id_, other->player_id_);
    std::swap(steam_id_, other->steam_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string BreakInTargetData::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.BreakInTargetData";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestGetBreakInTargetList::kMapIdFieldNumber;
const int RequestGetBreakInTargetList::kOnlineAreaIdFieldNumber;
const int RequestGetBreakInTargetList::kMaxTargetsFieldNumber;
const int RequestGetBreakInTargetList::kMatchingParameterFieldNumber;
const int RequestGetBreakInTargetList::kUnknown5FieldNumber;
#endif  // !_MSC_VER

RequestGetBreakInTargetList::RequestGetBreakInTargetList()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestGetBreakInTargetList)
}

void RequestGetBreakInTargetList::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  matching_parameter_ = const_cast< ::DS3_Frpg2RequestMessage::MatchingParameter*>(
      ::DS3_Frpg2RequestMessage::MatchingParameter::internal_default_instance());
#else
  matching_parameter_ = const_cast< ::DS3_Frpg2RequestMessage::MatchingParameter*>(&::DS3_Frpg2RequestMessage::MatchingParameter::default_instance());
#endif
}

RequestGetBreakInTargetList::RequestGetBreakInTargetList(const RequestGetBreakInTargetList& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestGetBreakInTargetList)
}

void RequestGetBreakInTargetList::SharedCtor() {
  _cached_size_ = 0;
  map_id_ = 0u;
  online_area_id_ = 0u;
  max_targets_ = 0u;
  matching_parameter_ = NULL;
  unknown_5_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestGetBreakInTargetList::~RequestGetBreakInTargetList() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestGetBreakInTargetList)
  SharedDtor();
}

void RequestGetBreakInTargetList::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete matching_parameter_;
  }
}

void RequestGetBreakInTargetList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestGetBreakInTargetList& RequestGetBreakInTargetList::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestGetBreakInTargetList* RequestGetBreakInTargetList::default_instance_ = NULL;

RequestGetBreakInTargetList* RequestGetBreakInTargetList::New() const {
  return new RequestGetBreakInTargetList;
}

void RequestGetBreakInTargetList::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<RequestGetBreakInTargetList*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 31) {
    ZR_(map_id_, online_area_id_);
    ZR_(max_targets_, unknown_5_);
    if (has_matching_parameter()) {
      if (matching_parameter_ != NULL) matching_parameter_->::DS3_Frpg2RequestMessage::MatchingParameter::Clear();
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestGetBreakInTargetList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestGetBreakInTargetList)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 map_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &map_id_)));
          set_has_map_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_online_area_id;
        break;
      }

      // required uint32 online_area_id = 2;
      case 2: {
        if (tag == 16) {
         parse_online_area_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &online_area_id_)));
          set_has_online_area_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_max_targets;
        break;
      }

      // required uint32 max_targets = 3;
      case 3: {
        if (tag == 24) {
         parse_max_targets:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &max_targets_)));
          set_has_max_targets();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_matching_parameter;
        break;
      }

      // required .DS3_Frpg2RequestMessage.MatchingParameter matching_parameter = 4;
      case 4: {
        if (tag == 34) {
         parse_matching_parameter:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_matching_parameter()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_unknown_5;
        break;
      }

      // required uint32 unknown_5 = 5;
      case 5: {
        if (tag == 40) {
         parse_unknown_5:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_5_)));
          set_has_unknown_5();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestGetBreakInTargetList)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestGetBreakInTargetList)
  return false;
#undef DO_
}

void RequestGetBreakInTargetList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestGetBreakInTargetList)
  // required uint32 map_id = 1;
  if (has_map_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->map_id(), output);
  }

  // required uint32 online_area_id = 2;
  if (has_online_area_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->online_area_id(), output);
  }

  // required uint32 max_targets = 3;
  if (has_max_targets()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->max_targets(), output);
  }

  // required .DS3_Frpg2RequestMessage.MatchingParameter matching_parameter = 4;
  if (has_matching_parameter()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->matching_parameter(), output);
  }

  // required uint32 unknown_5 = 5;
  if (has_unknown_5()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->unknown_5(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestGetBreakInTargetList)
}

int RequestGetBreakInTargetList::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 map_id = 1;
    if (has_map_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->map_id());
    }

    // required uint32 online_area_id = 2;
    if (has_online_area_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->online_area_id());
    }

    // required uint32 max_targets = 3;
    if (has_max_targets()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->max_targets());
    }

    // required .DS3_Frpg2RequestMessage.MatchingParameter matching_parameter = 4;
    if (has_matching_parameter()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->matching_parameter());
    }

    // required uint32 unknown_5 = 5;
    if (has_unknown_5()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_5());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestGetBreakInTargetList::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestGetBreakInTargetList*>(&from));
}

void RequestGetBreakInTargetList::MergeFrom(const RequestGetBreakInTargetList& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_map_id()) {
      set_map_id(from.map_id());
    }
    if (from.has_online_area_id()) {
      set_online_area_id(from.online_area_id());
    }
    if (from.has_max_targets()) {
      set_max_targets(from.max_targets());
    }
    if (from.has_matching_parameter()) {
      mutable_matching_parameter()->::DS3_Frpg2RequestMessage::MatchingParameter::MergeFrom(from.matching_parameter());
    }
    if (from.has_unknown_5()) {
      set_unknown_5(from.unknown_5());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestGetBreakInTargetList::CopyFrom(const RequestGetBreakInTargetList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestGetBreakInTargetList::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;

  if (has_matching_parameter()) {
    if (!this->matching_parameter().IsInitialized()) return false;
  }
  return true;
}

void RequestGetBreakInTargetList::Swap(RequestGetBreakInTargetList* other) {
  if (other != this) {
    std::swap(map_id_, other->map_id_);
    std::swap(online_area_id_, other->online_area_id_);
    std::swap(max_targets_, other->max_targets_);
    std::swap(matching_parameter_, other->matching_parameter_);
    std::swap(unknown_5_, other->unknown_5_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestGetBreakInTargetList::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestGetBreakInTargetList";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestGetBreakInTargetListResponse::kMapIdFieldNumber;
const int RequestGetBreakInTargetListResponse::kOnlineAreaIdFieldNumber;
const int RequestGetBreakInTargetListResponse::kTargetDataFieldNumber;
#endif  // !_MSC_VER

RequestGetBreakInTargetListResponse::RequestGetBreakInTargetListResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestGetBreakInTargetListResponse)
}

void RequestGetBreakInTargetListResponse::InitAsDefaultInstance() {
}

RequestGetBreakInTargetListResponse::RequestGetBreakInTargetListResponse(const RequestGetBreakInTargetListResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestGetBreakInTargetListResponse)
}

void RequestGetBreakInTargetListResponse::SharedCtor() {
  _cached_size_ = 0;
  map_id_ = 0u;
  online_area_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestGetBreakInTargetListResponse::~RequestGetBreakInTargetListResponse() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestGetBreakInTargetListResponse)
  SharedDtor();
}

void RequestGetBreakInTargetListResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestGetBreakInTargetListResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestGetBreakInTargetListResponse& RequestGetBreakInTargetListResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestGetBreakInTargetListResponse* RequestGetBreakInTargetListResponse::default_instance_ = NULL;

RequestGetBreakInTargetListResponse* RequestGetBreakInTargetListResponse::New() const {
  return new RequestGetBreakInTargetListResponse;
}

void RequestGetBreakInTargetListResponse::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<RequestGetBreakInTargetListResponse*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(map_id_, online_area_id_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  target_data_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestGetBreakInTargetListResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestGetBreakInTargetListResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 map_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &map_id_)));
          set_has_map_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_online_area_id;
        break;
      }

      // optional uint32 online_area_id = 2;
      case 2: {
        if (tag == 16) {
         parse_online_area_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &online_area_id_)));
          set_has_online_area_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_target_data;
        break;
      }

      // repeated .DS3_Frpg2RequestMessage.BreakInTargetData target_data = 3;
      case 3: {
        if (tag == 26) {
         parse_target_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_target_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_target_data;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestGetBreakInTargetListResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestGetBreakInTargetListResponse)
  return false;
#undef DO_
}

void RequestGetBreakInTargetListResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestGetBreakInTargetListResponse)
  // optional uint32 map_id = 1;
  if (has_map_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->map_id(), output);
  }

  // optional uint32 online_area_id = 2;
  if (has_online_area_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->online_area_id(), output);
  }

  // repeated .DS3_Frpg2RequestMessage.BreakInTargetData target_data = 3;
  for (int i = 0; i < this->target_data_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->target_data(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestGetBreakInTargetListResponse)
}

int RequestGetBreakInTargetListResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 map_id = 1;
    if (has_map_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->map_id());
    }

    // optional uint32 online_area_id = 2;
    if (has_online_area_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->online_area_id());
    }

  }
  // repeated .DS3_Frpg2RequestMessage.BreakInTargetData target_data = 3;
  total_size += 1 * this->target_data_size();
  for (int i = 0; i < this->target_data_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->target_data(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestGetBreakInTargetListResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestGetBreakInTargetListResponse*>(&from));
}

void RequestGetBreakInTargetListResponse::MergeFrom(const RequestGetBreakInTargetListResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  target_data_.MergeFrom(from.target_data_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_map_id()) {
      set_map_id(from.map_id());
    }
    if (from.has_online_area_id()) {
      set_online_area_id(from.online_area_id());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestGetBreakInTargetListResponse::CopyFrom(const RequestGetBreakInTargetListResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestGetBreakInTargetListResponse::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->target_data())) return false;
  return true;
}

void RequestGetBreakInTargetListResponse::Swap(RequestGetBreakInTargetListResponse* other) {
  if (other != this) {
    std::swap(map_id_, other->map_id_);
    std::swap(online_area_id_, other->online_area_id_);
    target_data_.Swap(&other->target_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestGetBreakInTargetListResponse::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestGetBreakInTargetListResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int PushRequestAllowBreakInTarget::kPushMessageIdFieldNumber;
const int PushRequestAllowBreakInTarget::kPlayerIdFieldNumber;
const int PushRequestAllowBreakInTarget::kPlayerStructFieldNumber;
const int PushRequestAllowBreakInTarget::kUnknown4FieldNumber;
#endif  // !_MSC_VER

PushRequestAllowBreakInTarget::PushRequestAllowBreakInTarget()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.PushRequestAllowBreakInTarget)
}

void PushRequestAllowBreakInTarget::InitAsDefaultInstance() {
}

PushRequestAllowBreakInTarget::PushRequestAllowBreakInTarget(const PushRequestAllowBreakInTarget& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.PushRequestAllowBreakInTarget)
}

void PushRequestAllowBreakInTarget::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  push_message_id_ = 829;
  player_id_ = 0u;
  player_struct_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  unknown_4_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PushRequestAllowBreakInTarget::~PushRequestAllowBreakInTarget() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.PushRequestAllowBreakInTarget)
  SharedDtor();
}

void PushRequestAllowBreakInTarget::SharedDtor() {
  if (player_struct_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete player_struct_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void PushRequestAllowBreakInTarget::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PushRequestAllowBreakInTarget& PushRequestAllowBreakInTarget::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

PushRequestAllowBreakInTarget* PushRequestAllowBreakInTarget::default_instance_ = NULL;

PushRequestAllowBreakInTarget* PushRequestAllowBreakInTarget::New() const {
  return new PushRequestAllowBreakInTarget;
}

void PushRequestAllowBreakInTarget::Clear() {
  if (_has_bits_[0 / 32] & 15) {
    push_message_id_ = 829;
    player_id_ = 0u;
    if (has_player_struct()) {
      if (player_struct_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        player_struct_->clear();
      }
    }
    unknown_4_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool PushRequestAllowBreakInTarget::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.PushRequestAllowBreakInTarget)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::DS3_Frpg2RequestMessage::PushMessageId_IsValid(value)) {
            set_push_message_id(static_cast< ::DS3_Frpg2RequestMessage::PushMessageId >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_player_id;
        break;
      }

      // required uint32 player_id = 2;
      case 2: {
        if (tag == 16) {
         parse_player_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &player_id_)));
          set_has_player_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_player_struct;
        break;
      }

      // required bytes player_struct = 3;
      case 3: {
        if (tag == 26) {
         parse_player_struct:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_player_struct()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_unknown_4;
        break;
      }

      // required uint32 unknown_4 = 4;
      case 4: {
        if (tag == 32) {
         parse_unknown_4:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_4_)));
          set_has_unknown_4();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.PushRequestAllowBreakInTarget)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.PushRequestAllowBreakInTarget)
  return false;
#undef DO_
}

void PushRequestAllowBreakInTarget::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.PushRequestAllowBreakInTarget)
  // required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
  if (has_push_message_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->push_message_id(), output);
  }

  // required uint32 player_id = 2;
  if (has_player_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->player_id(), output);
  }

  // required bytes player_struct = 3;
  if (has_player_struct()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->player_struct(), output);
  }

  // required uint32 unknown_4 = 4;
  if (has_unknown_4()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->unknown_4(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.PushRequestAllowBreakInTarget)
}

int PushRequestAllowBreakInTarget::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
    if (has_push_message_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->push_message_id());
    }

    // required uint32 player_id = 2;
    if (has_player_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->player_id());
    }

    // required bytes player_struct = 3;
    if (has_player_struct()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->player_struct());
    }

    // required uint32 unknown_4 = 4;
    if (has_unknown_4()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_4());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PushRequestAllowBreakInTarget::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PushRequestAllowBreakInTarget*>(&from));
}

void PushRequestAllowBreakInTarget::MergeFrom(const PushRequestAllowBreakInTarget& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_push_message_id()) {
      set_push_message_id(from.push_message_id());
    }
    if (from.has_player_id()) {
      set_player_id(from.player_id());
    }
    if (from.has_player_struct()) {
      set_player_struct(from.player_struct());
    }
    if (from.has_unknown_4()) {
      set_unknown_4(from.unknown_4());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void PushRequestAllowBreakInTarget::CopyFrom(const PushRequestAllowBreakInTarget& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PushRequestAllowBreakInTarget::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void PushRequestAllowBreakInTarget::Swap(PushRequestAllowBreakInTarget* other) {
  if (other != this) {
    std::swap(push_message_id_, other->push_message_id_);
    std::swap(player_id_, other->player_id_);
    std::swap(player_struct_, other->player_struct_);
    std::swap(unknown_4_, other->unknown_4_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PushRequestAllowBreakInTarget::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.PushRequestAllowBreakInTarget";
}


// ===================================================================

#ifndef _MSC_VER
const int PushRequestBreakInTarget::kPushMessageIdFieldNumber;
const int PushRequestBreakInTarget::kPlayerIdFieldNumber;
const int PushRequestBreakInTarget::kSteamIdFieldNumber;
const int PushRequestBreakInTarget::kUnknown4FieldNumber;
const int PushRequestBreakInTarget::kMapIdFieldNumber;
const int PushRequestBreakInTarget::kOnlineAreaIdFieldNumber;
#endif  // !_MSC_VER

PushRequestBreakInTarget::PushRequestBreakInTarget()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.PushRequestBreakInTarget)
}

void PushRequestBreakInTarget::InitAsDefaultInstance() {
}

PushRequestBreakInTarget::PushRequestBreakInTarget(const PushRequestBreakInTarget& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.PushRequestBreakInTarget)
}

void PushRequestBreakInTarget::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  push_message_id_ = 829;
  player_id_ = 0u;
  steam_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  unknown_4_ = 0u;
  map_id_ = 0u;
  online_area_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PushRequestBreakInTarget::~PushRequestBreakInTarget() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.PushRequestBreakInTarget)
  SharedDtor();
}

void PushRequestBreakInTarget::SharedDtor() {
  if (steam_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete steam_id_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void PushRequestBreakInTarget::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PushRequestBreakInTarget& PushRequestBreakInTarget::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

PushRequestBreakInTarget* PushRequestBreakInTarget::default_instance_ = NULL;

PushRequestBreakInTarget* PushRequestBreakInTarget::New() const {
  return new PushRequestBreakInTarget;
}

void PushRequestBreakInTarget::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<PushRequestBreakInTarget*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 63) {
    ZR_(unknown_4_, online_area_id_);
    push_message_id_ = 829;
    player_id_ = 0u;
    if (has_steam_id()) {
      if (steam_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        steam_id_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool PushRequestBreakInTarget::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.PushRequestBreakInTarget)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::DS3_Frpg2RequestMessage::PushMessageId_IsValid(value)) {
            set_push_message_id(static_cast< ::DS3_Frpg2RequestMessage::PushMessageId >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_player_id;
        break;
      }

      // required uint32 player_id = 2;
      case 2: {
        if (tag == 16) {
         parse_player_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &player_id_)));
          set_has_player_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_steam_id;
        break;
      }

      // required string steam_id = 3;
      case 3: {
        if (tag == 26) {
         parse_steam_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_steam_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_unknown_4;
        break;
      }

      // required uint32 unknown_4 = 4;
      case 4: {
        if (tag == 32) {
         parse_unknown_4:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_4_)));
          set_has_unknown_4();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_map_id;
        break;
      }

      // required uint32 map_id = 5;
      case 5: {
        if (tag == 40) {
         parse_map_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &map_id_)));
          set_has_map_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_online_area_id;
        break;
      }

      // required uint32 online_area_id = 6;
      case 6: {
        if (tag == 48) {
         parse_online_area_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &online_area_id_)));
          set_has_online_area_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.PushRequestBreakInTarget)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.PushRequestBreakInTarget)
  return false;
#undef DO_
}

void PushRequestBreakInTarget::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.PushRequestBreakInTarget)
  // required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
  if (has_push_message_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->push_message_id(), output);
  }

  // required uint32 player_id = 2;
  if (has_player_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->player_id(), output);
  }

  // required string steam_id = 3;
  if (has_steam_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->steam_id(), output);
  }

  // required uint32 unknown_4 = 4;
  if (has_unknown_4()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->unknown_4(), output);
  }

  // required uint32 map_id = 5;
  if (has_map_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->map_id(), output);
  }

  // required uint32 online_area_id = 6;
  if (has_online_area_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->online_area_id(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.PushRequestBreakInTarget)
}

int PushRequestBreakInTarget::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
    if (has_push_message_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->push_message_id());
    }

    // required uint32 player_id = 2;
    if (has_player_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->player_id());
    }

    // required string steam_id = 3;
    if (has_steam_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->steam_id());
    }

    // required uint32 unknown_4 = 4;
    if (has_unknown_4()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_4());
    }

    // required uint32 map_id = 5;
    if (has_map_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->map_id());
    }

    // required uint32 online_area_id = 6;
    if (has_online_area_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->online_area_id());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PushRequestBreakInTarget::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PushRequestBreakInTarget*>(&from));
}

void PushRequestBreakInTarget::MergeFrom(const PushRequestBreakInTarget& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_push_message_id()) {
      set_push_message_id(from.push_message_id());
    }
    if (from.has_player_id()) {
      set_player_id(from.player_id());
    }
    if (from.has_steam_id()) {
      set_steam_id(from.steam_id());
    }
    if (from.has_unknown_4()) {
      set_unknown_4(from.unknown_4());
    }
    if (from.has_map_id()) {
      set_map_id(from.map_id());
    }
    if (from.has_online_area_id()) {
      set_online_area_id(from.online_area_id());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void PushRequestBreakInTarget::CopyFrom(const PushRequestBreakInTarget& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PushRequestBreakInTarget::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003f) != 0x0000003f) return false;

  return true;
}

void PushRequestBreakInTarget::Swap(PushRequestBreakInTarget* other) {
  if (other != this) {
    std::swap(push_message_id_, other->push_message_id_);
    std::swap(player_id_, other->player_id_);
    std::swap(steam_id_, other->steam_id_);
    std::swap(unknown_4_, other->unknown_4_);
    std::swap(map_id_, other->map_id_);
    std::swap(online_area_id_, other->online_area_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PushRequestBreakInTarget::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.PushRequestBreakInTarget";
}


// ===================================================================

#ifndef _MSC_VER
const int PushRequestRemoveBreakInTarget::kPushMessageIdFieldNumber;
const int PushRequestRemoveBreakInTarget::kUnknown2FieldNumber;
const int PushRequestRemoveBreakInTarget::kUnknown3FieldNumber;
const int PushRequestRemoveBreakInTarget::kUnknown4FieldNumber;
#endif  // !_MSC_VER

PushRequestRemoveBreakInTarget::PushRequestRemoveBreakInTarget()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.PushRequestRemoveBreakInTarget)
}

void PushRequestRemoveBreakInTarget::InitAsDefaultInstance() {
}

PushRequestRemoveBreakInTarget::PushRequestRemoveBreakInTarget(const PushRequestRemoveBreakInTarget& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.PushRequestRemoveBreakInTarget)
}

void PushRequestRemoveBreakInTarget::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  push_message_id_ = 829;
  unknown_2_ = 0u;
  unknown_3_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  unknown_4_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PushRequestRemoveBreakInTarget::~PushRequestRemoveBreakInTarget() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.PushRequestRemoveBreakInTarget)
  SharedDtor();
}

void PushRequestRemoveBreakInTarget::SharedDtor() {
  if (unknown_3_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete unknown_3_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void PushRequestRemoveBreakInTarget::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PushRequestRemoveBreakInTarget& PushRequestRemoveBreakInTarget::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

PushRequestRemoveBreakInTarget* PushRequestRemoveBreakInTarget::default_instance_ = NULL;

PushRequestRemoveBreakInTarget* PushRequestRemoveBreakInTarget::New() const {
  return new PushRequestRemoveBreakInTarget;
}

void PushRequestRemoveBreakInTarget::Clear() {
  if (_has_bits_[0 / 32] & 15) {
    push_message_id_ = 829;
    unknown_2_ = 0u;
    if (has_unknown_3()) {
      if (unknown_3_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        unknown_3_->clear();
      }
    }
    unknown_4_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool PushRequestRemoveBreakInTarget::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.PushRequestRemoveBreakInTarget)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::DS3_Frpg2RequestMessage::PushMessageId_IsValid(value)) {
            set_push_message_id(static_cast< ::DS3_Frpg2RequestMessage::PushMessageId >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_unknown_2;
        break;
      }

      // required uint32 unknown_2 = 2;
      case 2: {
        if (tag == 16) {
         parse_unknown_2:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_2_)));
          set_has_unknown_2();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_unknown_3;
        break;
      }

      // required string unknown_3 = 3;
      case 3: {
        if (tag == 26) {
         parse_unknown_3:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_unknown_3()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_unknown_4;
        break;
      }

      // required uint32 unknown_4 = 4;
      case 4: {
        if (tag == 32) {
         parse_unknown_4:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_4_)));
          set_has_unknown_4();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.PushRequestRemoveBreakInTarget)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.PushRequestRemoveBreakInTarget)
  return false;
#undef DO_
}

void PushRequestRemoveBreakInTarget::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.PushRequestRemoveBreakInTarget)
  // required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
  if (has_push_message_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->push_message_id(), output);
  }

  // required uint32 unknown_2 = 2;
  if (has_unknown_2()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->unknown_2(), output);
  }

  // required string unknown_3 = 3;
  if (has_unknown_3()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->unknown_3(), output);
  }

  // required uint32 unknown_4 = 4;
  if (has_unknown_4()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->unknown_4(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.PushRequestRemoveBreakInTarget)
}

int PushRequestRemoveBreakInTarget::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
    if (has_push_message_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->push_message_id());
    }

    // required uint32 unknown_2 = 2;
    if (has_unknown_2()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_2());
    }

    // required string unknown_3 = 3;
    if (has_unknown_3()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->unknown_3());
    }

    // required uint32 unknown_4 = 4;
    if (has_unknown_4()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_4());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PushRequestRemoveBreakInTarget::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PushRequestRemoveBreakInTarget*>(&from));
}

void PushRequestRemoveBreakInTarget::MergeFrom(const PushRequestRemoveBreakInTarget& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_push_message_id()) {
      set_push_message_id(from.push_message_id());
    }
    if (from.has_unknown_2()) {
      set_unknown_2(from.unknown_2());
    }
    if (from.has_unknown_3()) {
      set_unknown_3(from.unknown_3());
    }
    if (from.has_unknown_4()) {
      set_unknown_4(from.unknown_4());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void PushRequestRemoveBreakInTarget::CopyFrom(const PushRequestRemoveBreakInTarget& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PushRequestRemoveBreakInTarget::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void PushRequestRemoveBreakInTarget::Swap(PushRequestRemoveBreakInTarget* other) {
  if (other != this) {
    std::swap(push_message_id_, other->push_message_id_);
    std::swap(unknown_2_, other->unknown_2_);
    std::swap(unknown_3_, other->unknown_3_);
    std::swap(unknown_4_, other->unknown_4_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PushRequestRemoveBreakInTarget::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.PushRequestRemoveBreakInTarget";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestBreakInTarget::kMapIdFieldNumber;
const int RequestBreakInTarget::kOnlineAreaIdFieldNumber;
const int RequestBreakInTarget::kPlayerIdFieldNumber;
const int RequestBreakInTarget::kUnknown4FieldNumber;
#endif  // !_MSC_VER

RequestBreakInTarget::RequestBreakInTarget()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestBreakInTarget)
}

void RequestBreakInTarget::InitAsDefaultInstance() {
}

RequestBreakInTarget::RequestBreakInTarget(const RequestBreakInTarget& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestBreakInTarget)
}

void RequestBreakInTarget::SharedCtor() {
  _cached_size_ = 0;
  map_id_ = 0u;
  online_area_id_ = 0u;
  player_id_ = 0u;
  unknown_4_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestBreakInTarget::~RequestBreakInTarget() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestBreakInTarget)
  SharedDtor();
}

void RequestBreakInTarget::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestBreakInTarget::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestBreakInTarget& RequestBreakInTarget::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestBreakInTarget* RequestBreakInTarget::default_instance_ = NULL;

RequestBreakInTarget* RequestBreakInTarget::New() const {
  return new RequestBreakInTarget;
}

void RequestBreakInTarget::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<RequestBreakInTarget*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(map_id_, unknown_4_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestBreakInTarget::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestBreakInTarget)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 map_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &map_id_)));
          set_has_map_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_online_area_id;
        break;
      }

      // required uint32 online_area_id = 2;
      case 2: {
        if (tag == 16) {
         parse_online_area_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &online_area_id_)));
          set_has_online_area_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_player_id;
        break;
      }

      // required uint32 player_id = 3;
      case 3: {
        if (tag == 24) {
         parse_player_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &player_id_)));
          set_has_player_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_unknown_4;
        break;
      }

      // required uint32 unknown_4 = 4;
      case 4: {
        if (tag == 32) {
         parse_unknown_4:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_4_)));
          set_has_unknown_4();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestBreakInTarget)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestBreakInTarget)
  return false;
#undef DO_
}

void RequestBreakInTarget::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestBreakInTarget)
  // required uint32 map_id = 1;
  if (has_map_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->map_id(), output);
  }

  // required uint32 online_area_id = 2;
  if (has_online_area_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->online_area_id(), output);
  }

  // required uint32 player_id = 3;
  if (has_player_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->player_id(), output);
  }

  // required uint32 unknown_4 = 4;
  if (has_unknown_4()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->unknown_4(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestBreakInTarget)
}

int RequestBreakInTarget::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 map_id = 1;
    if (has_map_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->map_id());
    }

    // required uint32 online_area_id = 2;
    if (has_online_area_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->online_area_id());
    }

    // required uint32 player_id = 3;
    if (has_player_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->player_id());
    }

    // required uint32 unknown_4 = 4;
    if (has_unknown_4()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_4());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestBreakInTarget::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestBreakInTarget*>(&from));
}

void RequestBreakInTarget::MergeFrom(const RequestBreakInTarget& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_map_id()) {
      set_map_id(from.map_id());
    }
    if (from.has_online_area_id()) {
      set_online_area_id(from.online_area_id());
    }
    if (from.has_player_id()) {
      set_player_id(from.player_id());
    }
    if (from.has_unknown_4()) {
      set_unknown_4(from.unknown_4());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestBreakInTarget::CopyFrom(const RequestBreakInTarget& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestBreakInTarget::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void RequestBreakInTarget::Swap(RequestBreakInTarget* other) {
  if (other != this) {
    std::swap(map_id_, other->map_id_);
    std::swap(online_area_id_, other->online_area_id_);
    std::swap(player_id_, other->player_id_);
    std::swap(unknown_4_, other->unknown_4_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestBreakInTarget::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestBreakInTarget";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestRejectBreakInTarget::kPlayerIdFieldNumber;
const int RequestRejectBreakInTarget::kUnknown2FieldNumber;
const int RequestRejectBreakInTarget::kMapIdFieldNumber;
const int RequestRejectBreakInTarget::kOnlineAreaIdFieldNumber;
const int RequestRejectBreakInTarget::kUnknown5FieldNumber;
#endif  // !_MSC_VER

RequestRejectBreakInTarget::RequestRejectBreakInTarget()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestRejectBreakInTarget)
}

void RequestRejectBreakInTarget::InitAsDefaultInstance() {
}

RequestRejectBreakInTarget::RequestRejectBreakInTarget(const RequestRejectBreakInTarget& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestRejectBreakInTarget)
}

void RequestRejectBreakInTarget::SharedCtor() {
  _cached_size_ = 0;
  player_id_ = 0u;
  unknown_2_ = 0u;
  map_id_ = 0u;
  online_area_id_ = 0u;
  unknown_5_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestRejectBreakInTarget::~RequestRejectBreakInTarget() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestRejectBreakInTarget)
  SharedDtor();
}

void RequestRejectBreakInTarget::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestRejectBreakInTarget::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestRejectBreakInTarget& RequestRejectBreakInTarget::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestRejectBreakInTarget* RequestRejectBreakInTarget::default_instance_ = NULL;

RequestRejectBreakInTarget* RequestRejectBreakInTarget::New() const {
  return new RequestRejectBreakInTarget;
}

void RequestRejectBreakInTarget::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<RequestRejectBreakInTarget*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 31) {
    ZR_(player_id_, unknown_5_);
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestRejectBreakInTarget::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestRejectBreakInTarget)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 player_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &player_id_)));
          set_has_player_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_unknown_2;
        break;
      }

      // required uint32 unknown_2 = 2;
      case 2: {
        if (tag == 16) {
         parse_unknown_2:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_2_)));
          set_has_unknown_2();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_map_id;
        break;
      }

      // required uint32 map_id = 3;
      case 3: {
        if (tag == 24) {
         parse_map_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &map_id_)));
          set_has_map_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_online_area_id;
        break;
      }

      // required uint32 online_area_id = 4;
      case 4: {
        if (tag == 32) {
         parse_online_area_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &online_area_id_)));
          set_has_online_area_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_unknown_5;
        break;
      }

      // required uint32 unknown_5 = 5;
      case 5: {
        if (tag == 40) {
         parse_unknown_5:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_5_)));
          set_has_unknown_5();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestRejectBreakInTarget)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestRejectBreakInTarget)
  return false;
#undef DO_
}

void RequestRejectBreakInTarget::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestRejectBreakInTarget)
  // required uint32 player_id = 1;
  if (has_player_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->player_id(), output);
  }

  // required uint32 unknown_2 = 2;
  if (has_unknown_2()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->unknown_2(), output);
  }

  // required uint32 map_id = 3;
  if (has_map_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->map_id(), output);
  }

  // required uint32 online_area_id = 4;
  if (has_online_area_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->online_area_id(), output);
  }

  // required uint32 unknown_5 = 5;
  if (has_unknown_5()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->unknown_5(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestRejectBreakInTarget)
}

int RequestRejectBreakInTarget::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 player_id = 1;
    if (has_player_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->player_id());
    }

    // required uint32 unknown_2 = 2;
    if (has_unknown_2()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_2());
    }

    // required uint32 map_id = 3;
    if (has_map_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->map_id());
    }

    // required uint32 online_area_id = 4;
    if (has_online_area_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->online_area_id());
    }

    // required uint32 unknown_5 = 5;
    if (has_unknown_5()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_5());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestRejectBreakInTarget::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestRejectBreakInTarget*>(&from));
}

void RequestRejectBreakInTarget::MergeFrom(const RequestRejectBreakInTarget& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_player_id()) {
      set_player_id(from.player_id());
    }
    if (from.has_unknown_2()) {
      set_unknown_2(from.unknown_2());
    }
    if (from.has_map_id()) {
      set_map_id(from.map_id());
    }
    if (from.has_online_area_id()) {
      set_online_area_id(from.online_area_id());
    }
    if (from.has_unknown_5()) {
      set_unknown_5(from.unknown_5());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestRejectBreakInTarget::CopyFrom(const RequestRejectBreakInTarget& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestRejectBreakInTarget::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;

  return true;
}

void RequestRejectBreakInTarget::Swap(RequestRejectBreakInTarget* other) {
  if (other != this) {
    std::swap(player_id_, other->player_id_);
    std::swap(unknown_2_, other->unknown_2_);
    std::swap(map_id_, other->map_id_);
    std::swap(online_area_id_, other->online_area_id_);
    std::swap(unknown_5_, other->unknown_5_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestRejectBreakInTarget::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestRejectBreakInTarget";
}


// ===================================================================

#ifndef _MSC_VER
const int PushRequestRejectBreakInTarget::kPushMessageIdFieldNumber;
const int PushRequestRejectBreakInTarget::kPlayerIdFieldNumber;
const int PushRequestRejectBreakInTarget::kUnknown3FieldNumber;
const int PushRequestRejectBreakInTarget::kSteamIdFieldNumber;
const int PushRequestRejectBreakInTarget::kUnknown5FieldNumber;
#endif  // !_MSC_VER

PushRequestRejectBreakInTarget::PushRequestRejectBreakInTarget()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.PushRequestRejectBreakInTarget)
}

void PushRequestRejectBreakInTarget::InitAsDefaultInstance() {
}

PushRequestRejectBreakInTarget::PushRequestRejectBreakInTarget(const PushRequestRejectBreakInTarget& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.PushRequestRejectBreakInTarget)
}

void PushRequestRejectBreakInTarget::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  push_message_id_ = 829;
  player_id_ = 0u;
  unknown_3_ = 0u;
  steam_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  unknown_5_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PushRequestRejectBreakInTarget::~PushRequestRejectBreakInTarget() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.PushRequestRejectBreakInTarget)
  SharedDtor();
}

void PushRequestRejectBreakInTarget::SharedDtor() {
  if (steam_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete steam_id_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void PushRequestRejectBreakInTarget::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PushRequestRejectBreakInTarget& PushRequestRejectBreakInTarget::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

PushRequestRejectBreakInTarget* PushRequestRejectBreakInTarget::default_instance_ = NULL;

PushRequestRejectBreakInTarget* PushRequestRejectBreakInTarget::New() const {
  return new PushRequestRejectBreakInTarget;
}

void PushRequestRejectBreakInTarget::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<PushRequestRejectBreakInTarget*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 31) {
    ZR_(unknown_3_, unknown_5_);
    push_message_id_ = 829;
    player_id_ = 0u;
    if (has_steam_id()) {
      if (steam_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        steam_id_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool PushRequestRejectBreakInTarget::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.PushRequestRejectBreakInTarget)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::DS3_Frpg2RequestMessage::PushMessageId_IsValid(value)) {
            set_push_message_id(static_cast< ::DS3_Frpg2RequestMessage::PushMessageId >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_player_id;
        break;
      }

      // required uint32 player_id = 2;
      case 2: {
        if (tag == 16) {
         parse_player_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &player_id_)));
          set_has_player_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_unknown_3;
        break;
      }

      // required uint32 unknown_3 = 3;
      case 3: {
        if (tag == 24) {
         parse_unknown_3:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_3_)));
          set_has_unknown_3();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_steam_id;
        break;
      }

      // required string steam_id = 4;
      case 4: {
        if (tag == 34) {
         parse_steam_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_steam_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_unknown_5;
        break;
      }

      // required uint32 unknown_5 = 5;
      case 5: {
        if (tag == 40) {
         parse_unknown_5:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_5_)));
          set_has_unknown_5();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.PushRequestRejectBreakInTarget)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.PushRequestRejectBreakInTarget)
  return false;
#undef DO_
}

void PushRequestRejectBreakInTarget::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.PushRequestRejectBreakInTarget)
  // required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
  if (has_push_message_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->push_message_id(), output);
  }

  // required uint32 player_id = 2;
  if (has_player_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->player_id(), output);
  }

  // required uint32 unknown_3 = 3;
  if (has_unknown_3()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->unknown_3(), output);
  }

  // required string steam_id = 4;
  if (has_steam_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->steam_id(), output);
  }

  // required uint32 unknown_5 = 5;
  if (has_unknown_5()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->unknown_5(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.PushRequestRejectBreakInTarget)
}

int PushRequestRejectBreakInTarget::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
    if (has_push_message_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->push_message_id());
    }

    // required uint32 player_id = 2;
    if (has_player_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->player_id());
    }

    // required uint32 unknown_3 = 3;
    if (has_unknown_3()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_3());
    }

    // required string steam_id = 4;
    if (has_steam_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->steam_id());
    }

    // required uint32 unknown_5 = 5;
    if (has_unknown_5()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_5());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PushRequestRejectBreakInTarget::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PushRequestRejectBreakInTarget*>(&from));
}

void PushRequestRejectBreakInTarget::MergeFrom(const PushRequestRejectBreakInTarget& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_push_message_id()) {
      set_push_message_id(from.push_message_id());
    }
    if (from.has_player_id()) {
      set_player_id(from.player_id());
    }
    if (from.has_unknown_3()) {
      set_unknown_3(from.unknown_3());
    }
    if (from.has_steam_id()) {
      set_steam_id(from.steam_id());
    }
    if (from.has_unknown_5()) {
      set_unknown_5(from.unknown_5());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void PushRequestRejectBreakInTarget::CopyFrom(const PushRequestRejectBreakInTarget& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PushRequestRejectBreakInTarget::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;

  return true;
}

void PushRequestRejectBreakInTarget::Swap(PushRequestRejectBreakInTarget* other) {
  if (other != this) {
    std::swap(push_message_id_, other->push_message_id_);
    std::swap(player_id_, other->player_id_);
    std::swap(unknown_3_, other->unknown_3_);
    std::swap(steam_id_, other->steam_id_);
    std::swap(unknown_5_, other->unknown_5_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PushRequestRejectBreakInTarget::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.PushRequestRejectBreakInTarget";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RequestBreakInTargetResponse::RequestBreakInTargetResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestBreakInTargetResponse)
}

void RequestBreakInTargetResponse::InitAsDefaultInstance() {
}

RequestBreakInTargetResponse::RequestBreakInTargetResponse(const RequestBreakInTargetResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestBreakInTargetResponse)
}

void RequestBreakInTargetResponse::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestBreakInTargetResponse::~RequestBreakInTargetResponse() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestBreakInTargetResponse)
  SharedDtor();
}

void RequestBreakInTargetResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestBreakInTargetResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestBreakInTargetResponse& RequestBreakInTargetResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestBreakInTargetResponse* RequestBreakInTargetResponse::default_instance_ = NULL;

RequestBreakInTargetResponse* RequestBreakInTargetResponse::New() const {
  return new RequestBreakInTargetResponse;
}

void RequestBreakInTargetResponse::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestBreakInTargetResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestBreakInTargetResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestBreakInTargetResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestBreakInTargetResponse)
  return false;
#undef DO_
}

void RequestBreakInTargetResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestBreakInTargetResponse)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestBreakInTargetResponse)
}

int RequestBreakInTargetResponse::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestBreakInTargetResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestBreakInTargetResponse*>(&from));
}

void RequestBreakInTargetResponse::MergeFrom(const RequestBreakInTargetResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestBreakInTargetResponse::CopyFrom(const RequestBreakInTargetResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestBreakInTargetResponse::IsInitialized() const {

  return true;
}

void RequestBreakInTargetResponse::Swap(RequestBreakInTargetResponse* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestBreakInTargetResponse::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestBreakInTargetResponse";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RequestRejectBreakInTargetResponse::RequestRejectBreakInTargetResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestRejectBreakInTargetResponse)
}

void RequestRejectBreakInTargetResponse::InitAsDefaultInstance() {
}

RequestRejectBreakInTargetResponse::RequestRejectBreakInTargetResponse(const RequestRejectBreakInTargetResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestRejectBreakInTargetResponse)
}

void RequestRejectBreakInTargetResponse::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestRejectBreakInTargetResponse::~RequestRejectBreakInTargetResponse() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestRejectBreakInTargetResponse)
  SharedDtor();
}

void RequestRejectBreakInTargetResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestRejectBreakInTargetResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestRejectBreakInTargetResponse& RequestRejectBreakInTargetResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestRejectBreakInTargetResponse* RequestRejectBreakInTargetResponse::default_instance_ = NULL;

RequestRejectBreakInTargetResponse* RequestRejectBreakInTargetResponse::New() const {
  return new RequestRejectBreakInTargetResponse;
}

void RequestRejectBreakInTargetResponse::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestRejectBreakInTargetResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestRejectBreakInTargetResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestRejectBreakInTargetResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestRejectBreakInTargetResponse)
  return false;
#undef DO_
}

void RequestRejectBreakInTargetResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestRejectBreakInTargetResponse)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestRejectBreakInTargetResponse)
}

int RequestRejectBreakInTargetResponse::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestRejectBreakInTargetResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestRejectBreakInTargetResponse*>(&from));
}

void RequestRejectBreakInTargetResponse::MergeFrom(const RequestRejectBreakInTargetResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestRejectBreakInTargetResponse::CopyFrom(const RequestRejectBreakInTargetResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestRejectBreakInTargetResponse::IsInitialized() const {

  return true;
}

void RequestRejectBreakInTargetResponse::Swap(RequestRejectBreakInTargetResponse* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestRejectBreakInTargetResponse::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestRejectBreakInTargetResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestGetGhostDataList::kMaxGhostsFieldNumber;
const int RequestGetGhostDataList::kSearchAreasFieldNumber;
#endif  // !_MSC_VER

RequestGetGhostDataList::RequestGetGhostDataList()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestGetGhostDataList)
}

void RequestGetGhostDataList::InitAsDefaultInstance() {
}

RequestGetGhostDataList::RequestGetGhostDataList(const RequestGetGhostDataList& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestGetGhostDataList)
}

void RequestGetGhostDataList::SharedCtor() {
  _cached_size_ = 0;
  max_ghosts_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestGetGhostDataList::~RequestGetGhostDataList() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestGetGhostDataList)
  SharedDtor();
}

void RequestGetGhostDataList::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestGetGhostDataList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestGetGhostDataList& RequestGetGhostDataList::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestGetGhostDataList* RequestGetGhostDataList::default_instance_ = NULL;

RequestGetGhostDataList* RequestGetGhostDataList::New() const {
  return new RequestGetGhostDataList;
}

void RequestGetGhostDataList::Clear() {
  max_ghosts_ = 0u;
  search_areas_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestGetGhostDataList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestGetGhostDataList)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 max_ghosts = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &max_ghosts_)));
          set_has_max_ghosts();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_search_areas;
        break;
      }

      // repeated .DS3_Frpg2RequestMessage.DomainLimitData search_areas = 2;
      case 2: {
        if (tag == 18) {
         parse_search_areas:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_search_areas()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_search_areas;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestGetGhostDataList)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestGetGhostDataList)
  return false;
#undef DO_
}

void RequestGetGhostDataList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestGetGhostDataList)
  // required uint32 max_ghosts = 1;
  if (has_max_ghosts()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->max_ghosts(), output);
  }

  // repeated .DS3_Frpg2RequestMessage.DomainLimitData search_areas = 2;
  for (int i = 0; i < this->search_areas_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->search_areas(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestGetGhostDataList)
}

int RequestGetGhostDataList::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 max_ghosts = 1;
    if (has_max_ghosts()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->max_ghosts());
    }

  }
  // repeated .DS3_Frpg2RequestMessage.DomainLimitData search_areas = 2;
  total_size += 1 * this->search_areas_size();
  for (int i = 0; i < this->search_areas_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->search_areas(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestGetGhostDataList::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestGetGhostDataList*>(&from));
}

void RequestGetGhostDataList::MergeFrom(const RequestGetGhostDataList& from) {
  GOOGLE_CHECK_NE(&from, this);
  search_areas_.MergeFrom(from.search_areas_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_max_ghosts()) {
      set_max_ghosts(from.max_ghosts());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestGetGhostDataList::CopyFrom(const RequestGetGhostDataList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestGetGhostDataList::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->search_areas())) return false;
  return true;
}

void RequestGetGhostDataList::Swap(RequestGetGhostDataList* other) {
  if (other != this) {
    std::swap(max_ghosts_, other->max_ghosts_);
    search_areas_.Swap(&other->search_areas_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestGetGhostDataList::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestGetGhostDataList";
}


// ===================================================================

#ifndef _MSC_VER
const int GhostData::kUnknown1FieldNumber;
const int GhostData::kGhostIdFieldNumber;
const int GhostData::kDataFieldNumber;
#endif  // !_MSC_VER

GhostData::GhostData()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.GhostData)
}

void GhostData::InitAsDefaultInstance() {
}

GhostData::GhostData(const GhostData& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.GhostData)
}

void GhostData::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  unknown_1_ = 0u;
  ghost_id_ = 0u;
  data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GhostData::~GhostData() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.GhostData)
  SharedDtor();
}

void GhostData::SharedDtor() {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GhostData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GhostData& GhostData::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

GhostData* GhostData::default_instance_ = NULL;

GhostData* GhostData::New() const {
  return new GhostData;
}

void GhostData::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<GhostData*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 7) {
    ZR_(unknown_1_, ghost_id_);
    if (has_data()) {
      if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        data_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool GhostData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.GhostData)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 unknown_1 = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_1_)));
          set_has_unknown_1();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_ghost_id;
        break;
      }

      // required uint32 ghost_id = 2;
      case 2: {
        if (tag == 16) {
         parse_ghost_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ghost_id_)));
          set_has_ghost_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_data;
        break;
      }

      // required bytes data = 3;
      case 3: {
        if (tag == 26) {
         parse_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.GhostData)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.GhostData)
  return false;
#undef DO_
}

void GhostData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.GhostData)
  // required uint32 unknown_1 = 1;
  if (has_unknown_1()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->unknown_1(), output);
  }

  // required uint32 ghost_id = 2;
  if (has_ghost_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->ghost_id(), output);
  }

  // required bytes data = 3;
  if (has_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.GhostData)
}

int GhostData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 unknown_1 = 1;
    if (has_unknown_1()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_1());
    }

    // required uint32 ghost_id = 2;
    if (has_ghost_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->ghost_id());
    }

    // required bytes data = 3;
    if (has_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->data());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GhostData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GhostData*>(&from));
}

void GhostData::MergeFrom(const GhostData& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_unknown_1()) {
      set_unknown_1(from.unknown_1());
    }
    if (from.has_ghost_id()) {
      set_ghost_id(from.ghost_id());
    }
    if (from.has_data()) {
      set_data(from.data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void GhostData::CopyFrom(const GhostData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GhostData::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void GhostData::Swap(GhostData* other) {
  if (other != this) {
    std::swap(unknown_1_, other->unknown_1_);
    std::swap(ghost_id_, other->ghost_id_);
    std::swap(data_, other->data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GhostData::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.GhostData";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestCreateGhostData::kOnlineAreaIdFieldNumber;
const int RequestCreateGhostData::kDataFieldNumber;
#endif  // !_MSC_VER

RequestCreateGhostData::RequestCreateGhostData()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestCreateGhostData)
}

void RequestCreateGhostData::InitAsDefaultInstance() {
}

RequestCreateGhostData::RequestCreateGhostData(const RequestCreateGhostData& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestCreateGhostData)
}

void RequestCreateGhostData::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  online_area_id_ = 0u;
  data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestCreateGhostData::~RequestCreateGhostData() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestCreateGhostData)
  SharedDtor();
}

void RequestCreateGhostData::SharedDtor() {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestCreateGhostData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestCreateGhostData& RequestCreateGhostData::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestCreateGhostData* RequestCreateGhostData::default_instance_ = NULL;

RequestCreateGhostData* RequestCreateGhostData::New() const {
  return new RequestCreateGhostData;
}

void RequestCreateGhostData::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    online_area_id_ = 0u;
    if (has_data()) {
      if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        data_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestCreateGhostData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestCreateGhostData)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 online_area_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &online_area_id_)));
          set_has_online_area_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_data;
        break;
      }

      // required bytes data = 2;
      case 2: {
        if (tag == 18) {
         parse_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestCreateGhostData)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestCreateGhostData)
  return false;
#undef DO_
}

void RequestCreateGhostData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestCreateGhostData)
  // required uint32 online_area_id = 1;
  if (has_online_area_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->online_area_id(), output);
  }

  // required bytes data = 2;
  if (has_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestCreateGhostData)
}

int RequestCreateGhostData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 online_area_id = 1;
    if (has_online_area_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->online_area_id());
    }

    // required bytes data = 2;
    if (has_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->data());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestCreateGhostData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestCreateGhostData*>(&from));
}

void RequestCreateGhostData::MergeFrom(const RequestCreateGhostData& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_online_area_id()) {
      set_online_area_id(from.online_area_id());
    }
    if (from.has_data()) {
      set_data(from.data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestCreateGhostData::CopyFrom(const RequestCreateGhostData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestCreateGhostData::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void RequestCreateGhostData::Swap(RequestCreateGhostData* other) {
  if (other != this) {
    std::swap(online_area_id_, other->online_area_id_);
    std::swap(data_, other->data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestCreateGhostData::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestCreateGhostData";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RequestCreateGhostDataResponse::RequestCreateGhostDataResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestCreateGhostDataResponse)
}

void RequestCreateGhostDataResponse::InitAsDefaultInstance() {
}

RequestCreateGhostDataResponse::RequestCreateGhostDataResponse(const RequestCreateGhostDataResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestCreateGhostDataResponse)
}

void RequestCreateGhostDataResponse::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestCreateGhostDataResponse::~RequestCreateGhostDataResponse() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestCreateGhostDataResponse)
  SharedDtor();
}

void RequestCreateGhostDataResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestCreateGhostDataResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestCreateGhostDataResponse& RequestCreateGhostDataResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestCreateGhostDataResponse* RequestCreateGhostDataResponse::default_instance_ = NULL;

RequestCreateGhostDataResponse* RequestCreateGhostDataResponse::New() const {
  return new RequestCreateGhostDataResponse;
}

void RequestCreateGhostDataResponse::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestCreateGhostDataResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestCreateGhostDataResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestCreateGhostDataResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestCreateGhostDataResponse)
  return false;
#undef DO_
}

void RequestCreateGhostDataResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestCreateGhostDataResponse)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestCreateGhostDataResponse)
}

int RequestCreateGhostDataResponse::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestCreateGhostDataResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestCreateGhostDataResponse*>(&from));
}

void RequestCreateGhostDataResponse::MergeFrom(const RequestCreateGhostDataResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestCreateGhostDataResponse::CopyFrom(const RequestCreateGhostDataResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestCreateGhostDataResponse::IsInitialized() const {

  return true;
}

void RequestCreateGhostDataResponse::Swap(RequestCreateGhostDataResponse* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestCreateGhostDataResponse::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestCreateGhostDataResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestGetGhostDataListResponse::kGhostsFieldNumber;
#endif  // !_MSC_VER

RequestGetGhostDataListResponse::RequestGetGhostDataListResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestGetGhostDataListResponse)
}

void RequestGetGhostDataListResponse::InitAsDefaultInstance() {
}

RequestGetGhostDataListResponse::RequestGetGhostDataListResponse(const RequestGetGhostDataListResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestGetGhostDataListResponse)
}

void RequestGetGhostDataListResponse::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestGetGhostDataListResponse::~RequestGetGhostDataListResponse() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestGetGhostDataListResponse)
  SharedDtor();
}

void RequestGetGhostDataListResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestGetGhostDataListResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestGetGhostDataListResponse& RequestGetGhostDataListResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestGetGhostDataListResponse* RequestGetGhostDataListResponse::default_instance_ = NULL;

RequestGetGhostDataListResponse* RequestGetGhostDataListResponse::New() const {
  return new RequestGetGhostDataListResponse;
}

void RequestGetGhostDataListResponse::Clear() {
  ghosts_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestGetGhostDataListResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestGetGhostDataListResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .DS3_Frpg2RequestMessage.GhostData ghosts = 1;
      case 1: {
        if (tag == 10) {
         parse_ghosts:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_ghosts()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_ghosts;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestGetGhostDataListResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestGetGhostDataListResponse)
  return false;
#undef DO_
}

void RequestGetGhostDataListResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestGetGhostDataListResponse)
  // repeated .DS3_Frpg2RequestMessage.GhostData ghosts = 1;
  for (int i = 0; i < this->ghosts_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->ghosts(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestGetGhostDataListResponse)
}

int RequestGetGhostDataListResponse::ByteSize() const {
  int total_size = 0;

  // repeated .DS3_Frpg2RequestMessage.GhostData ghosts = 1;
  total_size += 1 * this->ghosts_size();
  for (int i = 0; i < this->ghosts_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->ghosts(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestGetGhostDataListResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestGetGhostDataListResponse*>(&from));
}

void RequestGetGhostDataListResponse::MergeFrom(const RequestGetGhostDataListResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  ghosts_.MergeFrom(from.ghosts_);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestGetGhostDataListResponse::CopyFrom(const RequestGetGhostDataListResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestGetGhostDataListResponse::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->ghosts())) return false;
  return true;
}

void RequestGetGhostDataListResponse::Swap(RequestGetGhostDataListResponse* other) {
  if (other != this) {
    ghosts_.Swap(&other->ghosts_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestGetGhostDataListResponse::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestGetGhostDataListResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestGetVisitorList::kMapIdFieldNumber;
const int RequestGetVisitorList::kOnlineAreaIdFieldNumber;
const int RequestGetVisitorList::kMaxVisitorsFieldNumber;
const int RequestGetVisitorList::kMatchingParameterFieldNumber;
const int RequestGetVisitorList::kVisitorPoolFieldNumber;
const int RequestGetVisitorList::kUnknown6FieldNumber;
#endif  // !_MSC_VER

RequestGetVisitorList::RequestGetVisitorList()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestGetVisitorList)
}

void RequestGetVisitorList::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  matching_parameter_ = const_cast< ::DS3_Frpg2RequestMessage::MatchingParameter*>(
      ::DS3_Frpg2RequestMessage::MatchingParameter::internal_default_instance());
#else
  matching_parameter_ = const_cast< ::DS3_Frpg2RequestMessage::MatchingParameter*>(&::DS3_Frpg2RequestMessage::MatchingParameter::default_instance());
#endif
}

RequestGetVisitorList::RequestGetVisitorList(const RequestGetVisitorList& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestGetVisitorList)
}

void RequestGetVisitorList::SharedCtor() {
  _cached_size_ = 0;
  map_id_ = 0u;
  online_area_id_ = 0u;
  max_visitors_ = 0u;
  matching_parameter_ = NULL;
  visitor_pool_ = -1;
  unknown_6_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestGetVisitorList::~RequestGetVisitorList() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestGetVisitorList)
  SharedDtor();
}

void RequestGetVisitorList::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete matching_parameter_;
  }
}

void RequestGetVisitorList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestGetVisitorList& RequestGetVisitorList::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestGetVisitorList* RequestGetVisitorList::default_instance_ = NULL;

RequestGetVisitorList* RequestGetVisitorList::New() const {
  return new RequestGetVisitorList;
}

void RequestGetVisitorList::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<RequestGetVisitorList*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 63) {
    ZR_(map_id_, online_area_id_);
    max_visitors_ = 0u;
    if (has_matching_parameter()) {
      if (matching_parameter_ != NULL) matching_parameter_->::DS3_Frpg2RequestMessage::MatchingParameter::Clear();
    }
    visitor_pool_ = -1;
    unknown_6_ = 0u;
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestGetVisitorList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestGetVisitorList)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 map_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &map_id_)));
          set_has_map_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_online_area_id;
        break;
      }

      // required uint32 online_area_id = 2;
      case 2: {
        if (tag == 16) {
         parse_online_area_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &online_area_id_)));
          set_has_online_area_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_max_visitors;
        break;
      }

      // required uint32 max_visitors = 3;
      case 3: {
        if (tag == 24) {
         parse_max_visitors:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &max_visitors_)));
          set_has_max_visitors();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_matching_parameter;
        break;
      }

      // required .DS3_Frpg2RequestMessage.MatchingParameter matching_parameter = 4;
      case 4: {
        if (tag == 34) {
         parse_matching_parameter:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_matching_parameter()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_visitor_pool;
        break;
      }

      // required .DS3_Frpg2RequestMessage.VisitorPool visitor_pool = 5;
      case 5: {
        if (tag == 40) {
         parse_visitor_pool:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::DS3_Frpg2RequestMessage::VisitorPool_IsValid(value)) {
            set_visitor_pool(static_cast< ::DS3_Frpg2RequestMessage::VisitorPool >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_unknown_6;
        break;
      }

      // required uint32 unknown_6 = 6;
      case 6: {
        if (tag == 48) {
         parse_unknown_6:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_6_)));
          set_has_unknown_6();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestGetVisitorList)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestGetVisitorList)
  return false;
#undef DO_
}

void RequestGetVisitorList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestGetVisitorList)
  // required uint32 map_id = 1;
  if (has_map_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->map_id(), output);
  }

  // required uint32 online_area_id = 2;
  if (has_online_area_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->online_area_id(), output);
  }

  // required uint32 max_visitors = 3;
  if (has_max_visitors()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->max_visitors(), output);
  }

  // required .DS3_Frpg2RequestMessage.MatchingParameter matching_parameter = 4;
  if (has_matching_parameter()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->matching_parameter(), output);
  }

  // required .DS3_Frpg2RequestMessage.VisitorPool visitor_pool = 5;
  if (has_visitor_pool()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      5, this->visitor_pool(), output);
  }

  // required uint32 unknown_6 = 6;
  if (has_unknown_6()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->unknown_6(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestGetVisitorList)
}

int RequestGetVisitorList::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 map_id = 1;
    if (has_map_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->map_id());
    }

    // required uint32 online_area_id = 2;
    if (has_online_area_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->online_area_id());
    }

    // required uint32 max_visitors = 3;
    if (has_max_visitors()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->max_visitors());
    }

    // required .DS3_Frpg2RequestMessage.MatchingParameter matching_parameter = 4;
    if (has_matching_parameter()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->matching_parameter());
    }

    // required .DS3_Frpg2RequestMessage.VisitorPool visitor_pool = 5;
    if (has_visitor_pool()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->visitor_pool());
    }

    // required uint32 unknown_6 = 6;
    if (has_unknown_6()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_6());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestGetVisitorList::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestGetVisitorList*>(&from));
}

void RequestGetVisitorList::MergeFrom(const RequestGetVisitorList& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_map_id()) {
      set_map_id(from.map_id());
    }
    if (from.has_online_area_id()) {
      set_online_area_id(from.online_area_id());
    }
    if (from.has_max_visitors()) {
      set_max_visitors(from.max_visitors());
    }
    if (from.has_matching_parameter()) {
      mutable_matching_parameter()->::DS3_Frpg2RequestMessage::MatchingParameter::MergeFrom(from.matching_parameter());
    }
    if (from.has_visitor_pool()) {
      set_visitor_pool(from.visitor_pool());
    }
    if (from.has_unknown_6()) {
      set_unknown_6(from.unknown_6());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestGetVisitorList::CopyFrom(const RequestGetVisitorList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestGetVisitorList::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003f) != 0x0000003f) return false;

  if (has_matching_parameter()) {
    if (!this->matching_parameter().IsInitialized()) return false;
  }
  return true;
}

void RequestGetVisitorList::Swap(RequestGetVisitorList* other) {
  if (other != this) {
    std::swap(map_id_, other->map_id_);
    std::swap(online_area_id_, other->online_area_id_);
    std::swap(max_visitors_, other->max_visitors_);
    std::swap(matching_parameter_, other->matching_parameter_);
    std::swap(visitor_pool_, other->visitor_pool_);
    std::swap(unknown_6_, other->unknown_6_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestGetVisitorList::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestGetVisitorList";
}


// ===================================================================

#ifndef _MSC_VER
const int VisitorData::kPlayerIdFieldNumber;
const int VisitorData::kPlayerSteamIdFieldNumber;
#endif  // !_MSC_VER

VisitorData::VisitorData()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.VisitorData)
}

void VisitorData::InitAsDefaultInstance() {
}

VisitorData::VisitorData(const VisitorData& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.VisitorData)
}

void VisitorData::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  player_id_ = 0u;
  player_steam_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

VisitorData::~VisitorData() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.VisitorData)
  SharedDtor();
}

void VisitorData::SharedDtor() {
  if (player_steam_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete player_steam_id_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void VisitorData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const VisitorData& VisitorData::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

VisitorData* VisitorData::default_instance_ = NULL;

VisitorData* VisitorData::New() const {
  return new VisitorData;
}

void VisitorData::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    player_id_ = 0u;
    if (has_player_steam_id()) {
      if (player_steam_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        player_steam_id_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool VisitorData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.VisitorData)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 player_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &player_id_)));
          set_has_player_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_player_steam_id;
        break;
      }

      // required string player_steam_id = 2;
      case 2: {
        if (tag == 18) {
         parse_player_steam_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_player_steam_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.VisitorData)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.VisitorData)
  return false;
#undef DO_
}

void VisitorData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.VisitorData)
  // required uint32 player_id = 1;
  if (has_player_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->player_id(), output);
  }

  // required string player_steam_id = 2;
  if (has_player_steam_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->player_steam_id(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.VisitorData)
}

int VisitorData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 player_id = 1;
    if (has_player_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->player_id());
    }

    // required string player_steam_id = 2;
    if (has_player_steam_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->player_steam_id());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void VisitorData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const VisitorData*>(&from));
}

void VisitorData::MergeFrom(const VisitorData& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_player_id()) {
      set_player_id(from.player_id());
    }
    if (from.has_player_steam_id()) {
      set_player_steam_id(from.player_steam_id());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void VisitorData::CopyFrom(const VisitorData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VisitorData::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void VisitorData::Swap(VisitorData* other) {
  if (other != this) {
    std::swap(player_id_, other->player_id_);
    std::swap(player_steam_id_, other->player_steam_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string VisitorData::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.VisitorData";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestGetVisitorListResponse::kMapIdFieldNumber;
const int RequestGetVisitorListResponse::kOnlineAreaIdFieldNumber;
const int RequestGetVisitorListResponse::kVisitorsFieldNumber;
#endif  // !_MSC_VER

RequestGetVisitorListResponse::RequestGetVisitorListResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestGetVisitorListResponse)
}

void RequestGetVisitorListResponse::InitAsDefaultInstance() {
}

RequestGetVisitorListResponse::RequestGetVisitorListResponse(const RequestGetVisitorListResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestGetVisitorListResponse)
}

void RequestGetVisitorListResponse::SharedCtor() {
  _cached_size_ = 0;
  map_id_ = 0u;
  online_area_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestGetVisitorListResponse::~RequestGetVisitorListResponse() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestGetVisitorListResponse)
  SharedDtor();
}

void RequestGetVisitorListResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestGetVisitorListResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestGetVisitorListResponse& RequestGetVisitorListResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestGetVisitorListResponse* RequestGetVisitorListResponse::default_instance_ = NULL;

RequestGetVisitorListResponse* RequestGetVisitorListResponse::New() const {
  return new RequestGetVisitorListResponse;
}

void RequestGetVisitorListResponse::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<RequestGetVisitorListResponse*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(map_id_, online_area_id_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  visitors_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestGetVisitorListResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestGetVisitorListResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 map_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &map_id_)));
          set_has_map_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_online_area_id;
        break;
      }

      // required uint32 online_area_id = 2;
      case 2: {
        if (tag == 16) {
         parse_online_area_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &online_area_id_)));
          set_has_online_area_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_visitors;
        break;
      }

      // repeated .DS3_Frpg2RequestMessage.VisitorData visitors = 3;
      case 3: {
        if (tag == 26) {
         parse_visitors:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_visitors()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_visitors;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestGetVisitorListResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestGetVisitorListResponse)
  return false;
#undef DO_
}

void RequestGetVisitorListResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestGetVisitorListResponse)
  // required uint32 map_id = 1;
  if (has_map_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->map_id(), output);
  }

  // required uint32 online_area_id = 2;
  if (has_online_area_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->online_area_id(), output);
  }

  // repeated .DS3_Frpg2RequestMessage.VisitorData visitors = 3;
  for (int i = 0; i < this->visitors_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->visitors(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestGetVisitorListResponse)
}

int RequestGetVisitorListResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 map_id = 1;
    if (has_map_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->map_id());
    }

    // required uint32 online_area_id = 2;
    if (has_online_area_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->online_area_id());
    }

  }
  // repeated .DS3_Frpg2RequestMessage.VisitorData visitors = 3;
  total_size += 1 * this->visitors_size();
  for (int i = 0; i < this->visitors_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->visitors(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestGetVisitorListResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestGetVisitorListResponse*>(&from));
}

void RequestGetVisitorListResponse::MergeFrom(const RequestGetVisitorListResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  visitors_.MergeFrom(from.visitors_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_map_id()) {
      set_map_id(from.map_id());
    }
    if (from.has_online_area_id()) {
      set_online_area_id(from.online_area_id());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestGetVisitorListResponse::CopyFrom(const RequestGetVisitorListResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestGetVisitorListResponse::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->visitors())) return false;
  return true;
}

void RequestGetVisitorListResponse::Swap(RequestGetVisitorListResponse* other) {
  if (other != this) {
    std::swap(map_id_, other->map_id_);
    std::swap(online_area_id_, other->online_area_id_);
    visitors_.Swap(&other->visitors_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestGetVisitorListResponse::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestGetVisitorListResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int PushRequestRemoveVisitor::kPushMessageIdFieldNumber;
const int PushRequestRemoveVisitor::kPlayerIdFieldNumber;
const int PushRequestRemoveVisitor::kPlayerSteamIdFieldNumber;
const int PushRequestRemoveVisitor::kVisitorPoolFieldNumber;
#endif  // !_MSC_VER

PushRequestRemoveVisitor::PushRequestRemoveVisitor()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.PushRequestRemoveVisitor)
}

void PushRequestRemoveVisitor::InitAsDefaultInstance() {
}

PushRequestRemoveVisitor::PushRequestRemoveVisitor(const PushRequestRemoveVisitor& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.PushRequestRemoveVisitor)
}

void PushRequestRemoveVisitor::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  push_message_id_ = 829;
  player_id_ = 0u;
  player_steam_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  visitor_pool_ = -1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PushRequestRemoveVisitor::~PushRequestRemoveVisitor() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.PushRequestRemoveVisitor)
  SharedDtor();
}

void PushRequestRemoveVisitor::SharedDtor() {
  if (player_steam_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete player_steam_id_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void PushRequestRemoveVisitor::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PushRequestRemoveVisitor& PushRequestRemoveVisitor::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

PushRequestRemoveVisitor* PushRequestRemoveVisitor::default_instance_ = NULL;

PushRequestRemoveVisitor* PushRequestRemoveVisitor::New() const {
  return new PushRequestRemoveVisitor;
}

void PushRequestRemoveVisitor::Clear() {
  if (_has_bits_[0 / 32] & 15) {
    push_message_id_ = 829;
    player_id_ = 0u;
    if (has_player_steam_id()) {
      if (player_steam_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        player_steam_id_->clear();
      }
    }
    visitor_pool_ = -1;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool PushRequestRemoveVisitor::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.PushRequestRemoveVisitor)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::DS3_Frpg2RequestMessage::PushMessageId_IsValid(value)) {
            set_push_message_id(static_cast< ::DS3_Frpg2RequestMessage::PushMessageId >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_player_id;
        break;
      }

      // required uint32 player_id = 2;
      case 2: {
        if (tag == 16) {
         parse_player_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &player_id_)));
          set_has_player_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_player_steam_id;
        break;
      }

      // required string player_steam_id = 3;
      case 3: {
        if (tag == 26) {
         parse_player_steam_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_player_steam_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_visitor_pool;
        break;
      }

      // required .DS3_Frpg2RequestMessage.VisitorPool visitor_pool = 4;
      case 4: {
        if (tag == 32) {
         parse_visitor_pool:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::DS3_Frpg2RequestMessage::VisitorPool_IsValid(value)) {
            set_visitor_pool(static_cast< ::DS3_Frpg2RequestMessage::VisitorPool >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.PushRequestRemoveVisitor)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.PushRequestRemoveVisitor)
  return false;
#undef DO_
}

void PushRequestRemoveVisitor::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.PushRequestRemoveVisitor)
  // required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
  if (has_push_message_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->push_message_id(), output);
  }

  // required uint32 player_id = 2;
  if (has_player_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->player_id(), output);
  }

  // required string player_steam_id = 3;
  if (has_player_steam_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->player_steam_id(), output);
  }

  // required .DS3_Frpg2RequestMessage.VisitorPool visitor_pool = 4;
  if (has_visitor_pool()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->visitor_pool(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.PushRequestRemoveVisitor)
}

int PushRequestRemoveVisitor::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
    if (has_push_message_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->push_message_id());
    }

    // required uint32 player_id = 2;
    if (has_player_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->player_id());
    }

    // required string player_steam_id = 3;
    if (has_player_steam_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->player_steam_id());
    }

    // required .DS3_Frpg2RequestMessage.VisitorPool visitor_pool = 4;
    if (has_visitor_pool()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->visitor_pool());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PushRequestRemoveVisitor::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PushRequestRemoveVisitor*>(&from));
}

void PushRequestRemoveVisitor::MergeFrom(const PushRequestRemoveVisitor& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_push_message_id()) {
      set_push_message_id(from.push_message_id());
    }
    if (from.has_player_id()) {
      set_player_id(from.player_id());
    }
    if (from.has_player_steam_id()) {
      set_player_steam_id(from.player_steam_id());
    }
    if (from.has_visitor_pool()) {
      set_visitor_pool(from.visitor_pool());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void PushRequestRemoveVisitor::CopyFrom(const PushRequestRemoveVisitor& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PushRequestRemoveVisitor::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void PushRequestRemoveVisitor::Swap(PushRequestRemoveVisitor* other) {
  if (other != this) {
    std::swap(push_message_id_, other->push_message_id_);
    std::swap(player_id_, other->player_id_);
    std::swap(player_steam_id_, other->player_steam_id_);
    std::swap(visitor_pool_, other->visitor_pool_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PushRequestRemoveVisitor::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.PushRequestRemoveVisitor";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestVisit::kMapIdFieldNumber;
const int RequestVisit::kOnlineAreaIdFieldNumber;
const int RequestVisit::kVisitorPoolFieldNumber;
const int RequestVisit::kPlayerIdFieldNumber;
const int RequestVisit::kDataFieldNumber;
#endif  // !_MSC_VER

RequestVisit::RequestVisit()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestVisit)
}

void RequestVisit::InitAsDefaultInstance() {
}

RequestVisit::RequestVisit(const RequestVisit& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestVisit)
}

void RequestVisit::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  map_id_ = 0u;
  online_area_id_ = 0u;
  visitor_pool_ = -1;
  player_id_ = 0u;
  data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestVisit::~RequestVisit() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestVisit)
  SharedDtor();
}

void RequestVisit::SharedDtor() {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestVisit::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestVisit& RequestVisit::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestVisit* RequestVisit::default_instance_ = NULL;

RequestVisit* RequestVisit::New() const {
  return new RequestVisit;
}

void RequestVisit::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<RequestVisit*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 31) {
    ZR_(map_id_, online_area_id_);
    visitor_pool_ = -1;
    player_id_ = 0u;
    if (has_data()) {
      if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        data_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestVisit::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestVisit)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 map_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &map_id_)));
          set_has_map_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_online_area_id;
        break;
      }

      // required uint32 online_area_id = 2;
      case 2: {
        if (tag == 16) {
         parse_online_area_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &online_area_id_)));
          set_has_online_area_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_visitor_pool;
        break;
      }

      // required .DS3_Frpg2RequestMessage.VisitorPool visitor_pool = 3;
      case 3: {
        if (tag == 24) {
         parse_visitor_pool:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::DS3_Frpg2RequestMessage::VisitorPool_IsValid(value)) {
            set_visitor_pool(static_cast< ::DS3_Frpg2RequestMessage::VisitorPool >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_player_id;
        break;
      }

      // required uint32 player_id = 4;
      case 4: {
        if (tag == 32) {
         parse_player_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &player_id_)));
          set_has_player_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_data;
        break;
      }

      // required bytes data = 5;
      case 5: {
        if (tag == 42) {
         parse_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestVisit)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestVisit)
  return false;
#undef DO_
}

void RequestVisit::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestVisit)
  // required uint32 map_id = 1;
  if (has_map_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->map_id(), output);
  }

  // required uint32 online_area_id = 2;
  if (has_online_area_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->online_area_id(), output);
  }

  // required .DS3_Frpg2RequestMessage.VisitorPool visitor_pool = 3;
  if (has_visitor_pool()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->visitor_pool(), output);
  }

  // required uint32 player_id = 4;
  if (has_player_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->player_id(), output);
  }

  // required bytes data = 5;
  if (has_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      5, this->data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestVisit)
}

int RequestVisit::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 map_id = 1;
    if (has_map_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->map_id());
    }

    // required uint32 online_area_id = 2;
    if (has_online_area_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->online_area_id());
    }

    // required .DS3_Frpg2RequestMessage.VisitorPool visitor_pool = 3;
    if (has_visitor_pool()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->visitor_pool());
    }

    // required uint32 player_id = 4;
    if (has_player_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->player_id());
    }

    // required bytes data = 5;
    if (has_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->data());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestVisit::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestVisit*>(&from));
}

void RequestVisit::MergeFrom(const RequestVisit& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_map_id()) {
      set_map_id(from.map_id());
    }
    if (from.has_online_area_id()) {
      set_online_area_id(from.online_area_id());
    }
    if (from.has_visitor_pool()) {
      set_visitor_pool(from.visitor_pool());
    }
    if (from.has_player_id()) {
      set_player_id(from.player_id());
    }
    if (from.has_data()) {
      set_data(from.data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestVisit::CopyFrom(const RequestVisit& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestVisit::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;

  return true;
}

void RequestVisit::Swap(RequestVisit* other) {
  if (other != this) {
    std::swap(map_id_, other->map_id_);
    std::swap(online_area_id_, other->online_area_id_);
    std::swap(visitor_pool_, other->visitor_pool_);
    std::swap(player_id_, other->player_id_);
    std::swap(data_, other->data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestVisit::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestVisit";
}


// ===================================================================

#ifndef _MSC_VER
const int PushRequestVisit::kPushMessageIdFieldNumber;
const int PushRequestVisit::kPlayerIdFieldNumber;
const int PushRequestVisit::kPlayerSteamIdFieldNumber;
const int PushRequestVisit::kDataFieldNumber;
const int PushRequestVisit::kVisitorPoolFieldNumber;
const int PushRequestVisit::kMapIdFieldNumber;
const int PushRequestVisit::kOnlineAreaIdFieldNumber;
#endif  // !_MSC_VER

PushRequestVisit::PushRequestVisit()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.PushRequestVisit)
}

void PushRequestVisit::InitAsDefaultInstance() {
}

PushRequestVisit::PushRequestVisit(const PushRequestVisit& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.PushRequestVisit)
}

void PushRequestVisit::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  push_message_id_ = 829;
  player_id_ = 0u;
  player_steam_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  visitor_pool_ = -1;
  map_id_ = 0u;
  online_area_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PushRequestVisit::~PushRequestVisit() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.PushRequestVisit)
  SharedDtor();
}

void PushRequestVisit::SharedDtor() {
  if (player_steam_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete player_steam_id_;
  }
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void PushRequestVisit::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PushRequestVisit& PushRequestVisit::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

PushRequestVisit* PushRequestVisit::default_instance_ = NULL;

PushRequestVisit* PushRequestVisit::New() const {
  return new PushRequestVisit;
}

void PushRequestVisit::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<PushRequestVisit*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 127) {
    ZR_(map_id_, online_area_id_);
    push_message_id_ = 829;
    player_id_ = 0u;
    if (has_player_steam_id()) {
      if (player_steam_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        player_steam_id_->clear();
      }
    }
    if (has_data()) {
      if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        data_->clear();
      }
    }
    visitor_pool_ = -1;
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool PushRequestVisit::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.PushRequestVisit)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::DS3_Frpg2RequestMessage::PushMessageId_IsValid(value)) {
            set_push_message_id(static_cast< ::DS3_Frpg2RequestMessage::PushMessageId >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_player_id;
        break;
      }

      // required uint32 player_id = 2;
      case 2: {
        if (tag == 16) {
         parse_player_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &player_id_)));
          set_has_player_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_player_steam_id;
        break;
      }

      // required string player_steam_id = 3;
      case 3: {
        if (tag == 26) {
         parse_player_steam_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_player_steam_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_data;
        break;
      }

      // required bytes data = 4;
      case 4: {
        if (tag == 34) {
         parse_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_visitor_pool;
        break;
      }

      // required .DS3_Frpg2RequestMessage.VisitorPool visitor_pool = 5;
      case 5: {
        if (tag == 40) {
         parse_visitor_pool:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::DS3_Frpg2RequestMessage::VisitorPool_IsValid(value)) {
            set_visitor_pool(static_cast< ::DS3_Frpg2RequestMessage::VisitorPool >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_map_id;
        break;
      }

      // required uint32 map_id = 6;
      case 6: {
        if (tag == 48) {
         parse_map_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &map_id_)));
          set_has_map_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_online_area_id;
        break;
      }

      // required uint32 online_area_id = 7;
      case 7: {
        if (tag == 56) {
         parse_online_area_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &online_area_id_)));
          set_has_online_area_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.PushRequestVisit)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.PushRequestVisit)
  return false;
#undef DO_
}

void PushRequestVisit::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.PushRequestVisit)
  // required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
  if (has_push_message_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->push_message_id(), output);
  }

  // required uint32 player_id = 2;
  if (has_player_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->player_id(), output);
  }

  // required string player_steam_id = 3;
  if (has_player_steam_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->player_steam_id(), output);
  }

  // required bytes data = 4;
  if (has_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      4, this->data(), output);
  }

  // required .DS3_Frpg2RequestMessage.VisitorPool visitor_pool = 5;
  if (has_visitor_pool()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      5, this->visitor_pool(), output);
  }

  // required uint32 map_id = 6;
  if (has_map_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->map_id(), output);
  }

  // required uint32 online_area_id = 7;
  if (has_online_area_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->online_area_id(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.PushRequestVisit)
}

int PushRequestVisit::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
    if (has_push_message_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->push_message_id());
    }

    // required uint32 player_id = 2;
    if (has_player_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->player_id());
    }

    // required string player_steam_id = 3;
    if (has_player_steam_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->player_steam_id());
    }

    // required bytes data = 4;
    if (has_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->data());
    }

    // required .DS3_Frpg2RequestMessage.VisitorPool visitor_pool = 5;
    if (has_visitor_pool()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->visitor_pool());
    }

    // required uint32 map_id = 6;
    if (has_map_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->map_id());
    }

    // required uint32 online_area_id = 7;
    if (has_online_area_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->online_area_id());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PushRequestVisit::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PushRequestVisit*>(&from));
}

void PushRequestVisit::MergeFrom(const PushRequestVisit& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_push_message_id()) {
      set_push_message_id(from.push_message_id());
    }
    if (from.has_player_id()) {
      set_player_id(from.player_id());
    }
    if (from.has_player_steam_id()) {
      set_player_steam_id(from.player_steam_id());
    }
    if (from.has_data()) {
      set_data(from.data());
    }
    if (from.has_visitor_pool()) {
      set_visitor_pool(from.visitor_pool());
    }
    if (from.has_map_id()) {
      set_map_id(from.map_id());
    }
    if (from.has_online_area_id()) {
      set_online_area_id(from.online_area_id());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void PushRequestVisit::CopyFrom(const PushRequestVisit& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PushRequestVisit::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000007f) != 0x0000007f) return false;

  return true;
}

void PushRequestVisit::Swap(PushRequestVisit* other) {
  if (other != this) {
    std::swap(push_message_id_, other->push_message_id_);
    std::swap(player_id_, other->player_id_);
    std::swap(player_steam_id_, other->player_steam_id_);
    std::swap(data_, other->data_);
    std::swap(visitor_pool_, other->visitor_pool_);
    std::swap(map_id_, other->map_id_);
    std::swap(online_area_id_, other->online_area_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PushRequestVisit::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.PushRequestVisit";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestRejectVisit::kPlayerIdFieldNumber;
const int RequestRejectVisit::kVisitorPoolFieldNumber;
const int RequestRejectVisit::kMapIdFieldNumber;
const int RequestRejectVisit::kOnlineAreaIdFieldNumber;
const int RequestRejectVisit::kUnknown5FieldNumber;
#endif  // !_MSC_VER

RequestRejectVisit::RequestRejectVisit()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestRejectVisit)
}

void RequestRejectVisit::InitAsDefaultInstance() {
}

RequestRejectVisit::RequestRejectVisit(const RequestRejectVisit& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestRejectVisit)
}

void RequestRejectVisit::SharedCtor() {
  _cached_size_ = 0;
  player_id_ = 0u;
  visitor_pool_ = -1;
  map_id_ = 0u;
  online_area_id_ = 0u;
  unknown_5_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestRejectVisit::~RequestRejectVisit() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestRejectVisit)
  SharedDtor();
}

void RequestRejectVisit::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestRejectVisit::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestRejectVisit& RequestRejectVisit::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestRejectVisit* RequestRejectVisit::default_instance_ = NULL;

RequestRejectVisit* RequestRejectVisit::New() const {
  return new RequestRejectVisit;
}

void RequestRejectVisit::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<RequestRejectVisit*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 31) {
    ZR_(map_id_, unknown_5_);
    player_id_ = 0u;
    visitor_pool_ = -1;
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestRejectVisit::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestRejectVisit)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 player_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &player_id_)));
          set_has_player_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_visitor_pool;
        break;
      }

      // required .DS3_Frpg2RequestMessage.VisitorPool visitor_pool = 2;
      case 2: {
        if (tag == 16) {
         parse_visitor_pool:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::DS3_Frpg2RequestMessage::VisitorPool_IsValid(value)) {
            set_visitor_pool(static_cast< ::DS3_Frpg2RequestMessage::VisitorPool >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_map_id;
        break;
      }

      // required uint32 map_id = 3;
      case 3: {
        if (tag == 24) {
         parse_map_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &map_id_)));
          set_has_map_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_online_area_id;
        break;
      }

      // required uint32 online_area_id = 4;
      case 4: {
        if (tag == 32) {
         parse_online_area_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &online_area_id_)));
          set_has_online_area_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_unknown_5;
        break;
      }

      // required uint32 unknown_5 = 5;
      case 5: {
        if (tag == 40) {
         parse_unknown_5:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_5_)));
          set_has_unknown_5();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestRejectVisit)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestRejectVisit)
  return false;
#undef DO_
}

void RequestRejectVisit::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestRejectVisit)
  // required uint32 player_id = 1;
  if (has_player_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->player_id(), output);
  }

  // required .DS3_Frpg2RequestMessage.VisitorPool visitor_pool = 2;
  if (has_visitor_pool()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->visitor_pool(), output);
  }

  // required uint32 map_id = 3;
  if (has_map_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->map_id(), output);
  }

  // required uint32 online_area_id = 4;
  if (has_online_area_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->online_area_id(), output);
  }

  // required uint32 unknown_5 = 5;
  if (has_unknown_5()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->unknown_5(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestRejectVisit)
}

int RequestRejectVisit::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 player_id = 1;
    if (has_player_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->player_id());
    }

    // required .DS3_Frpg2RequestMessage.VisitorPool visitor_pool = 2;
    if (has_visitor_pool()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->visitor_pool());
    }

    // required uint32 map_id = 3;
    if (has_map_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->map_id());
    }

    // required uint32 online_area_id = 4;
    if (has_online_area_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->online_area_id());
    }

    // required uint32 unknown_5 = 5;
    if (has_unknown_5()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_5());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestRejectVisit::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestRejectVisit*>(&from));
}

void RequestRejectVisit::MergeFrom(const RequestRejectVisit& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_player_id()) {
      set_player_id(from.player_id());
    }
    if (from.has_visitor_pool()) {
      set_visitor_pool(from.visitor_pool());
    }
    if (from.has_map_id()) {
      set_map_id(from.map_id());
    }
    if (from.has_online_area_id()) {
      set_online_area_id(from.online_area_id());
    }
    if (from.has_unknown_5()) {
      set_unknown_5(from.unknown_5());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestRejectVisit::CopyFrom(const RequestRejectVisit& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestRejectVisit::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;

  return true;
}

void RequestRejectVisit::Swap(RequestRejectVisit* other) {
  if (other != this) {
    std::swap(player_id_, other->player_id_);
    std::swap(visitor_pool_, other->visitor_pool_);
    std::swap(map_id_, other->map_id_);
    std::swap(online_area_id_, other->online_area_id_);
    std::swap(unknown_5_, other->unknown_5_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestRejectVisit::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestRejectVisit";
}


// ===================================================================

#ifndef _MSC_VER
const int PushRequestRejectVisit::kPushMessageIdFieldNumber;
const int PushRequestRejectVisit::kPlayerIdFieldNumber;
const int PushRequestRejectVisit::kVisitorPoolFieldNumber;
const int PushRequestRejectVisit::kSteamIdFieldNumber;
const int PushRequestRejectVisit::kUnknown5FieldNumber;
#endif  // !_MSC_VER

PushRequestRejectVisit::PushRequestRejectVisit()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.PushRequestRejectVisit)
}

void PushRequestRejectVisit::InitAsDefaultInstance() {
}

PushRequestRejectVisit::PushRequestRejectVisit(const PushRequestRejectVisit& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.PushRequestRejectVisit)
}

void PushRequestRejectVisit::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  push_message_id_ = 829;
  player_id_ = 0u;
  visitor_pool_ = -1;
  steam_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  unknown_5_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PushRequestRejectVisit::~PushRequestRejectVisit() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.PushRequestRejectVisit)
  SharedDtor();
}

void PushRequestRejectVisit::SharedDtor() {
  if (steam_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete steam_id_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void PushRequestRejectVisit::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PushRequestRejectVisit& PushRequestRejectVisit::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

PushRequestRejectVisit* PushRequestRejectVisit::default_instance_ = NULL;

PushRequestRejectVisit* PushRequestRejectVisit::New() const {
  return new PushRequestRejectVisit;
}

void PushRequestRejectVisit::Clear() {
  if (_has_bits_[0 / 32] & 31) {
    push_message_id_ = 829;
    player_id_ = 0u;
    visitor_pool_ = -1;
    if (has_steam_id()) {
      if (steam_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        steam_id_->clear();
      }
    }
    unknown_5_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool PushRequestRejectVisit::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.PushRequestRejectVisit)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::DS3_Frpg2RequestMessage::PushMessageId_IsValid(value)) {
            set_push_message_id(static_cast< ::DS3_Frpg2RequestMessage::PushMessageId >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_player_id;
        break;
      }

      // required uint32 player_id = 2;
      case 2: {
        if (tag == 16) {
         parse_player_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &player_id_)));
          set_has_player_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_visitor_pool;
        break;
      }

      // optional .DS3_Frpg2RequestMessage.VisitorPool visitor_pool = 3;
      case 3: {
        if (tag == 24) {
         parse_visitor_pool:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::DS3_Frpg2RequestMessage::VisitorPool_IsValid(value)) {
            set_visitor_pool(static_cast< ::DS3_Frpg2RequestMessage::VisitorPool >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_steam_id;
        break;
      }

      // required string steam_id = 4;
      case 4: {
        if (tag == 34) {
         parse_steam_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_steam_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_unknown_5;
        break;
      }

      // required uint32 unknown_5 = 5;
      case 5: {
        if (tag == 40) {
         parse_unknown_5:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_5_)));
          set_has_unknown_5();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.PushRequestRejectVisit)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.PushRequestRejectVisit)
  return false;
#undef DO_
}

void PushRequestRejectVisit::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.PushRequestRejectVisit)
  // required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
  if (has_push_message_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->push_message_id(), output);
  }

  // required uint32 player_id = 2;
  if (has_player_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->player_id(), output);
  }

  // optional .DS3_Frpg2RequestMessage.VisitorPool visitor_pool = 3;
  if (has_visitor_pool()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->visitor_pool(), output);
  }

  // required string steam_id = 4;
  if (has_steam_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->steam_id(), output);
  }

  // required uint32 unknown_5 = 5;
  if (has_unknown_5()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->unknown_5(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.PushRequestRejectVisit)
}

int PushRequestRejectVisit::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
    if (has_push_message_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->push_message_id());
    }

    // required uint32 player_id = 2;
    if (has_player_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->player_id());
    }

    // optional .DS3_Frpg2RequestMessage.VisitorPool visitor_pool = 3;
    if (has_visitor_pool()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->visitor_pool());
    }

    // required string steam_id = 4;
    if (has_steam_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->steam_id());
    }

    // required uint32 unknown_5 = 5;
    if (has_unknown_5()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_5());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PushRequestRejectVisit::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PushRequestRejectVisit*>(&from));
}

void PushRequestRejectVisit::MergeFrom(const PushRequestRejectVisit& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_push_message_id()) {
      set_push_message_id(from.push_message_id());
    }
    if (from.has_player_id()) {
      set_player_id(from.player_id());
    }
    if (from.has_visitor_pool()) {
      set_visitor_pool(from.visitor_pool());
    }
    if (from.has_steam_id()) {
      set_steam_id(from.steam_id());
    }
    if (from.has_unknown_5()) {
      set_unknown_5(from.unknown_5());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void PushRequestRejectVisit::CopyFrom(const PushRequestRejectVisit& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PushRequestRejectVisit::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001b) != 0x0000001b) return false;

  return true;
}

void PushRequestRejectVisit::Swap(PushRequestRejectVisit* other) {
  if (other != this) {
    std::swap(push_message_id_, other->push_message_id_);
    std::swap(player_id_, other->player_id_);
    std::swap(visitor_pool_, other->visitor_pool_);
    std::swap(steam_id_, other->steam_id_);
    std::swap(unknown_5_, other->unknown_5_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PushRequestRejectVisit::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.PushRequestRejectVisit";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RequestVisitResponse::RequestVisitResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestVisitResponse)
}

void RequestVisitResponse::InitAsDefaultInstance() {
}

RequestVisitResponse::RequestVisitResponse(const RequestVisitResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestVisitResponse)
}

void RequestVisitResponse::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestVisitResponse::~RequestVisitResponse() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestVisitResponse)
  SharedDtor();
}

void RequestVisitResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestVisitResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestVisitResponse& RequestVisitResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestVisitResponse* RequestVisitResponse::default_instance_ = NULL;

RequestVisitResponse* RequestVisitResponse::New() const {
  return new RequestVisitResponse;
}

void RequestVisitResponse::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestVisitResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestVisitResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestVisitResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestVisitResponse)
  return false;
#undef DO_
}

void RequestVisitResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestVisitResponse)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestVisitResponse)
}

int RequestVisitResponse::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestVisitResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestVisitResponse*>(&from));
}

void RequestVisitResponse::MergeFrom(const RequestVisitResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestVisitResponse::CopyFrom(const RequestVisitResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestVisitResponse::IsInitialized() const {

  return true;
}

void RequestVisitResponse::Swap(RequestVisitResponse* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestVisitResponse::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestVisitResponse";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RequestRejectVisitResponse::RequestRejectVisitResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestRejectVisitResponse)
}

void RequestRejectVisitResponse::InitAsDefaultInstance() {
}

RequestRejectVisitResponse::RequestRejectVisitResponse(const RequestRejectVisitResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestRejectVisitResponse)
}

void RequestRejectVisitResponse::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestRejectVisitResponse::~RequestRejectVisitResponse() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestRejectVisitResponse)
  SharedDtor();
}

void RequestRejectVisitResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestRejectVisitResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestRejectVisitResponse& RequestRejectVisitResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestRejectVisitResponse* RequestRejectVisitResponse::default_instance_ = NULL;

RequestRejectVisitResponse* RequestRejectVisitResponse::New() const {
  return new RequestRejectVisitResponse;
}

void RequestRejectVisitResponse::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestRejectVisitResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestRejectVisitResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestRejectVisitResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestRejectVisitResponse)
  return false;
#undef DO_
}

void RequestRejectVisitResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestRejectVisitResponse)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestRejectVisitResponse)
}

int RequestRejectVisitResponse::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestRejectVisitResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestRejectVisitResponse*>(&from));
}

void RequestRejectVisitResponse::MergeFrom(const RequestRejectVisitResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestRejectVisitResponse::CopyFrom(const RequestRejectVisitResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestRejectVisitResponse::IsInitialized() const {

  return true;
}

void RequestRejectVisitResponse::Swap(RequestRejectVisitResponse* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestRejectVisitResponse::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestRejectVisitResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestNotifyRingBell::kOnlineAreaIdFieldNumber;
const int RequestNotifyRingBell::kDataFieldNumber;
#endif  // !_MSC_VER

RequestNotifyRingBell::RequestNotifyRingBell()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestNotifyRingBell)
}

void RequestNotifyRingBell::InitAsDefaultInstance() {
}

RequestNotifyRingBell::RequestNotifyRingBell(const RequestNotifyRingBell& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestNotifyRingBell)
}

void RequestNotifyRingBell::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  online_area_id_ = 0u;
  data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestNotifyRingBell::~RequestNotifyRingBell() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestNotifyRingBell)
  SharedDtor();
}

void RequestNotifyRingBell::SharedDtor() {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestNotifyRingBell::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestNotifyRingBell& RequestNotifyRingBell::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestNotifyRingBell* RequestNotifyRingBell::default_instance_ = NULL;

RequestNotifyRingBell* RequestNotifyRingBell::New() const {
  return new RequestNotifyRingBell;
}

void RequestNotifyRingBell::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    online_area_id_ = 0u;
    if (has_data()) {
      if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        data_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestNotifyRingBell::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestNotifyRingBell)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 online_area_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &online_area_id_)));
          set_has_online_area_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_data;
        break;
      }

      // required bytes data = 2;
      case 2: {
        if (tag == 18) {
         parse_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestNotifyRingBell)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestNotifyRingBell)
  return false;
#undef DO_
}

void RequestNotifyRingBell::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestNotifyRingBell)
  // required uint32 online_area_id = 1;
  if (has_online_area_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->online_area_id(), output);
  }

  // required bytes data = 2;
  if (has_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestNotifyRingBell)
}

int RequestNotifyRingBell::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 online_area_id = 1;
    if (has_online_area_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->online_area_id());
    }

    // required bytes data = 2;
    if (has_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->data());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestNotifyRingBell::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestNotifyRingBell*>(&from));
}

void RequestNotifyRingBell::MergeFrom(const RequestNotifyRingBell& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_online_area_id()) {
      set_online_area_id(from.online_area_id());
    }
    if (from.has_data()) {
      set_data(from.data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestNotifyRingBell::CopyFrom(const RequestNotifyRingBell& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestNotifyRingBell::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void RequestNotifyRingBell::Swap(RequestNotifyRingBell* other) {
  if (other != this) {
    std::swap(online_area_id_, other->online_area_id_);
    std::swap(data_, other->data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestNotifyRingBell::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestNotifyRingBell";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RequestNotifyRingBellResponse::RequestNotifyRingBellResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestNotifyRingBellResponse)
}

void RequestNotifyRingBellResponse::InitAsDefaultInstance() {
}

RequestNotifyRingBellResponse::RequestNotifyRingBellResponse(const RequestNotifyRingBellResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestNotifyRingBellResponse)
}

void RequestNotifyRingBellResponse::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestNotifyRingBellResponse::~RequestNotifyRingBellResponse() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestNotifyRingBellResponse)
  SharedDtor();
}

void RequestNotifyRingBellResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestNotifyRingBellResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestNotifyRingBellResponse& RequestNotifyRingBellResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestNotifyRingBellResponse* RequestNotifyRingBellResponse::default_instance_ = NULL;

RequestNotifyRingBellResponse* RequestNotifyRingBellResponse::New() const {
  return new RequestNotifyRingBellResponse;
}

void RequestNotifyRingBellResponse::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestNotifyRingBellResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestNotifyRingBellResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestNotifyRingBellResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestNotifyRingBellResponse)
  return false;
#undef DO_
}

void RequestNotifyRingBellResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestNotifyRingBellResponse)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestNotifyRingBellResponse)
}

int RequestNotifyRingBellResponse::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestNotifyRingBellResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestNotifyRingBellResponse*>(&from));
}

void RequestNotifyRingBellResponse::MergeFrom(const RequestNotifyRingBellResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestNotifyRingBellResponse::CopyFrom(const RequestNotifyRingBellResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestNotifyRingBellResponse::IsInitialized() const {

  return true;
}

void RequestNotifyRingBellResponse::Swap(RequestNotifyRingBellResponse* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestNotifyRingBellResponse::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestNotifyRingBellResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int PushRequestNotifyRingBell::kPushMessageIdFieldNumber;
const int PushRequestNotifyRingBell::kPlayerIdFieldNumber;
const int PushRequestNotifyRingBell::kOnlineAreaIdFieldNumber;
const int PushRequestNotifyRingBell::kDataFieldNumber;
#endif  // !_MSC_VER

PushRequestNotifyRingBell::PushRequestNotifyRingBell()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.PushRequestNotifyRingBell)
}

void PushRequestNotifyRingBell::InitAsDefaultInstance() {
}

PushRequestNotifyRingBell::PushRequestNotifyRingBell(const PushRequestNotifyRingBell& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.PushRequestNotifyRingBell)
}

void PushRequestNotifyRingBell::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  push_message_id_ = 829;
  player_id_ = 0u;
  online_area_id_ = 0u;
  data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PushRequestNotifyRingBell::~PushRequestNotifyRingBell() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.PushRequestNotifyRingBell)
  SharedDtor();
}

void PushRequestNotifyRingBell::SharedDtor() {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void PushRequestNotifyRingBell::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PushRequestNotifyRingBell& PushRequestNotifyRingBell::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

PushRequestNotifyRingBell* PushRequestNotifyRingBell::default_instance_ = NULL;

PushRequestNotifyRingBell* PushRequestNotifyRingBell::New() const {
  return new PushRequestNotifyRingBell;
}

void PushRequestNotifyRingBell::Clear() {
  if (_has_bits_[0 / 32] & 15) {
    push_message_id_ = 829;
    player_id_ = 0u;
    online_area_id_ = 0u;
    if (has_data()) {
      if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        data_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool PushRequestNotifyRingBell::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.PushRequestNotifyRingBell)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::DS3_Frpg2RequestMessage::PushMessageId_IsValid(value)) {
            set_push_message_id(static_cast< ::DS3_Frpg2RequestMessage::PushMessageId >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_player_id;
        break;
      }

      // required uint32 player_id = 2;
      case 2: {
        if (tag == 16) {
         parse_player_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &player_id_)));
          set_has_player_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_online_area_id;
        break;
      }

      // required uint32 online_area_id = 3;
      case 3: {
        if (tag == 24) {
         parse_online_area_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &online_area_id_)));
          set_has_online_area_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_data;
        break;
      }

      // required bytes data = 4;
      case 4: {
        if (tag == 34) {
         parse_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.PushRequestNotifyRingBell)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.PushRequestNotifyRingBell)
  return false;
#undef DO_
}

void PushRequestNotifyRingBell::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.PushRequestNotifyRingBell)
  // required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
  if (has_push_message_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->push_message_id(), output);
  }

  // required uint32 player_id = 2;
  if (has_player_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->player_id(), output);
  }

  // required uint32 online_area_id = 3;
  if (has_online_area_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->online_area_id(), output);
  }

  // required bytes data = 4;
  if (has_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      4, this->data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.PushRequestNotifyRingBell)
}

int PushRequestNotifyRingBell::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
    if (has_push_message_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->push_message_id());
    }

    // required uint32 player_id = 2;
    if (has_player_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->player_id());
    }

    // required uint32 online_area_id = 3;
    if (has_online_area_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->online_area_id());
    }

    // required bytes data = 4;
    if (has_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->data());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PushRequestNotifyRingBell::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PushRequestNotifyRingBell*>(&from));
}

void PushRequestNotifyRingBell::MergeFrom(const PushRequestNotifyRingBell& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_push_message_id()) {
      set_push_message_id(from.push_message_id());
    }
    if (from.has_player_id()) {
      set_player_id(from.player_id());
    }
    if (from.has_online_area_id()) {
      set_online_area_id(from.online_area_id());
    }
    if (from.has_data()) {
      set_data(from.data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void PushRequestNotifyRingBell::CopyFrom(const PushRequestNotifyRingBell& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PushRequestNotifyRingBell::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void PushRequestNotifyRingBell::Swap(PushRequestNotifyRingBell* other) {
  if (other != this) {
    std::swap(push_message_id_, other->push_message_id_);
    std::swap(player_id_, other->player_id_);
    std::swap(online_area_id_, other->online_area_id_);
    std::swap(data_, other->data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PushRequestNotifyRingBell::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.PushRequestNotifyRingBell";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RequestGetRegulationFile::RequestGetRegulationFile()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestGetRegulationFile)
}

void RequestGetRegulationFile::InitAsDefaultInstance() {
}

RequestGetRegulationFile::RequestGetRegulationFile(const RequestGetRegulationFile& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestGetRegulationFile)
}

void RequestGetRegulationFile::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestGetRegulationFile::~RequestGetRegulationFile() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestGetRegulationFile)
  SharedDtor();
}

void RequestGetRegulationFile::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestGetRegulationFile::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestGetRegulationFile& RequestGetRegulationFile::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestGetRegulationFile* RequestGetRegulationFile::default_instance_ = NULL;

RequestGetRegulationFile* RequestGetRegulationFile::New() const {
  return new RequestGetRegulationFile;
}

void RequestGetRegulationFile::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestGetRegulationFile::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestGetRegulationFile)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestGetRegulationFile)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestGetRegulationFile)
  return false;
#undef DO_
}

void RequestGetRegulationFile::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestGetRegulationFile)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestGetRegulationFile)
}

int RequestGetRegulationFile::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestGetRegulationFile::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestGetRegulationFile*>(&from));
}

void RequestGetRegulationFile::MergeFrom(const RequestGetRegulationFile& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestGetRegulationFile::CopyFrom(const RequestGetRegulationFile& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestGetRegulationFile::IsInitialized() const {

  return true;
}

void RequestGetRegulationFile::Swap(RequestGetRegulationFile* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestGetRegulationFile::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestGetRegulationFile";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RequestGetRegulationFileResponse::RequestGetRegulationFileResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestGetRegulationFileResponse)
}

void RequestGetRegulationFileResponse::InitAsDefaultInstance() {
}

RequestGetRegulationFileResponse::RequestGetRegulationFileResponse(const RequestGetRegulationFileResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestGetRegulationFileResponse)
}

void RequestGetRegulationFileResponse::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestGetRegulationFileResponse::~RequestGetRegulationFileResponse() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestGetRegulationFileResponse)
  SharedDtor();
}

void RequestGetRegulationFileResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestGetRegulationFileResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestGetRegulationFileResponse& RequestGetRegulationFileResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestGetRegulationFileResponse* RequestGetRegulationFileResponse::default_instance_ = NULL;

RequestGetRegulationFileResponse* RequestGetRegulationFileResponse::New() const {
  return new RequestGetRegulationFileResponse;
}

void RequestGetRegulationFileResponse::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestGetRegulationFileResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestGetRegulationFileResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestGetRegulationFileResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestGetRegulationFileResponse)
  return false;
#undef DO_
}

void RequestGetRegulationFileResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestGetRegulationFileResponse)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestGetRegulationFileResponse)
}

int RequestGetRegulationFileResponse::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestGetRegulationFileResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestGetRegulationFileResponse*>(&from));
}

void RequestGetRegulationFileResponse::MergeFrom(const RequestGetRegulationFileResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestGetRegulationFileResponse::CopyFrom(const RequestGetRegulationFileResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestGetRegulationFileResponse::IsInitialized() const {

  return true;
}

void RequestGetRegulationFileResponse::Swap(RequestGetRegulationFileResponse* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestGetRegulationFileResponse::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestGetRegulationFileResponse";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RegulationFileMessage::RegulationFileMessage()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RegulationFileMessage)
}

void RegulationFileMessage::InitAsDefaultInstance() {
}

RegulationFileMessage::RegulationFileMessage(const RegulationFileMessage& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RegulationFileMessage)
}

void RegulationFileMessage::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RegulationFileMessage::~RegulationFileMessage() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RegulationFileMessage)
  SharedDtor();
}

void RegulationFileMessage::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RegulationFileMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RegulationFileMessage& RegulationFileMessage::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RegulationFileMessage* RegulationFileMessage::default_instance_ = NULL;

RegulationFileMessage* RegulationFileMessage::New() const {
  return new RegulationFileMessage;
}

void RegulationFileMessage::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RegulationFileMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RegulationFileMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RegulationFileMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RegulationFileMessage)
  return false;
#undef DO_
}

void RegulationFileMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RegulationFileMessage)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RegulationFileMessage)
}

int RegulationFileMessage::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RegulationFileMessage::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RegulationFileMessage*>(&from));
}

void RegulationFileMessage::MergeFrom(const RegulationFileMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RegulationFileMessage::CopyFrom(const RegulationFileMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RegulationFileMessage::IsInitialized() const {

  return true;
}

void RegulationFileMessage::Swap(RegulationFileMessage* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RegulationFileMessage::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RegulationFileMessage";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RegulationFileDiffData::RegulationFileDiffData()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RegulationFileDiffData)
}

void RegulationFileDiffData::InitAsDefaultInstance() {
}

RegulationFileDiffData::RegulationFileDiffData(const RegulationFileDiffData& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RegulationFileDiffData)
}

void RegulationFileDiffData::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RegulationFileDiffData::~RegulationFileDiffData() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RegulationFileDiffData)
  SharedDtor();
}

void RegulationFileDiffData::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RegulationFileDiffData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RegulationFileDiffData& RegulationFileDiffData::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RegulationFileDiffData* RegulationFileDiffData::default_instance_ = NULL;

RegulationFileDiffData* RegulationFileDiffData::New() const {
  return new RegulationFileDiffData;
}

void RegulationFileDiffData::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RegulationFileDiffData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RegulationFileDiffData)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RegulationFileDiffData)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RegulationFileDiffData)
  return false;
#undef DO_
}

void RegulationFileDiffData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RegulationFileDiffData)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RegulationFileDiffData)
}

int RegulationFileDiffData::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RegulationFileDiffData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RegulationFileDiffData*>(&from));
}

void RegulationFileDiffData::MergeFrom(const RegulationFileDiffData& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RegulationFileDiffData::CopyFrom(const RegulationFileDiffData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RegulationFileDiffData::IsInitialized() const {

  return true;
}

void RegulationFileDiffData::Swap(RegulationFileDiffData* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RegulationFileDiffData::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RegulationFileDiffData";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RegulationFileUpdateMessage::RegulationFileUpdateMessage()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RegulationFileUpdateMessage)
}

void RegulationFileUpdateMessage::InitAsDefaultInstance() {
}

RegulationFileUpdateMessage::RegulationFileUpdateMessage(const RegulationFileUpdateMessage& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RegulationFileUpdateMessage)
}

void RegulationFileUpdateMessage::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RegulationFileUpdateMessage::~RegulationFileUpdateMessage() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RegulationFileUpdateMessage)
  SharedDtor();
}

void RegulationFileUpdateMessage::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RegulationFileUpdateMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RegulationFileUpdateMessage& RegulationFileUpdateMessage::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RegulationFileUpdateMessage* RegulationFileUpdateMessage::default_instance_ = NULL;

RegulationFileUpdateMessage* RegulationFileUpdateMessage::New() const {
  return new RegulationFileUpdateMessage;
}

void RegulationFileUpdateMessage::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RegulationFileUpdateMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RegulationFileUpdateMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RegulationFileUpdateMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RegulationFileUpdateMessage)
  return false;
#undef DO_
}

void RegulationFileUpdateMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RegulationFileUpdateMessage)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RegulationFileUpdateMessage)
}

int RegulationFileUpdateMessage::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RegulationFileUpdateMessage::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RegulationFileUpdateMessage*>(&from));
}

void RegulationFileUpdateMessage::MergeFrom(const RegulationFileUpdateMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RegulationFileUpdateMessage::CopyFrom(const RegulationFileUpdateMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RegulationFileUpdateMessage::IsInitialized() const {

  return true;
}

void RegulationFileUpdateMessage::Swap(RegulationFileUpdateMessage* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RegulationFileUpdateMessage::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RegulationFileUpdateMessage";
}


// ===================================================================

#ifndef _MSC_VER
const int RegulationFileUpdatePushMessage::kPushMessageIdFieldNumber;
const int RegulationFileUpdatePushMessage::kUpdateMessageFieldNumber;
#endif  // !_MSC_VER

RegulationFileUpdatePushMessage::RegulationFileUpdatePushMessage()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RegulationFileUpdatePushMessage)
}

void RegulationFileUpdatePushMessage::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  update_message_ = const_cast< ::DS3_Frpg2RequestMessage::RegulationFileUpdateMessage*>(
      ::DS3_Frpg2RequestMessage::RegulationFileUpdateMessage::internal_default_instance());
#else
  update_message_ = const_cast< ::DS3_Frpg2RequestMessage::RegulationFileUpdateMessage*>(&::DS3_Frpg2RequestMessage::RegulationFileUpdateMessage::default_instance());
#endif
}

RegulationFileUpdatePushMessage::RegulationFileUpdatePushMessage(const RegulationFileUpdatePushMessage& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RegulationFileUpdatePushMessage)
}

void RegulationFileUpdatePushMessage::SharedCtor() {
  _cached_size_ = 0;
  push_message_id_ = 829;
  update_message_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RegulationFileUpdatePushMessage::~RegulationFileUpdatePushMessage() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RegulationFileUpdatePushMessage)
  SharedDtor();
}

void RegulationFileUpdatePushMessage::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete update_message_;
  }
}

void RegulationFileUpdatePushMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RegulationFileUpdatePushMessage& RegulationFileUpdatePushMessage::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RegulationFileUpdatePushMessage* RegulationFileUpdatePushMessage::default_instance_ = NULL;

RegulationFileUpdatePushMessage* RegulationFileUpdatePushMessage::New() const {
  return new RegulationFileUpdatePushMessage;
}

void RegulationFileUpdatePushMessage::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    push_message_id_ = 829;
    if (has_update_message()) {
      if (update_message_ != NULL) update_message_->::DS3_Frpg2RequestMessage::RegulationFileUpdateMessage::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RegulationFileUpdatePushMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RegulationFileUpdatePushMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::DS3_Frpg2RequestMessage::PushMessageId_IsValid(value)) {
            set_push_message_id(static_cast< ::DS3_Frpg2RequestMessage::PushMessageId >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_update_message;
        break;
      }

      // required .DS3_Frpg2RequestMessage.RegulationFileUpdateMessage update_message = 2;
      case 2: {
        if (tag == 18) {
         parse_update_message:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_update_message()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RegulationFileUpdatePushMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RegulationFileUpdatePushMessage)
  return false;
#undef DO_
}

void RegulationFileUpdatePushMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RegulationFileUpdatePushMessage)
  // required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
  if (has_push_message_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->push_message_id(), output);
  }

  // required .DS3_Frpg2RequestMessage.RegulationFileUpdateMessage update_message = 2;
  if (has_update_message()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->update_message(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RegulationFileUpdatePushMessage)
}

int RegulationFileUpdatePushMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
    if (has_push_message_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->push_message_id());
    }

    // required .DS3_Frpg2RequestMessage.RegulationFileUpdateMessage update_message = 2;
    if (has_update_message()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->update_message());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RegulationFileUpdatePushMessage::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RegulationFileUpdatePushMessage*>(&from));
}

void RegulationFileUpdatePushMessage::MergeFrom(const RegulationFileUpdatePushMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_push_message_id()) {
      set_push_message_id(from.push_message_id());
    }
    if (from.has_update_message()) {
      mutable_update_message()->::DS3_Frpg2RequestMessage::RegulationFileUpdateMessage::MergeFrom(from.update_message());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RegulationFileUpdatePushMessage::CopyFrom(const RegulationFileUpdatePushMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RegulationFileUpdatePushMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void RegulationFileUpdatePushMessage::Swap(RegulationFileUpdatePushMessage* other) {
  if (other != this) {
    std::swap(push_message_id_, other->push_message_id_);
    std::swap(update_message_, other->update_message_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RegulationFileUpdatePushMessage::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RegulationFileUpdatePushMessage";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RequestBenchmarkThroughput::RequestBenchmarkThroughput()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestBenchmarkThroughput)
}

void RequestBenchmarkThroughput::InitAsDefaultInstance() {
}

RequestBenchmarkThroughput::RequestBenchmarkThroughput(const RequestBenchmarkThroughput& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestBenchmarkThroughput)
}

void RequestBenchmarkThroughput::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestBenchmarkThroughput::~RequestBenchmarkThroughput() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestBenchmarkThroughput)
  SharedDtor();
}

void RequestBenchmarkThroughput::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestBenchmarkThroughput::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestBenchmarkThroughput& RequestBenchmarkThroughput::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestBenchmarkThroughput* RequestBenchmarkThroughput::default_instance_ = NULL;

RequestBenchmarkThroughput* RequestBenchmarkThroughput::New() const {
  return new RequestBenchmarkThroughput;
}

void RequestBenchmarkThroughput::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestBenchmarkThroughput::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestBenchmarkThroughput)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestBenchmarkThroughput)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestBenchmarkThroughput)
  return false;
#undef DO_
}

void RequestBenchmarkThroughput::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestBenchmarkThroughput)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestBenchmarkThroughput)
}

int RequestBenchmarkThroughput::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestBenchmarkThroughput::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestBenchmarkThroughput*>(&from));
}

void RequestBenchmarkThroughput::MergeFrom(const RequestBenchmarkThroughput& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestBenchmarkThroughput::CopyFrom(const RequestBenchmarkThroughput& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestBenchmarkThroughput::IsInitialized() const {

  return true;
}

void RequestBenchmarkThroughput::Swap(RequestBenchmarkThroughput* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestBenchmarkThroughput::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestBenchmarkThroughput";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RequestBenchmarkThroughputResponse::RequestBenchmarkThroughputResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestBenchmarkThroughputResponse)
}

void RequestBenchmarkThroughputResponse::InitAsDefaultInstance() {
}

RequestBenchmarkThroughputResponse::RequestBenchmarkThroughputResponse(const RequestBenchmarkThroughputResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestBenchmarkThroughputResponse)
}

void RequestBenchmarkThroughputResponse::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestBenchmarkThroughputResponse::~RequestBenchmarkThroughputResponse() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestBenchmarkThroughputResponse)
  SharedDtor();
}

void RequestBenchmarkThroughputResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestBenchmarkThroughputResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestBenchmarkThroughputResponse& RequestBenchmarkThroughputResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestBenchmarkThroughputResponse* RequestBenchmarkThroughputResponse::default_instance_ = NULL;

RequestBenchmarkThroughputResponse* RequestBenchmarkThroughputResponse::New() const {
  return new RequestBenchmarkThroughputResponse;
}

void RequestBenchmarkThroughputResponse::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestBenchmarkThroughputResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestBenchmarkThroughputResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestBenchmarkThroughputResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestBenchmarkThroughputResponse)
  return false;
#undef DO_
}

void RequestBenchmarkThroughputResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestBenchmarkThroughputResponse)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestBenchmarkThroughputResponse)
}

int RequestBenchmarkThroughputResponse::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestBenchmarkThroughputResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestBenchmarkThroughputResponse*>(&from));
}

void RequestBenchmarkThroughputResponse::MergeFrom(const RequestBenchmarkThroughputResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestBenchmarkThroughputResponse::CopyFrom(const RequestBenchmarkThroughputResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestBenchmarkThroughputResponse::IsInitialized() const {

  return true;
}

void RequestBenchmarkThroughputResponse::Swap(RequestBenchmarkThroughputResponse* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestBenchmarkThroughputResponse::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestBenchmarkThroughputResponse";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RequestGetLoginPlayerCharacter::RequestGetLoginPlayerCharacter()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestGetLoginPlayerCharacter)
}

void RequestGetLoginPlayerCharacter::InitAsDefaultInstance() {
}

RequestGetLoginPlayerCharacter::RequestGetLoginPlayerCharacter(const RequestGetLoginPlayerCharacter& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestGetLoginPlayerCharacter)
}

void RequestGetLoginPlayerCharacter::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestGetLoginPlayerCharacter::~RequestGetLoginPlayerCharacter() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestGetLoginPlayerCharacter)
  SharedDtor();
}

void RequestGetLoginPlayerCharacter::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestGetLoginPlayerCharacter::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestGetLoginPlayerCharacter& RequestGetLoginPlayerCharacter::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestGetLoginPlayerCharacter* RequestGetLoginPlayerCharacter::default_instance_ = NULL;

RequestGetLoginPlayerCharacter* RequestGetLoginPlayerCharacter::New() const {
  return new RequestGetLoginPlayerCharacter;
}

void RequestGetLoginPlayerCharacter::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestGetLoginPlayerCharacter::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestGetLoginPlayerCharacter)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestGetLoginPlayerCharacter)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestGetLoginPlayerCharacter)
  return false;
#undef DO_
}

void RequestGetLoginPlayerCharacter::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestGetLoginPlayerCharacter)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestGetLoginPlayerCharacter)
}

int RequestGetLoginPlayerCharacter::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestGetLoginPlayerCharacter::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestGetLoginPlayerCharacter*>(&from));
}

void RequestGetLoginPlayerCharacter::MergeFrom(const RequestGetLoginPlayerCharacter& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestGetLoginPlayerCharacter::CopyFrom(const RequestGetLoginPlayerCharacter& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestGetLoginPlayerCharacter::IsInitialized() const {

  return true;
}

void RequestGetLoginPlayerCharacter::Swap(RequestGetLoginPlayerCharacter* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestGetLoginPlayerCharacter::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestGetLoginPlayerCharacter";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RequestGetLoginPlayerCharacterResponse::RequestGetLoginPlayerCharacterResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestGetLoginPlayerCharacterResponse)
}

void RequestGetLoginPlayerCharacterResponse::InitAsDefaultInstance() {
}

RequestGetLoginPlayerCharacterResponse::RequestGetLoginPlayerCharacterResponse(const RequestGetLoginPlayerCharacterResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestGetLoginPlayerCharacterResponse)
}

void RequestGetLoginPlayerCharacterResponse::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestGetLoginPlayerCharacterResponse::~RequestGetLoginPlayerCharacterResponse() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestGetLoginPlayerCharacterResponse)
  SharedDtor();
}

void RequestGetLoginPlayerCharacterResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestGetLoginPlayerCharacterResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestGetLoginPlayerCharacterResponse& RequestGetLoginPlayerCharacterResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestGetLoginPlayerCharacterResponse* RequestGetLoginPlayerCharacterResponse::default_instance_ = NULL;

RequestGetLoginPlayerCharacterResponse* RequestGetLoginPlayerCharacterResponse::New() const {
  return new RequestGetLoginPlayerCharacterResponse;
}

void RequestGetLoginPlayerCharacterResponse::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestGetLoginPlayerCharacterResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestGetLoginPlayerCharacterResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestGetLoginPlayerCharacterResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestGetLoginPlayerCharacterResponse)
  return false;
#undef DO_
}

void RequestGetLoginPlayerCharacterResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestGetLoginPlayerCharacterResponse)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestGetLoginPlayerCharacterResponse)
}

int RequestGetLoginPlayerCharacterResponse::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestGetLoginPlayerCharacterResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestGetLoginPlayerCharacterResponse*>(&from));
}

void RequestGetLoginPlayerCharacterResponse::MergeFrom(const RequestGetLoginPlayerCharacterResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestGetLoginPlayerCharacterResponse::CopyFrom(const RequestGetLoginPlayerCharacterResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestGetLoginPlayerCharacterResponse::IsInitialized() const {

  return true;
}

void RequestGetLoginPlayerCharacterResponse::Swap(RequestGetLoginPlayerCharacterResponse* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestGetLoginPlayerCharacterResponse::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestGetLoginPlayerCharacterResponse";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RequestGetPlayerCharacterList::RequestGetPlayerCharacterList()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestGetPlayerCharacterList)
}

void RequestGetPlayerCharacterList::InitAsDefaultInstance() {
}

RequestGetPlayerCharacterList::RequestGetPlayerCharacterList(const RequestGetPlayerCharacterList& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestGetPlayerCharacterList)
}

void RequestGetPlayerCharacterList::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestGetPlayerCharacterList::~RequestGetPlayerCharacterList() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestGetPlayerCharacterList)
  SharedDtor();
}

void RequestGetPlayerCharacterList::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestGetPlayerCharacterList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestGetPlayerCharacterList& RequestGetPlayerCharacterList::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestGetPlayerCharacterList* RequestGetPlayerCharacterList::default_instance_ = NULL;

RequestGetPlayerCharacterList* RequestGetPlayerCharacterList::New() const {
  return new RequestGetPlayerCharacterList;
}

void RequestGetPlayerCharacterList::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestGetPlayerCharacterList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestGetPlayerCharacterList)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestGetPlayerCharacterList)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestGetPlayerCharacterList)
  return false;
#undef DO_
}

void RequestGetPlayerCharacterList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestGetPlayerCharacterList)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestGetPlayerCharacterList)
}

int RequestGetPlayerCharacterList::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestGetPlayerCharacterList::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestGetPlayerCharacterList*>(&from));
}

void RequestGetPlayerCharacterList::MergeFrom(const RequestGetPlayerCharacterList& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestGetPlayerCharacterList::CopyFrom(const RequestGetPlayerCharacterList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestGetPlayerCharacterList::IsInitialized() const {

  return true;
}

void RequestGetPlayerCharacterList::Swap(RequestGetPlayerCharacterList* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestGetPlayerCharacterList::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestGetPlayerCharacterList";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RequestGetPlayerCharacterListResponse::RequestGetPlayerCharacterListResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestGetPlayerCharacterListResponse)
}

void RequestGetPlayerCharacterListResponse::InitAsDefaultInstance() {
}

RequestGetPlayerCharacterListResponse::RequestGetPlayerCharacterListResponse(const RequestGetPlayerCharacterListResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestGetPlayerCharacterListResponse)
}

void RequestGetPlayerCharacterListResponse::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestGetPlayerCharacterListResponse::~RequestGetPlayerCharacterListResponse() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestGetPlayerCharacterListResponse)
  SharedDtor();
}

void RequestGetPlayerCharacterListResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestGetPlayerCharacterListResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestGetPlayerCharacterListResponse& RequestGetPlayerCharacterListResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestGetPlayerCharacterListResponse* RequestGetPlayerCharacterListResponse::default_instance_ = NULL;

RequestGetPlayerCharacterListResponse* RequestGetPlayerCharacterListResponse::New() const {
  return new RequestGetPlayerCharacterListResponse;
}

void RequestGetPlayerCharacterListResponse::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestGetPlayerCharacterListResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestGetPlayerCharacterListResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestGetPlayerCharacterListResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestGetPlayerCharacterListResponse)
  return false;
#undef DO_
}

void RequestGetPlayerCharacterListResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestGetPlayerCharacterListResponse)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestGetPlayerCharacterListResponse)
}

int RequestGetPlayerCharacterListResponse::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestGetPlayerCharacterListResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestGetPlayerCharacterListResponse*>(&from));
}

void RequestGetPlayerCharacterListResponse::MergeFrom(const RequestGetPlayerCharacterListResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestGetPlayerCharacterListResponse::CopyFrom(const RequestGetPlayerCharacterListResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestGetPlayerCharacterListResponse::IsInitialized() const {

  return true;
}

void RequestGetPlayerCharacterListResponse::Swap(RequestGetPlayerCharacterListResponse* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestGetPlayerCharacterListResponse::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestGetPlayerCharacterListResponse";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RequestMeasureUploadBandwidth::RequestMeasureUploadBandwidth()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestMeasureUploadBandwidth)
}

void RequestMeasureUploadBandwidth::InitAsDefaultInstance() {
}

RequestMeasureUploadBandwidth::RequestMeasureUploadBandwidth(const RequestMeasureUploadBandwidth& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestMeasureUploadBandwidth)
}

void RequestMeasureUploadBandwidth::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestMeasureUploadBandwidth::~RequestMeasureUploadBandwidth() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestMeasureUploadBandwidth)
  SharedDtor();
}

void RequestMeasureUploadBandwidth::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestMeasureUploadBandwidth::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestMeasureUploadBandwidth& RequestMeasureUploadBandwidth::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestMeasureUploadBandwidth* RequestMeasureUploadBandwidth::default_instance_ = NULL;

RequestMeasureUploadBandwidth* RequestMeasureUploadBandwidth::New() const {
  return new RequestMeasureUploadBandwidth;
}

void RequestMeasureUploadBandwidth::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestMeasureUploadBandwidth::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestMeasureUploadBandwidth)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestMeasureUploadBandwidth)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestMeasureUploadBandwidth)
  return false;
#undef DO_
}

void RequestMeasureUploadBandwidth::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestMeasureUploadBandwidth)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestMeasureUploadBandwidth)
}

int RequestMeasureUploadBandwidth::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestMeasureUploadBandwidth::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestMeasureUploadBandwidth*>(&from));
}

void RequestMeasureUploadBandwidth::MergeFrom(const RequestMeasureUploadBandwidth& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestMeasureUploadBandwidth::CopyFrom(const RequestMeasureUploadBandwidth& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestMeasureUploadBandwidth::IsInitialized() const {

  return true;
}

void RequestMeasureUploadBandwidth::Swap(RequestMeasureUploadBandwidth* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestMeasureUploadBandwidth::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestMeasureUploadBandwidth";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RequestMeasureUploadBandwidthResponse::RequestMeasureUploadBandwidthResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestMeasureUploadBandwidthResponse)
}

void RequestMeasureUploadBandwidthResponse::InitAsDefaultInstance() {
}

RequestMeasureUploadBandwidthResponse::RequestMeasureUploadBandwidthResponse(const RequestMeasureUploadBandwidthResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestMeasureUploadBandwidthResponse)
}

void RequestMeasureUploadBandwidthResponse::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestMeasureUploadBandwidthResponse::~RequestMeasureUploadBandwidthResponse() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestMeasureUploadBandwidthResponse)
  SharedDtor();
}

void RequestMeasureUploadBandwidthResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestMeasureUploadBandwidthResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestMeasureUploadBandwidthResponse& RequestMeasureUploadBandwidthResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestMeasureUploadBandwidthResponse* RequestMeasureUploadBandwidthResponse::default_instance_ = NULL;

RequestMeasureUploadBandwidthResponse* RequestMeasureUploadBandwidthResponse::New() const {
  return new RequestMeasureUploadBandwidthResponse;
}

void RequestMeasureUploadBandwidthResponse::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestMeasureUploadBandwidthResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestMeasureUploadBandwidthResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestMeasureUploadBandwidthResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestMeasureUploadBandwidthResponse)
  return false;
#undef DO_
}

void RequestMeasureUploadBandwidthResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestMeasureUploadBandwidthResponse)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestMeasureUploadBandwidthResponse)
}

int RequestMeasureUploadBandwidthResponse::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestMeasureUploadBandwidthResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestMeasureUploadBandwidthResponse*>(&from));
}

void RequestMeasureUploadBandwidthResponse::MergeFrom(const RequestMeasureUploadBandwidthResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestMeasureUploadBandwidthResponse::CopyFrom(const RequestMeasureUploadBandwidthResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestMeasureUploadBandwidthResponse::IsInitialized() const {

  return true;
}

void RequestMeasureUploadBandwidthResponse::Swap(RequestMeasureUploadBandwidthResponse* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestMeasureUploadBandwidthResponse::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestMeasureUploadBandwidthResponse";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RequestMeasureDownloadBandwidth::RequestMeasureDownloadBandwidth()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestMeasureDownloadBandwidth)
}

void RequestMeasureDownloadBandwidth::InitAsDefaultInstance() {
}

RequestMeasureDownloadBandwidth::RequestMeasureDownloadBandwidth(const RequestMeasureDownloadBandwidth& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestMeasureDownloadBandwidth)
}

void RequestMeasureDownloadBandwidth::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestMeasureDownloadBandwidth::~RequestMeasureDownloadBandwidth() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestMeasureDownloadBandwidth)
  SharedDtor();
}

void RequestMeasureDownloadBandwidth::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestMeasureDownloadBandwidth::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestMeasureDownloadBandwidth& RequestMeasureDownloadBandwidth::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestMeasureDownloadBandwidth* RequestMeasureDownloadBandwidth::default_instance_ = NULL;

RequestMeasureDownloadBandwidth* RequestMeasureDownloadBandwidth::New() const {
  return new RequestMeasureDownloadBandwidth;
}

void RequestMeasureDownloadBandwidth::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestMeasureDownloadBandwidth::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestMeasureDownloadBandwidth)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestMeasureDownloadBandwidth)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestMeasureDownloadBandwidth)
  return false;
#undef DO_
}

void RequestMeasureDownloadBandwidth::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestMeasureDownloadBandwidth)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestMeasureDownloadBandwidth)
}

int RequestMeasureDownloadBandwidth::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestMeasureDownloadBandwidth::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestMeasureDownloadBandwidth*>(&from));
}

void RequestMeasureDownloadBandwidth::MergeFrom(const RequestMeasureDownloadBandwidth& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestMeasureDownloadBandwidth::CopyFrom(const RequestMeasureDownloadBandwidth& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestMeasureDownloadBandwidth::IsInitialized() const {

  return true;
}

void RequestMeasureDownloadBandwidth::Swap(RequestMeasureDownloadBandwidth* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestMeasureDownloadBandwidth::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestMeasureDownloadBandwidth";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RequestMeasureDownloadBandwidthResponse::RequestMeasureDownloadBandwidthResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestMeasureDownloadBandwidthResponse)
}

void RequestMeasureDownloadBandwidthResponse::InitAsDefaultInstance() {
}

RequestMeasureDownloadBandwidthResponse::RequestMeasureDownloadBandwidthResponse(const RequestMeasureDownloadBandwidthResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestMeasureDownloadBandwidthResponse)
}

void RequestMeasureDownloadBandwidthResponse::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestMeasureDownloadBandwidthResponse::~RequestMeasureDownloadBandwidthResponse() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestMeasureDownloadBandwidthResponse)
  SharedDtor();
}

void RequestMeasureDownloadBandwidthResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestMeasureDownloadBandwidthResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestMeasureDownloadBandwidthResponse& RequestMeasureDownloadBandwidthResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestMeasureDownloadBandwidthResponse* RequestMeasureDownloadBandwidthResponse::default_instance_ = NULL;

RequestMeasureDownloadBandwidthResponse* RequestMeasureDownloadBandwidthResponse::New() const {
  return new RequestMeasureDownloadBandwidthResponse;
}

void RequestMeasureDownloadBandwidthResponse::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestMeasureDownloadBandwidthResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestMeasureDownloadBandwidthResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestMeasureDownloadBandwidthResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestMeasureDownloadBandwidthResponse)
  return false;
#undef DO_
}

void RequestMeasureDownloadBandwidthResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestMeasureDownloadBandwidthResponse)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestMeasureDownloadBandwidthResponse)
}

int RequestMeasureDownloadBandwidthResponse::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestMeasureDownloadBandwidthResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestMeasureDownloadBandwidthResponse*>(&from));
}

void RequestMeasureDownloadBandwidthResponse::MergeFrom(const RequestMeasureDownloadBandwidthResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestMeasureDownloadBandwidthResponse::CopyFrom(const RequestMeasureDownloadBandwidthResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestMeasureDownloadBandwidthResponse::IsInitialized() const {

  return true;
}

void RequestMeasureDownloadBandwidthResponse::Swap(RequestMeasureDownloadBandwidthResponse* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestMeasureDownloadBandwidthResponse::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestMeasureDownloadBandwidthResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestSendMessageToPlayers::kPlayerIdsFieldNumber;
const int RequestSendMessageToPlayers::kMessageFieldNumber;
#endif  // !_MSC_VER

RequestSendMessageToPlayers::RequestSendMessageToPlayers()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestSendMessageToPlayers)
}

void RequestSendMessageToPlayers::InitAsDefaultInstance() {
}

RequestSendMessageToPlayers::RequestSendMessageToPlayers(const RequestSendMessageToPlayers& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestSendMessageToPlayers)
}

void RequestSendMessageToPlayers::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestSendMessageToPlayers::~RequestSendMessageToPlayers() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestSendMessageToPlayers)
  SharedDtor();
}

void RequestSendMessageToPlayers::SharedDtor() {
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete message_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestSendMessageToPlayers::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestSendMessageToPlayers& RequestSendMessageToPlayers::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestSendMessageToPlayers* RequestSendMessageToPlayers::default_instance_ = NULL;

RequestSendMessageToPlayers* RequestSendMessageToPlayers::New() const {
  return new RequestSendMessageToPlayers;
}

void RequestSendMessageToPlayers::Clear() {
  if (has_message()) {
    if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
      message_->clear();
    }
  }
  player_ids_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestSendMessageToPlayers::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestSendMessageToPlayers)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 player_ids = 1;
      case 1: {
        if (tag == 8) {
         parse_player_ids:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 8, input, this->mutable_player_ids())));
        } else if (tag == 10) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_player_ids())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(8)) goto parse_player_ids;
        if (input->ExpectTag(18)) goto parse_message;
        break;
      }

      // required bytes message = 2;
      case 2: {
        if (tag == 18) {
         parse_message:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_message()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestSendMessageToPlayers)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestSendMessageToPlayers)
  return false;
#undef DO_
}

void RequestSendMessageToPlayers::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestSendMessageToPlayers)
  // repeated uint32 player_ids = 1;
  for (int i = 0; i < this->player_ids_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      1, this->player_ids(i), output);
  }

  // required bytes message = 2;
  if (has_message()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->message(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestSendMessageToPlayers)
}

int RequestSendMessageToPlayers::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // required bytes message = 2;
    if (has_message()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->message());
    }

  }
  // repeated uint32 player_ids = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->player_ids_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->player_ids(i));
    }
    total_size += 1 * this->player_ids_size() + data_size;
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestSendMessageToPlayers::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestSendMessageToPlayers*>(&from));
}

void RequestSendMessageToPlayers::MergeFrom(const RequestSendMessageToPlayers& from) {
  GOOGLE_CHECK_NE(&from, this);
  player_ids_.MergeFrom(from.player_ids_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_message()) {
      set_message(from.message());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestSendMessageToPlayers::CopyFrom(const RequestSendMessageToPlayers& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestSendMessageToPlayers::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;

  return true;
}

void RequestSendMessageToPlayers::Swap(RequestSendMessageToPlayers* other) {
  if (other != this) {
    player_ids_.Swap(&other->player_ids_);
    std::swap(message_, other->message_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestSendMessageToPlayers::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestSendMessageToPlayers";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RequestSendMessageToPlayersResponse::RequestSendMessageToPlayersResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestSendMessageToPlayersResponse)
}

void RequestSendMessageToPlayersResponse::InitAsDefaultInstance() {
}

RequestSendMessageToPlayersResponse::RequestSendMessageToPlayersResponse(const RequestSendMessageToPlayersResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestSendMessageToPlayersResponse)
}

void RequestSendMessageToPlayersResponse::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestSendMessageToPlayersResponse::~RequestSendMessageToPlayersResponse() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestSendMessageToPlayersResponse)
  SharedDtor();
}

void RequestSendMessageToPlayersResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestSendMessageToPlayersResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestSendMessageToPlayersResponse& RequestSendMessageToPlayersResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestSendMessageToPlayersResponse* RequestSendMessageToPlayersResponse::default_instance_ = NULL;

RequestSendMessageToPlayersResponse* RequestSendMessageToPlayersResponse::New() const {
  return new RequestSendMessageToPlayersResponse;
}

void RequestSendMessageToPlayersResponse::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestSendMessageToPlayersResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestSendMessageToPlayersResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestSendMessageToPlayersResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestSendMessageToPlayersResponse)
  return false;
#undef DO_
}

void RequestSendMessageToPlayersResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestSendMessageToPlayersResponse)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestSendMessageToPlayersResponse)
}

int RequestSendMessageToPlayersResponse::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestSendMessageToPlayersResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestSendMessageToPlayersResponse*>(&from));
}

void RequestSendMessageToPlayersResponse::MergeFrom(const RequestSendMessageToPlayersResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestSendMessageToPlayersResponse::CopyFrom(const RequestSendMessageToPlayersResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestSendMessageToPlayersResponse::IsInitialized() const {

  return true;
}

void RequestSendMessageToPlayersResponse::Swap(RequestSendMessageToPlayersResponse* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestSendMessageToPlayersResponse::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestSendMessageToPlayersResponse";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RequestSendMessageToSelectLanguagePlayers::RequestSendMessageToSelectLanguagePlayers()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestSendMessageToSelectLanguagePlayers)
}

void RequestSendMessageToSelectLanguagePlayers::InitAsDefaultInstance() {
}

RequestSendMessageToSelectLanguagePlayers::RequestSendMessageToSelectLanguagePlayers(const RequestSendMessageToSelectLanguagePlayers& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestSendMessageToSelectLanguagePlayers)
}

void RequestSendMessageToSelectLanguagePlayers::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestSendMessageToSelectLanguagePlayers::~RequestSendMessageToSelectLanguagePlayers() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestSendMessageToSelectLanguagePlayers)
  SharedDtor();
}

void RequestSendMessageToSelectLanguagePlayers::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestSendMessageToSelectLanguagePlayers::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestSendMessageToSelectLanguagePlayers& RequestSendMessageToSelectLanguagePlayers::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestSendMessageToSelectLanguagePlayers* RequestSendMessageToSelectLanguagePlayers::default_instance_ = NULL;

RequestSendMessageToSelectLanguagePlayers* RequestSendMessageToSelectLanguagePlayers::New() const {
  return new RequestSendMessageToSelectLanguagePlayers;
}

void RequestSendMessageToSelectLanguagePlayers::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestSendMessageToSelectLanguagePlayers::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestSendMessageToSelectLanguagePlayers)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestSendMessageToSelectLanguagePlayers)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestSendMessageToSelectLanguagePlayers)
  return false;
#undef DO_
}

void RequestSendMessageToSelectLanguagePlayers::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestSendMessageToSelectLanguagePlayers)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestSendMessageToSelectLanguagePlayers)
}

int RequestSendMessageToSelectLanguagePlayers::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestSendMessageToSelectLanguagePlayers::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestSendMessageToSelectLanguagePlayers*>(&from));
}

void RequestSendMessageToSelectLanguagePlayers::MergeFrom(const RequestSendMessageToSelectLanguagePlayers& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestSendMessageToSelectLanguagePlayers::CopyFrom(const RequestSendMessageToSelectLanguagePlayers& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestSendMessageToSelectLanguagePlayers::IsInitialized() const {

  return true;
}

void RequestSendMessageToSelectLanguagePlayers::Swap(RequestSendMessageToSelectLanguagePlayers* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestSendMessageToSelectLanguagePlayers::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestSendMessageToSelectLanguagePlayers";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RequestSendMessageToSelectLanguagePlayersResponse::RequestSendMessageToSelectLanguagePlayersResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestSendMessageToSelectLanguagePlayersResponse)
}

void RequestSendMessageToSelectLanguagePlayersResponse::InitAsDefaultInstance() {
}

RequestSendMessageToSelectLanguagePlayersResponse::RequestSendMessageToSelectLanguagePlayersResponse(const RequestSendMessageToSelectLanguagePlayersResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestSendMessageToSelectLanguagePlayersResponse)
}

void RequestSendMessageToSelectLanguagePlayersResponse::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestSendMessageToSelectLanguagePlayersResponse::~RequestSendMessageToSelectLanguagePlayersResponse() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestSendMessageToSelectLanguagePlayersResponse)
  SharedDtor();
}

void RequestSendMessageToSelectLanguagePlayersResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestSendMessageToSelectLanguagePlayersResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestSendMessageToSelectLanguagePlayersResponse& RequestSendMessageToSelectLanguagePlayersResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestSendMessageToSelectLanguagePlayersResponse* RequestSendMessageToSelectLanguagePlayersResponse::default_instance_ = NULL;

RequestSendMessageToSelectLanguagePlayersResponse* RequestSendMessageToSelectLanguagePlayersResponse::New() const {
  return new RequestSendMessageToSelectLanguagePlayersResponse;
}

void RequestSendMessageToSelectLanguagePlayersResponse::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestSendMessageToSelectLanguagePlayersResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestSendMessageToSelectLanguagePlayersResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestSendMessageToSelectLanguagePlayersResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestSendMessageToSelectLanguagePlayersResponse)
  return false;
#undef DO_
}

void RequestSendMessageToSelectLanguagePlayersResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestSendMessageToSelectLanguagePlayersResponse)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestSendMessageToSelectLanguagePlayersResponse)
}

int RequestSendMessageToSelectLanguagePlayersResponse::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestSendMessageToSelectLanguagePlayersResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestSendMessageToSelectLanguagePlayersResponse*>(&from));
}

void RequestSendMessageToSelectLanguagePlayersResponse::MergeFrom(const RequestSendMessageToSelectLanguagePlayersResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestSendMessageToSelectLanguagePlayersResponse::CopyFrom(const RequestSendMessageToSelectLanguagePlayersResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestSendMessageToSelectLanguagePlayersResponse::IsInitialized() const {

  return true;
}

void RequestSendMessageToSelectLanguagePlayersResponse::Swap(RequestSendMessageToSelectLanguagePlayersResponse* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestSendMessageToSelectLanguagePlayersResponse::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestSendMessageToSelectLanguagePlayersResponse";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RequestSendMessageToAllPlayers::RequestSendMessageToAllPlayers()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestSendMessageToAllPlayers)
}

void RequestSendMessageToAllPlayers::InitAsDefaultInstance() {
}

RequestSendMessageToAllPlayers::RequestSendMessageToAllPlayers(const RequestSendMessageToAllPlayers& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestSendMessageToAllPlayers)
}

void RequestSendMessageToAllPlayers::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestSendMessageToAllPlayers::~RequestSendMessageToAllPlayers() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestSendMessageToAllPlayers)
  SharedDtor();
}

void RequestSendMessageToAllPlayers::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestSendMessageToAllPlayers::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestSendMessageToAllPlayers& RequestSendMessageToAllPlayers::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestSendMessageToAllPlayers* RequestSendMessageToAllPlayers::default_instance_ = NULL;

RequestSendMessageToAllPlayers* RequestSendMessageToAllPlayers::New() const {
  return new RequestSendMessageToAllPlayers;
}

void RequestSendMessageToAllPlayers::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestSendMessageToAllPlayers::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestSendMessageToAllPlayers)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestSendMessageToAllPlayers)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestSendMessageToAllPlayers)
  return false;
#undef DO_
}

void RequestSendMessageToAllPlayers::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestSendMessageToAllPlayers)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestSendMessageToAllPlayers)
}

int RequestSendMessageToAllPlayers::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestSendMessageToAllPlayers::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestSendMessageToAllPlayers*>(&from));
}

void RequestSendMessageToAllPlayers::MergeFrom(const RequestSendMessageToAllPlayers& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestSendMessageToAllPlayers::CopyFrom(const RequestSendMessageToAllPlayers& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestSendMessageToAllPlayers::IsInitialized() const {

  return true;
}

void RequestSendMessageToAllPlayers::Swap(RequestSendMessageToAllPlayers* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestSendMessageToAllPlayers::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestSendMessageToAllPlayers";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RequestSendMessageToAllPlayersResponse::RequestSendMessageToAllPlayersResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestSendMessageToAllPlayersResponse)
}

void RequestSendMessageToAllPlayersResponse::InitAsDefaultInstance() {
}

RequestSendMessageToAllPlayersResponse::RequestSendMessageToAllPlayersResponse(const RequestSendMessageToAllPlayersResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestSendMessageToAllPlayersResponse)
}

void RequestSendMessageToAllPlayersResponse::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestSendMessageToAllPlayersResponse::~RequestSendMessageToAllPlayersResponse() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestSendMessageToAllPlayersResponse)
  SharedDtor();
}

void RequestSendMessageToAllPlayersResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestSendMessageToAllPlayersResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestSendMessageToAllPlayersResponse& RequestSendMessageToAllPlayersResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestSendMessageToAllPlayersResponse* RequestSendMessageToAllPlayersResponse::default_instance_ = NULL;

RequestSendMessageToAllPlayersResponse* RequestSendMessageToAllPlayersResponse::New() const {
  return new RequestSendMessageToAllPlayersResponse;
}

void RequestSendMessageToAllPlayersResponse::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestSendMessageToAllPlayersResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestSendMessageToAllPlayersResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestSendMessageToAllPlayersResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestSendMessageToAllPlayersResponse)
  return false;
#undef DO_
}

void RequestSendMessageToAllPlayersResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestSendMessageToAllPlayersResponse)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestSendMessageToAllPlayersResponse)
}

int RequestSendMessageToAllPlayersResponse::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestSendMessageToAllPlayersResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestSendMessageToAllPlayersResponse*>(&from));
}

void RequestSendMessageToAllPlayersResponse::MergeFrom(const RequestSendMessageToAllPlayersResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestSendMessageToAllPlayersResponse::CopyFrom(const RequestSendMessageToAllPlayersResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestSendMessageToAllPlayersResponse::IsInitialized() const {

  return true;
}

void RequestSendMessageToAllPlayersResponse::Swap(RequestSendMessageToAllPlayersResponse* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestSendMessageToAllPlayersResponse::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestSendMessageToAllPlayersResponse";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RequestSendPlayerList::RequestSendPlayerList()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestSendPlayerList)
}

void RequestSendPlayerList::InitAsDefaultInstance() {
}

RequestSendPlayerList::RequestSendPlayerList(const RequestSendPlayerList& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestSendPlayerList)
}

void RequestSendPlayerList::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestSendPlayerList::~RequestSendPlayerList() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestSendPlayerList)
  SharedDtor();
}

void RequestSendPlayerList::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestSendPlayerList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestSendPlayerList& RequestSendPlayerList::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestSendPlayerList* RequestSendPlayerList::default_instance_ = NULL;

RequestSendPlayerList* RequestSendPlayerList::New() const {
  return new RequestSendPlayerList;
}

void RequestSendPlayerList::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestSendPlayerList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestSendPlayerList)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestSendPlayerList)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestSendPlayerList)
  return false;
#undef DO_
}

void RequestSendPlayerList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestSendPlayerList)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestSendPlayerList)
}

int RequestSendPlayerList::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestSendPlayerList::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestSendPlayerList*>(&from));
}

void RequestSendPlayerList::MergeFrom(const RequestSendPlayerList& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestSendPlayerList::CopyFrom(const RequestSendPlayerList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestSendPlayerList::IsInitialized() const {

  return true;
}

void RequestSendPlayerList::Swap(RequestSendPlayerList* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestSendPlayerList::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestSendPlayerList";
}


// ===================================================================

#ifndef _MSC_VER
const int RankingData::kPlayerIdFieldNumber;
const int RankingData::kCharacterIdFieldNumber;
const int RankingData::kSerialRankFieldNumber;
const int RankingData::kRankFieldNumber;
const int RankingData::kScoreFieldNumber;
const int RankingData::kDataFieldNumber;
#endif  // !_MSC_VER

RankingData::RankingData()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RankingData)
}

void RankingData::InitAsDefaultInstance() {
}

RankingData::RankingData(const RankingData& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RankingData)
}

void RankingData::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  player_id_ = 0u;
  character_id_ = 0u;
  serial_rank_ = 0u;
  rank_ = 0u;
  score_ = 0u;
  data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RankingData::~RankingData() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RankingData)
  SharedDtor();
}

void RankingData::SharedDtor() {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RankingData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RankingData& RankingData::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RankingData* RankingData::default_instance_ = NULL;

RankingData* RankingData::New() const {
  return new RankingData;
}

void RankingData::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<RankingData*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 63) {
    ZR_(player_id_, rank_);
    score_ = 0u;
    if (has_data()) {
      if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        data_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RankingData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RankingData)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 player_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &player_id_)));
          set_has_player_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_character_id;
        break;
      }

      // required uint32 character_id = 2;
      case 2: {
        if (tag == 16) {
         parse_character_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &character_id_)));
          set_has_character_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_serial_rank;
        break;
      }

      // required uint32 serial_rank = 3;
      case 3: {
        if (tag == 24) {
         parse_serial_rank:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &serial_rank_)));
          set_has_serial_rank();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_rank;
        break;
      }

      // required uint32 rank = 4;
      case 4: {
        if (tag == 32) {
         parse_rank:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &rank_)));
          set_has_rank();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_score;
        break;
      }

      // required uint32 score = 5;
      case 5: {
        if (tag == 40) {
         parse_score:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &score_)));
          set_has_score();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_data;
        break;
      }

      // required bytes data = 6;
      case 6: {
        if (tag == 50) {
         parse_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RankingData)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RankingData)
  return false;
#undef DO_
}

void RankingData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RankingData)
  // required uint32 player_id = 1;
  if (has_player_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->player_id(), output);
  }

  // required uint32 character_id = 2;
  if (has_character_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->character_id(), output);
  }

  // required uint32 serial_rank = 3;
  if (has_serial_rank()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->serial_rank(), output);
  }

  // required uint32 rank = 4;
  if (has_rank()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->rank(), output);
  }

  // required uint32 score = 5;
  if (has_score()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->score(), output);
  }

  // required bytes data = 6;
  if (has_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      6, this->data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RankingData)
}

int RankingData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 player_id = 1;
    if (has_player_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->player_id());
    }

    // required uint32 character_id = 2;
    if (has_character_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->character_id());
    }

    // required uint32 serial_rank = 3;
    if (has_serial_rank()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->serial_rank());
    }

    // required uint32 rank = 4;
    if (has_rank()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->rank());
    }

    // required uint32 score = 5;
    if (has_score()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->score());
    }

    // required bytes data = 6;
    if (has_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->data());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RankingData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RankingData*>(&from));
}

void RankingData::MergeFrom(const RankingData& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_player_id()) {
      set_player_id(from.player_id());
    }
    if (from.has_character_id()) {
      set_character_id(from.character_id());
    }
    if (from.has_serial_rank()) {
      set_serial_rank(from.serial_rank());
    }
    if (from.has_rank()) {
      set_rank(from.rank());
    }
    if (from.has_score()) {
      set_score(from.score());
    }
    if (from.has_data()) {
      set_data(from.data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RankingData::CopyFrom(const RankingData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RankingData::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003f) != 0x0000003f) return false;

  return true;
}

void RankingData::Swap(RankingData* other) {
  if (other != this) {
    std::swap(player_id_, other->player_id_);
    std::swap(character_id_, other->character_id_);
    std::swap(serial_rank_, other->serial_rank_);
    std::swap(rank_, other->rank_);
    std::swap(score_, other->score_);
    std::swap(data_, other->data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RankingData::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RankingData";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RankingRotationID::RankingRotationID()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RankingRotationID)
}

void RankingRotationID::InitAsDefaultInstance() {
}

RankingRotationID::RankingRotationID(const RankingRotationID& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RankingRotationID)
}

void RankingRotationID::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RankingRotationID::~RankingRotationID() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RankingRotationID)
  SharedDtor();
}

void RankingRotationID::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RankingRotationID::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RankingRotationID& RankingRotationID::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RankingRotationID* RankingRotationID::default_instance_ = NULL;

RankingRotationID* RankingRotationID::New() const {
  return new RankingRotationID;
}

void RankingRotationID::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RankingRotationID::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RankingRotationID)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RankingRotationID)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RankingRotationID)
  return false;
#undef DO_
}

void RankingRotationID::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RankingRotationID)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RankingRotationID)
}

int RankingRotationID::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RankingRotationID::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RankingRotationID*>(&from));
}

void RankingRotationID::MergeFrom(const RankingRotationID& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RankingRotationID::CopyFrom(const RankingRotationID& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RankingRotationID::IsInitialized() const {

  return true;
}

void RankingRotationID::Swap(RankingRotationID* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RankingRotationID::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RankingRotationID";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RankingRecordCount::RankingRecordCount()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RankingRecordCount)
}

void RankingRecordCount::InitAsDefaultInstance() {
}

RankingRecordCount::RankingRecordCount(const RankingRecordCount& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RankingRecordCount)
}

void RankingRecordCount::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RankingRecordCount::~RankingRecordCount() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RankingRecordCount)
  SharedDtor();
}

void RankingRecordCount::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RankingRecordCount::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RankingRecordCount& RankingRecordCount::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RankingRecordCount* RankingRecordCount::default_instance_ = NULL;

RankingRecordCount* RankingRecordCount::New() const {
  return new RankingRecordCount;
}

void RankingRecordCount::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RankingRecordCount::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RankingRecordCount)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RankingRecordCount)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RankingRecordCount)
  return false;
#undef DO_
}

void RankingRecordCount::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RankingRecordCount)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RankingRecordCount)
}

int RankingRecordCount::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RankingRecordCount::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RankingRecordCount*>(&from));
}

void RankingRecordCount::MergeFrom(const RankingRecordCount& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RankingRecordCount::CopyFrom(const RankingRecordCount& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RankingRecordCount::IsInitialized() const {

  return true;
}

void RankingRecordCount::Swap(RankingRecordCount* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RankingRecordCount::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RankingRecordCount";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RankingDataPack::RankingDataPack()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RankingDataPack)
}

void RankingDataPack::InitAsDefaultInstance() {
}

RankingDataPack::RankingDataPack(const RankingDataPack& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RankingDataPack)
}

void RankingDataPack::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RankingDataPack::~RankingDataPack() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RankingDataPack)
  SharedDtor();
}

void RankingDataPack::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RankingDataPack::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RankingDataPack& RankingDataPack::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RankingDataPack* RankingDataPack::default_instance_ = NULL;

RankingDataPack* RankingDataPack::New() const {
  return new RankingDataPack;
}

void RankingDataPack::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RankingDataPack::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RankingDataPack)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RankingDataPack)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RankingDataPack)
  return false;
#undef DO_
}

void RankingDataPack::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RankingDataPack)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RankingDataPack)
}

int RankingDataPack::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RankingDataPack::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RankingDataPack*>(&from));
}

void RankingDataPack::MergeFrom(const RankingDataPack& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RankingDataPack::CopyFrom(const RankingDataPack& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RankingDataPack::IsInitialized() const {

  return true;
}

void RankingDataPack::Swap(RankingDataPack* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RankingDataPack::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RankingDataPack";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestRegisterRankingData::kBoardIdFieldNumber;
const int RequestRegisterRankingData::kCharacterIdFieldNumber;
const int RequestRegisterRankingData::kScoreFieldNumber;
const int RequestRegisterRankingData::kDataFieldNumber;
#endif  // !_MSC_VER

RequestRegisterRankingData::RequestRegisterRankingData()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestRegisterRankingData)
}

void RequestRegisterRankingData::InitAsDefaultInstance() {
}

RequestRegisterRankingData::RequestRegisterRankingData(const RequestRegisterRankingData& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestRegisterRankingData)
}

void RequestRegisterRankingData::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  board_id_ = 0u;
  character_id_ = 0u;
  score_ = 0u;
  data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestRegisterRankingData::~RequestRegisterRankingData() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestRegisterRankingData)
  SharedDtor();
}

void RequestRegisterRankingData::SharedDtor() {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestRegisterRankingData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestRegisterRankingData& RequestRegisterRankingData::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestRegisterRankingData* RequestRegisterRankingData::default_instance_ = NULL;

RequestRegisterRankingData* RequestRegisterRankingData::New() const {
  return new RequestRegisterRankingData;
}

void RequestRegisterRankingData::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<RequestRegisterRankingData*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 15) {
    ZR_(board_id_, character_id_);
    score_ = 0u;
    if (has_data()) {
      if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        data_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestRegisterRankingData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestRegisterRankingData)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 board_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &board_id_)));
          set_has_board_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_character_id;
        break;
      }

      // required uint32 character_id = 2;
      case 2: {
        if (tag == 16) {
         parse_character_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &character_id_)));
          set_has_character_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_score;
        break;
      }

      // required uint32 score = 3;
      case 3: {
        if (tag == 24) {
         parse_score:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &score_)));
          set_has_score();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_data;
        break;
      }

      // required bytes data = 4;
      case 4: {
        if (tag == 34) {
         parse_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestRegisterRankingData)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestRegisterRankingData)
  return false;
#undef DO_
}

void RequestRegisterRankingData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestRegisterRankingData)
  // required uint32 board_id = 1;
  if (has_board_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->board_id(), output);
  }

  // required uint32 character_id = 2;
  if (has_character_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->character_id(), output);
  }

  // required uint32 score = 3;
  if (has_score()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->score(), output);
  }

  // required bytes data = 4;
  if (has_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      4, this->data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestRegisterRankingData)
}

int RequestRegisterRankingData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 board_id = 1;
    if (has_board_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->board_id());
    }

    // required uint32 character_id = 2;
    if (has_character_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->character_id());
    }

    // required uint32 score = 3;
    if (has_score()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->score());
    }

    // required bytes data = 4;
    if (has_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->data());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestRegisterRankingData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestRegisterRankingData*>(&from));
}

void RequestRegisterRankingData::MergeFrom(const RequestRegisterRankingData& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_board_id()) {
      set_board_id(from.board_id());
    }
    if (from.has_character_id()) {
      set_character_id(from.character_id());
    }
    if (from.has_score()) {
      set_score(from.score());
    }
    if (from.has_data()) {
      set_data(from.data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestRegisterRankingData::CopyFrom(const RequestRegisterRankingData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestRegisterRankingData::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void RequestRegisterRankingData::Swap(RequestRegisterRankingData* other) {
  if (other != this) {
    std::swap(board_id_, other->board_id_);
    std::swap(character_id_, other->character_id_);
    std::swap(score_, other->score_);
    std::swap(data_, other->data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestRegisterRankingData::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestRegisterRankingData";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RequestRegisterRankingDataResponse::RequestRegisterRankingDataResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestRegisterRankingDataResponse)
}

void RequestRegisterRankingDataResponse::InitAsDefaultInstance() {
}

RequestRegisterRankingDataResponse::RequestRegisterRankingDataResponse(const RequestRegisterRankingDataResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestRegisterRankingDataResponse)
}

void RequestRegisterRankingDataResponse::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestRegisterRankingDataResponse::~RequestRegisterRankingDataResponse() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestRegisterRankingDataResponse)
  SharedDtor();
}

void RequestRegisterRankingDataResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestRegisterRankingDataResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestRegisterRankingDataResponse& RequestRegisterRankingDataResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestRegisterRankingDataResponse* RequestRegisterRankingDataResponse::default_instance_ = NULL;

RequestRegisterRankingDataResponse* RequestRegisterRankingDataResponse::New() const {
  return new RequestRegisterRankingDataResponse;
}

void RequestRegisterRankingDataResponse::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestRegisterRankingDataResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestRegisterRankingDataResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestRegisterRankingDataResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestRegisterRankingDataResponse)
  return false;
#undef DO_
}

void RequestRegisterRankingDataResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestRegisterRankingDataResponse)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestRegisterRankingDataResponse)
}

int RequestRegisterRankingDataResponse::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestRegisterRankingDataResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestRegisterRankingDataResponse*>(&from));
}

void RequestRegisterRankingDataResponse::MergeFrom(const RequestRegisterRankingDataResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestRegisterRankingDataResponse::CopyFrom(const RequestRegisterRankingDataResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestRegisterRankingDataResponse::IsInitialized() const {

  return true;
}

void RequestRegisterRankingDataResponse::Swap(RequestRegisterRankingDataResponse* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestRegisterRankingDataResponse::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestRegisterRankingDataResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestGetRankingData::kBoardIdFieldNumber;
const int RequestGetRankingData::kOffsetFieldNumber;
const int RequestGetRankingData::kCountFieldNumber;
#endif  // !_MSC_VER

RequestGetRankingData::RequestGetRankingData()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestGetRankingData)
}

void RequestGetRankingData::InitAsDefaultInstance() {
}

RequestGetRankingData::RequestGetRankingData(const RequestGetRankingData& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestGetRankingData)
}

void RequestGetRankingData::SharedCtor() {
  _cached_size_ = 0;
  board_id_ = 0u;
  offset_ = 0u;
  count_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestGetRankingData::~RequestGetRankingData() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestGetRankingData)
  SharedDtor();
}

void RequestGetRankingData::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestGetRankingData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestGetRankingData& RequestGetRankingData::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestGetRankingData* RequestGetRankingData::default_instance_ = NULL;

RequestGetRankingData* RequestGetRankingData::New() const {
  return new RequestGetRankingData;
}

void RequestGetRankingData::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<RequestGetRankingData*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(board_id_, count_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestGetRankingData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestGetRankingData)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 board_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &board_id_)));
          set_has_board_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_offset;
        break;
      }

      // required uint32 offset = 2;
      case 2: {
        if (tag == 16) {
         parse_offset:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &offset_)));
          set_has_offset();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_count;
        break;
      }

      // required uint32 count = 3;
      case 3: {
        if (tag == 24) {
         parse_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &count_)));
          set_has_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestGetRankingData)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestGetRankingData)
  return false;
#undef DO_
}

void RequestGetRankingData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestGetRankingData)
  // required uint32 board_id = 1;
  if (has_board_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->board_id(), output);
  }

  // required uint32 offset = 2;
  if (has_offset()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->offset(), output);
  }

  // required uint32 count = 3;
  if (has_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->count(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestGetRankingData)
}

int RequestGetRankingData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 board_id = 1;
    if (has_board_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->board_id());
    }

    // required uint32 offset = 2;
    if (has_offset()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->offset());
    }

    // required uint32 count = 3;
    if (has_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->count());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestGetRankingData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestGetRankingData*>(&from));
}

void RequestGetRankingData::MergeFrom(const RequestGetRankingData& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_board_id()) {
      set_board_id(from.board_id());
    }
    if (from.has_offset()) {
      set_offset(from.offset());
    }
    if (from.has_count()) {
      set_count(from.count());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestGetRankingData::CopyFrom(const RequestGetRankingData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestGetRankingData::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void RequestGetRankingData::Swap(RequestGetRankingData* other) {
  if (other != this) {
    std::swap(board_id_, other->board_id_);
    std::swap(offset_, other->offset_);
    std::swap(count_, other->count_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestGetRankingData::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestGetRankingData";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestGetRankingDataResponse::kDataFieldNumber;
#endif  // !_MSC_VER

RequestGetRankingDataResponse::RequestGetRankingDataResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestGetRankingDataResponse)
}

void RequestGetRankingDataResponse::InitAsDefaultInstance() {
}

RequestGetRankingDataResponse::RequestGetRankingDataResponse(const RequestGetRankingDataResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestGetRankingDataResponse)
}

void RequestGetRankingDataResponse::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestGetRankingDataResponse::~RequestGetRankingDataResponse() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestGetRankingDataResponse)
  SharedDtor();
}

void RequestGetRankingDataResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestGetRankingDataResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestGetRankingDataResponse& RequestGetRankingDataResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestGetRankingDataResponse* RequestGetRankingDataResponse::default_instance_ = NULL;

RequestGetRankingDataResponse* RequestGetRankingDataResponse::New() const {
  return new RequestGetRankingDataResponse;
}

void RequestGetRankingDataResponse::Clear() {
  data_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestGetRankingDataResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestGetRankingDataResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .DS3_Frpg2RequestMessage.RankingData data = 1;
      case 1: {
        if (tag == 10) {
         parse_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_data;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestGetRankingDataResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestGetRankingDataResponse)
  return false;
#undef DO_
}

void RequestGetRankingDataResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestGetRankingDataResponse)
  // repeated .DS3_Frpg2RequestMessage.RankingData data = 1;
  for (int i = 0; i < this->data_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->data(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestGetRankingDataResponse)
}

int RequestGetRankingDataResponse::ByteSize() const {
  int total_size = 0;

  // repeated .DS3_Frpg2RequestMessage.RankingData data = 1;
  total_size += 1 * this->data_size();
  for (int i = 0; i < this->data_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->data(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestGetRankingDataResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestGetRankingDataResponse*>(&from));
}

void RequestGetRankingDataResponse::MergeFrom(const RequestGetRankingDataResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  data_.MergeFrom(from.data_);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestGetRankingDataResponse::CopyFrom(const RequestGetRankingDataResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestGetRankingDataResponse::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->data())) return false;
  return true;
}

void RequestGetRankingDataResponse::Swap(RequestGetRankingDataResponse* other) {
  if (other != this) {
    data_.Swap(&other->data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestGetRankingDataResponse::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestGetRankingDataResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestGetCharacterRankingData::kBoardIdFieldNumber;
const int RequestGetCharacterRankingData::kCharacterIdFieldNumber;
#endif  // !_MSC_VER

RequestGetCharacterRankingData::RequestGetCharacterRankingData()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestGetCharacterRankingData)
}

void RequestGetCharacterRankingData::InitAsDefaultInstance() {
}

RequestGetCharacterRankingData::RequestGetCharacterRankingData(const RequestGetCharacterRankingData& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestGetCharacterRankingData)
}

void RequestGetCharacterRankingData::SharedCtor() {
  _cached_size_ = 0;
  board_id_ = 0u;
  character_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestGetCharacterRankingData::~RequestGetCharacterRankingData() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestGetCharacterRankingData)
  SharedDtor();
}

void RequestGetCharacterRankingData::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestGetCharacterRankingData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestGetCharacterRankingData& RequestGetCharacterRankingData::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestGetCharacterRankingData* RequestGetCharacterRankingData::default_instance_ = NULL;

RequestGetCharacterRankingData* RequestGetCharacterRankingData::New() const {
  return new RequestGetCharacterRankingData;
}

void RequestGetCharacterRankingData::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<RequestGetCharacterRankingData*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(board_id_, character_id_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestGetCharacterRankingData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestGetCharacterRankingData)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 board_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &board_id_)));
          set_has_board_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_character_id;
        break;
      }

      // required uint32 character_id = 2;
      case 2: {
        if (tag == 16) {
         parse_character_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &character_id_)));
          set_has_character_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestGetCharacterRankingData)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestGetCharacterRankingData)
  return false;
#undef DO_
}

void RequestGetCharacterRankingData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestGetCharacterRankingData)
  // required uint32 board_id = 1;
  if (has_board_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->board_id(), output);
  }

  // required uint32 character_id = 2;
  if (has_character_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->character_id(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestGetCharacterRankingData)
}

int RequestGetCharacterRankingData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 board_id = 1;
    if (has_board_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->board_id());
    }

    // required uint32 character_id = 2;
    if (has_character_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->character_id());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestGetCharacterRankingData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestGetCharacterRankingData*>(&from));
}

void RequestGetCharacterRankingData::MergeFrom(const RequestGetCharacterRankingData& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_board_id()) {
      set_board_id(from.board_id());
    }
    if (from.has_character_id()) {
      set_character_id(from.character_id());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestGetCharacterRankingData::CopyFrom(const RequestGetCharacterRankingData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestGetCharacterRankingData::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void RequestGetCharacterRankingData::Swap(RequestGetCharacterRankingData* other) {
  if (other != this) {
    std::swap(board_id_, other->board_id_);
    std::swap(character_id_, other->character_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestGetCharacterRankingData::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestGetCharacterRankingData";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestGetCharacterRankingDataResponse::kDataFieldNumber;
#endif  // !_MSC_VER

RequestGetCharacterRankingDataResponse::RequestGetCharacterRankingDataResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestGetCharacterRankingDataResponse)
}

void RequestGetCharacterRankingDataResponse::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  data_ = const_cast< ::DS3_Frpg2RequestMessage::RankingData*>(
      ::DS3_Frpg2RequestMessage::RankingData::internal_default_instance());
#else
  data_ = const_cast< ::DS3_Frpg2RequestMessage::RankingData*>(&::DS3_Frpg2RequestMessage::RankingData::default_instance());
#endif
}

RequestGetCharacterRankingDataResponse::RequestGetCharacterRankingDataResponse(const RequestGetCharacterRankingDataResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestGetCharacterRankingDataResponse)
}

void RequestGetCharacterRankingDataResponse::SharedCtor() {
  _cached_size_ = 0;
  data_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestGetCharacterRankingDataResponse::~RequestGetCharacterRankingDataResponse() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestGetCharacterRankingDataResponse)
  SharedDtor();
}

void RequestGetCharacterRankingDataResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete data_;
  }
}

void RequestGetCharacterRankingDataResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestGetCharacterRankingDataResponse& RequestGetCharacterRankingDataResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestGetCharacterRankingDataResponse* RequestGetCharacterRankingDataResponse::default_instance_ = NULL;

RequestGetCharacterRankingDataResponse* RequestGetCharacterRankingDataResponse::New() const {
  return new RequestGetCharacterRankingDataResponse;
}

void RequestGetCharacterRankingDataResponse::Clear() {
  if (has_data()) {
    if (data_ != NULL) data_->::DS3_Frpg2RequestMessage::RankingData::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestGetCharacterRankingDataResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestGetCharacterRankingDataResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .DS3_Frpg2RequestMessage.RankingData data = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestGetCharacterRankingDataResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestGetCharacterRankingDataResponse)
  return false;
#undef DO_
}

void RequestGetCharacterRankingDataResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestGetCharacterRankingDataResponse)
  // optional .DS3_Frpg2RequestMessage.RankingData data = 1;
  if (has_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestGetCharacterRankingDataResponse)
}

int RequestGetCharacterRankingDataResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .DS3_Frpg2RequestMessage.RankingData data = 1;
    if (has_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->data());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestGetCharacterRankingDataResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestGetCharacterRankingDataResponse*>(&from));
}

void RequestGetCharacterRankingDataResponse::MergeFrom(const RequestGetCharacterRankingDataResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_data()) {
      mutable_data()->::DS3_Frpg2RequestMessage::RankingData::MergeFrom(from.data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestGetCharacterRankingDataResponse::CopyFrom(const RequestGetCharacterRankingDataResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestGetCharacterRankingDataResponse::IsInitialized() const {

  if (has_data()) {
    if (!this->data().IsInitialized()) return false;
  }
  return true;
}

void RequestGetCharacterRankingDataResponse::Swap(RequestGetCharacterRankingDataResponse* other) {
  if (other != this) {
    std::swap(data_, other->data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestGetCharacterRankingDataResponse::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestGetCharacterRankingDataResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestCountRankingData::kBoardIdFieldNumber;
#endif  // !_MSC_VER

RequestCountRankingData::RequestCountRankingData()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestCountRankingData)
}

void RequestCountRankingData::InitAsDefaultInstance() {
}

RequestCountRankingData::RequestCountRankingData(const RequestCountRankingData& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestCountRankingData)
}

void RequestCountRankingData::SharedCtor() {
  _cached_size_ = 0;
  board_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestCountRankingData::~RequestCountRankingData() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestCountRankingData)
  SharedDtor();
}

void RequestCountRankingData::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestCountRankingData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestCountRankingData& RequestCountRankingData::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestCountRankingData* RequestCountRankingData::default_instance_ = NULL;

RequestCountRankingData* RequestCountRankingData::New() const {
  return new RequestCountRankingData;
}

void RequestCountRankingData::Clear() {
  board_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestCountRankingData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestCountRankingData)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 board_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &board_id_)));
          set_has_board_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestCountRankingData)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestCountRankingData)
  return false;
#undef DO_
}

void RequestCountRankingData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestCountRankingData)
  // required uint32 board_id = 1;
  if (has_board_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->board_id(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestCountRankingData)
}

int RequestCountRankingData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 board_id = 1;
    if (has_board_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->board_id());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestCountRankingData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestCountRankingData*>(&from));
}

void RequestCountRankingData::MergeFrom(const RequestCountRankingData& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_board_id()) {
      set_board_id(from.board_id());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestCountRankingData::CopyFrom(const RequestCountRankingData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestCountRankingData::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void RequestCountRankingData::Swap(RequestCountRankingData* other) {
  if (other != this) {
    std::swap(board_id_, other->board_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestCountRankingData::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestCountRankingData";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestCountRankingDataResponse::kCountFieldNumber;
#endif  // !_MSC_VER

RequestCountRankingDataResponse::RequestCountRankingDataResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestCountRankingDataResponse)
}

void RequestCountRankingDataResponse::InitAsDefaultInstance() {
}

RequestCountRankingDataResponse::RequestCountRankingDataResponse(const RequestCountRankingDataResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestCountRankingDataResponse)
}

void RequestCountRankingDataResponse::SharedCtor() {
  _cached_size_ = 0;
  count_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestCountRankingDataResponse::~RequestCountRankingDataResponse() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestCountRankingDataResponse)
  SharedDtor();
}

void RequestCountRankingDataResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestCountRankingDataResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestCountRankingDataResponse& RequestCountRankingDataResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestCountRankingDataResponse* RequestCountRankingDataResponse::default_instance_ = NULL;

RequestCountRankingDataResponse* RequestCountRankingDataResponse::New() const {
  return new RequestCountRankingDataResponse;
}

void RequestCountRankingDataResponse::Clear() {
  count_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestCountRankingDataResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestCountRankingDataResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 count = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &count_)));
          set_has_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestCountRankingDataResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestCountRankingDataResponse)
  return false;
#undef DO_
}

void RequestCountRankingDataResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestCountRankingDataResponse)
  // required uint32 count = 1;
  if (has_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->count(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestCountRankingDataResponse)
}

int RequestCountRankingDataResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 count = 1;
    if (has_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->count());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestCountRankingDataResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestCountRankingDataResponse*>(&from));
}

void RequestCountRankingDataResponse::MergeFrom(const RequestCountRankingDataResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_count()) {
      set_count(from.count());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestCountRankingDataResponse::CopyFrom(const RequestCountRankingDataResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestCountRankingDataResponse::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void RequestCountRankingDataResponse::Swap(RequestCountRankingDataResponse* other) {
  if (other != this) {
    std::swap(count_, other->count_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestCountRankingDataResponse::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestCountRankingDataResponse";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RequestGetCurrentRank::RequestGetCurrentRank()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestGetCurrentRank)
}

void RequestGetCurrentRank::InitAsDefaultInstance() {
}

RequestGetCurrentRank::RequestGetCurrentRank(const RequestGetCurrentRank& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestGetCurrentRank)
}

void RequestGetCurrentRank::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestGetCurrentRank::~RequestGetCurrentRank() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestGetCurrentRank)
  SharedDtor();
}

void RequestGetCurrentRank::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestGetCurrentRank::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestGetCurrentRank& RequestGetCurrentRank::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestGetCurrentRank* RequestGetCurrentRank::default_instance_ = NULL;

RequestGetCurrentRank* RequestGetCurrentRank::New() const {
  return new RequestGetCurrentRank;
}

void RequestGetCurrentRank::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestGetCurrentRank::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestGetCurrentRank)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestGetCurrentRank)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestGetCurrentRank)
  return false;
#undef DO_
}

void RequestGetCurrentRank::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestGetCurrentRank)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestGetCurrentRank)
}

int RequestGetCurrentRank::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestGetCurrentRank::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestGetCurrentRank*>(&from));
}

void RequestGetCurrentRank::MergeFrom(const RequestGetCurrentRank& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestGetCurrentRank::CopyFrom(const RequestGetCurrentRank& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestGetCurrentRank::IsInitialized() const {

  return true;
}

void RequestGetCurrentRank::Swap(RequestGetCurrentRank* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestGetCurrentRank::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestGetCurrentRank";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RequestGetCurrentRankResponse::RequestGetCurrentRankResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestGetCurrentRankResponse)
}

void RequestGetCurrentRankResponse::InitAsDefaultInstance() {
}

RequestGetCurrentRankResponse::RequestGetCurrentRankResponse(const RequestGetCurrentRankResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestGetCurrentRankResponse)
}

void RequestGetCurrentRankResponse::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestGetCurrentRankResponse::~RequestGetCurrentRankResponse() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestGetCurrentRankResponse)
  SharedDtor();
}

void RequestGetCurrentRankResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestGetCurrentRankResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestGetCurrentRankResponse& RequestGetCurrentRankResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestGetCurrentRankResponse* RequestGetCurrentRankResponse::default_instance_ = NULL;

RequestGetCurrentRankResponse* RequestGetCurrentRankResponse::New() const {
  return new RequestGetCurrentRankResponse;
}

void RequestGetCurrentRankResponse::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestGetCurrentRankResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestGetCurrentRankResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestGetCurrentRankResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestGetCurrentRankResponse)
  return false;
#undef DO_
}

void RequestGetCurrentRankResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestGetCurrentRankResponse)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestGetCurrentRankResponse)
}

int RequestGetCurrentRankResponse::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestGetCurrentRankResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestGetCurrentRankResponse*>(&from));
}

void RequestGetCurrentRankResponse::MergeFrom(const RequestGetCurrentRankResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestGetCurrentRankResponse::CopyFrom(const RequestGetCurrentRankResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestGetCurrentRankResponse::IsInitialized() const {

  return true;
}

void RequestGetCurrentRankResponse::Swap(RequestGetCurrentRankResponse* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestGetCurrentRankResponse::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestGetCurrentRankResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int QuickMatchRank::kRankFieldNumber;
const int QuickMatchRank::kXpFieldNumber;
#endif  // !_MSC_VER

QuickMatchRank::QuickMatchRank()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.QuickMatchRank)
}

void QuickMatchRank::InitAsDefaultInstance() {
}

QuickMatchRank::QuickMatchRank(const QuickMatchRank& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.QuickMatchRank)
}

void QuickMatchRank::SharedCtor() {
  _cached_size_ = 0;
  rank_ = 0u;
  xp_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

QuickMatchRank::~QuickMatchRank() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.QuickMatchRank)
  SharedDtor();
}

void QuickMatchRank::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void QuickMatchRank::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const QuickMatchRank& QuickMatchRank::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

QuickMatchRank* QuickMatchRank::default_instance_ = NULL;

QuickMatchRank* QuickMatchRank::New() const {
  return new QuickMatchRank;
}

void QuickMatchRank::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<QuickMatchRank*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(rank_, xp_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool QuickMatchRank::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.QuickMatchRank)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 rank = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &rank_)));
          set_has_rank();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_xp;
        break;
      }

      // optional uint32 xp = 2;
      case 2: {
        if (tag == 16) {
         parse_xp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &xp_)));
          set_has_xp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.QuickMatchRank)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.QuickMatchRank)
  return false;
#undef DO_
}

void QuickMatchRank::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.QuickMatchRank)
  // optional uint32 rank = 1;
  if (has_rank()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->rank(), output);
  }

  // optional uint32 xp = 2;
  if (has_xp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->xp(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.QuickMatchRank)
}

int QuickMatchRank::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 rank = 1;
    if (has_rank()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->rank());
    }

    // optional uint32 xp = 2;
    if (has_xp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->xp());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void QuickMatchRank::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const QuickMatchRank*>(&from));
}

void QuickMatchRank::MergeFrom(const QuickMatchRank& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_rank()) {
      set_rank(from.rank());
    }
    if (from.has_xp()) {
      set_xp(from.xp());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void QuickMatchRank::CopyFrom(const QuickMatchRank& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool QuickMatchRank::IsInitialized() const {

  return true;
}

void QuickMatchRank::Swap(QuickMatchRank* other) {
  if (other != this) {
    std::swap(rank_, other->rank_);
    std::swap(xp_, other->xp_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string QuickMatchRank::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.QuickMatchRank";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

QuickMatchRankCache::QuickMatchRankCache()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.QuickMatchRankCache)
}

void QuickMatchRankCache::InitAsDefaultInstance() {
}

QuickMatchRankCache::QuickMatchRankCache(const QuickMatchRankCache& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.QuickMatchRankCache)
}

void QuickMatchRankCache::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

QuickMatchRankCache::~QuickMatchRankCache() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.QuickMatchRankCache)
  SharedDtor();
}

void QuickMatchRankCache::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void QuickMatchRankCache::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const QuickMatchRankCache& QuickMatchRankCache::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

QuickMatchRankCache* QuickMatchRankCache::default_instance_ = NULL;

QuickMatchRankCache* QuickMatchRankCache::New() const {
  return new QuickMatchRankCache;
}

void QuickMatchRankCache::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool QuickMatchRankCache::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.QuickMatchRankCache)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.QuickMatchRankCache)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.QuickMatchRankCache)
  return false;
#undef DO_
}

void QuickMatchRankCache::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.QuickMatchRankCache)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.QuickMatchRankCache)
}

int QuickMatchRankCache::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void QuickMatchRankCache::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const QuickMatchRankCache*>(&from));
}

void QuickMatchRankCache::MergeFrom(const QuickMatchRankCache& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void QuickMatchRankCache::CopyFrom(const QuickMatchRankCache& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool QuickMatchRankCache::IsInitialized() const {

  return true;
}

void QuickMatchRankCache::Swap(QuickMatchRankCache* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string QuickMatchRankCache::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.QuickMatchRankCache";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

QuickMatchSession_Result_list::QuickMatchSession_Result_list()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.QuickMatchSession.Result_list)
}

void QuickMatchSession_Result_list::InitAsDefaultInstance() {
}

QuickMatchSession_Result_list::QuickMatchSession_Result_list(const QuickMatchSession_Result_list& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.QuickMatchSession.Result_list)
}

void QuickMatchSession_Result_list::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

QuickMatchSession_Result_list::~QuickMatchSession_Result_list() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.QuickMatchSession.Result_list)
  SharedDtor();
}

void QuickMatchSession_Result_list::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void QuickMatchSession_Result_list::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const QuickMatchSession_Result_list& QuickMatchSession_Result_list::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

QuickMatchSession_Result_list* QuickMatchSession_Result_list::default_instance_ = NULL;

QuickMatchSession_Result_list* QuickMatchSession_Result_list::New() const {
  return new QuickMatchSession_Result_list;
}

void QuickMatchSession_Result_list::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool QuickMatchSession_Result_list::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.QuickMatchSession.Result_list)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.QuickMatchSession.Result_list)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.QuickMatchSession.Result_list)
  return false;
#undef DO_
}

void QuickMatchSession_Result_list::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.QuickMatchSession.Result_list)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.QuickMatchSession.Result_list)
}

int QuickMatchSession_Result_list::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void QuickMatchSession_Result_list::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const QuickMatchSession_Result_list*>(&from));
}

void QuickMatchSession_Result_list::MergeFrom(const QuickMatchSession_Result_list& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void QuickMatchSession_Result_list::CopyFrom(const QuickMatchSession_Result_list& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool QuickMatchSession_Result_list::IsInitialized() const {

  return true;
}

void QuickMatchSession_Result_list::Swap(QuickMatchSession_Result_list* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string QuickMatchSession_Result_list::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.QuickMatchSession.Result_list";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int QuickMatchSession::kResultListFieldNumber;
#endif  // !_MSC_VER

QuickMatchSession::QuickMatchSession()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.QuickMatchSession)
}

void QuickMatchSession::InitAsDefaultInstance() {
}

QuickMatchSession::QuickMatchSession(const QuickMatchSession& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.QuickMatchSession)
}

void QuickMatchSession::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

QuickMatchSession::~QuickMatchSession() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.QuickMatchSession)
  SharedDtor();
}

void QuickMatchSession::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void QuickMatchSession::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const QuickMatchSession& QuickMatchSession::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

QuickMatchSession* QuickMatchSession::default_instance_ = NULL;

QuickMatchSession* QuickMatchSession::New() const {
  return new QuickMatchSession;
}

void QuickMatchSession::Clear() {
  result_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool QuickMatchSession::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.QuickMatchSession)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated group Result_list = 2 {
      case 2: {
        if (tag == 19) {
         parse_result_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadGroupNoVirtual(
                2, input, add_result_list()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(19)) goto parse_result_list;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.QuickMatchSession)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.QuickMatchSession)
  return false;
#undef DO_
}

void QuickMatchSession::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.QuickMatchSession)
  // repeated group Result_list = 2 {
  for (int i = 0; i < this->result_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteGroup(
      2, this->result_list(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.QuickMatchSession)
}

int QuickMatchSession::ByteSize() const {
  int total_size = 0;

  // repeated group Result_list = 2 {
  total_size += 2 * this->result_list_size();
  for (int i = 0; i < this->result_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::GroupSizeNoVirtual(
        this->result_list(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void QuickMatchSession::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const QuickMatchSession*>(&from));
}

void QuickMatchSession::MergeFrom(const QuickMatchSession& from) {
  GOOGLE_CHECK_NE(&from, this);
  result_list_.MergeFrom(from.result_list_);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void QuickMatchSession::CopyFrom(const QuickMatchSession& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool QuickMatchSession::IsInitialized() const {

  return true;
}

void QuickMatchSession::Swap(QuickMatchSession* other) {
  if (other != this) {
    result_list_.Swap(&other->result_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string QuickMatchSession::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.QuickMatchSession";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

QuickMatchApologyPoint::QuickMatchApologyPoint()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.QuickMatchApologyPoint)
}

void QuickMatchApologyPoint::InitAsDefaultInstance() {
}

QuickMatchApologyPoint::QuickMatchApologyPoint(const QuickMatchApologyPoint& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.QuickMatchApologyPoint)
}

void QuickMatchApologyPoint::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

QuickMatchApologyPoint::~QuickMatchApologyPoint() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.QuickMatchApologyPoint)
  SharedDtor();
}

void QuickMatchApologyPoint::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void QuickMatchApologyPoint::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const QuickMatchApologyPoint& QuickMatchApologyPoint::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

QuickMatchApologyPoint* QuickMatchApologyPoint::default_instance_ = NULL;

QuickMatchApologyPoint* QuickMatchApologyPoint::New() const {
  return new QuickMatchApologyPoint;
}

void QuickMatchApologyPoint::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool QuickMatchApologyPoint::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.QuickMatchApologyPoint)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.QuickMatchApologyPoint)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.QuickMatchApologyPoint)
  return false;
#undef DO_
}

void QuickMatchApologyPoint::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.QuickMatchApologyPoint)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.QuickMatchApologyPoint)
}

int QuickMatchApologyPoint::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void QuickMatchApologyPoint::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const QuickMatchApologyPoint*>(&from));
}

void QuickMatchApologyPoint::MergeFrom(const QuickMatchApologyPoint& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void QuickMatchApologyPoint::CopyFrom(const QuickMatchApologyPoint& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool QuickMatchApologyPoint::IsInitialized() const {

  return true;
}

void QuickMatchApologyPoint::Swap(QuickMatchApologyPoint* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string QuickMatchApologyPoint::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.QuickMatchApologyPoint";
}


// ===================================================================

#ifndef _MSC_VER
const int QuickMatchData::kHostPlayerIdFieldNumber;
const int QuickMatchData::kHostPlayerSteamIdFieldNumber;
const int QuickMatchData::kOnlineAreaIdFieldNumber;
#endif  // !_MSC_VER

QuickMatchData::QuickMatchData()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.QuickMatchData)
}

void QuickMatchData::InitAsDefaultInstance() {
}

QuickMatchData::QuickMatchData(const QuickMatchData& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.QuickMatchData)
}

void QuickMatchData::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  host_player_id_ = 0u;
  host_player_steam_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  online_area_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

QuickMatchData::~QuickMatchData() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.QuickMatchData)
  SharedDtor();
}

void QuickMatchData::SharedDtor() {
  if (host_player_steam_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete host_player_steam_id_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void QuickMatchData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const QuickMatchData& QuickMatchData::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

QuickMatchData* QuickMatchData::default_instance_ = NULL;

QuickMatchData* QuickMatchData::New() const {
  return new QuickMatchData;
}

void QuickMatchData::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<QuickMatchData*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 7) {
    ZR_(host_player_id_, online_area_id_);
    if (has_host_player_steam_id()) {
      if (host_player_steam_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        host_player_steam_id_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool QuickMatchData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.QuickMatchData)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 host_player_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &host_player_id_)));
          set_has_host_player_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_host_player_steam_id;
        break;
      }

      // required string host_player_steam_id = 2;
      case 2: {
        if (tag == 18) {
         parse_host_player_steam_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_host_player_steam_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_online_area_id;
        break;
      }

      // required uint32 online_area_id = 3;
      case 3: {
        if (tag == 24) {
         parse_online_area_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &online_area_id_)));
          set_has_online_area_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.QuickMatchData)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.QuickMatchData)
  return false;
#undef DO_
}

void QuickMatchData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.QuickMatchData)
  // required uint32 host_player_id = 1;
  if (has_host_player_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->host_player_id(), output);
  }

  // required string host_player_steam_id = 2;
  if (has_host_player_steam_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->host_player_steam_id(), output);
  }

  // required uint32 online_area_id = 3;
  if (has_online_area_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->online_area_id(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.QuickMatchData)
}

int QuickMatchData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 host_player_id = 1;
    if (has_host_player_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->host_player_id());
    }

    // required string host_player_steam_id = 2;
    if (has_host_player_steam_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->host_player_steam_id());
    }

    // required uint32 online_area_id = 3;
    if (has_online_area_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->online_area_id());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void QuickMatchData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const QuickMatchData*>(&from));
}

void QuickMatchData::MergeFrom(const QuickMatchData& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_host_player_id()) {
      set_host_player_id(from.host_player_id());
    }
    if (from.has_host_player_steam_id()) {
      set_host_player_steam_id(from.host_player_steam_id());
    }
    if (from.has_online_area_id()) {
      set_online_area_id(from.online_area_id());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void QuickMatchData::CopyFrom(const QuickMatchData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool QuickMatchData::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void QuickMatchData::Swap(QuickMatchData* other) {
  if (other != this) {
    std::swap(host_player_id_, other->host_player_id_);
    std::swap(host_player_steam_id_, other->host_player_steam_id_);
    std::swap(online_area_id_, other->online_area_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string QuickMatchData::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.QuickMatchData";
}


// ===================================================================

#ifndef _MSC_VER
const int QuickMatchSearchResult::kDataFieldNumber;
const int QuickMatchSearchResult::kUnknown3FieldNumber;
const int QuickMatchSearchResult::kUnknown4FieldNumber;
#endif  // !_MSC_VER

QuickMatchSearchResult::QuickMatchSearchResult()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.QuickMatchSearchResult)
}

void QuickMatchSearchResult::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  data_ = const_cast< ::DS3_Frpg2RequestMessage::QuickMatchData*>(
      ::DS3_Frpg2RequestMessage::QuickMatchData::internal_default_instance());
#else
  data_ = const_cast< ::DS3_Frpg2RequestMessage::QuickMatchData*>(&::DS3_Frpg2RequestMessage::QuickMatchData::default_instance());
#endif
}

QuickMatchSearchResult::QuickMatchSearchResult(const QuickMatchSearchResult& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.QuickMatchSearchResult)
}

void QuickMatchSearchResult::SharedCtor() {
  _cached_size_ = 0;
  data_ = NULL;
  unknown_3_ = 0u;
  unknown_4_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

QuickMatchSearchResult::~QuickMatchSearchResult() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.QuickMatchSearchResult)
  SharedDtor();
}

void QuickMatchSearchResult::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete data_;
  }
}

void QuickMatchSearchResult::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const QuickMatchSearchResult& QuickMatchSearchResult::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

QuickMatchSearchResult* QuickMatchSearchResult::default_instance_ = NULL;

QuickMatchSearchResult* QuickMatchSearchResult::New() const {
  return new QuickMatchSearchResult;
}

void QuickMatchSearchResult::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<QuickMatchSearchResult*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 7) {
    ZR_(unknown_3_, unknown_4_);
    if (has_data()) {
      if (data_ != NULL) data_->::DS3_Frpg2RequestMessage::QuickMatchData::Clear();
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool QuickMatchSearchResult::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.QuickMatchSearchResult)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .DS3_Frpg2RequestMessage.QuickMatchData data = 2;
      case 2: {
        if (tag == 18) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_unknown_3;
        break;
      }

      // required uint32 unknown_3 = 3;
      case 3: {
        if (tag == 24) {
         parse_unknown_3:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_3_)));
          set_has_unknown_3();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_unknown_4;
        break;
      }

      // required uint32 unknown_4 = 4;
      case 4: {
        if (tag == 32) {
         parse_unknown_4:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_4_)));
          set_has_unknown_4();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.QuickMatchSearchResult)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.QuickMatchSearchResult)
  return false;
#undef DO_
}

void QuickMatchSearchResult::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.QuickMatchSearchResult)
  // optional .DS3_Frpg2RequestMessage.QuickMatchData data = 2;
  if (has_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->data(), output);
  }

  // required uint32 unknown_3 = 3;
  if (has_unknown_3()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->unknown_3(), output);
  }

  // required uint32 unknown_4 = 4;
  if (has_unknown_4()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->unknown_4(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.QuickMatchSearchResult)
}

int QuickMatchSearchResult::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .DS3_Frpg2RequestMessage.QuickMatchData data = 2;
    if (has_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->data());
    }

    // required uint32 unknown_3 = 3;
    if (has_unknown_3()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_3());
    }

    // required uint32 unknown_4 = 4;
    if (has_unknown_4()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_4());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void QuickMatchSearchResult::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const QuickMatchSearchResult*>(&from));
}

void QuickMatchSearchResult::MergeFrom(const QuickMatchSearchResult& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_data()) {
      mutable_data()->::DS3_Frpg2RequestMessage::QuickMatchData::MergeFrom(from.data());
    }
    if (from.has_unknown_3()) {
      set_unknown_3(from.unknown_3());
    }
    if (from.has_unknown_4()) {
      set_unknown_4(from.unknown_4());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void QuickMatchSearchResult::CopyFrom(const QuickMatchSearchResult& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool QuickMatchSearchResult::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000006) != 0x00000006) return false;

  if (has_data()) {
    if (!this->data().IsInitialized()) return false;
  }
  return true;
}

void QuickMatchSearchResult::Swap(QuickMatchSearchResult* other) {
  if (other != this) {
    std::swap(data_, other->data_);
    std::swap(unknown_3_, other->unknown_3_);
    std::swap(unknown_4_, other->unknown_4_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string QuickMatchSearchResult::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.QuickMatchSearchResult";
}


// ===================================================================

#ifndef _MSC_VER
const int AcceptQuickMatchMessage::kHostPlayerIdFieldNumber;
const int AcceptQuickMatchMessage::kHostPlayerSteamIdFieldNumber;
const int AcceptQuickMatchMessage::kMetadataFieldNumber;
#endif  // !_MSC_VER

AcceptQuickMatchMessage::AcceptQuickMatchMessage()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.AcceptQuickMatchMessage)
}

void AcceptQuickMatchMessage::InitAsDefaultInstance() {
}

AcceptQuickMatchMessage::AcceptQuickMatchMessage(const AcceptQuickMatchMessage& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.AcceptQuickMatchMessage)
}

void AcceptQuickMatchMessage::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  host_player_id_ = 0u;
  host_player_steam_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  metadata_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AcceptQuickMatchMessage::~AcceptQuickMatchMessage() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.AcceptQuickMatchMessage)
  SharedDtor();
}

void AcceptQuickMatchMessage::SharedDtor() {
  if (host_player_steam_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete host_player_steam_id_;
  }
  if (metadata_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete metadata_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void AcceptQuickMatchMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const AcceptQuickMatchMessage& AcceptQuickMatchMessage::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

AcceptQuickMatchMessage* AcceptQuickMatchMessage::default_instance_ = NULL;

AcceptQuickMatchMessage* AcceptQuickMatchMessage::New() const {
  return new AcceptQuickMatchMessage;
}

void AcceptQuickMatchMessage::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    host_player_id_ = 0u;
    if (has_host_player_steam_id()) {
      if (host_player_steam_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        host_player_steam_id_->clear();
      }
    }
    if (has_metadata()) {
      if (metadata_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        metadata_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool AcceptQuickMatchMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.AcceptQuickMatchMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 host_player_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &host_player_id_)));
          set_has_host_player_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_host_player_steam_id;
        break;
      }

      // required string host_player_steam_id = 2;
      case 2: {
        if (tag == 18) {
         parse_host_player_steam_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_host_player_steam_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_metadata;
        break;
      }

      // required bytes metadata = 3;
      case 3: {
        if (tag == 26) {
         parse_metadata:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_metadata()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.AcceptQuickMatchMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.AcceptQuickMatchMessage)
  return false;
#undef DO_
}

void AcceptQuickMatchMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.AcceptQuickMatchMessage)
  // required uint32 host_player_id = 1;
  if (has_host_player_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->host_player_id(), output);
  }

  // required string host_player_steam_id = 2;
  if (has_host_player_steam_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->host_player_steam_id(), output);
  }

  // required bytes metadata = 3;
  if (has_metadata()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->metadata(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.AcceptQuickMatchMessage)
}

int AcceptQuickMatchMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 host_player_id = 1;
    if (has_host_player_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->host_player_id());
    }

    // required string host_player_steam_id = 2;
    if (has_host_player_steam_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->host_player_steam_id());
    }

    // required bytes metadata = 3;
    if (has_metadata()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->metadata());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AcceptQuickMatchMessage::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const AcceptQuickMatchMessage*>(&from));
}

void AcceptQuickMatchMessage::MergeFrom(const AcceptQuickMatchMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_host_player_id()) {
      set_host_player_id(from.host_player_id());
    }
    if (from.has_host_player_steam_id()) {
      set_host_player_steam_id(from.host_player_steam_id());
    }
    if (from.has_metadata()) {
      set_metadata(from.metadata());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void AcceptQuickMatchMessage::CopyFrom(const AcceptQuickMatchMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AcceptQuickMatchMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void AcceptQuickMatchMessage::Swap(AcceptQuickMatchMessage* other) {
  if (other != this) {
    std::swap(host_player_id_, other->host_player_id_);
    std::swap(host_player_steam_id_, other->host_player_steam_id_);
    std::swap(metadata_, other->metadata_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string AcceptQuickMatchMessage::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.AcceptQuickMatchMessage";
}


// ===================================================================

#ifndef _MSC_VER
const int RejectQuickMatchMessage::kHostPlayerIdFieldNumber;
const int RejectQuickMatchMessage::kUnknown2FieldNumber;
#endif  // !_MSC_VER

RejectQuickMatchMessage::RejectQuickMatchMessage()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RejectQuickMatchMessage)
}

void RejectQuickMatchMessage::InitAsDefaultInstance() {
}

RejectQuickMatchMessage::RejectQuickMatchMessage(const RejectQuickMatchMessage& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RejectQuickMatchMessage)
}

void RejectQuickMatchMessage::SharedCtor() {
  _cached_size_ = 0;
  host_player_id_ = 0u;
  unknown_2_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RejectQuickMatchMessage::~RejectQuickMatchMessage() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RejectQuickMatchMessage)
  SharedDtor();
}

void RejectQuickMatchMessage::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RejectQuickMatchMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RejectQuickMatchMessage& RejectQuickMatchMessage::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RejectQuickMatchMessage* RejectQuickMatchMessage::default_instance_ = NULL;

RejectQuickMatchMessage* RejectQuickMatchMessage::New() const {
  return new RejectQuickMatchMessage;
}

void RejectQuickMatchMessage::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<RejectQuickMatchMessage*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(host_player_id_, unknown_2_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RejectQuickMatchMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RejectQuickMatchMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 host_player_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &host_player_id_)));
          set_has_host_player_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_unknown_2;
        break;
      }

      // required uint32 unknown_2 = 2;
      case 2: {
        if (tag == 16) {
         parse_unknown_2:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_2_)));
          set_has_unknown_2();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RejectQuickMatchMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RejectQuickMatchMessage)
  return false;
#undef DO_
}

void RejectQuickMatchMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RejectQuickMatchMessage)
  // required uint32 host_player_id = 1;
  if (has_host_player_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->host_player_id(), output);
  }

  // required uint32 unknown_2 = 2;
  if (has_unknown_2()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->unknown_2(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RejectQuickMatchMessage)
}

int RejectQuickMatchMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 host_player_id = 1;
    if (has_host_player_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->host_player_id());
    }

    // required uint32 unknown_2 = 2;
    if (has_unknown_2()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_2());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RejectQuickMatchMessage::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RejectQuickMatchMessage*>(&from));
}

void RejectQuickMatchMessage::MergeFrom(const RejectQuickMatchMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_host_player_id()) {
      set_host_player_id(from.host_player_id());
    }
    if (from.has_unknown_2()) {
      set_unknown_2(from.unknown_2());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RejectQuickMatchMessage::CopyFrom(const RejectQuickMatchMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RejectQuickMatchMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void RejectQuickMatchMessage::Swap(RejectQuickMatchMessage* other) {
  if (other != this) {
    std::swap(host_player_id_, other->host_player_id_);
    std::swap(unknown_2_, other->unknown_2_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RejectQuickMatchMessage::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RejectQuickMatchMessage";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RemoveQuickMatchMessage::RemoveQuickMatchMessage()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RemoveQuickMatchMessage)
}

void RemoveQuickMatchMessage::InitAsDefaultInstance() {
}

RemoveQuickMatchMessage::RemoveQuickMatchMessage(const RemoveQuickMatchMessage& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RemoveQuickMatchMessage)
}

void RemoveQuickMatchMessage::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RemoveQuickMatchMessage::~RemoveQuickMatchMessage() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RemoveQuickMatchMessage)
  SharedDtor();
}

void RemoveQuickMatchMessage::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RemoveQuickMatchMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RemoveQuickMatchMessage& RemoveQuickMatchMessage::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RemoveQuickMatchMessage* RemoveQuickMatchMessage::default_instance_ = NULL;

RemoveQuickMatchMessage* RemoveQuickMatchMessage::New() const {
  return new RemoveQuickMatchMessage;
}

void RemoveQuickMatchMessage::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RemoveQuickMatchMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RemoveQuickMatchMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RemoveQuickMatchMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RemoveQuickMatchMessage)
  return false;
#undef DO_
}

void RemoveQuickMatchMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RemoveQuickMatchMessage)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RemoveQuickMatchMessage)
}

int RemoveQuickMatchMessage::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RemoveQuickMatchMessage::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RemoveQuickMatchMessage*>(&from));
}

void RemoveQuickMatchMessage::MergeFrom(const RemoveQuickMatchMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RemoveQuickMatchMessage::CopyFrom(const RemoveQuickMatchMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RemoveQuickMatchMessage::IsInitialized() const {

  return true;
}

void RemoveQuickMatchMessage::Swap(RemoveQuickMatchMessage* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RemoveQuickMatchMessage::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RemoveQuickMatchMessage";
}


// ===================================================================

#ifndef _MSC_VER
const int JoinQuickMatchMessage::kJoinPlayerIdFieldNumber;
const int JoinQuickMatchMessage::kJoinPlayerSteamIdFieldNumber;
const int JoinQuickMatchMessage::kJoinCharacterIdFieldNumber;
const int JoinQuickMatchMessage::kOnlineAreaIdFieldNumber;
const int JoinQuickMatchMessage::kUnknown5FieldNumber;
const int JoinQuickMatchMessage::kUnknown6FieldNumber;
#endif  // !_MSC_VER

JoinQuickMatchMessage::JoinQuickMatchMessage()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.JoinQuickMatchMessage)
}

void JoinQuickMatchMessage::InitAsDefaultInstance() {
}

JoinQuickMatchMessage::JoinQuickMatchMessage(const JoinQuickMatchMessage& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.JoinQuickMatchMessage)
}

void JoinQuickMatchMessage::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  join_player_id_ = 0u;
  join_player_steam_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  join_character_id_ = 0u;
  online_area_id_ = 0u;
  unknown_5_ = 0u;
  unknown_6_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

JoinQuickMatchMessage::~JoinQuickMatchMessage() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.JoinQuickMatchMessage)
  SharedDtor();
}

void JoinQuickMatchMessage::SharedDtor() {
  if (join_player_steam_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete join_player_steam_id_;
  }
  if (unknown_6_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete unknown_6_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void JoinQuickMatchMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const JoinQuickMatchMessage& JoinQuickMatchMessage::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

JoinQuickMatchMessage* JoinQuickMatchMessage::default_instance_ = NULL;

JoinQuickMatchMessage* JoinQuickMatchMessage::New() const {
  return new JoinQuickMatchMessage;
}

void JoinQuickMatchMessage::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<JoinQuickMatchMessage*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 63) {
    ZR_(join_player_id_, unknown_5_);
    if (has_join_player_steam_id()) {
      if (join_player_steam_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        join_player_steam_id_->clear();
      }
    }
    if (has_unknown_6()) {
      if (unknown_6_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        unknown_6_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool JoinQuickMatchMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.JoinQuickMatchMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 join_player_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &join_player_id_)));
          set_has_join_player_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_join_player_steam_id;
        break;
      }

      // required string join_player_steam_id = 2;
      case 2: {
        if (tag == 18) {
         parse_join_player_steam_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_join_player_steam_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_join_character_id;
        break;
      }

      // required uint32 join_character_id = 3;
      case 3: {
        if (tag == 24) {
         parse_join_character_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &join_character_id_)));
          set_has_join_character_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_online_area_id;
        break;
      }

      // required uint32 online_area_id = 4;
      case 4: {
        if (tag == 32) {
         parse_online_area_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &online_area_id_)));
          set_has_online_area_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_unknown_5;
        break;
      }

      // required uint32 unknown_5 = 5;
      case 5: {
        if (tag == 40) {
         parse_unknown_5:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_5_)));
          set_has_unknown_5();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_unknown_6;
        break;
      }

      // required bytes unknown_6 = 6;
      case 6: {
        if (tag == 50) {
         parse_unknown_6:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_unknown_6()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.JoinQuickMatchMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.JoinQuickMatchMessage)
  return false;
#undef DO_
}

void JoinQuickMatchMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.JoinQuickMatchMessage)
  // required uint32 join_player_id = 1;
  if (has_join_player_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->join_player_id(), output);
  }

  // required string join_player_steam_id = 2;
  if (has_join_player_steam_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->join_player_steam_id(), output);
  }

  // required uint32 join_character_id = 3;
  if (has_join_character_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->join_character_id(), output);
  }

  // required uint32 online_area_id = 4;
  if (has_online_area_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->online_area_id(), output);
  }

  // required uint32 unknown_5 = 5;
  if (has_unknown_5()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->unknown_5(), output);
  }

  // required bytes unknown_6 = 6;
  if (has_unknown_6()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      6, this->unknown_6(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.JoinQuickMatchMessage)
}

int JoinQuickMatchMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 join_player_id = 1;
    if (has_join_player_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->join_player_id());
    }

    // required string join_player_steam_id = 2;
    if (has_join_player_steam_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->join_player_steam_id());
    }

    // required uint32 join_character_id = 3;
    if (has_join_character_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->join_character_id());
    }

    // required uint32 online_area_id = 4;
    if (has_online_area_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->online_area_id());
    }

    // required uint32 unknown_5 = 5;
    if (has_unknown_5()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_5());
    }

    // required bytes unknown_6 = 6;
    if (has_unknown_6()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->unknown_6());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void JoinQuickMatchMessage::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const JoinQuickMatchMessage*>(&from));
}

void JoinQuickMatchMessage::MergeFrom(const JoinQuickMatchMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_join_player_id()) {
      set_join_player_id(from.join_player_id());
    }
    if (from.has_join_player_steam_id()) {
      set_join_player_steam_id(from.join_player_steam_id());
    }
    if (from.has_join_character_id()) {
      set_join_character_id(from.join_character_id());
    }
    if (from.has_online_area_id()) {
      set_online_area_id(from.online_area_id());
    }
    if (from.has_unknown_5()) {
      set_unknown_5(from.unknown_5());
    }
    if (from.has_unknown_6()) {
      set_unknown_6(from.unknown_6());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void JoinQuickMatchMessage::CopyFrom(const JoinQuickMatchMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool JoinQuickMatchMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003f) != 0x0000003f) return false;

  return true;
}

void JoinQuickMatchMessage::Swap(JoinQuickMatchMessage* other) {
  if (other != this) {
    std::swap(join_player_id_, other->join_player_id_);
    std::swap(join_player_steam_id_, other->join_player_steam_id_);
    std::swap(join_character_id_, other->join_character_id_);
    std::swap(online_area_id_, other->online_area_id_);
    std::swap(unknown_5_, other->unknown_5_);
    std::swap(unknown_6_, other->unknown_6_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string JoinQuickMatchMessage::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.JoinQuickMatchMessage";
}


// ===================================================================

#ifndef _MSC_VER
const int PushRequestJoinQuickMatch::kPushMessageIdFieldNumber;
const int PushRequestJoinQuickMatch::kMessageFieldNumber;
#endif  // !_MSC_VER

PushRequestJoinQuickMatch::PushRequestJoinQuickMatch()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.PushRequestJoinQuickMatch)
}

void PushRequestJoinQuickMatch::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  message_ = const_cast< ::DS3_Frpg2RequestMessage::JoinQuickMatchMessage*>(
      ::DS3_Frpg2RequestMessage::JoinQuickMatchMessage::internal_default_instance());
#else
  message_ = const_cast< ::DS3_Frpg2RequestMessage::JoinQuickMatchMessage*>(&::DS3_Frpg2RequestMessage::JoinQuickMatchMessage::default_instance());
#endif
}

PushRequestJoinQuickMatch::PushRequestJoinQuickMatch(const PushRequestJoinQuickMatch& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.PushRequestJoinQuickMatch)
}

void PushRequestJoinQuickMatch::SharedCtor() {
  _cached_size_ = 0;
  push_message_id_ = 829;
  message_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PushRequestJoinQuickMatch::~PushRequestJoinQuickMatch() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.PushRequestJoinQuickMatch)
  SharedDtor();
}

void PushRequestJoinQuickMatch::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete message_;
  }
}

void PushRequestJoinQuickMatch::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PushRequestJoinQuickMatch& PushRequestJoinQuickMatch::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

PushRequestJoinQuickMatch* PushRequestJoinQuickMatch::default_instance_ = NULL;

PushRequestJoinQuickMatch* PushRequestJoinQuickMatch::New() const {
  return new PushRequestJoinQuickMatch;
}

void PushRequestJoinQuickMatch::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    push_message_id_ = 829;
    if (has_message()) {
      if (message_ != NULL) message_->::DS3_Frpg2RequestMessage::JoinQuickMatchMessage::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool PushRequestJoinQuickMatch::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.PushRequestJoinQuickMatch)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::DS3_Frpg2RequestMessage::PushMessageId_IsValid(value)) {
            set_push_message_id(static_cast< ::DS3_Frpg2RequestMessage::PushMessageId >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_message;
        break;
      }

      // required .DS3_Frpg2RequestMessage.JoinQuickMatchMessage message = 2;
      case 2: {
        if (tag == 18) {
         parse_message:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_message()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.PushRequestJoinQuickMatch)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.PushRequestJoinQuickMatch)
  return false;
#undef DO_
}

void PushRequestJoinQuickMatch::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.PushRequestJoinQuickMatch)
  // required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
  if (has_push_message_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->push_message_id(), output);
  }

  // required .DS3_Frpg2RequestMessage.JoinQuickMatchMessage message = 2;
  if (has_message()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->message(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.PushRequestJoinQuickMatch)
}

int PushRequestJoinQuickMatch::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
    if (has_push_message_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->push_message_id());
    }

    // required .DS3_Frpg2RequestMessage.JoinQuickMatchMessage message = 2;
    if (has_message()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->message());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PushRequestJoinQuickMatch::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PushRequestJoinQuickMatch*>(&from));
}

void PushRequestJoinQuickMatch::MergeFrom(const PushRequestJoinQuickMatch& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_push_message_id()) {
      set_push_message_id(from.push_message_id());
    }
    if (from.has_message()) {
      mutable_message()->::DS3_Frpg2RequestMessage::JoinQuickMatchMessage::MergeFrom(from.message());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void PushRequestJoinQuickMatch::CopyFrom(const PushRequestJoinQuickMatch& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PushRequestJoinQuickMatch::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_message()) {
    if (!this->message().IsInitialized()) return false;
  }
  return true;
}

void PushRequestJoinQuickMatch::Swap(PushRequestJoinQuickMatch* other) {
  if (other != this) {
    std::swap(push_message_id_, other->push_message_id_);
    std::swap(message_, other->message_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PushRequestJoinQuickMatch::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.PushRequestJoinQuickMatch";
}


// ===================================================================

#ifndef _MSC_VER
const int PushRequestAcceptQuickMatch::kPushMessageIdFieldNumber;
const int PushRequestAcceptQuickMatch::kMessageFieldNumber;
#endif  // !_MSC_VER

PushRequestAcceptQuickMatch::PushRequestAcceptQuickMatch()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.PushRequestAcceptQuickMatch)
}

void PushRequestAcceptQuickMatch::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  message_ = const_cast< ::DS3_Frpg2RequestMessage::AcceptQuickMatchMessage*>(
      ::DS3_Frpg2RequestMessage::AcceptQuickMatchMessage::internal_default_instance());
#else
  message_ = const_cast< ::DS3_Frpg2RequestMessage::AcceptQuickMatchMessage*>(&::DS3_Frpg2RequestMessage::AcceptQuickMatchMessage::default_instance());
#endif
}

PushRequestAcceptQuickMatch::PushRequestAcceptQuickMatch(const PushRequestAcceptQuickMatch& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.PushRequestAcceptQuickMatch)
}

void PushRequestAcceptQuickMatch::SharedCtor() {
  _cached_size_ = 0;
  push_message_id_ = 829;
  message_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PushRequestAcceptQuickMatch::~PushRequestAcceptQuickMatch() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.PushRequestAcceptQuickMatch)
  SharedDtor();
}

void PushRequestAcceptQuickMatch::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete message_;
  }
}

void PushRequestAcceptQuickMatch::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PushRequestAcceptQuickMatch& PushRequestAcceptQuickMatch::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

PushRequestAcceptQuickMatch* PushRequestAcceptQuickMatch::default_instance_ = NULL;

PushRequestAcceptQuickMatch* PushRequestAcceptQuickMatch::New() const {
  return new PushRequestAcceptQuickMatch;
}

void PushRequestAcceptQuickMatch::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    push_message_id_ = 829;
    if (has_message()) {
      if (message_ != NULL) message_->::DS3_Frpg2RequestMessage::AcceptQuickMatchMessage::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool PushRequestAcceptQuickMatch::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.PushRequestAcceptQuickMatch)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::DS3_Frpg2RequestMessage::PushMessageId_IsValid(value)) {
            set_push_message_id(static_cast< ::DS3_Frpg2RequestMessage::PushMessageId >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_message;
        break;
      }

      // required .DS3_Frpg2RequestMessage.AcceptQuickMatchMessage message = 2;
      case 2: {
        if (tag == 18) {
         parse_message:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_message()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.PushRequestAcceptQuickMatch)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.PushRequestAcceptQuickMatch)
  return false;
#undef DO_
}

void PushRequestAcceptQuickMatch::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.PushRequestAcceptQuickMatch)
  // required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
  if (has_push_message_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->push_message_id(), output);
  }

  // required .DS3_Frpg2RequestMessage.AcceptQuickMatchMessage message = 2;
  if (has_message()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->message(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.PushRequestAcceptQuickMatch)
}

int PushRequestAcceptQuickMatch::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
    if (has_push_message_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->push_message_id());
    }

    // required .DS3_Frpg2RequestMessage.AcceptQuickMatchMessage message = 2;
    if (has_message()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->message());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PushRequestAcceptQuickMatch::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PushRequestAcceptQuickMatch*>(&from));
}

void PushRequestAcceptQuickMatch::MergeFrom(const PushRequestAcceptQuickMatch& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_push_message_id()) {
      set_push_message_id(from.push_message_id());
    }
    if (from.has_message()) {
      mutable_message()->::DS3_Frpg2RequestMessage::AcceptQuickMatchMessage::MergeFrom(from.message());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void PushRequestAcceptQuickMatch::CopyFrom(const PushRequestAcceptQuickMatch& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PushRequestAcceptQuickMatch::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_message()) {
    if (!this->message().IsInitialized()) return false;
  }
  return true;
}

void PushRequestAcceptQuickMatch::Swap(PushRequestAcceptQuickMatch* other) {
  if (other != this) {
    std::swap(push_message_id_, other->push_message_id_);
    std::swap(message_, other->message_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PushRequestAcceptQuickMatch::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.PushRequestAcceptQuickMatch";
}


// ===================================================================

#ifndef _MSC_VER
const int PushRequestRejectQuickMatch::kPushMessageIdFieldNumber;
const int PushRequestRejectQuickMatch::kMessageFieldNumber;
#endif  // !_MSC_VER

PushRequestRejectQuickMatch::PushRequestRejectQuickMatch()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.PushRequestRejectQuickMatch)
}

void PushRequestRejectQuickMatch::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  message_ = const_cast< ::DS3_Frpg2RequestMessage::RejectQuickMatchMessage*>(
      ::DS3_Frpg2RequestMessage::RejectQuickMatchMessage::internal_default_instance());
#else
  message_ = const_cast< ::DS3_Frpg2RequestMessage::RejectQuickMatchMessage*>(&::DS3_Frpg2RequestMessage::RejectQuickMatchMessage::default_instance());
#endif
}

PushRequestRejectQuickMatch::PushRequestRejectQuickMatch(const PushRequestRejectQuickMatch& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.PushRequestRejectQuickMatch)
}

void PushRequestRejectQuickMatch::SharedCtor() {
  _cached_size_ = 0;
  push_message_id_ = 829;
  message_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PushRequestRejectQuickMatch::~PushRequestRejectQuickMatch() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.PushRequestRejectQuickMatch)
  SharedDtor();
}

void PushRequestRejectQuickMatch::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete message_;
  }
}

void PushRequestRejectQuickMatch::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PushRequestRejectQuickMatch& PushRequestRejectQuickMatch::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

PushRequestRejectQuickMatch* PushRequestRejectQuickMatch::default_instance_ = NULL;

PushRequestRejectQuickMatch* PushRequestRejectQuickMatch::New() const {
  return new PushRequestRejectQuickMatch;
}

void PushRequestRejectQuickMatch::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    push_message_id_ = 829;
    if (has_message()) {
      if (message_ != NULL) message_->::DS3_Frpg2RequestMessage::RejectQuickMatchMessage::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool PushRequestRejectQuickMatch::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.PushRequestRejectQuickMatch)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::DS3_Frpg2RequestMessage::PushMessageId_IsValid(value)) {
            set_push_message_id(static_cast< ::DS3_Frpg2RequestMessage::PushMessageId >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_message;
        break;
      }

      // required .DS3_Frpg2RequestMessage.RejectQuickMatchMessage message = 2;
      case 2: {
        if (tag == 18) {
         parse_message:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_message()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.PushRequestRejectQuickMatch)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.PushRequestRejectQuickMatch)
  return false;
#undef DO_
}

void PushRequestRejectQuickMatch::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.PushRequestRejectQuickMatch)
  // required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
  if (has_push_message_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->push_message_id(), output);
  }

  // required .DS3_Frpg2RequestMessage.RejectQuickMatchMessage message = 2;
  if (has_message()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->message(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.PushRequestRejectQuickMatch)
}

int PushRequestRejectQuickMatch::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
    if (has_push_message_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->push_message_id());
    }

    // required .DS3_Frpg2RequestMessage.RejectQuickMatchMessage message = 2;
    if (has_message()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->message());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PushRequestRejectQuickMatch::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PushRequestRejectQuickMatch*>(&from));
}

void PushRequestRejectQuickMatch::MergeFrom(const PushRequestRejectQuickMatch& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_push_message_id()) {
      set_push_message_id(from.push_message_id());
    }
    if (from.has_message()) {
      mutable_message()->::DS3_Frpg2RequestMessage::RejectQuickMatchMessage::MergeFrom(from.message());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void PushRequestRejectQuickMatch::CopyFrom(const PushRequestRejectQuickMatch& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PushRequestRejectQuickMatch::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_message()) {
    if (!this->message().IsInitialized()) return false;
  }
  return true;
}

void PushRequestRejectQuickMatch::Swap(PushRequestRejectQuickMatch* other) {
  if (other != this) {
    std::swap(push_message_id_, other->push_message_id_);
    std::swap(message_, other->message_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PushRequestRejectQuickMatch::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.PushRequestRejectQuickMatch";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestSearchQuickMatch_Map_id_list::kMapIdFieldNumber;
const int RequestSearchQuickMatch_Map_id_list::kOnlineAreaIdFieldNumber;
#endif  // !_MSC_VER

RequestSearchQuickMatch_Map_id_list::RequestSearchQuickMatch_Map_id_list()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestSearchQuickMatch.Map_id_list)
}

void RequestSearchQuickMatch_Map_id_list::InitAsDefaultInstance() {
}

RequestSearchQuickMatch_Map_id_list::RequestSearchQuickMatch_Map_id_list(const RequestSearchQuickMatch_Map_id_list& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestSearchQuickMatch.Map_id_list)
}

void RequestSearchQuickMatch_Map_id_list::SharedCtor() {
  _cached_size_ = 0;
  map_id_ = 0u;
  online_area_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestSearchQuickMatch_Map_id_list::~RequestSearchQuickMatch_Map_id_list() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestSearchQuickMatch.Map_id_list)
  SharedDtor();
}

void RequestSearchQuickMatch_Map_id_list::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestSearchQuickMatch_Map_id_list::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestSearchQuickMatch_Map_id_list& RequestSearchQuickMatch_Map_id_list::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestSearchQuickMatch_Map_id_list* RequestSearchQuickMatch_Map_id_list::default_instance_ = NULL;

RequestSearchQuickMatch_Map_id_list* RequestSearchQuickMatch_Map_id_list::New() const {
  return new RequestSearchQuickMatch_Map_id_list;
}

void RequestSearchQuickMatch_Map_id_list::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<RequestSearchQuickMatch_Map_id_list*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(map_id_, online_area_id_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestSearchQuickMatch_Map_id_list::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestSearchQuickMatch.Map_id_list)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 map_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &map_id_)));
          set_has_map_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_online_area_id;
        break;
      }

      // required uint32 online_area_id = 2;
      case 2: {
        if (tag == 16) {
         parse_online_area_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &online_area_id_)));
          set_has_online_area_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestSearchQuickMatch.Map_id_list)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestSearchQuickMatch.Map_id_list)
  return false;
#undef DO_
}

void RequestSearchQuickMatch_Map_id_list::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestSearchQuickMatch.Map_id_list)
  // required uint32 map_id = 1;
  if (has_map_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->map_id(), output);
  }

  // required uint32 online_area_id = 2;
  if (has_online_area_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->online_area_id(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestSearchQuickMatch.Map_id_list)
}

int RequestSearchQuickMatch_Map_id_list::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 map_id = 1;
    if (has_map_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->map_id());
    }

    // required uint32 online_area_id = 2;
    if (has_online_area_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->online_area_id());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestSearchQuickMatch_Map_id_list::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestSearchQuickMatch_Map_id_list*>(&from));
}

void RequestSearchQuickMatch_Map_id_list::MergeFrom(const RequestSearchQuickMatch_Map_id_list& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_map_id()) {
      set_map_id(from.map_id());
    }
    if (from.has_online_area_id()) {
      set_online_area_id(from.online_area_id());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestSearchQuickMatch_Map_id_list::CopyFrom(const RequestSearchQuickMatch_Map_id_list& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestSearchQuickMatch_Map_id_list::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void RequestSearchQuickMatch_Map_id_list::Swap(RequestSearchQuickMatch_Map_id_list* other) {
  if (other != this) {
    std::swap(map_id_, other->map_id_);
    std::swap(online_area_id_, other->online_area_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestSearchQuickMatch_Map_id_list::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestSearchQuickMatch.Map_id_list";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int RequestSearchQuickMatch::kModeFieldNumber;
const int RequestSearchQuickMatch::kMapIdListFieldNumber;
const int RequestSearchQuickMatch::kUnknown3FieldNumber;
const int RequestSearchQuickMatch::kMatchingParameterFieldNumber;
#endif  // !_MSC_VER

RequestSearchQuickMatch::RequestSearchQuickMatch()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestSearchQuickMatch)
}

void RequestSearchQuickMatch::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  matching_parameter_ = const_cast< ::DS3_Frpg2RequestMessage::MatchingParameter*>(
      ::DS3_Frpg2RequestMessage::MatchingParameter::internal_default_instance());
#else
  matching_parameter_ = const_cast< ::DS3_Frpg2RequestMessage::MatchingParameter*>(&::DS3_Frpg2RequestMessage::MatchingParameter::default_instance());
#endif
}

RequestSearchQuickMatch::RequestSearchQuickMatch(const RequestSearchQuickMatch& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestSearchQuickMatch)
}

void RequestSearchQuickMatch::SharedCtor() {
  _cached_size_ = 0;
  mode_ = 0;
  unknown_3_ = 0u;
  matching_parameter_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestSearchQuickMatch::~RequestSearchQuickMatch() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestSearchQuickMatch)
  SharedDtor();
}

void RequestSearchQuickMatch::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete matching_parameter_;
  }
}

void RequestSearchQuickMatch::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestSearchQuickMatch& RequestSearchQuickMatch::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestSearchQuickMatch* RequestSearchQuickMatch::default_instance_ = NULL;

RequestSearchQuickMatch* RequestSearchQuickMatch::New() const {
  return new RequestSearchQuickMatch;
}

void RequestSearchQuickMatch::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<RequestSearchQuickMatch*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 13) {
    ZR_(mode_, unknown_3_);
    if (has_matching_parameter()) {
      if (matching_parameter_ != NULL) matching_parameter_->::DS3_Frpg2RequestMessage::MatchingParameter::Clear();
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  map_id_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestSearchQuickMatch::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestSearchQuickMatch)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .DS3_Frpg2RequestMessage.QuickMatchGameMode mode = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::DS3_Frpg2RequestMessage::QuickMatchGameMode_IsValid(value)) {
            set_mode(static_cast< ::DS3_Frpg2RequestMessage::QuickMatchGameMode >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(19)) goto parse_map_id_list;
        break;
      }

      // repeated group Map_id_list = 2 {
      case 2: {
        if (tag == 19) {
         parse_map_id_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadGroupNoVirtual(
                2, input, add_map_id_list()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(19)) goto parse_map_id_list;
        if (input->ExpectTag(24)) goto parse_unknown_3;
        break;
      }

      // required uint32 unknown_3 = 3;
      case 3: {
        if (tag == 24) {
         parse_unknown_3:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_3_)));
          set_has_unknown_3();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_matching_parameter;
        break;
      }

      // required .DS3_Frpg2RequestMessage.MatchingParameter matching_parameter = 4;
      case 4: {
        if (tag == 34) {
         parse_matching_parameter:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_matching_parameter()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestSearchQuickMatch)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestSearchQuickMatch)
  return false;
#undef DO_
}

void RequestSearchQuickMatch::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestSearchQuickMatch)
  // required .DS3_Frpg2RequestMessage.QuickMatchGameMode mode = 1;
  if (has_mode()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->mode(), output);
  }

  // repeated group Map_id_list = 2 {
  for (int i = 0; i < this->map_id_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteGroup(
      2, this->map_id_list(i), output);
  }

  // required uint32 unknown_3 = 3;
  if (has_unknown_3()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->unknown_3(), output);
  }

  // required .DS3_Frpg2RequestMessage.MatchingParameter matching_parameter = 4;
  if (has_matching_parameter()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->matching_parameter(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestSearchQuickMatch)
}

int RequestSearchQuickMatch::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .DS3_Frpg2RequestMessage.QuickMatchGameMode mode = 1;
    if (has_mode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->mode());
    }

    // required uint32 unknown_3 = 3;
    if (has_unknown_3()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_3());
    }

    // required .DS3_Frpg2RequestMessage.MatchingParameter matching_parameter = 4;
    if (has_matching_parameter()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->matching_parameter());
    }

  }
  // repeated group Map_id_list = 2 {
  total_size += 2 * this->map_id_list_size();
  for (int i = 0; i < this->map_id_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::GroupSizeNoVirtual(
        this->map_id_list(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestSearchQuickMatch::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestSearchQuickMatch*>(&from));
}

void RequestSearchQuickMatch::MergeFrom(const RequestSearchQuickMatch& from) {
  GOOGLE_CHECK_NE(&from, this);
  map_id_list_.MergeFrom(from.map_id_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_mode()) {
      set_mode(from.mode());
    }
    if (from.has_unknown_3()) {
      set_unknown_3(from.unknown_3());
    }
    if (from.has_matching_parameter()) {
      mutable_matching_parameter()->::DS3_Frpg2RequestMessage::MatchingParameter::MergeFrom(from.matching_parameter());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestSearchQuickMatch::CopyFrom(const RequestSearchQuickMatch& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestSearchQuickMatch::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000d) != 0x0000000d) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->map_id_list())) return false;
  if (has_matching_parameter()) {
    if (!this->matching_parameter().IsInitialized()) return false;
  }
  return true;
}

void RequestSearchQuickMatch::Swap(RequestSearchQuickMatch* other) {
  if (other != this) {
    std::swap(mode_, other->mode_);
    map_id_list_.Swap(&other->map_id_list_);
    std::swap(unknown_3_, other->unknown_3_);
    std::swap(matching_parameter_, other->matching_parameter_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestSearchQuickMatch::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestSearchQuickMatch";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestSearchQuickMatchResponse::kMatchesFieldNumber;
#endif  // !_MSC_VER

RequestSearchQuickMatchResponse::RequestSearchQuickMatchResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestSearchQuickMatchResponse)
}

void RequestSearchQuickMatchResponse::InitAsDefaultInstance() {
}

RequestSearchQuickMatchResponse::RequestSearchQuickMatchResponse(const RequestSearchQuickMatchResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestSearchQuickMatchResponse)
}

void RequestSearchQuickMatchResponse::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestSearchQuickMatchResponse::~RequestSearchQuickMatchResponse() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestSearchQuickMatchResponse)
  SharedDtor();
}

void RequestSearchQuickMatchResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestSearchQuickMatchResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestSearchQuickMatchResponse& RequestSearchQuickMatchResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestSearchQuickMatchResponse* RequestSearchQuickMatchResponse::default_instance_ = NULL;

RequestSearchQuickMatchResponse* RequestSearchQuickMatchResponse::New() const {
  return new RequestSearchQuickMatchResponse;
}

void RequestSearchQuickMatchResponse::Clear() {
  matches_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestSearchQuickMatchResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestSearchQuickMatchResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .DS3_Frpg2RequestMessage.QuickMatchSearchResult matches = 1;
      case 1: {
        if (tag == 10) {
         parse_matches:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_matches()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_matches;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestSearchQuickMatchResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestSearchQuickMatchResponse)
  return false;
#undef DO_
}

void RequestSearchQuickMatchResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestSearchQuickMatchResponse)
  // repeated .DS3_Frpg2RequestMessage.QuickMatchSearchResult matches = 1;
  for (int i = 0; i < this->matches_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->matches(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestSearchQuickMatchResponse)
}

int RequestSearchQuickMatchResponse::ByteSize() const {
  int total_size = 0;

  // repeated .DS3_Frpg2RequestMessage.QuickMatchSearchResult matches = 1;
  total_size += 1 * this->matches_size();
  for (int i = 0; i < this->matches_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->matches(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestSearchQuickMatchResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestSearchQuickMatchResponse*>(&from));
}

void RequestSearchQuickMatchResponse::MergeFrom(const RequestSearchQuickMatchResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  matches_.MergeFrom(from.matches_);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestSearchQuickMatchResponse::CopyFrom(const RequestSearchQuickMatchResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestSearchQuickMatchResponse::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->matches())) return false;
  return true;
}

void RequestSearchQuickMatchResponse::Swap(RequestSearchQuickMatchResponse* other) {
  if (other != this) {
    matches_.Swap(&other->matches_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestSearchQuickMatchResponse::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestSearchQuickMatchResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestRegisterQuickMatch::kModeFieldNumber;
const int RequestRegisterQuickMatch::kMapIdFieldNumber;
const int RequestRegisterQuickMatch::kOnlineAreaIdFieldNumber;
const int RequestRegisterQuickMatch::kMatchingParameterFieldNumber;
const int RequestRegisterQuickMatch::kUnknown5FieldNumber;
#endif  // !_MSC_VER

RequestRegisterQuickMatch::RequestRegisterQuickMatch()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestRegisterQuickMatch)
}

void RequestRegisterQuickMatch::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  matching_parameter_ = const_cast< ::DS3_Frpg2RequestMessage::MatchingParameter*>(
      ::DS3_Frpg2RequestMessage::MatchingParameter::internal_default_instance());
#else
  matching_parameter_ = const_cast< ::DS3_Frpg2RequestMessage::MatchingParameter*>(&::DS3_Frpg2RequestMessage::MatchingParameter::default_instance());
#endif
}

RequestRegisterQuickMatch::RequestRegisterQuickMatch(const RequestRegisterQuickMatch& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestRegisterQuickMatch)
}

void RequestRegisterQuickMatch::SharedCtor() {
  _cached_size_ = 0;
  mode_ = 0;
  map_id_ = 0u;
  online_area_id_ = 0u;
  matching_parameter_ = NULL;
  unknown_5_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestRegisterQuickMatch::~RequestRegisterQuickMatch() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestRegisterQuickMatch)
  SharedDtor();
}

void RequestRegisterQuickMatch::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete matching_parameter_;
  }
}

void RequestRegisterQuickMatch::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestRegisterQuickMatch& RequestRegisterQuickMatch::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestRegisterQuickMatch* RequestRegisterQuickMatch::default_instance_ = NULL;

RequestRegisterQuickMatch* RequestRegisterQuickMatch::New() const {
  return new RequestRegisterQuickMatch;
}

void RequestRegisterQuickMatch::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<RequestRegisterQuickMatch*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 31) {
    ZR_(mode_, map_id_);
    ZR_(online_area_id_, unknown_5_);
    if (has_matching_parameter()) {
      if (matching_parameter_ != NULL) matching_parameter_->::DS3_Frpg2RequestMessage::MatchingParameter::Clear();
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestRegisterQuickMatch::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestRegisterQuickMatch)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .DS3_Frpg2RequestMessage.QuickMatchGameMode mode = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::DS3_Frpg2RequestMessage::QuickMatchGameMode_IsValid(value)) {
            set_mode(static_cast< ::DS3_Frpg2RequestMessage::QuickMatchGameMode >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_map_id;
        break;
      }

      // required uint32 map_id = 2;
      case 2: {
        if (tag == 16) {
         parse_map_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &map_id_)));
          set_has_map_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_online_area_id;
        break;
      }

      // required uint32 online_area_id = 3;
      case 3: {
        if (tag == 24) {
         parse_online_area_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &online_area_id_)));
          set_has_online_area_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_matching_parameter;
        break;
      }

      // required .DS3_Frpg2RequestMessage.MatchingParameter matching_parameter = 4;
      case 4: {
        if (tag == 34) {
         parse_matching_parameter:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_matching_parameter()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_unknown_5;
        break;
      }

      // required uint32 unknown_5 = 5;
      case 5: {
        if (tag == 40) {
         parse_unknown_5:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_5_)));
          set_has_unknown_5();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestRegisterQuickMatch)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestRegisterQuickMatch)
  return false;
#undef DO_
}

void RequestRegisterQuickMatch::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestRegisterQuickMatch)
  // required .DS3_Frpg2RequestMessage.QuickMatchGameMode mode = 1;
  if (has_mode()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->mode(), output);
  }

  // required uint32 map_id = 2;
  if (has_map_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->map_id(), output);
  }

  // required uint32 online_area_id = 3;
  if (has_online_area_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->online_area_id(), output);
  }

  // required .DS3_Frpg2RequestMessage.MatchingParameter matching_parameter = 4;
  if (has_matching_parameter()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->matching_parameter(), output);
  }

  // required uint32 unknown_5 = 5;
  if (has_unknown_5()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->unknown_5(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestRegisterQuickMatch)
}

int RequestRegisterQuickMatch::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .DS3_Frpg2RequestMessage.QuickMatchGameMode mode = 1;
    if (has_mode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->mode());
    }

    // required uint32 map_id = 2;
    if (has_map_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->map_id());
    }

    // required uint32 online_area_id = 3;
    if (has_online_area_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->online_area_id());
    }

    // required .DS3_Frpg2RequestMessage.MatchingParameter matching_parameter = 4;
    if (has_matching_parameter()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->matching_parameter());
    }

    // required uint32 unknown_5 = 5;
    if (has_unknown_5()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_5());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestRegisterQuickMatch::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestRegisterQuickMatch*>(&from));
}

void RequestRegisterQuickMatch::MergeFrom(const RequestRegisterQuickMatch& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_mode()) {
      set_mode(from.mode());
    }
    if (from.has_map_id()) {
      set_map_id(from.map_id());
    }
    if (from.has_online_area_id()) {
      set_online_area_id(from.online_area_id());
    }
    if (from.has_matching_parameter()) {
      mutable_matching_parameter()->::DS3_Frpg2RequestMessage::MatchingParameter::MergeFrom(from.matching_parameter());
    }
    if (from.has_unknown_5()) {
      set_unknown_5(from.unknown_5());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestRegisterQuickMatch::CopyFrom(const RequestRegisterQuickMatch& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestRegisterQuickMatch::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;

  if (has_matching_parameter()) {
    if (!this->matching_parameter().IsInitialized()) return false;
  }
  return true;
}

void RequestRegisterQuickMatch::Swap(RequestRegisterQuickMatch* other) {
  if (other != this) {
    std::swap(mode_, other->mode_);
    std::swap(map_id_, other->map_id_);
    std::swap(online_area_id_, other->online_area_id_);
    std::swap(matching_parameter_, other->matching_parameter_);
    std::swap(unknown_5_, other->unknown_5_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestRegisterQuickMatch::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestRegisterQuickMatch";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestUnregisterQuickMatch::kModeFieldNumber;
const int RequestUnregisterQuickMatch::kMapIdFieldNumber;
const int RequestUnregisterQuickMatch::kOnlineAreaIdFieldNumber;
const int RequestUnregisterQuickMatch::kUnknown4FieldNumber;
#endif  // !_MSC_VER

RequestUnregisterQuickMatch::RequestUnregisterQuickMatch()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestUnregisterQuickMatch)
}

void RequestUnregisterQuickMatch::InitAsDefaultInstance() {
}

RequestUnregisterQuickMatch::RequestUnregisterQuickMatch(const RequestUnregisterQuickMatch& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestUnregisterQuickMatch)
}

void RequestUnregisterQuickMatch::SharedCtor() {
  _cached_size_ = 0;
  mode_ = 0;
  map_id_ = 0u;
  online_area_id_ = 0u;
  unknown_4_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestUnregisterQuickMatch::~RequestUnregisterQuickMatch() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestUnregisterQuickMatch)
  SharedDtor();
}

void RequestUnregisterQuickMatch::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestUnregisterQuickMatch::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestUnregisterQuickMatch& RequestUnregisterQuickMatch::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestUnregisterQuickMatch* RequestUnregisterQuickMatch::default_instance_ = NULL;

RequestUnregisterQuickMatch* RequestUnregisterQuickMatch::New() const {
  return new RequestUnregisterQuickMatch;
}

void RequestUnregisterQuickMatch::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<RequestUnregisterQuickMatch*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(mode_, unknown_4_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestUnregisterQuickMatch::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestUnregisterQuickMatch)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .DS3_Frpg2RequestMessage.QuickMatchGameMode mode = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::DS3_Frpg2RequestMessage::QuickMatchGameMode_IsValid(value)) {
            set_mode(static_cast< ::DS3_Frpg2RequestMessage::QuickMatchGameMode >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_map_id;
        break;
      }

      // required uint32 map_id = 2;
      case 2: {
        if (tag == 16) {
         parse_map_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &map_id_)));
          set_has_map_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_online_area_id;
        break;
      }

      // required uint32 online_area_id = 3;
      case 3: {
        if (tag == 24) {
         parse_online_area_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &online_area_id_)));
          set_has_online_area_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_unknown_4;
        break;
      }

      // required uint32 unknown_4 = 4;
      case 4: {
        if (tag == 32) {
         parse_unknown_4:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_4_)));
          set_has_unknown_4();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestUnregisterQuickMatch)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestUnregisterQuickMatch)
  return false;
#undef DO_
}

void RequestUnregisterQuickMatch::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestUnregisterQuickMatch)
  // required .DS3_Frpg2RequestMessage.QuickMatchGameMode mode = 1;
  if (has_mode()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->mode(), output);
  }

  // required uint32 map_id = 2;
  if (has_map_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->map_id(), output);
  }

  // required uint32 online_area_id = 3;
  if (has_online_area_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->online_area_id(), output);
  }

  // required uint32 unknown_4 = 4;
  if (has_unknown_4()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->unknown_4(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestUnregisterQuickMatch)
}

int RequestUnregisterQuickMatch::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .DS3_Frpg2RequestMessage.QuickMatchGameMode mode = 1;
    if (has_mode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->mode());
    }

    // required uint32 map_id = 2;
    if (has_map_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->map_id());
    }

    // required uint32 online_area_id = 3;
    if (has_online_area_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->online_area_id());
    }

    // required uint32 unknown_4 = 4;
    if (has_unknown_4()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_4());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestUnregisterQuickMatch::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestUnregisterQuickMatch*>(&from));
}

void RequestUnregisterQuickMatch::MergeFrom(const RequestUnregisterQuickMatch& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_mode()) {
      set_mode(from.mode());
    }
    if (from.has_map_id()) {
      set_map_id(from.map_id());
    }
    if (from.has_online_area_id()) {
      set_online_area_id(from.online_area_id());
    }
    if (from.has_unknown_4()) {
      set_unknown_4(from.unknown_4());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestUnregisterQuickMatch::CopyFrom(const RequestUnregisterQuickMatch& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestUnregisterQuickMatch::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void RequestUnregisterQuickMatch::Swap(RequestUnregisterQuickMatch* other) {
  if (other != this) {
    std::swap(mode_, other->mode_);
    std::swap(map_id_, other->map_id_);
    std::swap(online_area_id_, other->online_area_id_);
    std::swap(unknown_4_, other->unknown_4_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestUnregisterQuickMatch::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestUnregisterQuickMatch";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RequestRegisterQuickMatchResponse::RequestRegisterQuickMatchResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestRegisterQuickMatchResponse)
}

void RequestRegisterQuickMatchResponse::InitAsDefaultInstance() {
}

RequestRegisterQuickMatchResponse::RequestRegisterQuickMatchResponse(const RequestRegisterQuickMatchResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestRegisterQuickMatchResponse)
}

void RequestRegisterQuickMatchResponse::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestRegisterQuickMatchResponse::~RequestRegisterQuickMatchResponse() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestRegisterQuickMatchResponse)
  SharedDtor();
}

void RequestRegisterQuickMatchResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestRegisterQuickMatchResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestRegisterQuickMatchResponse& RequestRegisterQuickMatchResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestRegisterQuickMatchResponse* RequestRegisterQuickMatchResponse::default_instance_ = NULL;

RequestRegisterQuickMatchResponse* RequestRegisterQuickMatchResponse::New() const {
  return new RequestRegisterQuickMatchResponse;
}

void RequestRegisterQuickMatchResponse::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestRegisterQuickMatchResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestRegisterQuickMatchResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestRegisterQuickMatchResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestRegisterQuickMatchResponse)
  return false;
#undef DO_
}

void RequestRegisterQuickMatchResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestRegisterQuickMatchResponse)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestRegisterQuickMatchResponse)
}

int RequestRegisterQuickMatchResponse::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestRegisterQuickMatchResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestRegisterQuickMatchResponse*>(&from));
}

void RequestRegisterQuickMatchResponse::MergeFrom(const RequestRegisterQuickMatchResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestRegisterQuickMatchResponse::CopyFrom(const RequestRegisterQuickMatchResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestRegisterQuickMatchResponse::IsInitialized() const {

  return true;
}

void RequestRegisterQuickMatchResponse::Swap(RequestRegisterQuickMatchResponse* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestRegisterQuickMatchResponse::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestRegisterQuickMatchResponse";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RequestUnregisterQuickMatchResponse::RequestUnregisterQuickMatchResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestUnregisterQuickMatchResponse)
}

void RequestUnregisterQuickMatchResponse::InitAsDefaultInstance() {
}

RequestUnregisterQuickMatchResponse::RequestUnregisterQuickMatchResponse(const RequestUnregisterQuickMatchResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestUnregisterQuickMatchResponse)
}

void RequestUnregisterQuickMatchResponse::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestUnregisterQuickMatchResponse::~RequestUnregisterQuickMatchResponse() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestUnregisterQuickMatchResponse)
  SharedDtor();
}

void RequestUnregisterQuickMatchResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestUnregisterQuickMatchResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestUnregisterQuickMatchResponse& RequestUnregisterQuickMatchResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestUnregisterQuickMatchResponse* RequestUnregisterQuickMatchResponse::default_instance_ = NULL;

RequestUnregisterQuickMatchResponse* RequestUnregisterQuickMatchResponse::New() const {
  return new RequestUnregisterQuickMatchResponse;
}

void RequestUnregisterQuickMatchResponse::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestUnregisterQuickMatchResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestUnregisterQuickMatchResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestUnregisterQuickMatchResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestUnregisterQuickMatchResponse)
  return false;
#undef DO_
}

void RequestUnregisterQuickMatchResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestUnregisterQuickMatchResponse)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestUnregisterQuickMatchResponse)
}

int RequestUnregisterQuickMatchResponse::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestUnregisterQuickMatchResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestUnregisterQuickMatchResponse*>(&from));
}

void RequestUnregisterQuickMatchResponse::MergeFrom(const RequestUnregisterQuickMatchResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestUnregisterQuickMatchResponse::CopyFrom(const RequestUnregisterQuickMatchResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestUnregisterQuickMatchResponse::IsInitialized() const {

  return true;
}

void RequestUnregisterQuickMatchResponse::Swap(RequestUnregisterQuickMatchResponse* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestUnregisterQuickMatchResponse::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestUnregisterQuickMatchResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestUpdateQuickMatch::kModeFieldNumber;
const int RequestUpdateQuickMatch::kMapIdFieldNumber;
const int RequestUpdateQuickMatch::kOnlineAreaIdFieldNumber;
#endif  // !_MSC_VER

RequestUpdateQuickMatch::RequestUpdateQuickMatch()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestUpdateQuickMatch)
}

void RequestUpdateQuickMatch::InitAsDefaultInstance() {
}

RequestUpdateQuickMatch::RequestUpdateQuickMatch(const RequestUpdateQuickMatch& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestUpdateQuickMatch)
}

void RequestUpdateQuickMatch::SharedCtor() {
  _cached_size_ = 0;
  mode_ = 0;
  map_id_ = 0u;
  online_area_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestUpdateQuickMatch::~RequestUpdateQuickMatch() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestUpdateQuickMatch)
  SharedDtor();
}

void RequestUpdateQuickMatch::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestUpdateQuickMatch::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestUpdateQuickMatch& RequestUpdateQuickMatch::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestUpdateQuickMatch* RequestUpdateQuickMatch::default_instance_ = NULL;

RequestUpdateQuickMatch* RequestUpdateQuickMatch::New() const {
  return new RequestUpdateQuickMatch;
}

void RequestUpdateQuickMatch::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<RequestUpdateQuickMatch*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(mode_, online_area_id_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestUpdateQuickMatch::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestUpdateQuickMatch)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .DS3_Frpg2RequestMessage.QuickMatchGameMode mode = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::DS3_Frpg2RequestMessage::QuickMatchGameMode_IsValid(value)) {
            set_mode(static_cast< ::DS3_Frpg2RequestMessage::QuickMatchGameMode >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_map_id;
        break;
      }

      // required uint32 map_id = 2;
      case 2: {
        if (tag == 16) {
         parse_map_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &map_id_)));
          set_has_map_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_online_area_id;
        break;
      }

      // required uint32 online_area_id = 3;
      case 3: {
        if (tag == 24) {
         parse_online_area_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &online_area_id_)));
          set_has_online_area_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestUpdateQuickMatch)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestUpdateQuickMatch)
  return false;
#undef DO_
}

void RequestUpdateQuickMatch::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestUpdateQuickMatch)
  // required .DS3_Frpg2RequestMessage.QuickMatchGameMode mode = 1;
  if (has_mode()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->mode(), output);
  }

  // required uint32 map_id = 2;
  if (has_map_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->map_id(), output);
  }

  // required uint32 online_area_id = 3;
  if (has_online_area_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->online_area_id(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestUpdateQuickMatch)
}

int RequestUpdateQuickMatch::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .DS3_Frpg2RequestMessage.QuickMatchGameMode mode = 1;
    if (has_mode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->mode());
    }

    // required uint32 map_id = 2;
    if (has_map_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->map_id());
    }

    // required uint32 online_area_id = 3;
    if (has_online_area_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->online_area_id());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestUpdateQuickMatch::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestUpdateQuickMatch*>(&from));
}

void RequestUpdateQuickMatch::MergeFrom(const RequestUpdateQuickMatch& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_mode()) {
      set_mode(from.mode());
    }
    if (from.has_map_id()) {
      set_map_id(from.map_id());
    }
    if (from.has_online_area_id()) {
      set_online_area_id(from.online_area_id());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestUpdateQuickMatch::CopyFrom(const RequestUpdateQuickMatch& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestUpdateQuickMatch::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void RequestUpdateQuickMatch::Swap(RequestUpdateQuickMatch* other) {
  if (other != this) {
    std::swap(mode_, other->mode_);
    std::swap(map_id_, other->map_id_);
    std::swap(online_area_id_, other->online_area_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestUpdateQuickMatch::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestUpdateQuickMatch";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RequestUpdateQuickMatchResponse::RequestUpdateQuickMatchResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestUpdateQuickMatchResponse)
}

void RequestUpdateQuickMatchResponse::InitAsDefaultInstance() {
}

RequestUpdateQuickMatchResponse::RequestUpdateQuickMatchResponse(const RequestUpdateQuickMatchResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestUpdateQuickMatchResponse)
}

void RequestUpdateQuickMatchResponse::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestUpdateQuickMatchResponse::~RequestUpdateQuickMatchResponse() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestUpdateQuickMatchResponse)
  SharedDtor();
}

void RequestUpdateQuickMatchResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestUpdateQuickMatchResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestUpdateQuickMatchResponse& RequestUpdateQuickMatchResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestUpdateQuickMatchResponse* RequestUpdateQuickMatchResponse::default_instance_ = NULL;

RequestUpdateQuickMatchResponse* RequestUpdateQuickMatchResponse::New() const {
  return new RequestUpdateQuickMatchResponse;
}

void RequestUpdateQuickMatchResponse::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestUpdateQuickMatchResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestUpdateQuickMatchResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestUpdateQuickMatchResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestUpdateQuickMatchResponse)
  return false;
#undef DO_
}

void RequestUpdateQuickMatchResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestUpdateQuickMatchResponse)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestUpdateQuickMatchResponse)
}

int RequestUpdateQuickMatchResponse::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestUpdateQuickMatchResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestUpdateQuickMatchResponse*>(&from));
}

void RequestUpdateQuickMatchResponse::MergeFrom(const RequestUpdateQuickMatchResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestUpdateQuickMatchResponse::CopyFrom(const RequestUpdateQuickMatchResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestUpdateQuickMatchResponse::IsInitialized() const {

  return true;
}

void RequestUpdateQuickMatchResponse::Swap(RequestUpdateQuickMatchResponse* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestUpdateQuickMatchResponse::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestUpdateQuickMatchResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestJoinQuickMatch::kModeFieldNumber;
const int RequestJoinQuickMatch::kCharacterIdFieldNumber;
const int RequestJoinQuickMatch::kHostPlayerIdFieldNumber;
const int RequestJoinQuickMatch::kMapIdFieldNumber;
const int RequestJoinQuickMatch::kOnlineAreaIdFieldNumber;
const int RequestJoinQuickMatch::kUnknown7FieldNumber;
const int RequestJoinQuickMatch::kPasswordFieldNumber;
#endif  // !_MSC_VER

RequestJoinQuickMatch::RequestJoinQuickMatch()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestJoinQuickMatch)
}

void RequestJoinQuickMatch::InitAsDefaultInstance() {
}

RequestJoinQuickMatch::RequestJoinQuickMatch(const RequestJoinQuickMatch& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestJoinQuickMatch)
}

void RequestJoinQuickMatch::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  mode_ = 0;
  character_id_ = 0u;
  host_player_id_ = 0u;
  map_id_ = 0u;
  online_area_id_ = 0u;
  unknown_7_ = 0u;
  password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestJoinQuickMatch::~RequestJoinQuickMatch() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestJoinQuickMatch)
  SharedDtor();
}

void RequestJoinQuickMatch::SharedDtor() {
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete password_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestJoinQuickMatch::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestJoinQuickMatch& RequestJoinQuickMatch::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestJoinQuickMatch* RequestJoinQuickMatch::default_instance_ = NULL;

RequestJoinQuickMatch* RequestJoinQuickMatch::New() const {
  return new RequestJoinQuickMatch;
}

void RequestJoinQuickMatch::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<RequestJoinQuickMatch*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 127) {
    ZR_(mode_, unknown_7_);
    if (has_password()) {
      if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        password_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestJoinQuickMatch::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestJoinQuickMatch)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .DS3_Frpg2RequestMessage.QuickMatchGameMode mode = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::DS3_Frpg2RequestMessage::QuickMatchGameMode_IsValid(value)) {
            set_mode(static_cast< ::DS3_Frpg2RequestMessage::QuickMatchGameMode >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_character_id;
        break;
      }

      // required uint32 character_id = 2;
      case 2: {
        if (tag == 16) {
         parse_character_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &character_id_)));
          set_has_character_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_host_player_id;
        break;
      }

      // required uint32 host_player_id = 4;
      case 4: {
        if (tag == 32) {
         parse_host_player_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &host_player_id_)));
          set_has_host_player_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_map_id;
        break;
      }

      // required uint32 map_id = 5;
      case 5: {
        if (tag == 40) {
         parse_map_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &map_id_)));
          set_has_map_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_online_area_id;
        break;
      }

      // required uint32 online_area_id = 6;
      case 6: {
        if (tag == 48) {
         parse_online_area_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &online_area_id_)));
          set_has_online_area_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_unknown_7;
        break;
      }

      // required uint32 unknown_7 = 7;
      case 7: {
        if (tag == 56) {
         parse_unknown_7:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_7_)));
          set_has_unknown_7();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_password;
        break;
      }

      // required string password = 8;
      case 8: {
        if (tag == 66) {
         parse_password:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_password()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestJoinQuickMatch)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestJoinQuickMatch)
  return false;
#undef DO_
}

void RequestJoinQuickMatch::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestJoinQuickMatch)
  // required .DS3_Frpg2RequestMessage.QuickMatchGameMode mode = 1;
  if (has_mode()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->mode(), output);
  }

  // required uint32 character_id = 2;
  if (has_character_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->character_id(), output);
  }

  // required uint32 host_player_id = 4;
  if (has_host_player_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->host_player_id(), output);
  }

  // required uint32 map_id = 5;
  if (has_map_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->map_id(), output);
  }

  // required uint32 online_area_id = 6;
  if (has_online_area_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->online_area_id(), output);
  }

  // required uint32 unknown_7 = 7;
  if (has_unknown_7()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->unknown_7(), output);
  }

  // required string password = 8;
  if (has_password()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      8, this->password(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestJoinQuickMatch)
}

int RequestJoinQuickMatch::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .DS3_Frpg2RequestMessage.QuickMatchGameMode mode = 1;
    if (has_mode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->mode());
    }

    // required uint32 character_id = 2;
    if (has_character_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->character_id());
    }

    // required uint32 host_player_id = 4;
    if (has_host_player_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->host_player_id());
    }

    // required uint32 map_id = 5;
    if (has_map_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->map_id());
    }

    // required uint32 online_area_id = 6;
    if (has_online_area_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->online_area_id());
    }

    // required uint32 unknown_7 = 7;
    if (has_unknown_7()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_7());
    }

    // required string password = 8;
    if (has_password()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->password());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestJoinQuickMatch::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestJoinQuickMatch*>(&from));
}

void RequestJoinQuickMatch::MergeFrom(const RequestJoinQuickMatch& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_mode()) {
      set_mode(from.mode());
    }
    if (from.has_character_id()) {
      set_character_id(from.character_id());
    }
    if (from.has_host_player_id()) {
      set_host_player_id(from.host_player_id());
    }
    if (from.has_map_id()) {
      set_map_id(from.map_id());
    }
    if (from.has_online_area_id()) {
      set_online_area_id(from.online_area_id());
    }
    if (from.has_unknown_7()) {
      set_unknown_7(from.unknown_7());
    }
    if (from.has_password()) {
      set_password(from.password());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestJoinQuickMatch::CopyFrom(const RequestJoinQuickMatch& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestJoinQuickMatch::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000007f) != 0x0000007f) return false;

  return true;
}

void RequestJoinQuickMatch::Swap(RequestJoinQuickMatch* other) {
  if (other != this) {
    std::swap(mode_, other->mode_);
    std::swap(character_id_, other->character_id_);
    std::swap(host_player_id_, other->host_player_id_);
    std::swap(map_id_, other->map_id_);
    std::swap(online_area_id_, other->online_area_id_);
    std::swap(unknown_7_, other->unknown_7_);
    std::swap(password_, other->password_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestJoinQuickMatch::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestJoinQuickMatch";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RequestJoinQuickMatchResponse::RequestJoinQuickMatchResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestJoinQuickMatchResponse)
}

void RequestJoinQuickMatchResponse::InitAsDefaultInstance() {
}

RequestJoinQuickMatchResponse::RequestJoinQuickMatchResponse(const RequestJoinQuickMatchResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestJoinQuickMatchResponse)
}

void RequestJoinQuickMatchResponse::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestJoinQuickMatchResponse::~RequestJoinQuickMatchResponse() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestJoinQuickMatchResponse)
  SharedDtor();
}

void RequestJoinQuickMatchResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestJoinQuickMatchResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestJoinQuickMatchResponse& RequestJoinQuickMatchResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestJoinQuickMatchResponse* RequestJoinQuickMatchResponse::default_instance_ = NULL;

RequestJoinQuickMatchResponse* RequestJoinQuickMatchResponse::New() const {
  return new RequestJoinQuickMatchResponse;
}

void RequestJoinQuickMatchResponse::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestJoinQuickMatchResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestJoinQuickMatchResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestJoinQuickMatchResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestJoinQuickMatchResponse)
  return false;
#undef DO_
}

void RequestJoinQuickMatchResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestJoinQuickMatchResponse)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestJoinQuickMatchResponse)
}

int RequestJoinQuickMatchResponse::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestJoinQuickMatchResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestJoinQuickMatchResponse*>(&from));
}

void RequestJoinQuickMatchResponse::MergeFrom(const RequestJoinQuickMatchResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestJoinQuickMatchResponse::CopyFrom(const RequestJoinQuickMatchResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestJoinQuickMatchResponse::IsInitialized() const {

  return true;
}

void RequestJoinQuickMatchResponse::Swap(RequestJoinQuickMatchResponse* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestJoinQuickMatchResponse::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestJoinQuickMatchResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestAcceptQuickMatch::kModeFieldNumber;
const int RequestAcceptQuickMatch::kJoinPlayerIdFieldNumber;
const int RequestAcceptQuickMatch::kDataFieldNumber;
#endif  // !_MSC_VER

RequestAcceptQuickMatch::RequestAcceptQuickMatch()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestAcceptQuickMatch)
}

void RequestAcceptQuickMatch::InitAsDefaultInstance() {
}

RequestAcceptQuickMatch::RequestAcceptQuickMatch(const RequestAcceptQuickMatch& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestAcceptQuickMatch)
}

void RequestAcceptQuickMatch::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  mode_ = 0;
  join_player_id_ = 0u;
  data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestAcceptQuickMatch::~RequestAcceptQuickMatch() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestAcceptQuickMatch)
  SharedDtor();
}

void RequestAcceptQuickMatch::SharedDtor() {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestAcceptQuickMatch::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestAcceptQuickMatch& RequestAcceptQuickMatch::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestAcceptQuickMatch* RequestAcceptQuickMatch::default_instance_ = NULL;

RequestAcceptQuickMatch* RequestAcceptQuickMatch::New() const {
  return new RequestAcceptQuickMatch;
}

void RequestAcceptQuickMatch::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<RequestAcceptQuickMatch*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 7) {
    ZR_(mode_, join_player_id_);
    if (has_data()) {
      if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        data_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestAcceptQuickMatch::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestAcceptQuickMatch)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .DS3_Frpg2RequestMessage.QuickMatchGameMode mode = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::DS3_Frpg2RequestMessage::QuickMatchGameMode_IsValid(value)) {
            set_mode(static_cast< ::DS3_Frpg2RequestMessage::QuickMatchGameMode >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_join_player_id;
        break;
      }

      // required uint32 join_player_id = 4;
      case 4: {
        if (tag == 32) {
         parse_join_player_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &join_player_id_)));
          set_has_join_player_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_data;
        break;
      }

      // required bytes data = 5;
      case 5: {
        if (tag == 42) {
         parse_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestAcceptQuickMatch)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestAcceptQuickMatch)
  return false;
#undef DO_
}

void RequestAcceptQuickMatch::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestAcceptQuickMatch)
  // required .DS3_Frpg2RequestMessage.QuickMatchGameMode mode = 1;
  if (has_mode()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->mode(), output);
  }

  // required uint32 join_player_id = 4;
  if (has_join_player_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->join_player_id(), output);
  }

  // required bytes data = 5;
  if (has_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      5, this->data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestAcceptQuickMatch)
}

int RequestAcceptQuickMatch::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .DS3_Frpg2RequestMessage.QuickMatchGameMode mode = 1;
    if (has_mode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->mode());
    }

    // required uint32 join_player_id = 4;
    if (has_join_player_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->join_player_id());
    }

    // required bytes data = 5;
    if (has_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->data());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestAcceptQuickMatch::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestAcceptQuickMatch*>(&from));
}

void RequestAcceptQuickMatch::MergeFrom(const RequestAcceptQuickMatch& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_mode()) {
      set_mode(from.mode());
    }
    if (from.has_join_player_id()) {
      set_join_player_id(from.join_player_id());
    }
    if (from.has_data()) {
      set_data(from.data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestAcceptQuickMatch::CopyFrom(const RequestAcceptQuickMatch& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestAcceptQuickMatch::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void RequestAcceptQuickMatch::Swap(RequestAcceptQuickMatch* other) {
  if (other != this) {
    std::swap(mode_, other->mode_);
    std::swap(join_player_id_, other->join_player_id_);
    std::swap(data_, other->data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestAcceptQuickMatch::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestAcceptQuickMatch";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RequestAcceptQuickMatchResponse::RequestAcceptQuickMatchResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestAcceptQuickMatchResponse)
}

void RequestAcceptQuickMatchResponse::InitAsDefaultInstance() {
}

RequestAcceptQuickMatchResponse::RequestAcceptQuickMatchResponse(const RequestAcceptQuickMatchResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestAcceptQuickMatchResponse)
}

void RequestAcceptQuickMatchResponse::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestAcceptQuickMatchResponse::~RequestAcceptQuickMatchResponse() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestAcceptQuickMatchResponse)
  SharedDtor();
}

void RequestAcceptQuickMatchResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestAcceptQuickMatchResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestAcceptQuickMatchResponse& RequestAcceptQuickMatchResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestAcceptQuickMatchResponse* RequestAcceptQuickMatchResponse::default_instance_ = NULL;

RequestAcceptQuickMatchResponse* RequestAcceptQuickMatchResponse::New() const {
  return new RequestAcceptQuickMatchResponse;
}

void RequestAcceptQuickMatchResponse::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestAcceptQuickMatchResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestAcceptQuickMatchResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestAcceptQuickMatchResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestAcceptQuickMatchResponse)
  return false;
#undef DO_
}

void RequestAcceptQuickMatchResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestAcceptQuickMatchResponse)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestAcceptQuickMatchResponse)
}

int RequestAcceptQuickMatchResponse::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestAcceptQuickMatchResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestAcceptQuickMatchResponse*>(&from));
}

void RequestAcceptQuickMatchResponse::MergeFrom(const RequestAcceptQuickMatchResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestAcceptQuickMatchResponse::CopyFrom(const RequestAcceptQuickMatchResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestAcceptQuickMatchResponse::IsInitialized() const {

  return true;
}

void RequestAcceptQuickMatchResponse::Swap(RequestAcceptQuickMatchResponse* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestAcceptQuickMatchResponse::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestAcceptQuickMatchResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestRejectQuickMatch::kModeFieldNumber;
const int RequestRejectQuickMatch::kMapIdFieldNumber;
const int RequestRejectQuickMatch::kOnlineAreaIdFieldNumber;
const int RequestRejectQuickMatch::kJoinPlayerIdFieldNumber;
const int RequestRejectQuickMatch::kUnknown5FieldNumber;
#endif  // !_MSC_VER

RequestRejectQuickMatch::RequestRejectQuickMatch()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestRejectQuickMatch)
}

void RequestRejectQuickMatch::InitAsDefaultInstance() {
}

RequestRejectQuickMatch::RequestRejectQuickMatch(const RequestRejectQuickMatch& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestRejectQuickMatch)
}

void RequestRejectQuickMatch::SharedCtor() {
  _cached_size_ = 0;
  mode_ = 0;
  map_id_ = 0u;
  online_area_id_ = 0u;
  join_player_id_ = 0u;
  unknown_5_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestRejectQuickMatch::~RequestRejectQuickMatch() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestRejectQuickMatch)
  SharedDtor();
}

void RequestRejectQuickMatch::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestRejectQuickMatch::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestRejectQuickMatch& RequestRejectQuickMatch::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestRejectQuickMatch* RequestRejectQuickMatch::default_instance_ = NULL;

RequestRejectQuickMatch* RequestRejectQuickMatch::New() const {
  return new RequestRejectQuickMatch;
}

void RequestRejectQuickMatch::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<RequestRejectQuickMatch*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 31) {
    ZR_(mode_, unknown_5_);
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestRejectQuickMatch::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestRejectQuickMatch)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .DS3_Frpg2RequestMessage.QuickMatchGameMode mode = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::DS3_Frpg2RequestMessage::QuickMatchGameMode_IsValid(value)) {
            set_mode(static_cast< ::DS3_Frpg2RequestMessage::QuickMatchGameMode >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_map_id;
        break;
      }

      // required uint32 map_id = 2;
      case 2: {
        if (tag == 16) {
         parse_map_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &map_id_)));
          set_has_map_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_online_area_id;
        break;
      }

      // required uint32 online_area_id = 3;
      case 3: {
        if (tag == 24) {
         parse_online_area_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &online_area_id_)));
          set_has_online_area_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_join_player_id;
        break;
      }

      // required uint32 join_player_id = 4;
      case 4: {
        if (tag == 32) {
         parse_join_player_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &join_player_id_)));
          set_has_join_player_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_unknown_5;
        break;
      }

      // required uint32 unknown_5 = 5;
      case 5: {
        if (tag == 40) {
         parse_unknown_5:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_5_)));
          set_has_unknown_5();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestRejectQuickMatch)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestRejectQuickMatch)
  return false;
#undef DO_
}

void RequestRejectQuickMatch::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestRejectQuickMatch)
  // required .DS3_Frpg2RequestMessage.QuickMatchGameMode mode = 1;
  if (has_mode()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->mode(), output);
  }

  // required uint32 map_id = 2;
  if (has_map_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->map_id(), output);
  }

  // required uint32 online_area_id = 3;
  if (has_online_area_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->online_area_id(), output);
  }

  // required uint32 join_player_id = 4;
  if (has_join_player_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->join_player_id(), output);
  }

  // required uint32 unknown_5 = 5;
  if (has_unknown_5()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->unknown_5(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestRejectQuickMatch)
}

int RequestRejectQuickMatch::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .DS3_Frpg2RequestMessage.QuickMatchGameMode mode = 1;
    if (has_mode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->mode());
    }

    // required uint32 map_id = 2;
    if (has_map_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->map_id());
    }

    // required uint32 online_area_id = 3;
    if (has_online_area_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->online_area_id());
    }

    // required uint32 join_player_id = 4;
    if (has_join_player_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->join_player_id());
    }

    // required uint32 unknown_5 = 5;
    if (has_unknown_5()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_5());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestRejectQuickMatch::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestRejectQuickMatch*>(&from));
}

void RequestRejectQuickMatch::MergeFrom(const RequestRejectQuickMatch& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_mode()) {
      set_mode(from.mode());
    }
    if (from.has_map_id()) {
      set_map_id(from.map_id());
    }
    if (from.has_online_area_id()) {
      set_online_area_id(from.online_area_id());
    }
    if (from.has_join_player_id()) {
      set_join_player_id(from.join_player_id());
    }
    if (from.has_unknown_5()) {
      set_unknown_5(from.unknown_5());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestRejectQuickMatch::CopyFrom(const RequestRejectQuickMatch& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestRejectQuickMatch::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;

  return true;
}

void RequestRejectQuickMatch::Swap(RequestRejectQuickMatch* other) {
  if (other != this) {
    std::swap(mode_, other->mode_);
    std::swap(map_id_, other->map_id_);
    std::swap(online_area_id_, other->online_area_id_);
    std::swap(join_player_id_, other->join_player_id_);
    std::swap(unknown_5_, other->unknown_5_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestRejectQuickMatch::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestRejectQuickMatch";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RequestRejectQuickMatchResponse::RequestRejectQuickMatchResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestRejectQuickMatchResponse)
}

void RequestRejectQuickMatchResponse::InitAsDefaultInstance() {
}

RequestRejectQuickMatchResponse::RequestRejectQuickMatchResponse(const RequestRejectQuickMatchResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestRejectQuickMatchResponse)
}

void RequestRejectQuickMatchResponse::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestRejectQuickMatchResponse::~RequestRejectQuickMatchResponse() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestRejectQuickMatchResponse)
  SharedDtor();
}

void RequestRejectQuickMatchResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestRejectQuickMatchResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestRejectQuickMatchResponse& RequestRejectQuickMatchResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestRejectQuickMatchResponse* RequestRejectQuickMatchResponse::default_instance_ = NULL;

RequestRejectQuickMatchResponse* RequestRejectQuickMatchResponse::New() const {
  return new RequestRejectQuickMatchResponse;
}

void RequestRejectQuickMatchResponse::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestRejectQuickMatchResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestRejectQuickMatchResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestRejectQuickMatchResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestRejectQuickMatchResponse)
  return false;
#undef DO_
}

void RequestRejectQuickMatchResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestRejectQuickMatchResponse)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestRejectQuickMatchResponse)
}

int RequestRejectQuickMatchResponse::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestRejectQuickMatchResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestRejectQuickMatchResponse*>(&from));
}

void RequestRejectQuickMatchResponse::MergeFrom(const RequestRejectQuickMatchResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestRejectQuickMatchResponse::CopyFrom(const RequestRejectQuickMatchResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestRejectQuickMatchResponse::IsInitialized() const {

  return true;
}

void RequestRejectQuickMatchResponse::Swap(RequestRejectQuickMatchResponse* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestRejectQuickMatchResponse::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestRejectQuickMatchResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestSendQuickMatchStart_Session_member_list::kPlayerIdFieldNumber;
const int RequestSendQuickMatchStart_Session_member_list::kCharacterIdFieldNumber;
#endif  // !_MSC_VER

RequestSendQuickMatchStart_Session_member_list::RequestSendQuickMatchStart_Session_member_list()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestSendQuickMatchStart.Session_member_list)
}

void RequestSendQuickMatchStart_Session_member_list::InitAsDefaultInstance() {
}

RequestSendQuickMatchStart_Session_member_list::RequestSendQuickMatchStart_Session_member_list(const RequestSendQuickMatchStart_Session_member_list& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestSendQuickMatchStart.Session_member_list)
}

void RequestSendQuickMatchStart_Session_member_list::SharedCtor() {
  _cached_size_ = 0;
  player_id_ = 0u;
  character_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestSendQuickMatchStart_Session_member_list::~RequestSendQuickMatchStart_Session_member_list() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestSendQuickMatchStart.Session_member_list)
  SharedDtor();
}

void RequestSendQuickMatchStart_Session_member_list::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestSendQuickMatchStart_Session_member_list::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestSendQuickMatchStart_Session_member_list& RequestSendQuickMatchStart_Session_member_list::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestSendQuickMatchStart_Session_member_list* RequestSendQuickMatchStart_Session_member_list::default_instance_ = NULL;

RequestSendQuickMatchStart_Session_member_list* RequestSendQuickMatchStart_Session_member_list::New() const {
  return new RequestSendQuickMatchStart_Session_member_list;
}

void RequestSendQuickMatchStart_Session_member_list::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<RequestSendQuickMatchStart_Session_member_list*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(player_id_, character_id_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestSendQuickMatchStart_Session_member_list::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestSendQuickMatchStart.Session_member_list)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 player_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &player_id_)));
          set_has_player_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_character_id;
        break;
      }

      // required uint32 character_id = 2;
      case 2: {
        if (tag == 16) {
         parse_character_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &character_id_)));
          set_has_character_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestSendQuickMatchStart.Session_member_list)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestSendQuickMatchStart.Session_member_list)
  return false;
#undef DO_
}

void RequestSendQuickMatchStart_Session_member_list::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestSendQuickMatchStart.Session_member_list)
  // required uint32 player_id = 1;
  if (has_player_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->player_id(), output);
  }

  // required uint32 character_id = 2;
  if (has_character_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->character_id(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestSendQuickMatchStart.Session_member_list)
}

int RequestSendQuickMatchStart_Session_member_list::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 player_id = 1;
    if (has_player_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->player_id());
    }

    // required uint32 character_id = 2;
    if (has_character_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->character_id());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestSendQuickMatchStart_Session_member_list::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestSendQuickMatchStart_Session_member_list*>(&from));
}

void RequestSendQuickMatchStart_Session_member_list::MergeFrom(const RequestSendQuickMatchStart_Session_member_list& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_player_id()) {
      set_player_id(from.player_id());
    }
    if (from.has_character_id()) {
      set_character_id(from.character_id());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestSendQuickMatchStart_Session_member_list::CopyFrom(const RequestSendQuickMatchStart_Session_member_list& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestSendQuickMatchStart_Session_member_list::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void RequestSendQuickMatchStart_Session_member_list::Swap(RequestSendQuickMatchStart_Session_member_list* other) {
  if (other != this) {
    std::swap(player_id_, other->player_id_);
    std::swap(character_id_, other->character_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestSendQuickMatchStart_Session_member_list::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestSendQuickMatchStart.Session_member_list";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int RequestSendQuickMatchStart::kUnknown1FieldNumber;
const int RequestSendQuickMatchStart::kSessionMemberListFieldNumber;
#endif  // !_MSC_VER

RequestSendQuickMatchStart::RequestSendQuickMatchStart()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestSendQuickMatchStart)
}

void RequestSendQuickMatchStart::InitAsDefaultInstance() {
}

RequestSendQuickMatchStart::RequestSendQuickMatchStart(const RequestSendQuickMatchStart& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestSendQuickMatchStart)
}

void RequestSendQuickMatchStart::SharedCtor() {
  _cached_size_ = 0;
  unknown_1_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestSendQuickMatchStart::~RequestSendQuickMatchStart() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestSendQuickMatchStart)
  SharedDtor();
}

void RequestSendQuickMatchStart::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestSendQuickMatchStart::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestSendQuickMatchStart& RequestSendQuickMatchStart::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestSendQuickMatchStart* RequestSendQuickMatchStart::default_instance_ = NULL;

RequestSendQuickMatchStart* RequestSendQuickMatchStart::New() const {
  return new RequestSendQuickMatchStart;
}

void RequestSendQuickMatchStart::Clear() {
  unknown_1_ = 0u;
  session_member_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestSendQuickMatchStart::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestSendQuickMatchStart)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 unknown_1 = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_1_)));
          set_has_unknown_1();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(19)) goto parse_session_member_list;
        break;
      }

      // repeated group Session_member_list = 2 {
      case 2: {
        if (tag == 19) {
         parse_session_member_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadGroupNoVirtual(
                2, input, add_session_member_list()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(19)) goto parse_session_member_list;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestSendQuickMatchStart)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestSendQuickMatchStart)
  return false;
#undef DO_
}

void RequestSendQuickMatchStart::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestSendQuickMatchStart)
  // required uint32 unknown_1 = 1;
  if (has_unknown_1()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->unknown_1(), output);
  }

  // repeated group Session_member_list = 2 {
  for (int i = 0; i < this->session_member_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteGroup(
      2, this->session_member_list(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestSendQuickMatchStart)
}

int RequestSendQuickMatchStart::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 unknown_1 = 1;
    if (has_unknown_1()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_1());
    }

  }
  // repeated group Session_member_list = 2 {
  total_size += 2 * this->session_member_list_size();
  for (int i = 0; i < this->session_member_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::GroupSizeNoVirtual(
        this->session_member_list(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestSendQuickMatchStart::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestSendQuickMatchStart*>(&from));
}

void RequestSendQuickMatchStart::MergeFrom(const RequestSendQuickMatchStart& from) {
  GOOGLE_CHECK_NE(&from, this);
  session_member_list_.MergeFrom(from.session_member_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_unknown_1()) {
      set_unknown_1(from.unknown_1());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestSendQuickMatchStart::CopyFrom(const RequestSendQuickMatchStart& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestSendQuickMatchStart::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->session_member_list())) return false;
  return true;
}

void RequestSendQuickMatchStart::Swap(RequestSendQuickMatchStart* other) {
  if (other != this) {
    std::swap(unknown_1_, other->unknown_1_);
    session_member_list_.Swap(&other->session_member_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestSendQuickMatchStart::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestSendQuickMatchStart";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RequestSendQuickMatchStartResponse::RequestSendQuickMatchStartResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestSendQuickMatchStartResponse)
}

void RequestSendQuickMatchStartResponse::InitAsDefaultInstance() {
}

RequestSendQuickMatchStartResponse::RequestSendQuickMatchStartResponse(const RequestSendQuickMatchStartResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestSendQuickMatchStartResponse)
}

void RequestSendQuickMatchStartResponse::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestSendQuickMatchStartResponse::~RequestSendQuickMatchStartResponse() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestSendQuickMatchStartResponse)
  SharedDtor();
}

void RequestSendQuickMatchStartResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestSendQuickMatchStartResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestSendQuickMatchStartResponse& RequestSendQuickMatchStartResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestSendQuickMatchStartResponse* RequestSendQuickMatchStartResponse::default_instance_ = NULL;

RequestSendQuickMatchStartResponse* RequestSendQuickMatchStartResponse::New() const {
  return new RequestSendQuickMatchStartResponse;
}

void RequestSendQuickMatchStartResponse::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestSendQuickMatchStartResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestSendQuickMatchStartResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestSendQuickMatchStartResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestSendQuickMatchStartResponse)
  return false;
#undef DO_
}

void RequestSendQuickMatchStartResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestSendQuickMatchStartResponse)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestSendQuickMatchStartResponse)
}

int RequestSendQuickMatchStartResponse::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestSendQuickMatchStartResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestSendQuickMatchStartResponse*>(&from));
}

void RequestSendQuickMatchStartResponse::MergeFrom(const RequestSendQuickMatchStartResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestSendQuickMatchStartResponse::CopyFrom(const RequestSendQuickMatchStartResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestSendQuickMatchStartResponse::IsInitialized() const {

  return true;
}

void RequestSendQuickMatchStartResponse::Swap(RequestSendQuickMatchStartResponse* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestSendQuickMatchStartResponse::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestSendQuickMatchStartResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestSendQuickMatchResult::kModeFieldNumber;
const int RequestSendQuickMatchResult::kUnknown2FieldNumber;
const int RequestSendQuickMatchResult::kResultFieldNumber;
const int RequestSendQuickMatchResult::kLocalWonFieldNumber;
const int RequestSendQuickMatchResult::kRemoteRankFieldNumber;
const int RequestSendQuickMatchResult::kLocalRankFieldNumber;
const int RequestSendQuickMatchResult::kUnknown7FieldNumber;
#endif  // !_MSC_VER

RequestSendQuickMatchResult::RequestSendQuickMatchResult()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestSendQuickMatchResult)
}

void RequestSendQuickMatchResult::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  remote_rank_ = const_cast< ::DS3_Frpg2RequestMessage::QuickMatchRank*>(
      ::DS3_Frpg2RequestMessage::QuickMatchRank::internal_default_instance());
#else
  remote_rank_ = const_cast< ::DS3_Frpg2RequestMessage::QuickMatchRank*>(&::DS3_Frpg2RequestMessage::QuickMatchRank::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  local_rank_ = const_cast< ::DS3_Frpg2RequestMessage::QuickMatchRank*>(
      ::DS3_Frpg2RequestMessage::QuickMatchRank::internal_default_instance());
#else
  local_rank_ = const_cast< ::DS3_Frpg2RequestMessage::QuickMatchRank*>(&::DS3_Frpg2RequestMessage::QuickMatchRank::default_instance());
#endif
}

RequestSendQuickMatchResult::RequestSendQuickMatchResult(const RequestSendQuickMatchResult& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestSendQuickMatchResult)
}

void RequestSendQuickMatchResult::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  mode_ = 0;
  unknown_2_ = 0u;
  result_ = 0;
  local_won_ = false;
  remote_rank_ = NULL;
  local_rank_ = NULL;
  unknown_7_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestSendQuickMatchResult::~RequestSendQuickMatchResult() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestSendQuickMatchResult)
  SharedDtor();
}

void RequestSendQuickMatchResult::SharedDtor() {
  if (unknown_7_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete unknown_7_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete remote_rank_;
    delete local_rank_;
  }
}

void RequestSendQuickMatchResult::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestSendQuickMatchResult& RequestSendQuickMatchResult::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestSendQuickMatchResult* RequestSendQuickMatchResult::default_instance_ = NULL;

RequestSendQuickMatchResult* RequestSendQuickMatchResult::New() const {
  return new RequestSendQuickMatchResult;
}

void RequestSendQuickMatchResult::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<RequestSendQuickMatchResult*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 127) {
    ZR_(mode_, local_won_);
    if (has_remote_rank()) {
      if (remote_rank_ != NULL) remote_rank_->::DS3_Frpg2RequestMessage::QuickMatchRank::Clear();
    }
    if (has_local_rank()) {
      if (local_rank_ != NULL) local_rank_->::DS3_Frpg2RequestMessage::QuickMatchRank::Clear();
    }
    if (has_unknown_7()) {
      if (unknown_7_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        unknown_7_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestSendQuickMatchResult::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestSendQuickMatchResult)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .DS3_Frpg2RequestMessage.QuickMatchGameMode mode = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::DS3_Frpg2RequestMessage::QuickMatchGameMode_IsValid(value)) {
            set_mode(static_cast< ::DS3_Frpg2RequestMessage::QuickMatchGameMode >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_unknown_2;
        break;
      }

      // required uint32 unknown_2 = 2;
      case 2: {
        if (tag == 16) {
         parse_unknown_2:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_2_)));
          set_has_unknown_2();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_result;
        break;
      }

      // required .DS3_Frpg2RequestMessage.QuickMatchResult result = 3;
      case 3: {
        if (tag == 24) {
         parse_result:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::DS3_Frpg2RequestMessage::QuickMatchResult_IsValid(value)) {
            set_result(static_cast< ::DS3_Frpg2RequestMessage::QuickMatchResult >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_local_won;
        break;
      }

      // required bool local_won = 4;
      case 4: {
        if (tag == 32) {
         parse_local_won:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &local_won_)));
          set_has_local_won();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_remote_rank;
        break;
      }

      // required .DS3_Frpg2RequestMessage.QuickMatchRank remote_rank = 5;
      case 5: {
        if (tag == 42) {
         parse_remote_rank:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_remote_rank()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_local_rank;
        break;
      }

      // required .DS3_Frpg2RequestMessage.QuickMatchRank local_rank = 6;
      case 6: {
        if (tag == 50) {
         parse_local_rank:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_local_rank()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_unknown_7;
        break;
      }

      // optional string unknown_7 = 7;
      case 7: {
        if (tag == 58) {
         parse_unknown_7:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_unknown_7()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestSendQuickMatchResult)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestSendQuickMatchResult)
  return false;
#undef DO_
}

void RequestSendQuickMatchResult::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestSendQuickMatchResult)
  // required .DS3_Frpg2RequestMessage.QuickMatchGameMode mode = 1;
  if (has_mode()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->mode(), output);
  }

  // required uint32 unknown_2 = 2;
  if (has_unknown_2()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->unknown_2(), output);
  }

  // required .DS3_Frpg2RequestMessage.QuickMatchResult result = 3;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->result(), output);
  }

  // required bool local_won = 4;
  if (has_local_won()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->local_won(), output);
  }

  // required .DS3_Frpg2RequestMessage.QuickMatchRank remote_rank = 5;
  if (has_remote_rank()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, this->remote_rank(), output);
  }

  // required .DS3_Frpg2RequestMessage.QuickMatchRank local_rank = 6;
  if (has_local_rank()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, this->local_rank(), output);
  }

  // optional string unknown_7 = 7;
  if (has_unknown_7()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      7, this->unknown_7(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestSendQuickMatchResult)
}

int RequestSendQuickMatchResult::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .DS3_Frpg2RequestMessage.QuickMatchGameMode mode = 1;
    if (has_mode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->mode());
    }

    // required uint32 unknown_2 = 2;
    if (has_unknown_2()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_2());
    }

    // required .DS3_Frpg2RequestMessage.QuickMatchResult result = 3;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->result());
    }

    // required bool local_won = 4;
    if (has_local_won()) {
      total_size += 1 + 1;
    }

    // required .DS3_Frpg2RequestMessage.QuickMatchRank remote_rank = 5;
    if (has_remote_rank()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->remote_rank());
    }

    // required .DS3_Frpg2RequestMessage.QuickMatchRank local_rank = 6;
    if (has_local_rank()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->local_rank());
    }

    // optional string unknown_7 = 7;
    if (has_unknown_7()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->unknown_7());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestSendQuickMatchResult::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestSendQuickMatchResult*>(&from));
}

void RequestSendQuickMatchResult::MergeFrom(const RequestSendQuickMatchResult& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_mode()) {
      set_mode(from.mode());
    }
    if (from.has_unknown_2()) {
      set_unknown_2(from.unknown_2());
    }
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_local_won()) {
      set_local_won(from.local_won());
    }
    if (from.has_remote_rank()) {
      mutable_remote_rank()->::DS3_Frpg2RequestMessage::QuickMatchRank::MergeFrom(from.remote_rank());
    }
    if (from.has_local_rank()) {
      mutable_local_rank()->::DS3_Frpg2RequestMessage::QuickMatchRank::MergeFrom(from.local_rank());
    }
    if (from.has_unknown_7()) {
      set_unknown_7(from.unknown_7());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestSendQuickMatchResult::CopyFrom(const RequestSendQuickMatchResult& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestSendQuickMatchResult::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003f) != 0x0000003f) return false;

  return true;
}

void RequestSendQuickMatchResult::Swap(RequestSendQuickMatchResult* other) {
  if (other != this) {
    std::swap(mode_, other->mode_);
    std::swap(unknown_2_, other->unknown_2_);
    std::swap(result_, other->result_);
    std::swap(local_won_, other->local_won_);
    std::swap(remote_rank_, other->remote_rank_);
    std::swap(local_rank_, other->local_rank_);
    std::swap(unknown_7_, other->unknown_7_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestSendQuickMatchResult::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestSendQuickMatchResult";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestSendQuickMatchResultResponse::kUnknown1FieldNumber;
const int RequestSendQuickMatchResultResponse::kNewLocalRankFieldNumber;
#endif  // !_MSC_VER

RequestSendQuickMatchResultResponse::RequestSendQuickMatchResultResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestSendQuickMatchResultResponse)
}

void RequestSendQuickMatchResultResponse::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  new_local_rank_ = const_cast< ::DS3_Frpg2RequestMessage::QuickMatchRank*>(
      ::DS3_Frpg2RequestMessage::QuickMatchRank::internal_default_instance());
#else
  new_local_rank_ = const_cast< ::DS3_Frpg2RequestMessage::QuickMatchRank*>(&::DS3_Frpg2RequestMessage::QuickMatchRank::default_instance());
#endif
}

RequestSendQuickMatchResultResponse::RequestSendQuickMatchResultResponse(const RequestSendQuickMatchResultResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestSendQuickMatchResultResponse)
}

void RequestSendQuickMatchResultResponse::SharedCtor() {
  _cached_size_ = 0;
  unknown_1_ = 0u;
  new_local_rank_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestSendQuickMatchResultResponse::~RequestSendQuickMatchResultResponse() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestSendQuickMatchResultResponse)
  SharedDtor();
}

void RequestSendQuickMatchResultResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete new_local_rank_;
  }
}

void RequestSendQuickMatchResultResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestSendQuickMatchResultResponse& RequestSendQuickMatchResultResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestSendQuickMatchResultResponse* RequestSendQuickMatchResultResponse::default_instance_ = NULL;

RequestSendQuickMatchResultResponse* RequestSendQuickMatchResultResponse::New() const {
  return new RequestSendQuickMatchResultResponse;
}

void RequestSendQuickMatchResultResponse::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    unknown_1_ = 0u;
    if (has_new_local_rank()) {
      if (new_local_rank_ != NULL) new_local_rank_->::DS3_Frpg2RequestMessage::QuickMatchRank::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestSendQuickMatchResultResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestSendQuickMatchResultResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 unknown_1 = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_1_)));
          set_has_unknown_1();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_new_local_rank;
        break;
      }

      // required .DS3_Frpg2RequestMessage.QuickMatchRank new_local_rank = 2;
      case 2: {
        if (tag == 18) {
         parse_new_local_rank:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_new_local_rank()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestSendQuickMatchResultResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestSendQuickMatchResultResponse)
  return false;
#undef DO_
}

void RequestSendQuickMatchResultResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestSendQuickMatchResultResponse)
  // required uint32 unknown_1 = 1;
  if (has_unknown_1()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->unknown_1(), output);
  }

  // required .DS3_Frpg2RequestMessage.QuickMatchRank new_local_rank = 2;
  if (has_new_local_rank()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->new_local_rank(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestSendQuickMatchResultResponse)
}

int RequestSendQuickMatchResultResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 unknown_1 = 1;
    if (has_unknown_1()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_1());
    }

    // required .DS3_Frpg2RequestMessage.QuickMatchRank new_local_rank = 2;
    if (has_new_local_rank()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->new_local_rank());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestSendQuickMatchResultResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestSendQuickMatchResultResponse*>(&from));
}

void RequestSendQuickMatchResultResponse::MergeFrom(const RequestSendQuickMatchResultResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_unknown_1()) {
      set_unknown_1(from.unknown_1());
    }
    if (from.has_new_local_rank()) {
      mutable_new_local_rank()->::DS3_Frpg2RequestMessage::QuickMatchRank::MergeFrom(from.new_local_rank());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestSendQuickMatchResultResponse::CopyFrom(const RequestSendQuickMatchResultResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestSendQuickMatchResultResponse::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void RequestSendQuickMatchResultResponse::Swap(RequestSendQuickMatchResultResponse* other) {
  if (other != this) {
    std::swap(unknown_1_, other->unknown_1_);
    std::swap(new_local_rank_, other->new_local_rank_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestSendQuickMatchResultResponse::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestSendQuickMatchResultResponse";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RequestPushSendQuickMatchStart::RequestPushSendQuickMatchStart()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestPushSendQuickMatchStart)
}

void RequestPushSendQuickMatchStart::InitAsDefaultInstance() {
}

RequestPushSendQuickMatchStart::RequestPushSendQuickMatchStart(const RequestPushSendQuickMatchStart& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestPushSendQuickMatchStart)
}

void RequestPushSendQuickMatchStart::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestPushSendQuickMatchStart::~RequestPushSendQuickMatchStart() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestPushSendQuickMatchStart)
  SharedDtor();
}

void RequestPushSendQuickMatchStart::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestPushSendQuickMatchStart::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestPushSendQuickMatchStart& RequestPushSendQuickMatchStart::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestPushSendQuickMatchStart* RequestPushSendQuickMatchStart::default_instance_ = NULL;

RequestPushSendQuickMatchStart* RequestPushSendQuickMatchStart::New() const {
  return new RequestPushSendQuickMatchStart;
}

void RequestPushSendQuickMatchStart::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestPushSendQuickMatchStart::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestPushSendQuickMatchStart)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestPushSendQuickMatchStart)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestPushSendQuickMatchStart)
  return false;
#undef DO_
}

void RequestPushSendQuickMatchStart::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestPushSendQuickMatchStart)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestPushSendQuickMatchStart)
}

int RequestPushSendQuickMatchStart::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestPushSendQuickMatchStart::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestPushSendQuickMatchStart*>(&from));
}

void RequestPushSendQuickMatchStart::MergeFrom(const RequestPushSendQuickMatchStart& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestPushSendQuickMatchStart::CopyFrom(const RequestPushSendQuickMatchStart& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestPushSendQuickMatchStart::IsInitialized() const {

  return true;
}

void RequestPushSendQuickMatchStart::Swap(RequestPushSendQuickMatchStart* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestPushSendQuickMatchStart::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestPushSendQuickMatchStart";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RitualMarkData::RitualMarkData()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RitualMarkData)
}

void RitualMarkData::InitAsDefaultInstance() {
}

RitualMarkData::RitualMarkData(const RitualMarkData& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RitualMarkData)
}

void RitualMarkData::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RitualMarkData::~RitualMarkData() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RitualMarkData)
  SharedDtor();
}

void RitualMarkData::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RitualMarkData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RitualMarkData& RitualMarkData::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RitualMarkData* RitualMarkData::default_instance_ = NULL;

RitualMarkData* RitualMarkData::New() const {
  return new RitualMarkData;
}

void RitualMarkData::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RitualMarkData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RitualMarkData)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RitualMarkData)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RitualMarkData)
  return false;
#undef DO_
}

void RitualMarkData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RitualMarkData)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RitualMarkData)
}

int RitualMarkData::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RitualMarkData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RitualMarkData*>(&from));
}

void RitualMarkData::MergeFrom(const RitualMarkData& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RitualMarkData::CopyFrom(const RitualMarkData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RitualMarkData::IsInitialized() const {

  return true;
}

void RitualMarkData::Swap(RitualMarkData* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RitualMarkData::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RitualMarkData";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

LocatedRitualMark::LocatedRitualMark()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.LocatedRitualMark)
}

void LocatedRitualMark::InitAsDefaultInstance() {
}

LocatedRitualMark::LocatedRitualMark(const LocatedRitualMark& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.LocatedRitualMark)
}

void LocatedRitualMark::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LocatedRitualMark::~LocatedRitualMark() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.LocatedRitualMark)
  SharedDtor();
}

void LocatedRitualMark::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void LocatedRitualMark::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const LocatedRitualMark& LocatedRitualMark::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

LocatedRitualMark* LocatedRitualMark::default_instance_ = NULL;

LocatedRitualMark* LocatedRitualMark::New() const {
  return new LocatedRitualMark;
}

void LocatedRitualMark::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool LocatedRitualMark::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.LocatedRitualMark)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.LocatedRitualMark)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.LocatedRitualMark)
  return false;
#undef DO_
}

void LocatedRitualMark::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.LocatedRitualMark)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.LocatedRitualMark)
}

int LocatedRitualMark::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LocatedRitualMark::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const LocatedRitualMark*>(&from));
}

void LocatedRitualMark::MergeFrom(const LocatedRitualMark& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void LocatedRitualMark::CopyFrom(const LocatedRitualMark& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LocatedRitualMark::IsInitialized() const {

  return true;
}

void LocatedRitualMark::Swap(LocatedRitualMark* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string LocatedRitualMark::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.LocatedRitualMark";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RitualMarkDomainLimit::RitualMarkDomainLimit()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RitualMarkDomainLimit)
}

void RitualMarkDomainLimit::InitAsDefaultInstance() {
}

RitualMarkDomainLimit::RitualMarkDomainLimit(const RitualMarkDomainLimit& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RitualMarkDomainLimit)
}

void RitualMarkDomainLimit::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RitualMarkDomainLimit::~RitualMarkDomainLimit() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RitualMarkDomainLimit)
  SharedDtor();
}

void RitualMarkDomainLimit::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RitualMarkDomainLimit::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RitualMarkDomainLimit& RitualMarkDomainLimit::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RitualMarkDomainLimit* RitualMarkDomainLimit::default_instance_ = NULL;

RitualMarkDomainLimit* RitualMarkDomainLimit::New() const {
  return new RitualMarkDomainLimit;
}

void RitualMarkDomainLimit::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RitualMarkDomainLimit::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RitualMarkDomainLimit)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RitualMarkDomainLimit)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RitualMarkDomainLimit)
  return false;
#undef DO_
}

void RitualMarkDomainLimit::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RitualMarkDomainLimit)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RitualMarkDomainLimit)
}

int RitualMarkDomainLimit::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RitualMarkDomainLimit::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RitualMarkDomainLimit*>(&from));
}

void RitualMarkDomainLimit::MergeFrom(const RitualMarkDomainLimit& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RitualMarkDomainLimit::CopyFrom(const RitualMarkDomainLimit& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RitualMarkDomainLimit::IsInitialized() const {

  return true;
}

void RitualMarkDomainLimit::Swap(RitualMarkDomainLimit* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RitualMarkDomainLimit::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RitualMarkDomainLimit";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RequestCreateMark::RequestCreateMark()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestCreateMark)
}

void RequestCreateMark::InitAsDefaultInstance() {
}

RequestCreateMark::RequestCreateMark(const RequestCreateMark& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestCreateMark)
}

void RequestCreateMark::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestCreateMark::~RequestCreateMark() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestCreateMark)
  SharedDtor();
}

void RequestCreateMark::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestCreateMark::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestCreateMark& RequestCreateMark::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestCreateMark* RequestCreateMark::default_instance_ = NULL;

RequestCreateMark* RequestCreateMark::New() const {
  return new RequestCreateMark;
}

void RequestCreateMark::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestCreateMark::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestCreateMark)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestCreateMark)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestCreateMark)
  return false;
#undef DO_
}

void RequestCreateMark::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestCreateMark)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestCreateMark)
}

int RequestCreateMark::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestCreateMark::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestCreateMark*>(&from));
}

void RequestCreateMark::MergeFrom(const RequestCreateMark& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestCreateMark::CopyFrom(const RequestCreateMark& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestCreateMark::IsInitialized() const {

  return true;
}

void RequestCreateMark::Swap(RequestCreateMark* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestCreateMark::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestCreateMark";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RequestCreateMarkResponse::RequestCreateMarkResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestCreateMarkResponse)
}

void RequestCreateMarkResponse::InitAsDefaultInstance() {
}

RequestCreateMarkResponse::RequestCreateMarkResponse(const RequestCreateMarkResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestCreateMarkResponse)
}

void RequestCreateMarkResponse::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestCreateMarkResponse::~RequestCreateMarkResponse() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestCreateMarkResponse)
  SharedDtor();
}

void RequestCreateMarkResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestCreateMarkResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestCreateMarkResponse& RequestCreateMarkResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestCreateMarkResponse* RequestCreateMarkResponse::default_instance_ = NULL;

RequestCreateMarkResponse* RequestCreateMarkResponse::New() const {
  return new RequestCreateMarkResponse;
}

void RequestCreateMarkResponse::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestCreateMarkResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestCreateMarkResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestCreateMarkResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestCreateMarkResponse)
  return false;
#undef DO_
}

void RequestCreateMarkResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestCreateMarkResponse)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestCreateMarkResponse)
}

int RequestCreateMarkResponse::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestCreateMarkResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestCreateMarkResponse*>(&from));
}

void RequestCreateMarkResponse::MergeFrom(const RequestCreateMarkResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestCreateMarkResponse::CopyFrom(const RequestCreateMarkResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestCreateMarkResponse::IsInitialized() const {

  return true;
}

void RequestCreateMarkResponse::Swap(RequestCreateMarkResponse* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestCreateMarkResponse::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestCreateMarkResponse";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RequestRemoveMark::RequestRemoveMark()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestRemoveMark)
}

void RequestRemoveMark::InitAsDefaultInstance() {
}

RequestRemoveMark::RequestRemoveMark(const RequestRemoveMark& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestRemoveMark)
}

void RequestRemoveMark::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestRemoveMark::~RequestRemoveMark() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestRemoveMark)
  SharedDtor();
}

void RequestRemoveMark::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestRemoveMark::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestRemoveMark& RequestRemoveMark::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestRemoveMark* RequestRemoveMark::default_instance_ = NULL;

RequestRemoveMark* RequestRemoveMark::New() const {
  return new RequestRemoveMark;
}

void RequestRemoveMark::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestRemoveMark::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestRemoveMark)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestRemoveMark)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestRemoveMark)
  return false;
#undef DO_
}

void RequestRemoveMark::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestRemoveMark)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestRemoveMark)
}

int RequestRemoveMark::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestRemoveMark::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestRemoveMark*>(&from));
}

void RequestRemoveMark::MergeFrom(const RequestRemoveMark& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestRemoveMark::CopyFrom(const RequestRemoveMark& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestRemoveMark::IsInitialized() const {

  return true;
}

void RequestRemoveMark::Swap(RequestRemoveMark* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestRemoveMark::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestRemoveMark";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RequestRemoveMarkResponse::RequestRemoveMarkResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestRemoveMarkResponse)
}

void RequestRemoveMarkResponse::InitAsDefaultInstance() {
}

RequestRemoveMarkResponse::RequestRemoveMarkResponse(const RequestRemoveMarkResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestRemoveMarkResponse)
}

void RequestRemoveMarkResponse::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestRemoveMarkResponse::~RequestRemoveMarkResponse() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestRemoveMarkResponse)
  SharedDtor();
}

void RequestRemoveMarkResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestRemoveMarkResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestRemoveMarkResponse& RequestRemoveMarkResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestRemoveMarkResponse* RequestRemoveMarkResponse::default_instance_ = NULL;

RequestRemoveMarkResponse* RequestRemoveMarkResponse::New() const {
  return new RequestRemoveMarkResponse;
}

void RequestRemoveMarkResponse::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestRemoveMarkResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestRemoveMarkResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestRemoveMarkResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestRemoveMarkResponse)
  return false;
#undef DO_
}

void RequestRemoveMarkResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestRemoveMarkResponse)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestRemoveMarkResponse)
}

int RequestRemoveMarkResponse::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestRemoveMarkResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestRemoveMarkResponse*>(&from));
}

void RequestRemoveMarkResponse::MergeFrom(const RequestRemoveMarkResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestRemoveMarkResponse::CopyFrom(const RequestRemoveMarkResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestRemoveMarkResponse::IsInitialized() const {

  return true;
}

void RequestRemoveMarkResponse::Swap(RequestRemoveMarkResponse* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestRemoveMarkResponse::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestRemoveMarkResponse";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RequestReentryMark::RequestReentryMark()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestReentryMark)
}

void RequestReentryMark::InitAsDefaultInstance() {
}

RequestReentryMark::RequestReentryMark(const RequestReentryMark& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestReentryMark)
}

void RequestReentryMark::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestReentryMark::~RequestReentryMark() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestReentryMark)
  SharedDtor();
}

void RequestReentryMark::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestReentryMark::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestReentryMark& RequestReentryMark::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestReentryMark* RequestReentryMark::default_instance_ = NULL;

RequestReentryMark* RequestReentryMark::New() const {
  return new RequestReentryMark;
}

void RequestReentryMark::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestReentryMark::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestReentryMark)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestReentryMark)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestReentryMark)
  return false;
#undef DO_
}

void RequestReentryMark::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestReentryMark)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestReentryMark)
}

int RequestReentryMark::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestReentryMark::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestReentryMark*>(&from));
}

void RequestReentryMark::MergeFrom(const RequestReentryMark& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestReentryMark::CopyFrom(const RequestReentryMark& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestReentryMark::IsInitialized() const {

  return true;
}

void RequestReentryMark::Swap(RequestReentryMark* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestReentryMark::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestReentryMark";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RequestReentryMarkResponse::RequestReentryMarkResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestReentryMarkResponse)
}

void RequestReentryMarkResponse::InitAsDefaultInstance() {
}

RequestReentryMarkResponse::RequestReentryMarkResponse(const RequestReentryMarkResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestReentryMarkResponse)
}

void RequestReentryMarkResponse::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestReentryMarkResponse::~RequestReentryMarkResponse() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestReentryMarkResponse)
  SharedDtor();
}

void RequestReentryMarkResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestReentryMarkResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestReentryMarkResponse& RequestReentryMarkResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestReentryMarkResponse* RequestReentryMarkResponse::default_instance_ = NULL;

RequestReentryMarkResponse* RequestReentryMarkResponse::New() const {
  return new RequestReentryMarkResponse;
}

void RequestReentryMarkResponse::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestReentryMarkResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestReentryMarkResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestReentryMarkResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestReentryMarkResponse)
  return false;
#undef DO_
}

void RequestReentryMarkResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestReentryMarkResponse)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestReentryMarkResponse)
}

int RequestReentryMarkResponse::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestReentryMarkResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestReentryMarkResponse*>(&from));
}

void RequestReentryMarkResponse::MergeFrom(const RequestReentryMarkResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestReentryMarkResponse::CopyFrom(const RequestReentryMarkResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestReentryMarkResponse::IsInitialized() const {

  return true;
}

void RequestReentryMarkResponse::Swap(RequestReentryMarkResponse* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestReentryMarkResponse::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestReentryMarkResponse";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RequestGetMarkList::RequestGetMarkList()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestGetMarkList)
}

void RequestGetMarkList::InitAsDefaultInstance() {
}

RequestGetMarkList::RequestGetMarkList(const RequestGetMarkList& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestGetMarkList)
}

void RequestGetMarkList::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestGetMarkList::~RequestGetMarkList() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestGetMarkList)
  SharedDtor();
}

void RequestGetMarkList::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestGetMarkList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestGetMarkList& RequestGetMarkList::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestGetMarkList* RequestGetMarkList::default_instance_ = NULL;

RequestGetMarkList* RequestGetMarkList::New() const {
  return new RequestGetMarkList;
}

void RequestGetMarkList::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestGetMarkList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestGetMarkList)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestGetMarkList)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestGetMarkList)
  return false;
#undef DO_
}

void RequestGetMarkList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestGetMarkList)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestGetMarkList)
}

int RequestGetMarkList::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestGetMarkList::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestGetMarkList*>(&from));
}

void RequestGetMarkList::MergeFrom(const RequestGetMarkList& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestGetMarkList::CopyFrom(const RequestGetMarkList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestGetMarkList::IsInitialized() const {

  return true;
}

void RequestGetMarkList::Swap(RequestGetMarkList* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestGetMarkList::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestGetMarkList";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RequestGetMarkListResponse::RequestGetMarkListResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestGetMarkListResponse)
}

void RequestGetMarkListResponse::InitAsDefaultInstance() {
}

RequestGetMarkListResponse::RequestGetMarkListResponse(const RequestGetMarkListResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestGetMarkListResponse)
}

void RequestGetMarkListResponse::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestGetMarkListResponse::~RequestGetMarkListResponse() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestGetMarkListResponse)
  SharedDtor();
}

void RequestGetMarkListResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestGetMarkListResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestGetMarkListResponse& RequestGetMarkListResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestGetMarkListResponse* RequestGetMarkListResponse::default_instance_ = NULL;

RequestGetMarkListResponse* RequestGetMarkListResponse::New() const {
  return new RequestGetMarkListResponse;
}

void RequestGetMarkListResponse::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestGetMarkListResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestGetMarkListResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestGetMarkListResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestGetMarkListResponse)
  return false;
#undef DO_
}

void RequestGetMarkListResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestGetMarkListResponse)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestGetMarkListResponse)
}

int RequestGetMarkListResponse::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestGetMarkListResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestGetMarkListResponse*>(&from));
}

void RequestGetMarkListResponse::MergeFrom(const RequestGetMarkListResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestGetMarkListResponse::CopyFrom(const RequestGetMarkListResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestGetMarkListResponse::IsInitialized() const {

  return true;
}

void RequestGetMarkListResponse::Swap(RequestGetMarkListResponse* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestGetMarkListResponse::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestGetMarkListResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int PushRequestHeader::kPushMessageIdFieldNumber;
#endif  // !_MSC_VER

PushRequestHeader::PushRequestHeader()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.PushRequestHeader)
}

void PushRequestHeader::InitAsDefaultInstance() {
}

PushRequestHeader::PushRequestHeader(const PushRequestHeader& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.PushRequestHeader)
}

void PushRequestHeader::SharedCtor() {
  _cached_size_ = 0;
  push_message_id_ = 829;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PushRequestHeader::~PushRequestHeader() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.PushRequestHeader)
  SharedDtor();
}

void PushRequestHeader::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void PushRequestHeader::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PushRequestHeader& PushRequestHeader::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

PushRequestHeader* PushRequestHeader::default_instance_ = NULL;

PushRequestHeader* PushRequestHeader::New() const {
  return new PushRequestHeader;
}

void PushRequestHeader::Clear() {
  push_message_id_ = 829;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool PushRequestHeader::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.PushRequestHeader)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::DS3_Frpg2RequestMessage::PushMessageId_IsValid(value)) {
            set_push_message_id(static_cast< ::DS3_Frpg2RequestMessage::PushMessageId >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.PushRequestHeader)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.PushRequestHeader)
  return false;
#undef DO_
}

void PushRequestHeader::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.PushRequestHeader)
  // required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
  if (has_push_message_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->push_message_id(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.PushRequestHeader)
}

int PushRequestHeader::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
    if (has_push_message_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->push_message_id());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PushRequestHeader::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PushRequestHeader*>(&from));
}

void PushRequestHeader::MergeFrom(const PushRequestHeader& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_push_message_id()) {
      set_push_message_id(from.push_message_id());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void PushRequestHeader::CopyFrom(const PushRequestHeader& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PushRequestHeader::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void PushRequestHeader::Swap(PushRequestHeader* other) {
  if (other != this) {
    std::swap(push_message_id_, other->push_message_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PushRequestHeader::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.PushRequestHeader";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RangedLimit::RangedLimit()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RangedLimit)
}

void RangedLimit::InitAsDefaultInstance() {
}

RangedLimit::RangedLimit(const RangedLimit& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RangedLimit)
}

void RangedLimit::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RangedLimit::~RangedLimit() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RangedLimit)
  SharedDtor();
}

void RangedLimit::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RangedLimit::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RangedLimit& RangedLimit::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RangedLimit* RangedLimit::default_instance_ = NULL;

RangedLimit* RangedLimit::New() const {
  return new RangedLimit;
}

void RangedLimit::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RangedLimit::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RangedLimit)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RangedLimit)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RangedLimit)
  return false;
#undef DO_
}

void RangedLimit::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RangedLimit)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RangedLimit)
}

int RangedLimit::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RangedLimit::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RangedLimit*>(&from));
}

void RangedLimit::MergeFrom(const RangedLimit& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RangedLimit::CopyFrom(const RangedLimit& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RangedLimit::IsInitialized() const {

  return true;
}

void RangedLimit::Swap(RangedLimit* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RangedLimit::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RangedLimit";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

PlayerUserIDPair::PlayerUserIDPair()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.PlayerUserIDPair)
}

void PlayerUserIDPair::InitAsDefaultInstance() {
}

PlayerUserIDPair::PlayerUserIDPair(const PlayerUserIDPair& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.PlayerUserIDPair)
}

void PlayerUserIDPair::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PlayerUserIDPair::~PlayerUserIDPair() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.PlayerUserIDPair)
  SharedDtor();
}

void PlayerUserIDPair::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void PlayerUserIDPair::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PlayerUserIDPair& PlayerUserIDPair::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

PlayerUserIDPair* PlayerUserIDPair::default_instance_ = NULL;

PlayerUserIDPair* PlayerUserIDPair::New() const {
  return new PlayerUserIDPair;
}

void PlayerUserIDPair::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool PlayerUserIDPair::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.PlayerUserIDPair)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.PlayerUserIDPair)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.PlayerUserIDPair)
  return false;
#undef DO_
}

void PlayerUserIDPair::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.PlayerUserIDPair)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.PlayerUserIDPair)
}

int PlayerUserIDPair::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PlayerUserIDPair::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PlayerUserIDPair*>(&from));
}

void PlayerUserIDPair::MergeFrom(const PlayerUserIDPair& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void PlayerUserIDPair::CopyFrom(const PlayerUserIDPair& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlayerUserIDPair::IsInitialized() const {

  return true;
}

void PlayerUserIDPair::Swap(PlayerUserIDPair* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PlayerUserIDPair::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.PlayerUserIDPair";
}


// ===================================================================

#ifndef _MSC_VER
const int ManagementTextMessage::kPushMessageIdFieldNumber;
const int ManagementTextMessage::kMessageFieldNumber;
const int ManagementTextMessage::kTimestampFieldNumber;
const int ManagementTextMessage::kUnknown4FieldNumber;
const int ManagementTextMessage::kUnknown5FieldNumber;
#endif  // !_MSC_VER

ManagementTextMessage::ManagementTextMessage()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.ManagementTextMessage)
}

void ManagementTextMessage::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  timestamp_ = const_cast< ::DS3_Frpg2PlayerData::DateTime*>(
      ::DS3_Frpg2PlayerData::DateTime::internal_default_instance());
#else
  timestamp_ = const_cast< ::DS3_Frpg2PlayerData::DateTime*>(&::DS3_Frpg2PlayerData::DateTime::default_instance());
#endif
}

ManagementTextMessage::ManagementTextMessage(const ManagementTextMessage& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.ManagementTextMessage)
}

void ManagementTextMessage::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  push_message_id_ = 829;
  message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  timestamp_ = NULL;
  unknown_4_ = 0u;
  unknown_5_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ManagementTextMessage::~ManagementTextMessage() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.ManagementTextMessage)
  SharedDtor();
}

void ManagementTextMessage::SharedDtor() {
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete message_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete timestamp_;
  }
}

void ManagementTextMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ManagementTextMessage& ManagementTextMessage::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

ManagementTextMessage* ManagementTextMessage::default_instance_ = NULL;

ManagementTextMessage* ManagementTextMessage::New() const {
  return new ManagementTextMessage;
}

void ManagementTextMessage::Clear() {
  if (_has_bits_[0 / 32] & 31) {
    push_message_id_ = 829;
    if (has_message()) {
      if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        message_->clear();
      }
    }
    if (has_timestamp()) {
      if (timestamp_ != NULL) timestamp_->::DS3_Frpg2PlayerData::DateTime::Clear();
    }
    unknown_4_ = 0u;
    unknown_5_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool ManagementTextMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.ManagementTextMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::DS3_Frpg2RequestMessage::PushMessageId_IsValid(value)) {
            set_push_message_id(static_cast< ::DS3_Frpg2RequestMessage::PushMessageId >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_message;
        break;
      }

      // required string message = 2;
      case 2: {
        if (tag == 18) {
         parse_message:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_message()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_timestamp;
        break;
      }

      // required .DS3_Frpg2PlayerData.DateTime timestamp = 3;
      case 3: {
        if (tag == 26) {
         parse_timestamp:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_timestamp()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_unknown_4;
        break;
      }

      // required uint32 unknown_4 = 4;
      case 4: {
        if (tag == 32) {
         parse_unknown_4:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_4_)));
          set_has_unknown_4();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_unknown_5;
        break;
      }

      // required uint32 unknown_5 = 5;
      case 5: {
        if (tag == 40) {
         parse_unknown_5:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_5_)));
          set_has_unknown_5();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.ManagementTextMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.ManagementTextMessage)
  return false;
#undef DO_
}

void ManagementTextMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.ManagementTextMessage)
  // required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
  if (has_push_message_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->push_message_id(), output);
  }

  // required string message = 2;
  if (has_message()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->message(), output);
  }

  // required .DS3_Frpg2PlayerData.DateTime timestamp = 3;
  if (has_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->timestamp(), output);
  }

  // required uint32 unknown_4 = 4;
  if (has_unknown_4()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->unknown_4(), output);
  }

  // required uint32 unknown_5 = 5;
  if (has_unknown_5()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->unknown_5(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.ManagementTextMessage)
}

int ManagementTextMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .DS3_Frpg2RequestMessage.PushMessageId push_message_id = 1;
    if (has_push_message_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->push_message_id());
    }

    // required string message = 2;
    if (has_message()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->message());
    }

    // required .DS3_Frpg2PlayerData.DateTime timestamp = 3;
    if (has_timestamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->timestamp());
    }

    // required uint32 unknown_4 = 4;
    if (has_unknown_4()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_4());
    }

    // required uint32 unknown_5 = 5;
    if (has_unknown_5()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_5());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ManagementTextMessage::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ManagementTextMessage*>(&from));
}

void ManagementTextMessage::MergeFrom(const ManagementTextMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_push_message_id()) {
      set_push_message_id(from.push_message_id());
    }
    if (from.has_message()) {
      set_message(from.message());
    }
    if (from.has_timestamp()) {
      mutable_timestamp()->::DS3_Frpg2PlayerData::DateTime::MergeFrom(from.timestamp());
    }
    if (from.has_unknown_4()) {
      set_unknown_4(from.unknown_4());
    }
    if (from.has_unknown_5()) {
      set_unknown_5(from.unknown_5());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void ManagementTextMessage::CopyFrom(const ManagementTextMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ManagementTextMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;

  if (has_timestamp()) {
    if (!this->timestamp().IsInitialized()) return false;
  }
  return true;
}

void ManagementTextMessage::Swap(ManagementTextMessage* other) {
  if (other != this) {
    std::swap(push_message_id_, other->push_message_id_);
    std::swap(message_, other->message_);
    std::swap(timestamp_, other->timestamp_);
    std::swap(unknown_4_, other->unknown_4_);
    std::swap(unknown_5_, other->unknown_5_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ManagementTextMessage::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.ManagementTextMessage";
}


// ===================================================================

#ifndef _MSC_VER
const int NRLogUploadRequest::kUnknown1FieldNumber;
const int NRLogUploadRequest::kUnknown2FieldNumber;
#endif  // !_MSC_VER

NRLogUploadRequest::NRLogUploadRequest()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.NRLogUploadRequest)
}

void NRLogUploadRequest::InitAsDefaultInstance() {
}

NRLogUploadRequest::NRLogUploadRequest(const NRLogUploadRequest& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.NRLogUploadRequest)
}

void NRLogUploadRequest::SharedCtor() {
  _cached_size_ = 0;
  unknown_1_ = 0u;
  unknown_2_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NRLogUploadRequest::~NRLogUploadRequest() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.NRLogUploadRequest)
  SharedDtor();
}

void NRLogUploadRequest::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void NRLogUploadRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const NRLogUploadRequest& NRLogUploadRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

NRLogUploadRequest* NRLogUploadRequest::default_instance_ = NULL;

NRLogUploadRequest* NRLogUploadRequest::New() const {
  return new NRLogUploadRequest;
}

void NRLogUploadRequest::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<NRLogUploadRequest*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(unknown_1_, unknown_2_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool NRLogUploadRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.NRLogUploadRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 unknown_1 = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_1_)));
          set_has_unknown_1();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_unknown_2;
        break;
      }

      // required uint32 unknown_2 = 2;
      case 2: {
        if (tag == 16) {
         parse_unknown_2:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_2_)));
          set_has_unknown_2();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.NRLogUploadRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.NRLogUploadRequest)
  return false;
#undef DO_
}

void NRLogUploadRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.NRLogUploadRequest)
  // required uint32 unknown_1 = 1;
  if (has_unknown_1()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->unknown_1(), output);
  }

  // required uint32 unknown_2 = 2;
  if (has_unknown_2()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->unknown_2(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.NRLogUploadRequest)
}

int NRLogUploadRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 unknown_1 = 1;
    if (has_unknown_1()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_1());
    }

    // required uint32 unknown_2 = 2;
    if (has_unknown_2()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_2());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NRLogUploadRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const NRLogUploadRequest*>(&from));
}

void NRLogUploadRequest::MergeFrom(const NRLogUploadRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_unknown_1()) {
      set_unknown_1(from.unknown_1());
    }
    if (from.has_unknown_2()) {
      set_unknown_2(from.unknown_2());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void NRLogUploadRequest::CopyFrom(const NRLogUploadRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NRLogUploadRequest::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void NRLogUploadRequest::Swap(NRLogUploadRequest* other) {
  if (other != this) {
    std::swap(unknown_1_, other->unknown_1_);
    std::swap(unknown_2_, other->unknown_2_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string NRLogUploadRequest::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.NRLogUploadRequest";
}


// ===================================================================

#ifndef _MSC_VER
const int NRLoggingMessage::kUnknown1FieldNumber;
const int NRLoggingMessage::kUnknown2FieldNumber;
#endif  // !_MSC_VER

NRLoggingMessage::NRLoggingMessage()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.NRLoggingMessage)
}

void NRLoggingMessage::InitAsDefaultInstance() {
}

NRLoggingMessage::NRLoggingMessage(const NRLoggingMessage& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.NRLoggingMessage)
}

void NRLoggingMessage::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  unknown_1_ = 0u;
  unknown_2_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NRLoggingMessage::~NRLoggingMessage() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.NRLoggingMessage)
  SharedDtor();
}

void NRLoggingMessage::SharedDtor() {
  if (unknown_2_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete unknown_2_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void NRLoggingMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const NRLoggingMessage& NRLoggingMessage::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

NRLoggingMessage* NRLoggingMessage::default_instance_ = NULL;

NRLoggingMessage* NRLoggingMessage::New() const {
  return new NRLoggingMessage;
}

void NRLoggingMessage::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    unknown_1_ = 0u;
    if (has_unknown_2()) {
      if (unknown_2_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        unknown_2_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool NRLoggingMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.NRLoggingMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 unknown_1 = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_1_)));
          set_has_unknown_1();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_unknown_2;
        break;
      }

      // required bytes unknown_2 = 2;
      case 2: {
        if (tag == 18) {
         parse_unknown_2:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_unknown_2()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.NRLoggingMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.NRLoggingMessage)
  return false;
#undef DO_
}

void NRLoggingMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.NRLoggingMessage)
  // required uint32 unknown_1 = 1;
  if (has_unknown_1()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->unknown_1(), output);
  }

  // required bytes unknown_2 = 2;
  if (has_unknown_2()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->unknown_2(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.NRLoggingMessage)
}

int NRLoggingMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 unknown_1 = 1;
    if (has_unknown_1()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_1());
    }

    // required bytes unknown_2 = 2;
    if (has_unknown_2()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->unknown_2());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NRLoggingMessage::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const NRLoggingMessage*>(&from));
}

void NRLoggingMessage::MergeFrom(const NRLoggingMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_unknown_1()) {
      set_unknown_1(from.unknown_1());
    }
    if (from.has_unknown_2()) {
      set_unknown_2(from.unknown_2());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void NRLoggingMessage::CopyFrom(const NRLoggingMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NRLoggingMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void NRLoggingMessage::Swap(NRLoggingMessage* other) {
  if (other != this) {
    std::swap(unknown_1_, other->unknown_1_);
    std::swap(unknown_2_, other->unknown_2_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string NRLoggingMessage::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.NRLoggingMessage";
}


// ===================================================================

#ifndef _MSC_VER
const int ServerPing::kUnknown1FieldNumber;
#endif  // !_MSC_VER

ServerPing::ServerPing()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.ServerPing)
}

void ServerPing::InitAsDefaultInstance() {
}

ServerPing::ServerPing(const ServerPing& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.ServerPing)
}

void ServerPing::SharedCtor() {
  _cached_size_ = 0;
  unknown_1_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ServerPing::~ServerPing() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.ServerPing)
  SharedDtor();
}

void ServerPing::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ServerPing::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ServerPing& ServerPing::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

ServerPing* ServerPing::default_instance_ = NULL;

ServerPing* ServerPing::New() const {
  return new ServerPing;
}

void ServerPing::Clear() {
  unknown_1_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool ServerPing::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.ServerPing)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 unknown_1 = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_1_)));
          set_has_unknown_1();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.ServerPing)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.ServerPing)
  return false;
#undef DO_
}

void ServerPing::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.ServerPing)
  // required uint32 unknown_1 = 1;
  if (has_unknown_1()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->unknown_1(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.ServerPing)
}

int ServerPing::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 unknown_1 = 1;
    if (has_unknown_1()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_1());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ServerPing::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ServerPing*>(&from));
}

void ServerPing::MergeFrom(const ServerPing& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_unknown_1()) {
      set_unknown_1(from.unknown_1());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void ServerPing::CopyFrom(const ServerPing& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ServerPing::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ServerPing::Swap(ServerPing* other) {
  if (other != this) {
    std::swap(unknown_1_, other->unknown_1_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ServerPing::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.ServerPing";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RequestGetOnlineShopItemList::RequestGetOnlineShopItemList()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestGetOnlineShopItemList)
}

void RequestGetOnlineShopItemList::InitAsDefaultInstance() {
}

RequestGetOnlineShopItemList::RequestGetOnlineShopItemList(const RequestGetOnlineShopItemList& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestGetOnlineShopItemList)
}

void RequestGetOnlineShopItemList::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestGetOnlineShopItemList::~RequestGetOnlineShopItemList() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestGetOnlineShopItemList)
  SharedDtor();
}

void RequestGetOnlineShopItemList::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestGetOnlineShopItemList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestGetOnlineShopItemList& RequestGetOnlineShopItemList::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestGetOnlineShopItemList* RequestGetOnlineShopItemList::default_instance_ = NULL;

RequestGetOnlineShopItemList* RequestGetOnlineShopItemList::New() const {
  return new RequestGetOnlineShopItemList;
}

void RequestGetOnlineShopItemList::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestGetOnlineShopItemList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestGetOnlineShopItemList)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestGetOnlineShopItemList)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestGetOnlineShopItemList)
  return false;
#undef DO_
}

void RequestGetOnlineShopItemList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestGetOnlineShopItemList)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestGetOnlineShopItemList)
}

int RequestGetOnlineShopItemList::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestGetOnlineShopItemList::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestGetOnlineShopItemList*>(&from));
}

void RequestGetOnlineShopItemList::MergeFrom(const RequestGetOnlineShopItemList& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestGetOnlineShopItemList::CopyFrom(const RequestGetOnlineShopItemList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestGetOnlineShopItemList::IsInitialized() const {

  return true;
}

void RequestGetOnlineShopItemList::Swap(RequestGetOnlineShopItemList* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestGetOnlineShopItemList::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestGetOnlineShopItemList";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RequestGetOnlineShopItemListResponse_Lineup::RequestGetOnlineShopItemListResponse_Lineup()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestGetOnlineShopItemListResponse.Lineup)
}

void RequestGetOnlineShopItemListResponse_Lineup::InitAsDefaultInstance() {
}

RequestGetOnlineShopItemListResponse_Lineup::RequestGetOnlineShopItemListResponse_Lineup(const RequestGetOnlineShopItemListResponse_Lineup& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestGetOnlineShopItemListResponse.Lineup)
}

void RequestGetOnlineShopItemListResponse_Lineup::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestGetOnlineShopItemListResponse_Lineup::~RequestGetOnlineShopItemListResponse_Lineup() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestGetOnlineShopItemListResponse.Lineup)
  SharedDtor();
}

void RequestGetOnlineShopItemListResponse_Lineup::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestGetOnlineShopItemListResponse_Lineup::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestGetOnlineShopItemListResponse_Lineup& RequestGetOnlineShopItemListResponse_Lineup::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestGetOnlineShopItemListResponse_Lineup* RequestGetOnlineShopItemListResponse_Lineup::default_instance_ = NULL;

RequestGetOnlineShopItemListResponse_Lineup* RequestGetOnlineShopItemListResponse_Lineup::New() const {
  return new RequestGetOnlineShopItemListResponse_Lineup;
}

void RequestGetOnlineShopItemListResponse_Lineup::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestGetOnlineShopItemListResponse_Lineup::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestGetOnlineShopItemListResponse.Lineup)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestGetOnlineShopItemListResponse.Lineup)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestGetOnlineShopItemListResponse.Lineup)
  return false;
#undef DO_
}

void RequestGetOnlineShopItemListResponse_Lineup::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestGetOnlineShopItemListResponse.Lineup)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestGetOnlineShopItemListResponse.Lineup)
}

int RequestGetOnlineShopItemListResponse_Lineup::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestGetOnlineShopItemListResponse_Lineup::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestGetOnlineShopItemListResponse_Lineup*>(&from));
}

void RequestGetOnlineShopItemListResponse_Lineup::MergeFrom(const RequestGetOnlineShopItemListResponse_Lineup& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestGetOnlineShopItemListResponse_Lineup::CopyFrom(const RequestGetOnlineShopItemListResponse_Lineup& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestGetOnlineShopItemListResponse_Lineup::IsInitialized() const {

  return true;
}

void RequestGetOnlineShopItemListResponse_Lineup::Swap(RequestGetOnlineShopItemListResponse_Lineup* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestGetOnlineShopItemListResponse_Lineup::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestGetOnlineShopItemListResponse.Lineup";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int RequestGetOnlineShopItemListResponse::kLineupFieldNumber;
#endif  // !_MSC_VER

RequestGetOnlineShopItemListResponse::RequestGetOnlineShopItemListResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestGetOnlineShopItemListResponse)
}

void RequestGetOnlineShopItemListResponse::InitAsDefaultInstance() {
}

RequestGetOnlineShopItemListResponse::RequestGetOnlineShopItemListResponse(const RequestGetOnlineShopItemListResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestGetOnlineShopItemListResponse)
}

void RequestGetOnlineShopItemListResponse::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestGetOnlineShopItemListResponse::~RequestGetOnlineShopItemListResponse() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestGetOnlineShopItemListResponse)
  SharedDtor();
}

void RequestGetOnlineShopItemListResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestGetOnlineShopItemListResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestGetOnlineShopItemListResponse& RequestGetOnlineShopItemListResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestGetOnlineShopItemListResponse* RequestGetOnlineShopItemListResponse::default_instance_ = NULL;

RequestGetOnlineShopItemListResponse* RequestGetOnlineShopItemListResponse::New() const {
  return new RequestGetOnlineShopItemListResponse;
}

void RequestGetOnlineShopItemListResponse::Clear() {
  lineup_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestGetOnlineShopItemListResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestGetOnlineShopItemListResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated group Lineup = 2 {
      case 2: {
        if (tag == 19) {
         parse_lineup:
          DO_(::google::protobuf::internal::WireFormatLite::ReadGroupNoVirtual(
                2, input, add_lineup()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(19)) goto parse_lineup;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestGetOnlineShopItemListResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestGetOnlineShopItemListResponse)
  return false;
#undef DO_
}

void RequestGetOnlineShopItemListResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestGetOnlineShopItemListResponse)
  // repeated group Lineup = 2 {
  for (int i = 0; i < this->lineup_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteGroup(
      2, this->lineup(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestGetOnlineShopItemListResponse)
}

int RequestGetOnlineShopItemListResponse::ByteSize() const {
  int total_size = 0;

  // repeated group Lineup = 2 {
  total_size += 2 * this->lineup_size();
  for (int i = 0; i < this->lineup_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::GroupSizeNoVirtual(
        this->lineup(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestGetOnlineShopItemListResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestGetOnlineShopItemListResponse*>(&from));
}

void RequestGetOnlineShopItemListResponse::MergeFrom(const RequestGetOnlineShopItemListResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  lineup_.MergeFrom(from.lineup_);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestGetOnlineShopItemListResponse::CopyFrom(const RequestGetOnlineShopItemListResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestGetOnlineShopItemListResponse::IsInitialized() const {

  return true;
}

void RequestGetOnlineShopItemListResponse::Swap(RequestGetOnlineShopItemListResponse* other) {
  if (other != this) {
    lineup_.Swap(&other->lineup_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestGetOnlineShopItemListResponse::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestGetOnlineShopItemListResponse";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

LoginForXboxOne::LoginForXboxOne()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.LoginForXboxOne)
}

void LoginForXboxOne::InitAsDefaultInstance() {
}

LoginForXboxOne::LoginForXboxOne(const LoginForXboxOne& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.LoginForXboxOne)
}

void LoginForXboxOne::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LoginForXboxOne::~LoginForXboxOne() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.LoginForXboxOne)
  SharedDtor();
}

void LoginForXboxOne::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void LoginForXboxOne::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const LoginForXboxOne& LoginForXboxOne::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

LoginForXboxOne* LoginForXboxOne::default_instance_ = NULL;

LoginForXboxOne* LoginForXboxOne::New() const {
  return new LoginForXboxOne;
}

void LoginForXboxOne::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool LoginForXboxOne::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.LoginForXboxOne)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.LoginForXboxOne)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.LoginForXboxOne)
  return false;
#undef DO_
}

void LoginForXboxOne::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.LoginForXboxOne)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.LoginForXboxOne)
}

int LoginForXboxOne::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LoginForXboxOne::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const LoginForXboxOne*>(&from));
}

void LoginForXboxOne::MergeFrom(const LoginForXboxOne& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void LoginForXboxOne::CopyFrom(const LoginForXboxOne& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoginForXboxOne::IsInitialized() const {

  return true;
}

void LoginForXboxOne::Swap(LoginForXboxOne* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string LoginForXboxOne::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.LoginForXboxOne";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

SocketOptionSetting::SocketOptionSetting()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.SocketOptionSetting)
}

void SocketOptionSetting::InitAsDefaultInstance() {
}

SocketOptionSetting::SocketOptionSetting(const SocketOptionSetting& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.SocketOptionSetting)
}

void SocketOptionSetting::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SocketOptionSetting::~SocketOptionSetting() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.SocketOptionSetting)
  SharedDtor();
}

void SocketOptionSetting::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void SocketOptionSetting::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SocketOptionSetting& SocketOptionSetting::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

SocketOptionSetting* SocketOptionSetting::default_instance_ = NULL;

SocketOptionSetting* SocketOptionSetting::New() const {
  return new SocketOptionSetting;
}

void SocketOptionSetting::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool SocketOptionSetting::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.SocketOptionSetting)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.SocketOptionSetting)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.SocketOptionSetting)
  return false;
#undef DO_
}

void SocketOptionSetting::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.SocketOptionSetting)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.SocketOptionSetting)
}

int SocketOptionSetting::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SocketOptionSetting::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SocketOptionSetting*>(&from));
}

void SocketOptionSetting::MergeFrom(const SocketOptionSetting& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void SocketOptionSetting::CopyFrom(const SocketOptionSetting& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SocketOptionSetting::IsInitialized() const {

  return true;
}

void SocketOptionSetting::Swap(SocketOptionSetting* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SocketOptionSetting::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.SocketOptionSetting";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

GetConnectGameServerPortIdResponse::GetConnectGameServerPortIdResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.GetConnectGameServerPortIdResponse)
}

void GetConnectGameServerPortIdResponse::InitAsDefaultInstance() {
}

GetConnectGameServerPortIdResponse::GetConnectGameServerPortIdResponse(const GetConnectGameServerPortIdResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.GetConnectGameServerPortIdResponse)
}

void GetConnectGameServerPortIdResponse::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetConnectGameServerPortIdResponse::~GetConnectGameServerPortIdResponse() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.GetConnectGameServerPortIdResponse)
  SharedDtor();
}

void GetConnectGameServerPortIdResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GetConnectGameServerPortIdResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GetConnectGameServerPortIdResponse& GetConnectGameServerPortIdResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

GetConnectGameServerPortIdResponse* GetConnectGameServerPortIdResponse::default_instance_ = NULL;

GetConnectGameServerPortIdResponse* GetConnectGameServerPortIdResponse::New() const {
  return new GetConnectGameServerPortIdResponse;
}

void GetConnectGameServerPortIdResponse::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool GetConnectGameServerPortIdResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.GetConnectGameServerPortIdResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.GetConnectGameServerPortIdResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.GetConnectGameServerPortIdResponse)
  return false;
#undef DO_
}

void GetConnectGameServerPortIdResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.GetConnectGameServerPortIdResponse)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.GetConnectGameServerPortIdResponse)
}

int GetConnectGameServerPortIdResponse::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetConnectGameServerPortIdResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GetConnectGameServerPortIdResponse*>(&from));
}

void GetConnectGameServerPortIdResponse::MergeFrom(const GetConnectGameServerPortIdResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void GetConnectGameServerPortIdResponse::CopyFrom(const GetConnectGameServerPortIdResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetConnectGameServerPortIdResponse::IsInitialized() const {

  return true;
}

void GetConnectGameServerPortIdResponse::Swap(GetConnectGameServerPortIdResponse* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GetConnectGameServerPortIdResponse::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.GetConnectGameServerPortIdResponse";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

NotifyLoginToPushServer::NotifyLoginToPushServer()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.NotifyLoginToPushServer)
}

void NotifyLoginToPushServer::InitAsDefaultInstance() {
}

NotifyLoginToPushServer::NotifyLoginToPushServer(const NotifyLoginToPushServer& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.NotifyLoginToPushServer)
}

void NotifyLoginToPushServer::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NotifyLoginToPushServer::~NotifyLoginToPushServer() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.NotifyLoginToPushServer)
  SharedDtor();
}

void NotifyLoginToPushServer::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void NotifyLoginToPushServer::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const NotifyLoginToPushServer& NotifyLoginToPushServer::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

NotifyLoginToPushServer* NotifyLoginToPushServer::default_instance_ = NULL;

NotifyLoginToPushServer* NotifyLoginToPushServer::New() const {
  return new NotifyLoginToPushServer;
}

void NotifyLoginToPushServer::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool NotifyLoginToPushServer::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.NotifyLoginToPushServer)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.NotifyLoginToPushServer)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.NotifyLoginToPushServer)
  return false;
#undef DO_
}

void NotifyLoginToPushServer::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.NotifyLoginToPushServer)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.NotifyLoginToPushServer)
}

int NotifyLoginToPushServer::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NotifyLoginToPushServer::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const NotifyLoginToPushServer*>(&from));
}

void NotifyLoginToPushServer::MergeFrom(const NotifyLoginToPushServer& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void NotifyLoginToPushServer::CopyFrom(const NotifyLoginToPushServer& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NotifyLoginToPushServer::IsInitialized() const {

  return true;
}

void NotifyLoginToPushServer::Swap(NotifyLoginToPushServer* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string NotifyLoginToPushServer::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.NotifyLoginToPushServer";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

NotifyLogoutToPushServer::NotifyLogoutToPushServer()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.NotifyLogoutToPushServer)
}

void NotifyLogoutToPushServer::InitAsDefaultInstance() {
}

NotifyLogoutToPushServer::NotifyLogoutToPushServer(const NotifyLogoutToPushServer& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.NotifyLogoutToPushServer)
}

void NotifyLogoutToPushServer::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NotifyLogoutToPushServer::~NotifyLogoutToPushServer() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.NotifyLogoutToPushServer)
  SharedDtor();
}

void NotifyLogoutToPushServer::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void NotifyLogoutToPushServer::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const NotifyLogoutToPushServer& NotifyLogoutToPushServer::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

NotifyLogoutToPushServer* NotifyLogoutToPushServer::default_instance_ = NULL;

NotifyLogoutToPushServer* NotifyLogoutToPushServer::New() const {
  return new NotifyLogoutToPushServer;
}

void NotifyLogoutToPushServer::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool NotifyLogoutToPushServer::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.NotifyLogoutToPushServer)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.NotifyLogoutToPushServer)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.NotifyLogoutToPushServer)
  return false;
#undef DO_
}

void NotifyLogoutToPushServer::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.NotifyLogoutToPushServer)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.NotifyLogoutToPushServer)
}

int NotifyLogoutToPushServer::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NotifyLogoutToPushServer::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const NotifyLogoutToPushServer*>(&from));
}

void NotifyLogoutToPushServer::MergeFrom(const NotifyLogoutToPushServer& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void NotifyLogoutToPushServer::CopyFrom(const NotifyLogoutToPushServer& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NotifyLogoutToPushServer::IsInitialized() const {

  return true;
}

void NotifyLogoutToPushServer::Swap(NotifyLogoutToPushServer* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string NotifyLogoutToPushServer::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.NotifyLogoutToPushServer";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

UserLoginInfo::UserLoginInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.UserLoginInfo)
}

void UserLoginInfo::InitAsDefaultInstance() {
}

UserLoginInfo::UserLoginInfo(const UserLoginInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.UserLoginInfo)
}

void UserLoginInfo::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UserLoginInfo::~UserLoginInfo() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.UserLoginInfo)
  SharedDtor();
}

void UserLoginInfo::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void UserLoginInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UserLoginInfo& UserLoginInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

UserLoginInfo* UserLoginInfo::default_instance_ = NULL;

UserLoginInfo* UserLoginInfo::New() const {
  return new UserLoginInfo;
}

void UserLoginInfo::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool UserLoginInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.UserLoginInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.UserLoginInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.UserLoginInfo)
  return false;
#undef DO_
}

void UserLoginInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.UserLoginInfo)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.UserLoginInfo)
}

int UserLoginInfo::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UserLoginInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UserLoginInfo*>(&from));
}

void UserLoginInfo::MergeFrom(const UserLoginInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void UserLoginInfo::CopyFrom(const UserLoginInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UserLoginInfo::IsInitialized() const {

  return true;
}

void UserLoginInfo::Swap(UserLoginInfo* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UserLoginInfo::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.UserLoginInfo";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

UserLogout::UserLogout()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.UserLogout)
}

void UserLogout::InitAsDefaultInstance() {
}

UserLogout::UserLogout(const UserLogout& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.UserLogout)
}

void UserLogout::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UserLogout::~UserLogout() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.UserLogout)
  SharedDtor();
}

void UserLogout::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void UserLogout::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UserLogout& UserLogout::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

UserLogout* UserLogout::default_instance_ = NULL;

UserLogout* UserLogout::New() const {
  return new UserLogout;
}

void UserLogout::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool UserLogout::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.UserLogout)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.UserLogout)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.UserLogout)
  return false;
#undef DO_
}

void UserLogout::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.UserLogout)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.UserLogout)
}

int UserLogout::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UserLogout::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UserLogout*>(&from));
}

void UserLogout::MergeFrom(const UserLogout& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void UserLogout::CopyFrom(const UserLogout& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UserLogout::IsInitialized() const {

  return true;
}

void UserLogout::Swap(UserLogout* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UserLogout::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.UserLogout";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

LoginClientInfo::LoginClientInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.LoginClientInfo)
}

void LoginClientInfo::InitAsDefaultInstance() {
}

LoginClientInfo::LoginClientInfo(const LoginClientInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.LoginClientInfo)
}

void LoginClientInfo::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LoginClientInfo::~LoginClientInfo() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.LoginClientInfo)
  SharedDtor();
}

void LoginClientInfo::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void LoginClientInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const LoginClientInfo& LoginClientInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

LoginClientInfo* LoginClientInfo::default_instance_ = NULL;

LoginClientInfo* LoginClientInfo::New() const {
  return new LoginClientInfo;
}

void LoginClientInfo::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool LoginClientInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.LoginClientInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.LoginClientInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.LoginClientInfo)
  return false;
#undef DO_
}

void LoginClientInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.LoginClientInfo)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.LoginClientInfo)
}

int LoginClientInfo::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LoginClientInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const LoginClientInfo*>(&from));
}

void LoginClientInfo::MergeFrom(const LoginClientInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void LoginClientInfo::CopyFrom(const LoginClientInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoginClientInfo::IsInitialized() const {

  return true;
}

void LoginClientInfo::Swap(LoginClientInfo* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string LoginClientInfo::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.LoginClientInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int NotifyClientServerInfoToPushServer::kUnknown1FieldNumber;
const int NotifyClientServerInfoToPushServer::kUnknown2FieldNumber;
const int NotifyClientServerInfoToPushServer::kUnknown3FieldNumber;
#endif  // !_MSC_VER

NotifyClientServerInfoToPushServer::NotifyClientServerInfoToPushServer()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.NotifyClientServerInfoToPushServer)
}

void NotifyClientServerInfoToPushServer::InitAsDefaultInstance() {
}

NotifyClientServerInfoToPushServer::NotifyClientServerInfoToPushServer(const NotifyClientServerInfoToPushServer& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.NotifyClientServerInfoToPushServer)
}

void NotifyClientServerInfoToPushServer::SharedCtor() {
  _cached_size_ = 0;
  unknown_1_ = 0u;
  unknown_2_ = 0u;
  unknown_3_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NotifyClientServerInfoToPushServer::~NotifyClientServerInfoToPushServer() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.NotifyClientServerInfoToPushServer)
  SharedDtor();
}

void NotifyClientServerInfoToPushServer::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void NotifyClientServerInfoToPushServer::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const NotifyClientServerInfoToPushServer& NotifyClientServerInfoToPushServer::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

NotifyClientServerInfoToPushServer* NotifyClientServerInfoToPushServer::default_instance_ = NULL;

NotifyClientServerInfoToPushServer* NotifyClientServerInfoToPushServer::New() const {
  return new NotifyClientServerInfoToPushServer;
}

void NotifyClientServerInfoToPushServer::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<NotifyClientServerInfoToPushServer*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(unknown_1_, unknown_3_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool NotifyClientServerInfoToPushServer::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.NotifyClientServerInfoToPushServer)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 unknown_1 = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_1_)));
          set_has_unknown_1();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_unknown_2;
        break;
      }

      // required uint32 unknown_2 = 2;
      case 2: {
        if (tag == 16) {
         parse_unknown_2:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_2_)));
          set_has_unknown_2();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_unknown_3;
        break;
      }

      // required uint32 unknown_3 = 3;
      case 3: {
        if (tag == 24) {
         parse_unknown_3:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_3_)));
          set_has_unknown_3();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.NotifyClientServerInfoToPushServer)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.NotifyClientServerInfoToPushServer)
  return false;
#undef DO_
}

void NotifyClientServerInfoToPushServer::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.NotifyClientServerInfoToPushServer)
  // required uint32 unknown_1 = 1;
  if (has_unknown_1()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->unknown_1(), output);
  }

  // required uint32 unknown_2 = 2;
  if (has_unknown_2()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->unknown_2(), output);
  }

  // required uint32 unknown_3 = 3;
  if (has_unknown_3()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->unknown_3(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.NotifyClientServerInfoToPushServer)
}

int NotifyClientServerInfoToPushServer::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 unknown_1 = 1;
    if (has_unknown_1()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_1());
    }

    // required uint32 unknown_2 = 2;
    if (has_unknown_2()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_2());
    }

    // required uint32 unknown_3 = 3;
    if (has_unknown_3()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_3());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NotifyClientServerInfoToPushServer::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const NotifyClientServerInfoToPushServer*>(&from));
}

void NotifyClientServerInfoToPushServer::MergeFrom(const NotifyClientServerInfoToPushServer& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_unknown_1()) {
      set_unknown_1(from.unknown_1());
    }
    if (from.has_unknown_2()) {
      set_unknown_2(from.unknown_2());
    }
    if (from.has_unknown_3()) {
      set_unknown_3(from.unknown_3());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void NotifyClientServerInfoToPushServer::CopyFrom(const NotifyClientServerInfoToPushServer& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NotifyClientServerInfoToPushServer::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void NotifyClientServerInfoToPushServer::Swap(NotifyClientServerInfoToPushServer* other) {
  if (other != this) {
    std::swap(unknown_1_, other->unknown_1_);
    std::swap(unknown_2_, other->unknown_2_);
    std::swap(unknown_3_, other->unknown_3_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string NotifyClientServerInfoToPushServer::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.NotifyClientServerInfoToPushServer";
}


// ===================================================================

#ifndef _MSC_VER
const int PushLoginUserInfo::kUnknown1FieldNumber;
const int PushLoginUserInfo::kUnknown2FieldNumber;
#endif  // !_MSC_VER

PushLoginUserInfo::PushLoginUserInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.PushLoginUserInfo)
}

void PushLoginUserInfo::InitAsDefaultInstance() {
}

PushLoginUserInfo::PushLoginUserInfo(const PushLoginUserInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.PushLoginUserInfo)
}

void PushLoginUserInfo::SharedCtor() {
  _cached_size_ = 0;
  unknown_1_ = 0u;
  unknown_2_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PushLoginUserInfo::~PushLoginUserInfo() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.PushLoginUserInfo)
  SharedDtor();
}

void PushLoginUserInfo::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void PushLoginUserInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PushLoginUserInfo& PushLoginUserInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

PushLoginUserInfo* PushLoginUserInfo::default_instance_ = NULL;

PushLoginUserInfo* PushLoginUserInfo::New() const {
  return new PushLoginUserInfo;
}

void PushLoginUserInfo::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<PushLoginUserInfo*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(unknown_1_, unknown_2_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool PushLoginUserInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.PushLoginUserInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 unknown_1 = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_1_)));
          set_has_unknown_1();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_unknown_2;
        break;
      }

      // required uint32 unknown_2 = 2;
      case 2: {
        if (tag == 16) {
         parse_unknown_2:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_2_)));
          set_has_unknown_2();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.PushLoginUserInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.PushLoginUserInfo)
  return false;
#undef DO_
}

void PushLoginUserInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.PushLoginUserInfo)
  // required uint32 unknown_1 = 1;
  if (has_unknown_1()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->unknown_1(), output);
  }

  // required uint32 unknown_2 = 2;
  if (has_unknown_2()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->unknown_2(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.PushLoginUserInfo)
}

int PushLoginUserInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 unknown_1 = 1;
    if (has_unknown_1()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_1());
    }

    // required uint32 unknown_2 = 2;
    if (has_unknown_2()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_2());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PushLoginUserInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PushLoginUserInfo*>(&from));
}

void PushLoginUserInfo::MergeFrom(const PushLoginUserInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_unknown_1()) {
      set_unknown_1(from.unknown_1());
    }
    if (from.has_unknown_2()) {
      set_unknown_2(from.unknown_2());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void PushLoginUserInfo::CopyFrom(const PushLoginUserInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PushLoginUserInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void PushLoginUserInfo::Swap(PushLoginUserInfo* other) {
  if (other != this) {
    std::swap(unknown_1_, other->unknown_1_);
    std::swap(unknown_2_, other->unknown_2_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PushLoginUserInfo::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.PushLoginUserInfo";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RequestCheckLogin::RequestCheckLogin()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestCheckLogin)
}

void RequestCheckLogin::InitAsDefaultInstance() {
}

RequestCheckLogin::RequestCheckLogin(const RequestCheckLogin& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestCheckLogin)
}

void RequestCheckLogin::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestCheckLogin::~RequestCheckLogin() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestCheckLogin)
  SharedDtor();
}

void RequestCheckLogin::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestCheckLogin::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestCheckLogin& RequestCheckLogin::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestCheckLogin* RequestCheckLogin::default_instance_ = NULL;

RequestCheckLogin* RequestCheckLogin::New() const {
  return new RequestCheckLogin;
}

void RequestCheckLogin::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestCheckLogin::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestCheckLogin)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestCheckLogin)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestCheckLogin)
  return false;
#undef DO_
}

void RequestCheckLogin::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestCheckLogin)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestCheckLogin)
}

int RequestCheckLogin::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestCheckLogin::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestCheckLogin*>(&from));
}

void RequestCheckLogin::MergeFrom(const RequestCheckLogin& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestCheckLogin::CopyFrom(const RequestCheckLogin& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestCheckLogin::IsInitialized() const {

  return true;
}

void RequestCheckLogin::Swap(RequestCheckLogin* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestCheckLogin::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestCheckLogin";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RequestCheckLoginResponse::RequestCheckLoginResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestCheckLoginResponse)
}

void RequestCheckLoginResponse::InitAsDefaultInstance() {
}

RequestCheckLoginResponse::RequestCheckLoginResponse(const RequestCheckLoginResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestCheckLoginResponse)
}

void RequestCheckLoginResponse::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestCheckLoginResponse::~RequestCheckLoginResponse() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestCheckLoginResponse)
  SharedDtor();
}

void RequestCheckLoginResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestCheckLoginResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestCheckLoginResponse& RequestCheckLoginResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestCheckLoginResponse* RequestCheckLoginResponse::default_instance_ = NULL;

RequestCheckLoginResponse* RequestCheckLoginResponse::New() const {
  return new RequestCheckLoginResponse;
}

void RequestCheckLoginResponse::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestCheckLoginResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestCheckLoginResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestCheckLoginResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestCheckLoginResponse)
  return false;
#undef DO_
}

void RequestCheckLoginResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestCheckLoginResponse)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestCheckLoginResponse)
}

int RequestCheckLoginResponse::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestCheckLoginResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestCheckLoginResponse*>(&from));
}

void RequestCheckLoginResponse::MergeFrom(const RequestCheckLoginResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestCheckLoginResponse::CopyFrom(const RequestCheckLoginResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestCheckLoginResponse::IsInitialized() const {

  return true;
}

void RequestCheckLoginResponse::Swap(RequestCheckLoginResponse* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestCheckLoginResponse::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestCheckLoginResponse";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RequestGetPlayerConnectGameServer::RequestGetPlayerConnectGameServer()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestGetPlayerConnectGameServer)
}

void RequestGetPlayerConnectGameServer::InitAsDefaultInstance() {
}

RequestGetPlayerConnectGameServer::RequestGetPlayerConnectGameServer(const RequestGetPlayerConnectGameServer& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestGetPlayerConnectGameServer)
}

void RequestGetPlayerConnectGameServer::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestGetPlayerConnectGameServer::~RequestGetPlayerConnectGameServer() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestGetPlayerConnectGameServer)
  SharedDtor();
}

void RequestGetPlayerConnectGameServer::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestGetPlayerConnectGameServer::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestGetPlayerConnectGameServer& RequestGetPlayerConnectGameServer::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestGetPlayerConnectGameServer* RequestGetPlayerConnectGameServer::default_instance_ = NULL;

RequestGetPlayerConnectGameServer* RequestGetPlayerConnectGameServer::New() const {
  return new RequestGetPlayerConnectGameServer;
}

void RequestGetPlayerConnectGameServer::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestGetPlayerConnectGameServer::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestGetPlayerConnectGameServer)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestGetPlayerConnectGameServer)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestGetPlayerConnectGameServer)
  return false;
#undef DO_
}

void RequestGetPlayerConnectGameServer::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestGetPlayerConnectGameServer)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestGetPlayerConnectGameServer)
}

int RequestGetPlayerConnectGameServer::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestGetPlayerConnectGameServer::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestGetPlayerConnectGameServer*>(&from));
}

void RequestGetPlayerConnectGameServer::MergeFrom(const RequestGetPlayerConnectGameServer& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestGetPlayerConnectGameServer::CopyFrom(const RequestGetPlayerConnectGameServer& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestGetPlayerConnectGameServer::IsInitialized() const {

  return true;
}

void RequestGetPlayerConnectGameServer::Swap(RequestGetPlayerConnectGameServer* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestGetPlayerConnectGameServer::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestGetPlayerConnectGameServer";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

PlayerConnectServerInfo::PlayerConnectServerInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.PlayerConnectServerInfo)
}

void PlayerConnectServerInfo::InitAsDefaultInstance() {
}

PlayerConnectServerInfo::PlayerConnectServerInfo(const PlayerConnectServerInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.PlayerConnectServerInfo)
}

void PlayerConnectServerInfo::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PlayerConnectServerInfo::~PlayerConnectServerInfo() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.PlayerConnectServerInfo)
  SharedDtor();
}

void PlayerConnectServerInfo::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void PlayerConnectServerInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PlayerConnectServerInfo& PlayerConnectServerInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

PlayerConnectServerInfo* PlayerConnectServerInfo::default_instance_ = NULL;

PlayerConnectServerInfo* PlayerConnectServerInfo::New() const {
  return new PlayerConnectServerInfo;
}

void PlayerConnectServerInfo::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool PlayerConnectServerInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.PlayerConnectServerInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.PlayerConnectServerInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.PlayerConnectServerInfo)
  return false;
#undef DO_
}

void PlayerConnectServerInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.PlayerConnectServerInfo)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.PlayerConnectServerInfo)
}

int PlayerConnectServerInfo::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PlayerConnectServerInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PlayerConnectServerInfo*>(&from));
}

void PlayerConnectServerInfo::MergeFrom(const PlayerConnectServerInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void PlayerConnectServerInfo::CopyFrom(const PlayerConnectServerInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlayerConnectServerInfo::IsInitialized() const {

  return true;
}

void PlayerConnectServerInfo::Swap(PlayerConnectServerInfo* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PlayerConnectServerInfo::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.PlayerConnectServerInfo";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RequestGetPlayerConnectGameServerResponse::RequestGetPlayerConnectGameServerResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestGetPlayerConnectGameServerResponse)
}

void RequestGetPlayerConnectGameServerResponse::InitAsDefaultInstance() {
}

RequestGetPlayerConnectGameServerResponse::RequestGetPlayerConnectGameServerResponse(const RequestGetPlayerConnectGameServerResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestGetPlayerConnectGameServerResponse)
}

void RequestGetPlayerConnectGameServerResponse::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestGetPlayerConnectGameServerResponse::~RequestGetPlayerConnectGameServerResponse() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestGetPlayerConnectGameServerResponse)
  SharedDtor();
}

void RequestGetPlayerConnectGameServerResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestGetPlayerConnectGameServerResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestGetPlayerConnectGameServerResponse& RequestGetPlayerConnectGameServerResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestGetPlayerConnectGameServerResponse* RequestGetPlayerConnectGameServerResponse::default_instance_ = NULL;

RequestGetPlayerConnectGameServerResponse* RequestGetPlayerConnectGameServerResponse::New() const {
  return new RequestGetPlayerConnectGameServerResponse;
}

void RequestGetPlayerConnectGameServerResponse::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestGetPlayerConnectGameServerResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestGetPlayerConnectGameServerResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestGetPlayerConnectGameServerResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestGetPlayerConnectGameServerResponse)
  return false;
#undef DO_
}

void RequestGetPlayerConnectGameServerResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestGetPlayerConnectGameServerResponse)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestGetPlayerConnectGameServerResponse)
}

int RequestGetPlayerConnectGameServerResponse::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestGetPlayerConnectGameServerResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestGetPlayerConnectGameServerResponse*>(&from));
}

void RequestGetPlayerConnectGameServerResponse::MergeFrom(const RequestGetPlayerConnectGameServerResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestGetPlayerConnectGameServerResponse::CopyFrom(const RequestGetPlayerConnectGameServerResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestGetPlayerConnectGameServerResponse::IsInitialized() const {

  return true;
}

void RequestGetPlayerConnectGameServerResponse::Swap(RequestGetPlayerConnectGameServerResponse* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestGetPlayerConnectGameServerResponse::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestGetPlayerConnectGameServerResponse";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RequestGetServerConnectTime::RequestGetServerConnectTime()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestGetServerConnectTime)
}

void RequestGetServerConnectTime::InitAsDefaultInstance() {
}

RequestGetServerConnectTime::RequestGetServerConnectTime(const RequestGetServerConnectTime& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestGetServerConnectTime)
}

void RequestGetServerConnectTime::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestGetServerConnectTime::~RequestGetServerConnectTime() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestGetServerConnectTime)
  SharedDtor();
}

void RequestGetServerConnectTime::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestGetServerConnectTime::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestGetServerConnectTime& RequestGetServerConnectTime::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestGetServerConnectTime* RequestGetServerConnectTime::default_instance_ = NULL;

RequestGetServerConnectTime* RequestGetServerConnectTime::New() const {
  return new RequestGetServerConnectTime;
}

void RequestGetServerConnectTime::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestGetServerConnectTime::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestGetServerConnectTime)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestGetServerConnectTime)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestGetServerConnectTime)
  return false;
#undef DO_
}

void RequestGetServerConnectTime::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestGetServerConnectTime)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestGetServerConnectTime)
}

int RequestGetServerConnectTime::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestGetServerConnectTime::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestGetServerConnectTime*>(&from));
}

void RequestGetServerConnectTime::MergeFrom(const RequestGetServerConnectTime& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestGetServerConnectTime::CopyFrom(const RequestGetServerConnectTime& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestGetServerConnectTime::IsInitialized() const {

  return true;
}

void RequestGetServerConnectTime::Swap(RequestGetServerConnectTime* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestGetServerConnectTime::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestGetServerConnectTime";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RequestGetServerConnectTimeResponse::RequestGetServerConnectTimeResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestGetServerConnectTimeResponse)
}

void RequestGetServerConnectTimeResponse::InitAsDefaultInstance() {
}

RequestGetServerConnectTimeResponse::RequestGetServerConnectTimeResponse(const RequestGetServerConnectTimeResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestGetServerConnectTimeResponse)
}

void RequestGetServerConnectTimeResponse::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestGetServerConnectTimeResponse::~RequestGetServerConnectTimeResponse() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestGetServerConnectTimeResponse)
  SharedDtor();
}

void RequestGetServerConnectTimeResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestGetServerConnectTimeResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestGetServerConnectTimeResponse& RequestGetServerConnectTimeResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestGetServerConnectTimeResponse* RequestGetServerConnectTimeResponse::default_instance_ = NULL;

RequestGetServerConnectTimeResponse* RequestGetServerConnectTimeResponse::New() const {
  return new RequestGetServerConnectTimeResponse;
}

void RequestGetServerConnectTimeResponse::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestGetServerConnectTimeResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestGetServerConnectTimeResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestGetServerConnectTimeResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestGetServerConnectTimeResponse)
  return false;
#undef DO_
}

void RequestGetServerConnectTimeResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestGetServerConnectTimeResponse)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestGetServerConnectTimeResponse)
}

int RequestGetServerConnectTimeResponse::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestGetServerConnectTimeResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestGetServerConnectTimeResponse*>(&from));
}

void RequestGetServerConnectTimeResponse::MergeFrom(const RequestGetServerConnectTimeResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestGetServerConnectTimeResponse::CopyFrom(const RequestGetServerConnectTimeResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestGetServerConnectTimeResponse::IsInitialized() const {

  return true;
}

void RequestGetServerConnectTimeResponse::Swap(RequestGetServerConnectTimeResponse* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestGetServerConnectTimeResponse::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestGetServerConnectTimeResponse";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RequestGetConnectionCount::RequestGetConnectionCount()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestGetConnectionCount)
}

void RequestGetConnectionCount::InitAsDefaultInstance() {
}

RequestGetConnectionCount::RequestGetConnectionCount(const RequestGetConnectionCount& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestGetConnectionCount)
}

void RequestGetConnectionCount::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestGetConnectionCount::~RequestGetConnectionCount() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestGetConnectionCount)
  SharedDtor();
}

void RequestGetConnectionCount::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestGetConnectionCount::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestGetConnectionCount& RequestGetConnectionCount::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestGetConnectionCount* RequestGetConnectionCount::default_instance_ = NULL;

RequestGetConnectionCount* RequestGetConnectionCount::New() const {
  return new RequestGetConnectionCount;
}

void RequestGetConnectionCount::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestGetConnectionCount::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestGetConnectionCount)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestGetConnectionCount)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestGetConnectionCount)
  return false;
#undef DO_
}

void RequestGetConnectionCount::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestGetConnectionCount)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestGetConnectionCount)
}

int RequestGetConnectionCount::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestGetConnectionCount::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestGetConnectionCount*>(&from));
}

void RequestGetConnectionCount::MergeFrom(const RequestGetConnectionCount& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestGetConnectionCount::CopyFrom(const RequestGetConnectionCount& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestGetConnectionCount::IsInitialized() const {

  return true;
}

void RequestGetConnectionCount::Swap(RequestGetConnectionCount* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestGetConnectionCount::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestGetConnectionCount";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RequestGetConnectionCountResponse::RequestGetConnectionCountResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestGetConnectionCountResponse)
}

void RequestGetConnectionCountResponse::InitAsDefaultInstance() {
}

RequestGetConnectionCountResponse::RequestGetConnectionCountResponse(const RequestGetConnectionCountResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestGetConnectionCountResponse)
}

void RequestGetConnectionCountResponse::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestGetConnectionCountResponse::~RequestGetConnectionCountResponse() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestGetConnectionCountResponse)
  SharedDtor();
}

void RequestGetConnectionCountResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestGetConnectionCountResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestGetConnectionCountResponse& RequestGetConnectionCountResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestGetConnectionCountResponse* RequestGetConnectionCountResponse::default_instance_ = NULL;

RequestGetConnectionCountResponse* RequestGetConnectionCountResponse::New() const {
  return new RequestGetConnectionCountResponse;
}

void RequestGetConnectionCountResponse::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestGetConnectionCountResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestGetConnectionCountResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestGetConnectionCountResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestGetConnectionCountResponse)
  return false;
#undef DO_
}

void RequestGetConnectionCountResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestGetConnectionCountResponse)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestGetConnectionCountResponse)
}

int RequestGetConnectionCountResponse::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestGetConnectionCountResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestGetConnectionCountResponse*>(&from));
}

void RequestGetConnectionCountResponse::MergeFrom(const RequestGetConnectionCountResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestGetConnectionCountResponse::CopyFrom(const RequestGetConnectionCountResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestGetConnectionCountResponse::IsInitialized() const {

  return true;
}

void RequestGetConnectionCountResponse::Swap(RequestGetConnectionCountResponse* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestGetConnectionCountResponse::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestGetConnectionCountResponse";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RequestDisconnectUser::RequestDisconnectUser()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestDisconnectUser)
}

void RequestDisconnectUser::InitAsDefaultInstance() {
}

RequestDisconnectUser::RequestDisconnectUser(const RequestDisconnectUser& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestDisconnectUser)
}

void RequestDisconnectUser::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestDisconnectUser::~RequestDisconnectUser() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestDisconnectUser)
  SharedDtor();
}

void RequestDisconnectUser::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestDisconnectUser::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestDisconnectUser& RequestDisconnectUser::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestDisconnectUser* RequestDisconnectUser::default_instance_ = NULL;

RequestDisconnectUser* RequestDisconnectUser::New() const {
  return new RequestDisconnectUser;
}

void RequestDisconnectUser::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestDisconnectUser::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestDisconnectUser)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestDisconnectUser)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestDisconnectUser)
  return false;
#undef DO_
}

void RequestDisconnectUser::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestDisconnectUser)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestDisconnectUser)
}

int RequestDisconnectUser::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestDisconnectUser::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestDisconnectUser*>(&from));
}

void RequestDisconnectUser::MergeFrom(const RequestDisconnectUser& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestDisconnectUser::CopyFrom(const RequestDisconnectUser& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestDisconnectUser::IsInitialized() const {

  return true;
}

void RequestDisconnectUser::Swap(RequestDisconnectUser* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestDisconnectUser::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestDisconnectUser";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RequestDisconnectAllUser::RequestDisconnectAllUser()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestDisconnectAllUser)
}

void RequestDisconnectAllUser::InitAsDefaultInstance() {
}

RequestDisconnectAllUser::RequestDisconnectAllUser(const RequestDisconnectAllUser& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestDisconnectAllUser)
}

void RequestDisconnectAllUser::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestDisconnectAllUser::~RequestDisconnectAllUser() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestDisconnectAllUser)
  SharedDtor();
}

void RequestDisconnectAllUser::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestDisconnectAllUser::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestDisconnectAllUser& RequestDisconnectAllUser::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestDisconnectAllUser* RequestDisconnectAllUser::default_instance_ = NULL;

RequestDisconnectAllUser* RequestDisconnectAllUser::New() const {
  return new RequestDisconnectAllUser;
}

void RequestDisconnectAllUser::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestDisconnectAllUser::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestDisconnectAllUser)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestDisconnectAllUser)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestDisconnectAllUser)
  return false;
#undef DO_
}

void RequestDisconnectAllUser::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestDisconnectAllUser)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestDisconnectAllUser)
}

int RequestDisconnectAllUser::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestDisconnectAllUser::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestDisconnectAllUser*>(&from));
}

void RequestDisconnectAllUser::MergeFrom(const RequestDisconnectAllUser& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestDisconnectAllUser::CopyFrom(const RequestDisconnectAllUser& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestDisconnectAllUser::IsInitialized() const {

  return true;
}

void RequestDisconnectAllUser::Swap(RequestDisconnectAllUser* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestDisconnectAllUser::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestDisconnectAllUser";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RequestSendMessageToPushClient::RequestSendMessageToPushClient()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestSendMessageToPushClient)
}

void RequestSendMessageToPushClient::InitAsDefaultInstance() {
}

RequestSendMessageToPushClient::RequestSendMessageToPushClient(const RequestSendMessageToPushClient& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestSendMessageToPushClient)
}

void RequestSendMessageToPushClient::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestSendMessageToPushClient::~RequestSendMessageToPushClient() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestSendMessageToPushClient)
  SharedDtor();
}

void RequestSendMessageToPushClient::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestSendMessageToPushClient::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestSendMessageToPushClient& RequestSendMessageToPushClient::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestSendMessageToPushClient* RequestSendMessageToPushClient::default_instance_ = NULL;

RequestSendMessageToPushClient* RequestSendMessageToPushClient::New() const {
  return new RequestSendMessageToPushClient;
}

void RequestSendMessageToPushClient::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestSendMessageToPushClient::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestSendMessageToPushClient)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestSendMessageToPushClient)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestSendMessageToPushClient)
  return false;
#undef DO_
}

void RequestSendMessageToPushClient::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestSendMessageToPushClient)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestSendMessageToPushClient)
}

int RequestSendMessageToPushClient::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestSendMessageToPushClient::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestSendMessageToPushClient*>(&from));
}

void RequestSendMessageToPushClient::MergeFrom(const RequestSendMessageToPushClient& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestSendMessageToPushClient::CopyFrom(const RequestSendMessageToPushClient& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestSendMessageToPushClient::IsInitialized() const {

  return true;
}

void RequestSendMessageToPushClient::Swap(RequestSendMessageToPushClient* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestSendMessageToPushClient::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestSendMessageToPushClient";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RequestGetServerSidePlayerStatus::RequestGetServerSidePlayerStatus()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_Frpg2RequestMessage.RequestGetServerSidePlayerStatus)
}

void RequestGetServerSidePlayerStatus::InitAsDefaultInstance() {
}

RequestGetServerSidePlayerStatus::RequestGetServerSidePlayerStatus(const RequestGetServerSidePlayerStatus& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_Frpg2RequestMessage.RequestGetServerSidePlayerStatus)
}

void RequestGetServerSidePlayerStatus::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestGetServerSidePlayerStatus::~RequestGetServerSidePlayerStatus() {
  // @@protoc_insertion_point(destructor:DS3_Frpg2RequestMessage.RequestGetServerSidePlayerStatus)
  SharedDtor();
}

void RequestGetServerSidePlayerStatus::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestGetServerSidePlayerStatus::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestGetServerSidePlayerStatus& RequestGetServerSidePlayerStatus::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFrpg2RequestMessage_2eproto();
#endif
  return *default_instance_;
}

RequestGetServerSidePlayerStatus* RequestGetServerSidePlayerStatus::default_instance_ = NULL;

RequestGetServerSidePlayerStatus* RequestGetServerSidePlayerStatus::New() const {
  return new RequestGetServerSidePlayerStatus;
}

void RequestGetServerSidePlayerStatus::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RequestGetServerSidePlayerStatus::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_Frpg2RequestMessage.RequestGetServerSidePlayerStatus)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_Frpg2RequestMessage.RequestGetServerSidePlayerStatus)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_Frpg2RequestMessage.RequestGetServerSidePlayerStatus)
  return false;
#undef DO_
}

void RequestGetServerSidePlayerStatus::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_Frpg2RequestMessage.RequestGetServerSidePlayerStatus)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_Frpg2RequestMessage.RequestGetServerSidePlayerStatus)
}

int RequestGetServerSidePlayerStatus::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestGetServerSidePlayerStatus::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestGetServerSidePlayerStatus*>(&from));
}

void RequestGetServerSidePlayerStatus::MergeFrom(const RequestGetServerSidePlayerStatus& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RequestGetServerSidePlayerStatus::CopyFrom(const RequestGetServerSidePlayerStatus& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestGetServerSidePlayerStatus::IsInitialized() const {

  return true;
}

void RequestGetServerSidePlayerStatus::Swap(RequestGetServerSidePlayerStatus* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestGetServerSidePlayerStatus::GetTypeName() const {
  return "DS3_Frpg2RequestMessage.RequestGetServerSidePlayerStatus";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace DS3_Frpg2RequestMessage

// @@protoc_insertion_point(global_scope)
