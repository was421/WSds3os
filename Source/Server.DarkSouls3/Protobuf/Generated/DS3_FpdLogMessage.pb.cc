// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: DS3_FpdLogMessage.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "DS3_FpdLogMessage.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace DS3_FpdLogMessage {

void protobuf_ShutdownFile_DS3_5fFpdLogMessage_2eproto() {
  delete Vector::default_instance_;
  delete GlobalEventLog::default_instance_;
  delete SystemOptionLog::default_instance_;
  delete SystemOptionLog_Game_option_setting::default_instance_;
  delete SystemOptionLog_Network_setting::default_instance_;
  delete UseItemLog::default_instance_;
  delete UseItemLog_Use_item_info_list::default_instance_;
  delete GetItemLog::default_instance_;
  delete GetItemLog_Get_item_info_list::default_instance_;
  delete ActGestureLog::default_instance_;
  delete ActGestureLog_Use_gesture_info_list::default_instance_;
  delete UseMagicLog::default_instance_;
  delete UseMagicLog_Use_magic_info_list::default_instance_;
  delete PurchaseItemLog::default_instance_;
  delete PurchaseItemLog_Purchase_item_info_list::default_instance_;
  delete DropItemLog::default_instance_;
  delete DropItemLog_Throw_away_item_list::default_instance_;
  delete LeaveItemLog::default_instance_;
  delete LeaveItemLog_Set_item_info_list::default_instance_;
  delete SaleItemLog::default_instance_;
  delete SaleItemLog_Sale_item_info_list::default_instance_;
  delete StrengthenWeaponLog::default_instance_;
  delete StrengthenWeaponLog_Strengthen_weapon_info_list::default_instance_;
  delete VisitResultLog::default_instance_;
  delete QuickMatchResultLog::default_instance_;
  delete QuickMatchEndLog::default_instance_;
  delete ConvertSaveDataLog::default_instance_;
  delete AccessWarehouseLog::default_instance_;
  delete AccessWarehouseLog_Access_warehouse_info_list::default_instance_;
  delete RepairEquipmentLog::default_instance_;
  delete RepairEquipmentLog_Repair_equipment_info_list::default_instance_;
  delete LevelUpLog::default_instance_;
  delete BrokenEquipmentLog::default_instance_;
  delete EquipMagicLog::default_instance_;
  delete ChaneEstusFlaskNumLog::default_instance_;
  delete CreateBloodMessageLog::default_instance_;
  delete EvaluateBloodMessageLog::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_DS3_5fFpdLogMessage_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_DS3_5fFpdLogMessage_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  Vector::default_instance_ = new Vector();
  GlobalEventLog::default_instance_ = new GlobalEventLog();
  SystemOptionLog::default_instance_ = new SystemOptionLog();
  SystemOptionLog_Game_option_setting::default_instance_ = new SystemOptionLog_Game_option_setting();
  SystemOptionLog_Network_setting::default_instance_ = new SystemOptionLog_Network_setting();
  UseItemLog::default_instance_ = new UseItemLog();
  UseItemLog_Use_item_info_list::default_instance_ = new UseItemLog_Use_item_info_list();
  GetItemLog::default_instance_ = new GetItemLog();
  GetItemLog_Get_item_info_list::default_instance_ = new GetItemLog_Get_item_info_list();
  ActGestureLog::default_instance_ = new ActGestureLog();
  ActGestureLog_Use_gesture_info_list::default_instance_ = new ActGestureLog_Use_gesture_info_list();
  UseMagicLog::default_instance_ = new UseMagicLog();
  UseMagicLog_Use_magic_info_list::default_instance_ = new UseMagicLog_Use_magic_info_list();
  PurchaseItemLog::default_instance_ = new PurchaseItemLog();
  PurchaseItemLog_Purchase_item_info_list::default_instance_ = new PurchaseItemLog_Purchase_item_info_list();
  DropItemLog::default_instance_ = new DropItemLog();
  DropItemLog_Throw_away_item_list::default_instance_ = new DropItemLog_Throw_away_item_list();
  LeaveItemLog::default_instance_ = new LeaveItemLog();
  LeaveItemLog_Set_item_info_list::default_instance_ = new LeaveItemLog_Set_item_info_list();
  SaleItemLog::default_instance_ = new SaleItemLog();
  SaleItemLog_Sale_item_info_list::default_instance_ = new SaleItemLog_Sale_item_info_list();
  StrengthenWeaponLog::default_instance_ = new StrengthenWeaponLog();
  StrengthenWeaponLog_Strengthen_weapon_info_list::default_instance_ = new StrengthenWeaponLog_Strengthen_weapon_info_list();
  VisitResultLog::default_instance_ = new VisitResultLog();
  QuickMatchResultLog::default_instance_ = new QuickMatchResultLog();
  QuickMatchEndLog::default_instance_ = new QuickMatchEndLog();
  ConvertSaveDataLog::default_instance_ = new ConvertSaveDataLog();
  AccessWarehouseLog::default_instance_ = new AccessWarehouseLog();
  AccessWarehouseLog_Access_warehouse_info_list::default_instance_ = new AccessWarehouseLog_Access_warehouse_info_list();
  RepairEquipmentLog::default_instance_ = new RepairEquipmentLog();
  RepairEquipmentLog_Repair_equipment_info_list::default_instance_ = new RepairEquipmentLog_Repair_equipment_info_list();
  LevelUpLog::default_instance_ = new LevelUpLog();
  BrokenEquipmentLog::default_instance_ = new BrokenEquipmentLog();
  EquipMagicLog::default_instance_ = new EquipMagicLog();
  ChaneEstusFlaskNumLog::default_instance_ = new ChaneEstusFlaskNumLog();
  CreateBloodMessageLog::default_instance_ = new CreateBloodMessageLog();
  EvaluateBloodMessageLog::default_instance_ = new EvaluateBloodMessageLog();
  Vector::default_instance_->InitAsDefaultInstance();
  GlobalEventLog::default_instance_->InitAsDefaultInstance();
  SystemOptionLog::default_instance_->InitAsDefaultInstance();
  SystemOptionLog_Game_option_setting::default_instance_->InitAsDefaultInstance();
  SystemOptionLog_Network_setting::default_instance_->InitAsDefaultInstance();
  UseItemLog::default_instance_->InitAsDefaultInstance();
  UseItemLog_Use_item_info_list::default_instance_->InitAsDefaultInstance();
  GetItemLog::default_instance_->InitAsDefaultInstance();
  GetItemLog_Get_item_info_list::default_instance_->InitAsDefaultInstance();
  ActGestureLog::default_instance_->InitAsDefaultInstance();
  ActGestureLog_Use_gesture_info_list::default_instance_->InitAsDefaultInstance();
  UseMagicLog::default_instance_->InitAsDefaultInstance();
  UseMagicLog_Use_magic_info_list::default_instance_->InitAsDefaultInstance();
  PurchaseItemLog::default_instance_->InitAsDefaultInstance();
  PurchaseItemLog_Purchase_item_info_list::default_instance_->InitAsDefaultInstance();
  DropItemLog::default_instance_->InitAsDefaultInstance();
  DropItemLog_Throw_away_item_list::default_instance_->InitAsDefaultInstance();
  LeaveItemLog::default_instance_->InitAsDefaultInstance();
  LeaveItemLog_Set_item_info_list::default_instance_->InitAsDefaultInstance();
  SaleItemLog::default_instance_->InitAsDefaultInstance();
  SaleItemLog_Sale_item_info_list::default_instance_->InitAsDefaultInstance();
  StrengthenWeaponLog::default_instance_->InitAsDefaultInstance();
  StrengthenWeaponLog_Strengthen_weapon_info_list::default_instance_->InitAsDefaultInstance();
  VisitResultLog::default_instance_->InitAsDefaultInstance();
  QuickMatchResultLog::default_instance_->InitAsDefaultInstance();
  QuickMatchEndLog::default_instance_->InitAsDefaultInstance();
  ConvertSaveDataLog::default_instance_->InitAsDefaultInstance();
  AccessWarehouseLog::default_instance_->InitAsDefaultInstance();
  AccessWarehouseLog_Access_warehouse_info_list::default_instance_->InitAsDefaultInstance();
  RepairEquipmentLog::default_instance_->InitAsDefaultInstance();
  RepairEquipmentLog_Repair_equipment_info_list::default_instance_->InitAsDefaultInstance();
  LevelUpLog::default_instance_->InitAsDefaultInstance();
  BrokenEquipmentLog::default_instance_->InitAsDefaultInstance();
  EquipMagicLog::default_instance_->InitAsDefaultInstance();
  ChaneEstusFlaskNumLog::default_instance_->InitAsDefaultInstance();
  CreateBloodMessageLog::default_instance_->InitAsDefaultInstance();
  EvaluateBloodMessageLog::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_DS3_5fFpdLogMessage_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_DS3_5fFpdLogMessage_2eproto_once_);
void protobuf_AddDesc_DS3_5fFpdLogMessage_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_DS3_5fFpdLogMessage_2eproto_once_,
                 &protobuf_AddDesc_DS3_5fFpdLogMessage_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_DS3_5fFpdLogMessage_2eproto {
  StaticDescriptorInitializer_DS3_5fFpdLogMessage_2eproto() {
    protobuf_AddDesc_DS3_5fFpdLogMessage_2eproto();
  }
} static_descriptor_initializer_DS3_5fFpdLogMessage_2eproto_;
#endif

// ===================================================================

#ifndef _MSC_VER
const int Vector::kXFieldNumber;
const int Vector::kYFieldNumber;
const int Vector::kZFieldNumber;
#endif  // !_MSC_VER

Vector::Vector()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_FpdLogMessage.Vector)
}

void Vector::InitAsDefaultInstance() {
}

Vector::Vector(const Vector& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_FpdLogMessage.Vector)
}

void Vector::SharedCtor() {
  _cached_size_ = 0;
  x_ = 0;
  y_ = 0;
  z_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Vector::~Vector() {
  // @@protoc_insertion_point(destructor:DS3_FpdLogMessage.Vector)
  SharedDtor();
}

void Vector::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Vector::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Vector& Vector::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFpdLogMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFpdLogMessage_2eproto();
#endif
  return *default_instance_;
}

Vector* Vector::default_instance_ = NULL;

Vector* Vector::New() const {
  return new Vector;
}

void Vector::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<Vector*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(x_, z_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool Vector::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_FpdLogMessage.Vector)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float x = 1;
      case 1: {
        if (tag == 13) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(21)) goto parse_y;
        break;
      }

      // required float y = 2;
      case 2: {
        if (tag == 21) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(29)) goto parse_z;
        break;
      }

      // required float z = 3;
      case 3: {
        if (tag == 29) {
         parse_z:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &z_)));
          set_has_z();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_FpdLogMessage.Vector)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_FpdLogMessage.Vector)
  return false;
#undef DO_
}

void Vector::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_FpdLogMessage.Vector)
  // required float x = 1;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->x(), output);
  }

  // required float y = 2;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->y(), output);
  }

  // required float z = 3;
  if (has_z()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->z(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_FpdLogMessage.Vector)
}

int Vector::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required float x = 1;
    if (has_x()) {
      total_size += 1 + 4;
    }

    // required float y = 2;
    if (has_y()) {
      total_size += 1 + 4;
    }

    // required float z = 3;
    if (has_z()) {
      total_size += 1 + 4;
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Vector::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Vector*>(&from));
}

void Vector::MergeFrom(const Vector& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
    if (from.has_z()) {
      set_z(from.z());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void Vector::CopyFrom(const Vector& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Vector::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void Vector::Swap(Vector* other) {
  if (other != this) {
    std::swap(x_, other->x_);
    std::swap(y_, other->y_);
    std::swap(z_, other->z_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Vector::GetTypeName() const {
  return "DS3_FpdLogMessage.Vector";
}


// ===================================================================

#ifndef _MSC_VER
const int GlobalEventLog::kValuesFieldNumber;
#endif  // !_MSC_VER

GlobalEventLog::GlobalEventLog()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_FpdLogMessage.GlobalEventLog)
}

void GlobalEventLog::InitAsDefaultInstance() {
}

GlobalEventLog::GlobalEventLog(const GlobalEventLog& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_FpdLogMessage.GlobalEventLog)
}

void GlobalEventLog::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GlobalEventLog::~GlobalEventLog() {
  // @@protoc_insertion_point(destructor:DS3_FpdLogMessage.GlobalEventLog)
  SharedDtor();
}

void GlobalEventLog::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GlobalEventLog::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GlobalEventLog& GlobalEventLog::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFpdLogMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFpdLogMessage_2eproto();
#endif
  return *default_instance_;
}

GlobalEventLog* GlobalEventLog::default_instance_ = NULL;

GlobalEventLog* GlobalEventLog::New() const {
  return new GlobalEventLog;
}

void GlobalEventLog::Clear() {
  values_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool GlobalEventLog::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_FpdLogMessage.GlobalEventLog)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 values = 1;
      case 1: {
        if (tag == 8) {
         parse_values:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 8, input, this->mutable_values())));
        } else if (tag == 10) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_values())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(8)) goto parse_values;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_FpdLogMessage.GlobalEventLog)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_FpdLogMessage.GlobalEventLog)
  return false;
#undef DO_
}

void GlobalEventLog::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_FpdLogMessage.GlobalEventLog)
  // repeated uint32 values = 1;
  for (int i = 0; i < this->values_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      1, this->values(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_FpdLogMessage.GlobalEventLog)
}

int GlobalEventLog::ByteSize() const {
  int total_size = 0;

  // repeated uint32 values = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->values_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->values(i));
    }
    total_size += 1 * this->values_size() + data_size;
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GlobalEventLog::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GlobalEventLog*>(&from));
}

void GlobalEventLog::MergeFrom(const GlobalEventLog& from) {
  GOOGLE_CHECK_NE(&from, this);
  values_.MergeFrom(from.values_);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void GlobalEventLog::CopyFrom(const GlobalEventLog& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GlobalEventLog::IsInitialized() const {

  return true;
}

void GlobalEventLog::Swap(GlobalEventLog* other) {
  if (other != this) {
    values_.Swap(&other->values_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GlobalEventLog::GetTypeName() const {
  return "DS3_FpdLogMessage.GlobalEventLog";
}


// ===================================================================

#ifndef _MSC_VER
const int SystemOptionLog_Game_option_setting::kToggleAutoLockOnFieldNumber;
const int SystemOptionLog_Game_option_setting::kAutoTargetFieldNumber;
const int SystemOptionLog_Game_option_setting::kManualAttackAimingFieldNumber;
const int SystemOptionLog_Game_option_setting::kUnknown5FieldNumber;
const int SystemOptionLog_Game_option_setting::kVibrationLevelFieldNumber;
#endif  // !_MSC_VER

SystemOptionLog_Game_option_setting::SystemOptionLog_Game_option_setting()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_FpdLogMessage.SystemOptionLog.Game_option_setting)
}

void SystemOptionLog_Game_option_setting::InitAsDefaultInstance() {
}

SystemOptionLog_Game_option_setting::SystemOptionLog_Game_option_setting(const SystemOptionLog_Game_option_setting& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_FpdLogMessage.SystemOptionLog.Game_option_setting)
}

void SystemOptionLog_Game_option_setting::SharedCtor() {
  _cached_size_ = 0;
  toggle_auto_lock_on_ = 0u;
  auto_target_ = 0u;
  manual_attack_aiming_ = 0u;
  unknown_5_ = 0u;
  vibration_level_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SystemOptionLog_Game_option_setting::~SystemOptionLog_Game_option_setting() {
  // @@protoc_insertion_point(destructor:DS3_FpdLogMessage.SystemOptionLog.Game_option_setting)
  SharedDtor();
}

void SystemOptionLog_Game_option_setting::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void SystemOptionLog_Game_option_setting::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SystemOptionLog_Game_option_setting& SystemOptionLog_Game_option_setting::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFpdLogMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFpdLogMessage_2eproto();
#endif
  return *default_instance_;
}

SystemOptionLog_Game_option_setting* SystemOptionLog_Game_option_setting::default_instance_ = NULL;

SystemOptionLog_Game_option_setting* SystemOptionLog_Game_option_setting::New() const {
  return new SystemOptionLog_Game_option_setting;
}

void SystemOptionLog_Game_option_setting::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<SystemOptionLog_Game_option_setting*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 31) {
    ZR_(toggle_auto_lock_on_, vibration_level_);
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool SystemOptionLog_Game_option_setting::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_FpdLogMessage.SystemOptionLog.Game_option_setting)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 toggle_auto_lock_on = 2;
      case 2: {
        if (tag == 16) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &toggle_auto_lock_on_)));
          set_has_toggle_auto_lock_on();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_auto_target;
        break;
      }

      // required uint32 auto_target = 3;
      case 3: {
        if (tag == 24) {
         parse_auto_target:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &auto_target_)));
          set_has_auto_target();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_manual_attack_aiming;
        break;
      }

      // required uint32 manual_attack_aiming = 4;
      case 4: {
        if (tag == 32) {
         parse_manual_attack_aiming:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &manual_attack_aiming_)));
          set_has_manual_attack_aiming();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_unknown_5;
        break;
      }

      // required uint32 unknown_5 = 5;
      case 5: {
        if (tag == 40) {
         parse_unknown_5:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_5_)));
          set_has_unknown_5();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_vibration_level;
        break;
      }

      // required uint32 vibration_level = 6;
      case 6: {
        if (tag == 48) {
         parse_vibration_level:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &vibration_level_)));
          set_has_vibration_level();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_FpdLogMessage.SystemOptionLog.Game_option_setting)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_FpdLogMessage.SystemOptionLog.Game_option_setting)
  return false;
#undef DO_
}

void SystemOptionLog_Game_option_setting::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_FpdLogMessage.SystemOptionLog.Game_option_setting)
  // required uint32 toggle_auto_lock_on = 2;
  if (has_toggle_auto_lock_on()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->toggle_auto_lock_on(), output);
  }

  // required uint32 auto_target = 3;
  if (has_auto_target()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->auto_target(), output);
  }

  // required uint32 manual_attack_aiming = 4;
  if (has_manual_attack_aiming()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->manual_attack_aiming(), output);
  }

  // required uint32 unknown_5 = 5;
  if (has_unknown_5()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->unknown_5(), output);
  }

  // required uint32 vibration_level = 6;
  if (has_vibration_level()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->vibration_level(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_FpdLogMessage.SystemOptionLog.Game_option_setting)
}

int SystemOptionLog_Game_option_setting::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 toggle_auto_lock_on = 2;
    if (has_toggle_auto_lock_on()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->toggle_auto_lock_on());
    }

    // required uint32 auto_target = 3;
    if (has_auto_target()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->auto_target());
    }

    // required uint32 manual_attack_aiming = 4;
    if (has_manual_attack_aiming()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->manual_attack_aiming());
    }

    // required uint32 unknown_5 = 5;
    if (has_unknown_5()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_5());
    }

    // required uint32 vibration_level = 6;
    if (has_vibration_level()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->vibration_level());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SystemOptionLog_Game_option_setting::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SystemOptionLog_Game_option_setting*>(&from));
}

void SystemOptionLog_Game_option_setting::MergeFrom(const SystemOptionLog_Game_option_setting& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_toggle_auto_lock_on()) {
      set_toggle_auto_lock_on(from.toggle_auto_lock_on());
    }
    if (from.has_auto_target()) {
      set_auto_target(from.auto_target());
    }
    if (from.has_manual_attack_aiming()) {
      set_manual_attack_aiming(from.manual_attack_aiming());
    }
    if (from.has_unknown_5()) {
      set_unknown_5(from.unknown_5());
    }
    if (from.has_vibration_level()) {
      set_vibration_level(from.vibration_level());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void SystemOptionLog_Game_option_setting::CopyFrom(const SystemOptionLog_Game_option_setting& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SystemOptionLog_Game_option_setting::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;

  return true;
}

void SystemOptionLog_Game_option_setting::Swap(SystemOptionLog_Game_option_setting* other) {
  if (other != this) {
    std::swap(toggle_auto_lock_on_, other->toggle_auto_lock_on_);
    std::swap(auto_target_, other->auto_target_);
    std::swap(manual_attack_aiming_, other->manual_attack_aiming_);
    std::swap(unknown_5_, other->unknown_5_);
    std::swap(vibration_level_, other->vibration_level_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SystemOptionLog_Game_option_setting::GetTypeName() const {
  return "DS3_FpdLogMessage.SystemOptionLog.Game_option_setting";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int SystemOptionLog_Network_setting::kAllowCrossRegionPlayFieldNumber;
const int SystemOptionLog_Network_setting::kHasPasswordFieldNumber;
const int SystemOptionLog_Network_setting::kRestrictSummonSignVisibilityFieldNumber;
const int SystemOptionLog_Network_setting::kAllowVoiceChatFieldNumber;
const int SystemOptionLog_Network_setting::kUnknown12FieldNumber;
const int SystemOptionLog_Network_setting::kStartOfflineFieldNumber;
#endif  // !_MSC_VER

SystemOptionLog_Network_setting::SystemOptionLog_Network_setting()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_FpdLogMessage.SystemOptionLog.Network_setting)
}

void SystemOptionLog_Network_setting::InitAsDefaultInstance() {
}

SystemOptionLog_Network_setting::SystemOptionLog_Network_setting(const SystemOptionLog_Network_setting& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_FpdLogMessage.SystemOptionLog.Network_setting)
}

void SystemOptionLog_Network_setting::SharedCtor() {
  _cached_size_ = 0;
  allow_cross_region_play_ = 0u;
  has_password_ = 0u;
  restrict_summon_sign_visibility_ = 0u;
  allow_voice_chat_ = 0u;
  unknown_12_ = 0u;
  start_offline_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SystemOptionLog_Network_setting::~SystemOptionLog_Network_setting() {
  // @@protoc_insertion_point(destructor:DS3_FpdLogMessage.SystemOptionLog.Network_setting)
  SharedDtor();
}

void SystemOptionLog_Network_setting::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void SystemOptionLog_Network_setting::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SystemOptionLog_Network_setting& SystemOptionLog_Network_setting::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFpdLogMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFpdLogMessage_2eproto();
#endif
  return *default_instance_;
}

SystemOptionLog_Network_setting* SystemOptionLog_Network_setting::default_instance_ = NULL;

SystemOptionLog_Network_setting* SystemOptionLog_Network_setting::New() const {
  return new SystemOptionLog_Network_setting;
}

void SystemOptionLog_Network_setting::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<SystemOptionLog_Network_setting*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 63) {
    ZR_(allow_cross_region_play_, start_offline_);
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool SystemOptionLog_Network_setting::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_FpdLogMessage.SystemOptionLog.Network_setting)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 allow_cross_region_play = 8;
      case 8: {
        if (tag == 64) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &allow_cross_region_play_)));
          set_has_allow_cross_region_play();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_has_password;
        break;
      }

      // required uint32 has_password = 9;
      case 9: {
        if (tag == 72) {
         parse_has_password:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &has_password_)));
          set_has_has_password();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_restrict_summon_sign_visibility;
        break;
      }

      // required uint32 restrict_summon_sign_visibility = 10;
      case 10: {
        if (tag == 80) {
         parse_restrict_summon_sign_visibility:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &restrict_summon_sign_visibility_)));
          set_has_restrict_summon_sign_visibility();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(88)) goto parse_allow_voice_chat;
        break;
      }

      // required uint32 allow_voice_chat = 11;
      case 11: {
        if (tag == 88) {
         parse_allow_voice_chat:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &allow_voice_chat_)));
          set_has_allow_voice_chat();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(96)) goto parse_unknown_12;
        break;
      }

      // required uint32 unknown_12 = 12;
      case 12: {
        if (tag == 96) {
         parse_unknown_12:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_12_)));
          set_has_unknown_12();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(104)) goto parse_start_offline;
        break;
      }

      // required uint32 start_offline = 13;
      case 13: {
        if (tag == 104) {
         parse_start_offline:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &start_offline_)));
          set_has_start_offline();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_FpdLogMessage.SystemOptionLog.Network_setting)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_FpdLogMessage.SystemOptionLog.Network_setting)
  return false;
#undef DO_
}

void SystemOptionLog_Network_setting::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_FpdLogMessage.SystemOptionLog.Network_setting)
  // required uint32 allow_cross_region_play = 8;
  if (has_allow_cross_region_play()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->allow_cross_region_play(), output);
  }

  // required uint32 has_password = 9;
  if (has_has_password()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->has_password(), output);
  }

  // required uint32 restrict_summon_sign_visibility = 10;
  if (has_restrict_summon_sign_visibility()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(10, this->restrict_summon_sign_visibility(), output);
  }

  // required uint32 allow_voice_chat = 11;
  if (has_allow_voice_chat()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(11, this->allow_voice_chat(), output);
  }

  // required uint32 unknown_12 = 12;
  if (has_unknown_12()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(12, this->unknown_12(), output);
  }

  // required uint32 start_offline = 13;
  if (has_start_offline()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(13, this->start_offline(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_FpdLogMessage.SystemOptionLog.Network_setting)
}

int SystemOptionLog_Network_setting::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 allow_cross_region_play = 8;
    if (has_allow_cross_region_play()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->allow_cross_region_play());
    }

    // required uint32 has_password = 9;
    if (has_has_password()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->has_password());
    }

    // required uint32 restrict_summon_sign_visibility = 10;
    if (has_restrict_summon_sign_visibility()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->restrict_summon_sign_visibility());
    }

    // required uint32 allow_voice_chat = 11;
    if (has_allow_voice_chat()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->allow_voice_chat());
    }

    // required uint32 unknown_12 = 12;
    if (has_unknown_12()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_12());
    }

    // required uint32 start_offline = 13;
    if (has_start_offline()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->start_offline());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SystemOptionLog_Network_setting::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SystemOptionLog_Network_setting*>(&from));
}

void SystemOptionLog_Network_setting::MergeFrom(const SystemOptionLog_Network_setting& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_allow_cross_region_play()) {
      set_allow_cross_region_play(from.allow_cross_region_play());
    }
    if (from.has_has_password()) {
      set_has_password(from.has_password());
    }
    if (from.has_restrict_summon_sign_visibility()) {
      set_restrict_summon_sign_visibility(from.restrict_summon_sign_visibility());
    }
    if (from.has_allow_voice_chat()) {
      set_allow_voice_chat(from.allow_voice_chat());
    }
    if (from.has_unknown_12()) {
      set_unknown_12(from.unknown_12());
    }
    if (from.has_start_offline()) {
      set_start_offline(from.start_offline());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void SystemOptionLog_Network_setting::CopyFrom(const SystemOptionLog_Network_setting& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SystemOptionLog_Network_setting::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003f) != 0x0000003f) return false;

  return true;
}

void SystemOptionLog_Network_setting::Swap(SystemOptionLog_Network_setting* other) {
  if (other != this) {
    std::swap(allow_cross_region_play_, other->allow_cross_region_play_);
    std::swap(has_password_, other->has_password_);
    std::swap(restrict_summon_sign_visibility_, other->restrict_summon_sign_visibility_);
    std::swap(allow_voice_chat_, other->allow_voice_chat_);
    std::swap(unknown_12_, other->unknown_12_);
    std::swap(start_offline_, other->start_offline_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SystemOptionLog_Network_setting::GetTypeName() const {
  return "DS3_FpdLogMessage.SystemOptionLog.Network_setting";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int SystemOptionLog::kGameSettingsFieldNumber;
const int SystemOptionLog::kNetworkSettingsFieldNumber;
#endif  // !_MSC_VER

SystemOptionLog::SystemOptionLog()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_FpdLogMessage.SystemOptionLog)
}

void SystemOptionLog::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  game_settings_ = const_cast< ::DS3_FpdLogMessage::SystemOptionLog_Game_option_setting*>(
      ::DS3_FpdLogMessage::SystemOptionLog_Game_option_setting::internal_default_instance());
#else
  game_settings_ = const_cast< ::DS3_FpdLogMessage::SystemOptionLog_Game_option_setting*>(&::DS3_FpdLogMessage::SystemOptionLog_Game_option_setting::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  network_settings_ = const_cast< ::DS3_FpdLogMessage::SystemOptionLog_Network_setting*>(
      ::DS3_FpdLogMessage::SystemOptionLog_Network_setting::internal_default_instance());
#else
  network_settings_ = const_cast< ::DS3_FpdLogMessage::SystemOptionLog_Network_setting*>(&::DS3_FpdLogMessage::SystemOptionLog_Network_setting::default_instance());
#endif
}

SystemOptionLog::SystemOptionLog(const SystemOptionLog& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_FpdLogMessage.SystemOptionLog)
}

void SystemOptionLog::SharedCtor() {
  _cached_size_ = 0;
  game_settings_ = NULL;
  network_settings_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SystemOptionLog::~SystemOptionLog() {
  // @@protoc_insertion_point(destructor:DS3_FpdLogMessage.SystemOptionLog)
  SharedDtor();
}

void SystemOptionLog::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete game_settings_;
    delete network_settings_;
  }
}

void SystemOptionLog::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SystemOptionLog& SystemOptionLog::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFpdLogMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFpdLogMessage_2eproto();
#endif
  return *default_instance_;
}

SystemOptionLog* SystemOptionLog::default_instance_ = NULL;

SystemOptionLog* SystemOptionLog::New() const {
  return new SystemOptionLog;
}

void SystemOptionLog::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_game_settings()) {
      if (game_settings_ != NULL) game_settings_->::DS3_FpdLogMessage::SystemOptionLog_Game_option_setting::Clear();
    }
    if (has_network_settings()) {
      if (network_settings_ != NULL) network_settings_->::DS3_FpdLogMessage::SystemOptionLog_Network_setting::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool SystemOptionLog::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_FpdLogMessage.SystemOptionLog)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .DS3_FpdLogMessage.SystemOptionLog.Game_option_setting game_settings = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_game_settings()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_network_settings;
        break;
      }

      // required .DS3_FpdLogMessage.SystemOptionLog.Network_setting network_settings = 7;
      case 7: {
        if (tag == 58) {
         parse_network_settings:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_network_settings()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_FpdLogMessage.SystemOptionLog)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_FpdLogMessage.SystemOptionLog)
  return false;
#undef DO_
}

void SystemOptionLog::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_FpdLogMessage.SystemOptionLog)
  // required .DS3_FpdLogMessage.SystemOptionLog.Game_option_setting game_settings = 1;
  if (has_game_settings()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->game_settings(), output);
  }

  // required .DS3_FpdLogMessage.SystemOptionLog.Network_setting network_settings = 7;
  if (has_network_settings()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      7, this->network_settings(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_FpdLogMessage.SystemOptionLog)
}

int SystemOptionLog::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .DS3_FpdLogMessage.SystemOptionLog.Game_option_setting game_settings = 1;
    if (has_game_settings()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->game_settings());
    }

    // required .DS3_FpdLogMessage.SystemOptionLog.Network_setting network_settings = 7;
    if (has_network_settings()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->network_settings());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SystemOptionLog::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SystemOptionLog*>(&from));
}

void SystemOptionLog::MergeFrom(const SystemOptionLog& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_game_settings()) {
      mutable_game_settings()->::DS3_FpdLogMessage::SystemOptionLog_Game_option_setting::MergeFrom(from.game_settings());
    }
    if (from.has_network_settings()) {
      mutable_network_settings()->::DS3_FpdLogMessage::SystemOptionLog_Network_setting::MergeFrom(from.network_settings());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void SystemOptionLog::CopyFrom(const SystemOptionLog& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SystemOptionLog::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_game_settings()) {
    if (!this->game_settings().IsInitialized()) return false;
  }
  if (has_network_settings()) {
    if (!this->network_settings().IsInitialized()) return false;
  }
  return true;
}

void SystemOptionLog::Swap(SystemOptionLog* other) {
  if (other != this) {
    std::swap(game_settings_, other->game_settings_);
    std::swap(network_settings_, other->network_settings_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SystemOptionLog::GetTypeName() const {
  return "DS3_FpdLogMessage.SystemOptionLog";
}


// ===================================================================

#ifndef _MSC_VER
const int UseItemLog_Use_item_info_list::kItemIdFieldNumber;
const int UseItemLog_Use_item_info_list::kCountFieldNumber;
const int UseItemLog_Use_item_info_list::kUnknown4FieldNumber;
#endif  // !_MSC_VER

UseItemLog_Use_item_info_list::UseItemLog_Use_item_info_list()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_FpdLogMessage.UseItemLog.Use_item_info_list)
}

void UseItemLog_Use_item_info_list::InitAsDefaultInstance() {
}

UseItemLog_Use_item_info_list::UseItemLog_Use_item_info_list(const UseItemLog_Use_item_info_list& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_FpdLogMessage.UseItemLog.Use_item_info_list)
}

void UseItemLog_Use_item_info_list::SharedCtor() {
  _cached_size_ = 0;
  item_id_ = 0u;
  count_ = 0u;
  unknown_4_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UseItemLog_Use_item_info_list::~UseItemLog_Use_item_info_list() {
  // @@protoc_insertion_point(destructor:DS3_FpdLogMessage.UseItemLog.Use_item_info_list)
  SharedDtor();
}

void UseItemLog_Use_item_info_list::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void UseItemLog_Use_item_info_list::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UseItemLog_Use_item_info_list& UseItemLog_Use_item_info_list::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFpdLogMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFpdLogMessage_2eproto();
#endif
  return *default_instance_;
}

UseItemLog_Use_item_info_list* UseItemLog_Use_item_info_list::default_instance_ = NULL;

UseItemLog_Use_item_info_list* UseItemLog_Use_item_info_list::New() const {
  return new UseItemLog_Use_item_info_list;
}

void UseItemLog_Use_item_info_list::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<UseItemLog_Use_item_info_list*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(item_id_, unknown_4_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool UseItemLog_Use_item_info_list::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_FpdLogMessage.UseItemLog.Use_item_info_list)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 item_id = 2;
      case 2: {
        if (tag == 16) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &item_id_)));
          set_has_item_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_count;
        break;
      }

      // required uint32 count = 3;
      case 3: {
        if (tag == 24) {
         parse_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &count_)));
          set_has_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_unknown_4;
        break;
      }

      // required uint32 unknown_4 = 4;
      case 4: {
        if (tag == 32) {
         parse_unknown_4:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_4_)));
          set_has_unknown_4();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_FpdLogMessage.UseItemLog.Use_item_info_list)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_FpdLogMessage.UseItemLog.Use_item_info_list)
  return false;
#undef DO_
}

void UseItemLog_Use_item_info_list::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_FpdLogMessage.UseItemLog.Use_item_info_list)
  // required uint32 item_id = 2;
  if (has_item_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->item_id(), output);
  }

  // required uint32 count = 3;
  if (has_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->count(), output);
  }

  // required uint32 unknown_4 = 4;
  if (has_unknown_4()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->unknown_4(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_FpdLogMessage.UseItemLog.Use_item_info_list)
}

int UseItemLog_Use_item_info_list::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 item_id = 2;
    if (has_item_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->item_id());
    }

    // required uint32 count = 3;
    if (has_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->count());
    }

    // required uint32 unknown_4 = 4;
    if (has_unknown_4()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_4());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UseItemLog_Use_item_info_list::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UseItemLog_Use_item_info_list*>(&from));
}

void UseItemLog_Use_item_info_list::MergeFrom(const UseItemLog_Use_item_info_list& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_item_id()) {
      set_item_id(from.item_id());
    }
    if (from.has_count()) {
      set_count(from.count());
    }
    if (from.has_unknown_4()) {
      set_unknown_4(from.unknown_4());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void UseItemLog_Use_item_info_list::CopyFrom(const UseItemLog_Use_item_info_list& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UseItemLog_Use_item_info_list::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void UseItemLog_Use_item_info_list::Swap(UseItemLog_Use_item_info_list* other) {
  if (other != this) {
    std::swap(item_id_, other->item_id_);
    std::swap(count_, other->count_);
    std::swap(unknown_4_, other->unknown_4_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UseItemLog_Use_item_info_list::GetTypeName() const {
  return "DS3_FpdLogMessage.UseItemLog.Use_item_info_list";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int UseItemLog::kUseItemInfoListFieldNumber;
const int UseItemLog::kUnknown5FieldNumber;
const int UseItemLog::kLocationFieldNumber;
#endif  // !_MSC_VER

UseItemLog::UseItemLog()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_FpdLogMessage.UseItemLog)
}

void UseItemLog::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  location_ = const_cast< ::DS3_FpdLogMessage::Vector*>(
      ::DS3_FpdLogMessage::Vector::internal_default_instance());
#else
  location_ = const_cast< ::DS3_FpdLogMessage::Vector*>(&::DS3_FpdLogMessage::Vector::default_instance());
#endif
}

UseItemLog::UseItemLog(const UseItemLog& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_FpdLogMessage.UseItemLog)
}

void UseItemLog::SharedCtor() {
  _cached_size_ = 0;
  unknown_5_ = 0u;
  location_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UseItemLog::~UseItemLog() {
  // @@protoc_insertion_point(destructor:DS3_FpdLogMessage.UseItemLog)
  SharedDtor();
}

void UseItemLog::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete location_;
  }
}

void UseItemLog::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UseItemLog& UseItemLog::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFpdLogMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFpdLogMessage_2eproto();
#endif
  return *default_instance_;
}

UseItemLog* UseItemLog::default_instance_ = NULL;

UseItemLog* UseItemLog::New() const {
  return new UseItemLog;
}

void UseItemLog::Clear() {
  if (_has_bits_[0 / 32] & 6) {
    unknown_5_ = 0u;
    if (has_location()) {
      if (location_ != NULL) location_->::DS3_FpdLogMessage::Vector::Clear();
    }
  }
  use_item_info_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool UseItemLog::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_FpdLogMessage.UseItemLog)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated group Use_item_info_list = 1 {
      case 1: {
        if (tag == 11) {
         parse_use_item_info_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadGroupNoVirtual(
                1, input, add_use_item_info_list()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(11)) goto parse_use_item_info_list;
        if (input->ExpectTag(40)) goto parse_unknown_5;
        break;
      }

      // required uint32 unknown_5 = 5;
      case 5: {
        if (tag == 40) {
         parse_unknown_5:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_5_)));
          set_has_unknown_5();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_location;
        break;
      }

      // required .DS3_FpdLogMessage.Vector location = 6;
      case 6: {
        if (tag == 50) {
         parse_location:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_location()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_FpdLogMessage.UseItemLog)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_FpdLogMessage.UseItemLog)
  return false;
#undef DO_
}

void UseItemLog::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_FpdLogMessage.UseItemLog)
  // repeated group Use_item_info_list = 1 {
  for (int i = 0; i < this->use_item_info_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteGroup(
      1, this->use_item_info_list(i), output);
  }

  // required uint32 unknown_5 = 5;
  if (has_unknown_5()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->unknown_5(), output);
  }

  // required .DS3_FpdLogMessage.Vector location = 6;
  if (has_location()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, this->location(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_FpdLogMessage.UseItemLog)
}

int UseItemLog::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // required uint32 unknown_5 = 5;
    if (has_unknown_5()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_5());
    }

    // required .DS3_FpdLogMessage.Vector location = 6;
    if (has_location()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->location());
    }

  }
  // repeated group Use_item_info_list = 1 {
  total_size += 2 * this->use_item_info_list_size();
  for (int i = 0; i < this->use_item_info_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::GroupSizeNoVirtual(
        this->use_item_info_list(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UseItemLog::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UseItemLog*>(&from));
}

void UseItemLog::MergeFrom(const UseItemLog& from) {
  GOOGLE_CHECK_NE(&from, this);
  use_item_info_list_.MergeFrom(from.use_item_info_list_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_unknown_5()) {
      set_unknown_5(from.unknown_5());
    }
    if (from.has_location()) {
      mutable_location()->::DS3_FpdLogMessage::Vector::MergeFrom(from.location());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void UseItemLog::CopyFrom(const UseItemLog& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UseItemLog::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000006) != 0x00000006) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->use_item_info_list())) return false;
  if (has_location()) {
    if (!this->location().IsInitialized()) return false;
  }
  return true;
}

void UseItemLog::Swap(UseItemLog* other) {
  if (other != this) {
    use_item_info_list_.Swap(&other->use_item_info_list_);
    std::swap(unknown_5_, other->unknown_5_);
    std::swap(location_, other->location_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UseItemLog::GetTypeName() const {
  return "DS3_FpdLogMessage.UseItemLog";
}


// ===================================================================

#ifndef _MSC_VER
const int GetItemLog_Get_item_info_list::kUnknown2FieldNumber;
const int GetItemLog_Get_item_info_list::kLocationFieldNumber;
const int GetItemLog_Get_item_info_list::kUnknown4FieldNumber;
const int GetItemLog_Get_item_info_list::kItemIdFieldNumber;
const int GetItemLog_Get_item_info_list::kCountFieldNumber;
const int GetItemLog_Get_item_info_list::kUnknown7FieldNumber;
const int GetItemLog_Get_item_info_list::kUnknown8FieldNumber;
const int GetItemLog_Get_item_info_list::kUnknown9FieldNumber;
#endif  // !_MSC_VER

GetItemLog_Get_item_info_list::GetItemLog_Get_item_info_list()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_FpdLogMessage.GetItemLog.Get_item_info_list)
}

void GetItemLog_Get_item_info_list::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  location_ = const_cast< ::DS3_FpdLogMessage::Vector*>(
      ::DS3_FpdLogMessage::Vector::internal_default_instance());
#else
  location_ = const_cast< ::DS3_FpdLogMessage::Vector*>(&::DS3_FpdLogMessage::Vector::default_instance());
#endif
}

GetItemLog_Get_item_info_list::GetItemLog_Get_item_info_list(const GetItemLog_Get_item_info_list& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_FpdLogMessage.GetItemLog.Get_item_info_list)
}

void GetItemLog_Get_item_info_list::SharedCtor() {
  _cached_size_ = 0;
  unknown_2_ = 0u;
  location_ = NULL;
  unknown_4_ = 0u;
  item_id_ = 0u;
  count_ = 0u;
  unknown_7_ = 0u;
  unknown_8_ = 0u;
  unknown_9_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetItemLog_Get_item_info_list::~GetItemLog_Get_item_info_list() {
  // @@protoc_insertion_point(destructor:DS3_FpdLogMessage.GetItemLog.Get_item_info_list)
  SharedDtor();
}

void GetItemLog_Get_item_info_list::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete location_;
  }
}

void GetItemLog_Get_item_info_list::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GetItemLog_Get_item_info_list& GetItemLog_Get_item_info_list::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFpdLogMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFpdLogMessage_2eproto();
#endif
  return *default_instance_;
}

GetItemLog_Get_item_info_list* GetItemLog_Get_item_info_list::default_instance_ = NULL;

GetItemLog_Get_item_info_list* GetItemLog_Get_item_info_list::New() const {
  return new GetItemLog_Get_item_info_list;
}

void GetItemLog_Get_item_info_list::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<GetItemLog_Get_item_info_list*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(unknown_2_, unknown_9_);
    if (has_location()) {
      if (location_ != NULL) location_->::DS3_FpdLogMessage::Vector::Clear();
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool GetItemLog_Get_item_info_list::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_FpdLogMessage.GetItemLog.Get_item_info_list)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 unknown_2 = 2;
      case 2: {
        if (tag == 16) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_2_)));
          set_has_unknown_2();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_location;
        break;
      }

      // required .DS3_FpdLogMessage.Vector location = 3;
      case 3: {
        if (tag == 26) {
         parse_location:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_location()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_unknown_4;
        break;
      }

      // required uint32 unknown_4 = 4;
      case 4: {
        if (tag == 32) {
         parse_unknown_4:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_4_)));
          set_has_unknown_4();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_item_id;
        break;
      }

      // required uint32 item_id = 5;
      case 5: {
        if (tag == 40) {
         parse_item_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &item_id_)));
          set_has_item_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_count;
        break;
      }

      // required uint32 count = 6;
      case 6: {
        if (tag == 48) {
         parse_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &count_)));
          set_has_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_unknown_7;
        break;
      }

      // required uint32 unknown_7 = 7;
      case 7: {
        if (tag == 56) {
         parse_unknown_7:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_7_)));
          set_has_unknown_7();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_unknown_8;
        break;
      }

      // required uint32 unknown_8 = 8;
      case 8: {
        if (tag == 64) {
         parse_unknown_8:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_8_)));
          set_has_unknown_8();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_unknown_9;
        break;
      }

      // required uint32 unknown_9 = 9;
      case 9: {
        if (tag == 72) {
         parse_unknown_9:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_9_)));
          set_has_unknown_9();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_FpdLogMessage.GetItemLog.Get_item_info_list)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_FpdLogMessage.GetItemLog.Get_item_info_list)
  return false;
#undef DO_
}

void GetItemLog_Get_item_info_list::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_FpdLogMessage.GetItemLog.Get_item_info_list)
  // required uint32 unknown_2 = 2;
  if (has_unknown_2()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->unknown_2(), output);
  }

  // required .DS3_FpdLogMessage.Vector location = 3;
  if (has_location()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->location(), output);
  }

  // required uint32 unknown_4 = 4;
  if (has_unknown_4()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->unknown_4(), output);
  }

  // required uint32 item_id = 5;
  if (has_item_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->item_id(), output);
  }

  // required uint32 count = 6;
  if (has_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->count(), output);
  }

  // required uint32 unknown_7 = 7;
  if (has_unknown_7()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->unknown_7(), output);
  }

  // required uint32 unknown_8 = 8;
  if (has_unknown_8()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->unknown_8(), output);
  }

  // required uint32 unknown_9 = 9;
  if (has_unknown_9()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->unknown_9(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_FpdLogMessage.GetItemLog.Get_item_info_list)
}

int GetItemLog_Get_item_info_list::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 unknown_2 = 2;
    if (has_unknown_2()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_2());
    }

    // required .DS3_FpdLogMessage.Vector location = 3;
    if (has_location()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->location());
    }

    // required uint32 unknown_4 = 4;
    if (has_unknown_4()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_4());
    }

    // required uint32 item_id = 5;
    if (has_item_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->item_id());
    }

    // required uint32 count = 6;
    if (has_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->count());
    }

    // required uint32 unknown_7 = 7;
    if (has_unknown_7()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_7());
    }

    // required uint32 unknown_8 = 8;
    if (has_unknown_8()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_8());
    }

    // required uint32 unknown_9 = 9;
    if (has_unknown_9()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_9());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetItemLog_Get_item_info_list::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GetItemLog_Get_item_info_list*>(&from));
}

void GetItemLog_Get_item_info_list::MergeFrom(const GetItemLog_Get_item_info_list& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_unknown_2()) {
      set_unknown_2(from.unknown_2());
    }
    if (from.has_location()) {
      mutable_location()->::DS3_FpdLogMessage::Vector::MergeFrom(from.location());
    }
    if (from.has_unknown_4()) {
      set_unknown_4(from.unknown_4());
    }
    if (from.has_item_id()) {
      set_item_id(from.item_id());
    }
    if (from.has_count()) {
      set_count(from.count());
    }
    if (from.has_unknown_7()) {
      set_unknown_7(from.unknown_7());
    }
    if (from.has_unknown_8()) {
      set_unknown_8(from.unknown_8());
    }
    if (from.has_unknown_9()) {
      set_unknown_9(from.unknown_9());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void GetItemLog_Get_item_info_list::CopyFrom(const GetItemLog_Get_item_info_list& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetItemLog_Get_item_info_list::IsInitialized() const {
  if ((_has_bits_[0] & 0x000000ff) != 0x000000ff) return false;

  if (has_location()) {
    if (!this->location().IsInitialized()) return false;
  }
  return true;
}

void GetItemLog_Get_item_info_list::Swap(GetItemLog_Get_item_info_list* other) {
  if (other != this) {
    std::swap(unknown_2_, other->unknown_2_);
    std::swap(location_, other->location_);
    std::swap(unknown_4_, other->unknown_4_);
    std::swap(item_id_, other->item_id_);
    std::swap(count_, other->count_);
    std::swap(unknown_7_, other->unknown_7_);
    std::swap(unknown_8_, other->unknown_8_);
    std::swap(unknown_9_, other->unknown_9_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GetItemLog_Get_item_info_list::GetTypeName() const {
  return "DS3_FpdLogMessage.GetItemLog.Get_item_info_list";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int GetItemLog::kGetItemInfoListFieldNumber;
#endif  // !_MSC_VER

GetItemLog::GetItemLog()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_FpdLogMessage.GetItemLog)
}

void GetItemLog::InitAsDefaultInstance() {
}

GetItemLog::GetItemLog(const GetItemLog& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_FpdLogMessage.GetItemLog)
}

void GetItemLog::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetItemLog::~GetItemLog() {
  // @@protoc_insertion_point(destructor:DS3_FpdLogMessage.GetItemLog)
  SharedDtor();
}

void GetItemLog::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GetItemLog::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GetItemLog& GetItemLog::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFpdLogMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFpdLogMessage_2eproto();
#endif
  return *default_instance_;
}

GetItemLog* GetItemLog::default_instance_ = NULL;

GetItemLog* GetItemLog::New() const {
  return new GetItemLog;
}

void GetItemLog::Clear() {
  get_item_info_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool GetItemLog::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_FpdLogMessage.GetItemLog)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated group Get_item_info_list = 1 {
      case 1: {
        if (tag == 11) {
         parse_get_item_info_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadGroupNoVirtual(
                1, input, add_get_item_info_list()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(11)) goto parse_get_item_info_list;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_FpdLogMessage.GetItemLog)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_FpdLogMessage.GetItemLog)
  return false;
#undef DO_
}

void GetItemLog::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_FpdLogMessage.GetItemLog)
  // repeated group Get_item_info_list = 1 {
  for (int i = 0; i < this->get_item_info_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteGroup(
      1, this->get_item_info_list(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_FpdLogMessage.GetItemLog)
}

int GetItemLog::ByteSize() const {
  int total_size = 0;

  // repeated group Get_item_info_list = 1 {
  total_size += 2 * this->get_item_info_list_size();
  for (int i = 0; i < this->get_item_info_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::GroupSizeNoVirtual(
        this->get_item_info_list(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetItemLog::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GetItemLog*>(&from));
}

void GetItemLog::MergeFrom(const GetItemLog& from) {
  GOOGLE_CHECK_NE(&from, this);
  get_item_info_list_.MergeFrom(from.get_item_info_list_);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void GetItemLog::CopyFrom(const GetItemLog& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetItemLog::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->get_item_info_list())) return false;
  return true;
}

void GetItemLog::Swap(GetItemLog* other) {
  if (other != this) {
    get_item_info_list_.Swap(&other->get_item_info_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GetItemLog::GetTypeName() const {
  return "DS3_FpdLogMessage.GetItemLog";
}


// ===================================================================

#ifndef _MSC_VER
const int ActGestureLog_Use_gesture_info_list::kGuestureIdFieldNumber;
const int ActGestureLog_Use_gesture_info_list::kCountFieldNumber;
#endif  // !_MSC_VER

ActGestureLog_Use_gesture_info_list::ActGestureLog_Use_gesture_info_list()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_FpdLogMessage.ActGestureLog.Use_gesture_info_list)
}

void ActGestureLog_Use_gesture_info_list::InitAsDefaultInstance() {
}

ActGestureLog_Use_gesture_info_list::ActGestureLog_Use_gesture_info_list(const ActGestureLog_Use_gesture_info_list& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_FpdLogMessage.ActGestureLog.Use_gesture_info_list)
}

void ActGestureLog_Use_gesture_info_list::SharedCtor() {
  _cached_size_ = 0;
  guesture_id_ = 0u;
  count_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ActGestureLog_Use_gesture_info_list::~ActGestureLog_Use_gesture_info_list() {
  // @@protoc_insertion_point(destructor:DS3_FpdLogMessage.ActGestureLog.Use_gesture_info_list)
  SharedDtor();
}

void ActGestureLog_Use_gesture_info_list::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ActGestureLog_Use_gesture_info_list::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ActGestureLog_Use_gesture_info_list& ActGestureLog_Use_gesture_info_list::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFpdLogMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFpdLogMessage_2eproto();
#endif
  return *default_instance_;
}

ActGestureLog_Use_gesture_info_list* ActGestureLog_Use_gesture_info_list::default_instance_ = NULL;

ActGestureLog_Use_gesture_info_list* ActGestureLog_Use_gesture_info_list::New() const {
  return new ActGestureLog_Use_gesture_info_list;
}

void ActGestureLog_Use_gesture_info_list::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<ActGestureLog_Use_gesture_info_list*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(guesture_id_, count_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool ActGestureLog_Use_gesture_info_list::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_FpdLogMessage.ActGestureLog.Use_gesture_info_list)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 guesture_id = 2;
      case 2: {
        if (tag == 16) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &guesture_id_)));
          set_has_guesture_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_count;
        break;
      }

      // required uint32 count = 3;
      case 3: {
        if (tag == 24) {
         parse_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &count_)));
          set_has_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_FpdLogMessage.ActGestureLog.Use_gesture_info_list)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_FpdLogMessage.ActGestureLog.Use_gesture_info_list)
  return false;
#undef DO_
}

void ActGestureLog_Use_gesture_info_list::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_FpdLogMessage.ActGestureLog.Use_gesture_info_list)
  // required uint32 guesture_id = 2;
  if (has_guesture_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->guesture_id(), output);
  }

  // required uint32 count = 3;
  if (has_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->count(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_FpdLogMessage.ActGestureLog.Use_gesture_info_list)
}

int ActGestureLog_Use_gesture_info_list::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 guesture_id = 2;
    if (has_guesture_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->guesture_id());
    }

    // required uint32 count = 3;
    if (has_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->count());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ActGestureLog_Use_gesture_info_list::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ActGestureLog_Use_gesture_info_list*>(&from));
}

void ActGestureLog_Use_gesture_info_list::MergeFrom(const ActGestureLog_Use_gesture_info_list& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_guesture_id()) {
      set_guesture_id(from.guesture_id());
    }
    if (from.has_count()) {
      set_count(from.count());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void ActGestureLog_Use_gesture_info_list::CopyFrom(const ActGestureLog_Use_gesture_info_list& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ActGestureLog_Use_gesture_info_list::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void ActGestureLog_Use_gesture_info_list::Swap(ActGestureLog_Use_gesture_info_list* other) {
  if (other != this) {
    std::swap(guesture_id_, other->guesture_id_);
    std::swap(count_, other->count_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ActGestureLog_Use_gesture_info_list::GetTypeName() const {
  return "DS3_FpdLogMessage.ActGestureLog.Use_gesture_info_list";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int ActGestureLog::kUseGestureInfoListFieldNumber;
const int ActGestureLog::kUnknown4FieldNumber;
const int ActGestureLog::kUnknown5FieldNumber;
#endif  // !_MSC_VER

ActGestureLog::ActGestureLog()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_FpdLogMessage.ActGestureLog)
}

void ActGestureLog::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  unknown_5_ = const_cast< ::DS3_FpdLogMessage::Vector*>(
      ::DS3_FpdLogMessage::Vector::internal_default_instance());
#else
  unknown_5_ = const_cast< ::DS3_FpdLogMessage::Vector*>(&::DS3_FpdLogMessage::Vector::default_instance());
#endif
}

ActGestureLog::ActGestureLog(const ActGestureLog& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_FpdLogMessage.ActGestureLog)
}

void ActGestureLog::SharedCtor() {
  _cached_size_ = 0;
  unknown_4_ = 0u;
  unknown_5_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ActGestureLog::~ActGestureLog() {
  // @@protoc_insertion_point(destructor:DS3_FpdLogMessage.ActGestureLog)
  SharedDtor();
}

void ActGestureLog::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete unknown_5_;
  }
}

void ActGestureLog::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ActGestureLog& ActGestureLog::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFpdLogMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFpdLogMessage_2eproto();
#endif
  return *default_instance_;
}

ActGestureLog* ActGestureLog::default_instance_ = NULL;

ActGestureLog* ActGestureLog::New() const {
  return new ActGestureLog;
}

void ActGestureLog::Clear() {
  if (_has_bits_[0 / 32] & 6) {
    unknown_4_ = 0u;
    if (has_unknown_5()) {
      if (unknown_5_ != NULL) unknown_5_->::DS3_FpdLogMessage::Vector::Clear();
    }
  }
  use_gesture_info_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool ActGestureLog::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_FpdLogMessage.ActGestureLog)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated group Use_gesture_info_list = 1 {
      case 1: {
        if (tag == 11) {
         parse_use_gesture_info_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadGroupNoVirtual(
                1, input, add_use_gesture_info_list()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(11)) goto parse_use_gesture_info_list;
        if (input->ExpectTag(32)) goto parse_unknown_4;
        break;
      }

      // required uint32 unknown_4 = 4;
      case 4: {
        if (tag == 32) {
         parse_unknown_4:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_4_)));
          set_has_unknown_4();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_unknown_5;
        break;
      }

      // required .DS3_FpdLogMessage.Vector unknown_5 = 5;
      case 5: {
        if (tag == 42) {
         parse_unknown_5:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_unknown_5()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_FpdLogMessage.ActGestureLog)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_FpdLogMessage.ActGestureLog)
  return false;
#undef DO_
}

void ActGestureLog::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_FpdLogMessage.ActGestureLog)
  // repeated group Use_gesture_info_list = 1 {
  for (int i = 0; i < this->use_gesture_info_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteGroup(
      1, this->use_gesture_info_list(i), output);
  }

  // required uint32 unknown_4 = 4;
  if (has_unknown_4()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->unknown_4(), output);
  }

  // required .DS3_FpdLogMessage.Vector unknown_5 = 5;
  if (has_unknown_5()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, this->unknown_5(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_FpdLogMessage.ActGestureLog)
}

int ActGestureLog::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // required uint32 unknown_4 = 4;
    if (has_unknown_4()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_4());
    }

    // required .DS3_FpdLogMessage.Vector unknown_5 = 5;
    if (has_unknown_5()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->unknown_5());
    }

  }
  // repeated group Use_gesture_info_list = 1 {
  total_size += 2 * this->use_gesture_info_list_size();
  for (int i = 0; i < this->use_gesture_info_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::GroupSizeNoVirtual(
        this->use_gesture_info_list(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ActGestureLog::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ActGestureLog*>(&from));
}

void ActGestureLog::MergeFrom(const ActGestureLog& from) {
  GOOGLE_CHECK_NE(&from, this);
  use_gesture_info_list_.MergeFrom(from.use_gesture_info_list_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_unknown_4()) {
      set_unknown_4(from.unknown_4());
    }
    if (from.has_unknown_5()) {
      mutable_unknown_5()->::DS3_FpdLogMessage::Vector::MergeFrom(from.unknown_5());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void ActGestureLog::CopyFrom(const ActGestureLog& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ActGestureLog::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000006) != 0x00000006) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->use_gesture_info_list())) return false;
  if (has_unknown_5()) {
    if (!this->unknown_5().IsInitialized()) return false;
  }
  return true;
}

void ActGestureLog::Swap(ActGestureLog* other) {
  if (other != this) {
    use_gesture_info_list_.Swap(&other->use_gesture_info_list_);
    std::swap(unknown_4_, other->unknown_4_);
    std::swap(unknown_5_, other->unknown_5_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ActGestureLog::GetTypeName() const {
  return "DS3_FpdLogMessage.ActGestureLog";
}


// ===================================================================

#ifndef _MSC_VER
const int UseMagicLog_Use_magic_info_list::kSpellIdFieldNumber;
const int UseMagicLog_Use_magic_info_list::kCountFieldNumber;
#endif  // !_MSC_VER

UseMagicLog_Use_magic_info_list::UseMagicLog_Use_magic_info_list()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_FpdLogMessage.UseMagicLog.Use_magic_info_list)
}

void UseMagicLog_Use_magic_info_list::InitAsDefaultInstance() {
}

UseMagicLog_Use_magic_info_list::UseMagicLog_Use_magic_info_list(const UseMagicLog_Use_magic_info_list& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_FpdLogMessage.UseMagicLog.Use_magic_info_list)
}

void UseMagicLog_Use_magic_info_list::SharedCtor() {
  _cached_size_ = 0;
  spell_id_ = 0u;
  count_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UseMagicLog_Use_magic_info_list::~UseMagicLog_Use_magic_info_list() {
  // @@protoc_insertion_point(destructor:DS3_FpdLogMessage.UseMagicLog.Use_magic_info_list)
  SharedDtor();
}

void UseMagicLog_Use_magic_info_list::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void UseMagicLog_Use_magic_info_list::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UseMagicLog_Use_magic_info_list& UseMagicLog_Use_magic_info_list::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFpdLogMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFpdLogMessage_2eproto();
#endif
  return *default_instance_;
}

UseMagicLog_Use_magic_info_list* UseMagicLog_Use_magic_info_list::default_instance_ = NULL;

UseMagicLog_Use_magic_info_list* UseMagicLog_Use_magic_info_list::New() const {
  return new UseMagicLog_Use_magic_info_list;
}

void UseMagicLog_Use_magic_info_list::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<UseMagicLog_Use_magic_info_list*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(spell_id_, count_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool UseMagicLog_Use_magic_info_list::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_FpdLogMessage.UseMagicLog.Use_magic_info_list)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 spell_id = 2;
      case 2: {
        if (tag == 16) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &spell_id_)));
          set_has_spell_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_count;
        break;
      }

      // required uint32 count = 3;
      case 3: {
        if (tag == 24) {
         parse_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &count_)));
          set_has_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_FpdLogMessage.UseMagicLog.Use_magic_info_list)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_FpdLogMessage.UseMagicLog.Use_magic_info_list)
  return false;
#undef DO_
}

void UseMagicLog_Use_magic_info_list::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_FpdLogMessage.UseMagicLog.Use_magic_info_list)
  // required uint32 spell_id = 2;
  if (has_spell_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->spell_id(), output);
  }

  // required uint32 count = 3;
  if (has_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->count(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_FpdLogMessage.UseMagicLog.Use_magic_info_list)
}

int UseMagicLog_Use_magic_info_list::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 spell_id = 2;
    if (has_spell_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->spell_id());
    }

    // required uint32 count = 3;
    if (has_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->count());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UseMagicLog_Use_magic_info_list::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UseMagicLog_Use_magic_info_list*>(&from));
}

void UseMagicLog_Use_magic_info_list::MergeFrom(const UseMagicLog_Use_magic_info_list& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_spell_id()) {
      set_spell_id(from.spell_id());
    }
    if (from.has_count()) {
      set_count(from.count());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void UseMagicLog_Use_magic_info_list::CopyFrom(const UseMagicLog_Use_magic_info_list& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UseMagicLog_Use_magic_info_list::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void UseMagicLog_Use_magic_info_list::Swap(UseMagicLog_Use_magic_info_list* other) {
  if (other != this) {
    std::swap(spell_id_, other->spell_id_);
    std::swap(count_, other->count_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UseMagicLog_Use_magic_info_list::GetTypeName() const {
  return "DS3_FpdLogMessage.UseMagicLog.Use_magic_info_list";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int UseMagicLog::kUseMagicInfoListFieldNumber;
const int UseMagicLog::kUnknown4FieldNumber;
const int UseMagicLog::kLocationFieldNumber;
#endif  // !_MSC_VER

UseMagicLog::UseMagicLog()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_FpdLogMessage.UseMagicLog)
}

void UseMagicLog::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  location_ = const_cast< ::DS3_FpdLogMessage::Vector*>(
      ::DS3_FpdLogMessage::Vector::internal_default_instance());
#else
  location_ = const_cast< ::DS3_FpdLogMessage::Vector*>(&::DS3_FpdLogMessage::Vector::default_instance());
#endif
}

UseMagicLog::UseMagicLog(const UseMagicLog& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_FpdLogMessage.UseMagicLog)
}

void UseMagicLog::SharedCtor() {
  _cached_size_ = 0;
  unknown_4_ = 0u;
  location_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UseMagicLog::~UseMagicLog() {
  // @@protoc_insertion_point(destructor:DS3_FpdLogMessage.UseMagicLog)
  SharedDtor();
}

void UseMagicLog::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete location_;
  }
}

void UseMagicLog::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UseMagicLog& UseMagicLog::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFpdLogMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFpdLogMessage_2eproto();
#endif
  return *default_instance_;
}

UseMagicLog* UseMagicLog::default_instance_ = NULL;

UseMagicLog* UseMagicLog::New() const {
  return new UseMagicLog;
}

void UseMagicLog::Clear() {
  if (_has_bits_[0 / 32] & 6) {
    unknown_4_ = 0u;
    if (has_location()) {
      if (location_ != NULL) location_->::DS3_FpdLogMessage::Vector::Clear();
    }
  }
  use_magic_info_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool UseMagicLog::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_FpdLogMessage.UseMagicLog)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated group Use_magic_info_list = 1 {
      case 1: {
        if (tag == 11) {
         parse_use_magic_info_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadGroupNoVirtual(
                1, input, add_use_magic_info_list()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(11)) goto parse_use_magic_info_list;
        if (input->ExpectTag(32)) goto parse_unknown_4;
        break;
      }

      // required uint32 unknown_4 = 4;
      case 4: {
        if (tag == 32) {
         parse_unknown_4:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_4_)));
          set_has_unknown_4();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_location;
        break;
      }

      // required .DS3_FpdLogMessage.Vector location = 5;
      case 5: {
        if (tag == 42) {
         parse_location:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_location()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_FpdLogMessage.UseMagicLog)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_FpdLogMessage.UseMagicLog)
  return false;
#undef DO_
}

void UseMagicLog::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_FpdLogMessage.UseMagicLog)
  // repeated group Use_magic_info_list = 1 {
  for (int i = 0; i < this->use_magic_info_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteGroup(
      1, this->use_magic_info_list(i), output);
  }

  // required uint32 unknown_4 = 4;
  if (has_unknown_4()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->unknown_4(), output);
  }

  // required .DS3_FpdLogMessage.Vector location = 5;
  if (has_location()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, this->location(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_FpdLogMessage.UseMagicLog)
}

int UseMagicLog::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // required uint32 unknown_4 = 4;
    if (has_unknown_4()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_4());
    }

    // required .DS3_FpdLogMessage.Vector location = 5;
    if (has_location()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->location());
    }

  }
  // repeated group Use_magic_info_list = 1 {
  total_size += 2 * this->use_magic_info_list_size();
  for (int i = 0; i < this->use_magic_info_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::GroupSizeNoVirtual(
        this->use_magic_info_list(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UseMagicLog::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UseMagicLog*>(&from));
}

void UseMagicLog::MergeFrom(const UseMagicLog& from) {
  GOOGLE_CHECK_NE(&from, this);
  use_magic_info_list_.MergeFrom(from.use_magic_info_list_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_unknown_4()) {
      set_unknown_4(from.unknown_4());
    }
    if (from.has_location()) {
      mutable_location()->::DS3_FpdLogMessage::Vector::MergeFrom(from.location());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void UseMagicLog::CopyFrom(const UseMagicLog& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UseMagicLog::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000006) != 0x00000006) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->use_magic_info_list())) return false;
  if (has_location()) {
    if (!this->location().IsInitialized()) return false;
  }
  return true;
}

void UseMagicLog::Swap(UseMagicLog* other) {
  if (other != this) {
    use_magic_info_list_.Swap(&other->use_magic_info_list_);
    std::swap(unknown_4_, other->unknown_4_);
    std::swap(location_, other->location_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UseMagicLog::GetTypeName() const {
  return "DS3_FpdLogMessage.UseMagicLog";
}


// ===================================================================

#ifndef _MSC_VER
const int PurchaseItemLog_Purchase_item_info_list::kUnknown2FieldNumber;
const int PurchaseItemLog_Purchase_item_info_list::kLocationFieldNumber;
const int PurchaseItemLog_Purchase_item_info_list::kItemIdFieldNumber;
const int PurchaseItemLog_Purchase_item_info_list::kUnknown6FieldNumber;
const int PurchaseItemLog_Purchase_item_info_list::kCountFieldNumber;
#endif  // !_MSC_VER

PurchaseItemLog_Purchase_item_info_list::PurchaseItemLog_Purchase_item_info_list()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_FpdLogMessage.PurchaseItemLog.Purchase_item_info_list)
}

void PurchaseItemLog_Purchase_item_info_list::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  location_ = const_cast< ::DS3_FpdLogMessage::Vector*>(
      ::DS3_FpdLogMessage::Vector::internal_default_instance());
#else
  location_ = const_cast< ::DS3_FpdLogMessage::Vector*>(&::DS3_FpdLogMessage::Vector::default_instance());
#endif
}

PurchaseItemLog_Purchase_item_info_list::PurchaseItemLog_Purchase_item_info_list(const PurchaseItemLog_Purchase_item_info_list& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_FpdLogMessage.PurchaseItemLog.Purchase_item_info_list)
}

void PurchaseItemLog_Purchase_item_info_list::SharedCtor() {
  _cached_size_ = 0;
  unknown_2_ = 0u;
  location_ = NULL;
  item_id_ = 0u;
  unknown_6_ = 0u;
  count_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PurchaseItemLog_Purchase_item_info_list::~PurchaseItemLog_Purchase_item_info_list() {
  // @@protoc_insertion_point(destructor:DS3_FpdLogMessage.PurchaseItemLog.Purchase_item_info_list)
  SharedDtor();
}

void PurchaseItemLog_Purchase_item_info_list::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete location_;
  }
}

void PurchaseItemLog_Purchase_item_info_list::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PurchaseItemLog_Purchase_item_info_list& PurchaseItemLog_Purchase_item_info_list::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFpdLogMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFpdLogMessage_2eproto();
#endif
  return *default_instance_;
}

PurchaseItemLog_Purchase_item_info_list* PurchaseItemLog_Purchase_item_info_list::default_instance_ = NULL;

PurchaseItemLog_Purchase_item_info_list* PurchaseItemLog_Purchase_item_info_list::New() const {
  return new PurchaseItemLog_Purchase_item_info_list;
}

void PurchaseItemLog_Purchase_item_info_list::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<PurchaseItemLog_Purchase_item_info_list*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 31) {
    ZR_(unknown_2_, count_);
    if (has_location()) {
      if (location_ != NULL) location_->::DS3_FpdLogMessage::Vector::Clear();
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool PurchaseItemLog_Purchase_item_info_list::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_FpdLogMessage.PurchaseItemLog.Purchase_item_info_list)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 unknown_2 = 2;
      case 2: {
        if (tag == 16) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_2_)));
          set_has_unknown_2();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_location;
        break;
      }

      // required .DS3_FpdLogMessage.Vector location = 3;
      case 3: {
        if (tag == 26) {
         parse_location:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_location()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_item_id;
        break;
      }

      // required uint32 item_id = 5;
      case 5: {
        if (tag == 40) {
         parse_item_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &item_id_)));
          set_has_item_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_unknown_6;
        break;
      }

      // required uint32 unknown_6 = 6;
      case 6: {
        if (tag == 48) {
         parse_unknown_6:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_6_)));
          set_has_unknown_6();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_count;
        break;
      }

      // required uint32 count = 7;
      case 7: {
        if (tag == 56) {
         parse_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &count_)));
          set_has_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_FpdLogMessage.PurchaseItemLog.Purchase_item_info_list)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_FpdLogMessage.PurchaseItemLog.Purchase_item_info_list)
  return false;
#undef DO_
}

void PurchaseItemLog_Purchase_item_info_list::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_FpdLogMessage.PurchaseItemLog.Purchase_item_info_list)
  // required uint32 unknown_2 = 2;
  if (has_unknown_2()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->unknown_2(), output);
  }

  // required .DS3_FpdLogMessage.Vector location = 3;
  if (has_location()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->location(), output);
  }

  // required uint32 item_id = 5;
  if (has_item_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->item_id(), output);
  }

  // required uint32 unknown_6 = 6;
  if (has_unknown_6()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->unknown_6(), output);
  }

  // required uint32 count = 7;
  if (has_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->count(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_FpdLogMessage.PurchaseItemLog.Purchase_item_info_list)
}

int PurchaseItemLog_Purchase_item_info_list::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 unknown_2 = 2;
    if (has_unknown_2()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_2());
    }

    // required .DS3_FpdLogMessage.Vector location = 3;
    if (has_location()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->location());
    }

    // required uint32 item_id = 5;
    if (has_item_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->item_id());
    }

    // required uint32 unknown_6 = 6;
    if (has_unknown_6()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_6());
    }

    // required uint32 count = 7;
    if (has_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->count());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PurchaseItemLog_Purchase_item_info_list::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PurchaseItemLog_Purchase_item_info_list*>(&from));
}

void PurchaseItemLog_Purchase_item_info_list::MergeFrom(const PurchaseItemLog_Purchase_item_info_list& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_unknown_2()) {
      set_unknown_2(from.unknown_2());
    }
    if (from.has_location()) {
      mutable_location()->::DS3_FpdLogMessage::Vector::MergeFrom(from.location());
    }
    if (from.has_item_id()) {
      set_item_id(from.item_id());
    }
    if (from.has_unknown_6()) {
      set_unknown_6(from.unknown_6());
    }
    if (from.has_count()) {
      set_count(from.count());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void PurchaseItemLog_Purchase_item_info_list::CopyFrom(const PurchaseItemLog_Purchase_item_info_list& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PurchaseItemLog_Purchase_item_info_list::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;

  if (has_location()) {
    if (!this->location().IsInitialized()) return false;
  }
  return true;
}

void PurchaseItemLog_Purchase_item_info_list::Swap(PurchaseItemLog_Purchase_item_info_list* other) {
  if (other != this) {
    std::swap(unknown_2_, other->unknown_2_);
    std::swap(location_, other->location_);
    std::swap(item_id_, other->item_id_);
    std::swap(unknown_6_, other->unknown_6_);
    std::swap(count_, other->count_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PurchaseItemLog_Purchase_item_info_list::GetTypeName() const {
  return "DS3_FpdLogMessage.PurchaseItemLog.Purchase_item_info_list";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int PurchaseItemLog::kPurchaseItemInfoListFieldNumber;
#endif  // !_MSC_VER

PurchaseItemLog::PurchaseItemLog()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_FpdLogMessage.PurchaseItemLog)
}

void PurchaseItemLog::InitAsDefaultInstance() {
}

PurchaseItemLog::PurchaseItemLog(const PurchaseItemLog& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_FpdLogMessage.PurchaseItemLog)
}

void PurchaseItemLog::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PurchaseItemLog::~PurchaseItemLog() {
  // @@protoc_insertion_point(destructor:DS3_FpdLogMessage.PurchaseItemLog)
  SharedDtor();
}

void PurchaseItemLog::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void PurchaseItemLog::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PurchaseItemLog& PurchaseItemLog::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFpdLogMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFpdLogMessage_2eproto();
#endif
  return *default_instance_;
}

PurchaseItemLog* PurchaseItemLog::default_instance_ = NULL;

PurchaseItemLog* PurchaseItemLog::New() const {
  return new PurchaseItemLog;
}

void PurchaseItemLog::Clear() {
  purchase_item_info_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool PurchaseItemLog::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_FpdLogMessage.PurchaseItemLog)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated group Purchase_item_info_list = 1 {
      case 1: {
        if (tag == 11) {
         parse_purchase_item_info_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadGroupNoVirtual(
                1, input, add_purchase_item_info_list()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(11)) goto parse_purchase_item_info_list;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_FpdLogMessage.PurchaseItemLog)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_FpdLogMessage.PurchaseItemLog)
  return false;
#undef DO_
}

void PurchaseItemLog::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_FpdLogMessage.PurchaseItemLog)
  // repeated group Purchase_item_info_list = 1 {
  for (int i = 0; i < this->purchase_item_info_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteGroup(
      1, this->purchase_item_info_list(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_FpdLogMessage.PurchaseItemLog)
}

int PurchaseItemLog::ByteSize() const {
  int total_size = 0;

  // repeated group Purchase_item_info_list = 1 {
  total_size += 2 * this->purchase_item_info_list_size();
  for (int i = 0; i < this->purchase_item_info_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::GroupSizeNoVirtual(
        this->purchase_item_info_list(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PurchaseItemLog::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PurchaseItemLog*>(&from));
}

void PurchaseItemLog::MergeFrom(const PurchaseItemLog& from) {
  GOOGLE_CHECK_NE(&from, this);
  purchase_item_info_list_.MergeFrom(from.purchase_item_info_list_);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void PurchaseItemLog::CopyFrom(const PurchaseItemLog& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PurchaseItemLog::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->purchase_item_info_list())) return false;
  return true;
}

void PurchaseItemLog::Swap(PurchaseItemLog* other) {
  if (other != this) {
    purchase_item_info_list_.Swap(&other->purchase_item_info_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PurchaseItemLog::GetTypeName() const {
  return "DS3_FpdLogMessage.PurchaseItemLog";
}


// ===================================================================

#ifndef _MSC_VER
const int DropItemLog_Throw_away_item_list::kUnknown2FieldNumber;
const int DropItemLog_Throw_away_item_list::kLocationFieldNumber;
const int DropItemLog_Throw_away_item_list::kUnknown4FieldNumber;
const int DropItemLog_Throw_away_item_list::kItemIdFieldNumber;
const int DropItemLog_Throw_away_item_list::kCountFieldNumber;
#endif  // !_MSC_VER

DropItemLog_Throw_away_item_list::DropItemLog_Throw_away_item_list()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_FpdLogMessage.DropItemLog.Throw_away_item_list)
}

void DropItemLog_Throw_away_item_list::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  location_ = const_cast< ::DS3_FpdLogMessage::Vector*>(
      ::DS3_FpdLogMessage::Vector::internal_default_instance());
#else
  location_ = const_cast< ::DS3_FpdLogMessage::Vector*>(&::DS3_FpdLogMessage::Vector::default_instance());
#endif
}

DropItemLog_Throw_away_item_list::DropItemLog_Throw_away_item_list(const DropItemLog_Throw_away_item_list& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_FpdLogMessage.DropItemLog.Throw_away_item_list)
}

void DropItemLog_Throw_away_item_list::SharedCtor() {
  _cached_size_ = 0;
  unknown_2_ = 0u;
  location_ = NULL;
  unknown_4_ = 0u;
  item_id_ = 0u;
  count_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DropItemLog_Throw_away_item_list::~DropItemLog_Throw_away_item_list() {
  // @@protoc_insertion_point(destructor:DS3_FpdLogMessage.DropItemLog.Throw_away_item_list)
  SharedDtor();
}

void DropItemLog_Throw_away_item_list::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete location_;
  }
}

void DropItemLog_Throw_away_item_list::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DropItemLog_Throw_away_item_list& DropItemLog_Throw_away_item_list::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFpdLogMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFpdLogMessage_2eproto();
#endif
  return *default_instance_;
}

DropItemLog_Throw_away_item_list* DropItemLog_Throw_away_item_list::default_instance_ = NULL;

DropItemLog_Throw_away_item_list* DropItemLog_Throw_away_item_list::New() const {
  return new DropItemLog_Throw_away_item_list;
}

void DropItemLog_Throw_away_item_list::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<DropItemLog_Throw_away_item_list*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 31) {
    ZR_(unknown_2_, count_);
    if (has_location()) {
      if (location_ != NULL) location_->::DS3_FpdLogMessage::Vector::Clear();
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool DropItemLog_Throw_away_item_list::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_FpdLogMessage.DropItemLog.Throw_away_item_list)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 unknown_2 = 2;
      case 2: {
        if (tag == 16) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_2_)));
          set_has_unknown_2();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_location;
        break;
      }

      // required .DS3_FpdLogMessage.Vector location = 3;
      case 3: {
        if (tag == 26) {
         parse_location:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_location()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_unknown_4;
        break;
      }

      // required uint32 unknown_4 = 4;
      case 4: {
        if (tag == 32) {
         parse_unknown_4:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_4_)));
          set_has_unknown_4();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_item_id;
        break;
      }

      // required uint32 item_id = 5;
      case 5: {
        if (tag == 40) {
         parse_item_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &item_id_)));
          set_has_item_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_count;
        break;
      }

      // required uint32 count = 6;
      case 6: {
        if (tag == 48) {
         parse_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &count_)));
          set_has_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_FpdLogMessage.DropItemLog.Throw_away_item_list)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_FpdLogMessage.DropItemLog.Throw_away_item_list)
  return false;
#undef DO_
}

void DropItemLog_Throw_away_item_list::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_FpdLogMessage.DropItemLog.Throw_away_item_list)
  // required uint32 unknown_2 = 2;
  if (has_unknown_2()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->unknown_2(), output);
  }

  // required .DS3_FpdLogMessage.Vector location = 3;
  if (has_location()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->location(), output);
  }

  // required uint32 unknown_4 = 4;
  if (has_unknown_4()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->unknown_4(), output);
  }

  // required uint32 item_id = 5;
  if (has_item_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->item_id(), output);
  }

  // required uint32 count = 6;
  if (has_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->count(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_FpdLogMessage.DropItemLog.Throw_away_item_list)
}

int DropItemLog_Throw_away_item_list::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 unknown_2 = 2;
    if (has_unknown_2()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_2());
    }

    // required .DS3_FpdLogMessage.Vector location = 3;
    if (has_location()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->location());
    }

    // required uint32 unknown_4 = 4;
    if (has_unknown_4()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_4());
    }

    // required uint32 item_id = 5;
    if (has_item_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->item_id());
    }

    // required uint32 count = 6;
    if (has_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->count());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DropItemLog_Throw_away_item_list::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DropItemLog_Throw_away_item_list*>(&from));
}

void DropItemLog_Throw_away_item_list::MergeFrom(const DropItemLog_Throw_away_item_list& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_unknown_2()) {
      set_unknown_2(from.unknown_2());
    }
    if (from.has_location()) {
      mutable_location()->::DS3_FpdLogMessage::Vector::MergeFrom(from.location());
    }
    if (from.has_unknown_4()) {
      set_unknown_4(from.unknown_4());
    }
    if (from.has_item_id()) {
      set_item_id(from.item_id());
    }
    if (from.has_count()) {
      set_count(from.count());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void DropItemLog_Throw_away_item_list::CopyFrom(const DropItemLog_Throw_away_item_list& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DropItemLog_Throw_away_item_list::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;

  if (has_location()) {
    if (!this->location().IsInitialized()) return false;
  }
  return true;
}

void DropItemLog_Throw_away_item_list::Swap(DropItemLog_Throw_away_item_list* other) {
  if (other != this) {
    std::swap(unknown_2_, other->unknown_2_);
    std::swap(location_, other->location_);
    std::swap(unknown_4_, other->unknown_4_);
    std::swap(item_id_, other->item_id_);
    std::swap(count_, other->count_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string DropItemLog_Throw_away_item_list::GetTypeName() const {
  return "DS3_FpdLogMessage.DropItemLog.Throw_away_item_list";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int DropItemLog::kThrowAwayItemListFieldNumber;
#endif  // !_MSC_VER

DropItemLog::DropItemLog()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_FpdLogMessage.DropItemLog)
}

void DropItemLog::InitAsDefaultInstance() {
}

DropItemLog::DropItemLog(const DropItemLog& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_FpdLogMessage.DropItemLog)
}

void DropItemLog::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DropItemLog::~DropItemLog() {
  // @@protoc_insertion_point(destructor:DS3_FpdLogMessage.DropItemLog)
  SharedDtor();
}

void DropItemLog::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void DropItemLog::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DropItemLog& DropItemLog::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFpdLogMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFpdLogMessage_2eproto();
#endif
  return *default_instance_;
}

DropItemLog* DropItemLog::default_instance_ = NULL;

DropItemLog* DropItemLog::New() const {
  return new DropItemLog;
}

void DropItemLog::Clear() {
  throw_away_item_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool DropItemLog::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_FpdLogMessage.DropItemLog)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated group Throw_away_item_list = 1 {
      case 1: {
        if (tag == 11) {
         parse_throw_away_item_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadGroupNoVirtual(
                1, input, add_throw_away_item_list()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(11)) goto parse_throw_away_item_list;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_FpdLogMessage.DropItemLog)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_FpdLogMessage.DropItemLog)
  return false;
#undef DO_
}

void DropItemLog::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_FpdLogMessage.DropItemLog)
  // repeated group Throw_away_item_list = 1 {
  for (int i = 0; i < this->throw_away_item_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteGroup(
      1, this->throw_away_item_list(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_FpdLogMessage.DropItemLog)
}

int DropItemLog::ByteSize() const {
  int total_size = 0;

  // repeated group Throw_away_item_list = 1 {
  total_size += 2 * this->throw_away_item_list_size();
  for (int i = 0; i < this->throw_away_item_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::GroupSizeNoVirtual(
        this->throw_away_item_list(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DropItemLog::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DropItemLog*>(&from));
}

void DropItemLog::MergeFrom(const DropItemLog& from) {
  GOOGLE_CHECK_NE(&from, this);
  throw_away_item_list_.MergeFrom(from.throw_away_item_list_);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void DropItemLog::CopyFrom(const DropItemLog& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DropItemLog::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->throw_away_item_list())) return false;
  return true;
}

void DropItemLog::Swap(DropItemLog* other) {
  if (other != this) {
    throw_away_item_list_.Swap(&other->throw_away_item_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string DropItemLog::GetTypeName() const {
  return "DS3_FpdLogMessage.DropItemLog";
}


// ===================================================================

#ifndef _MSC_VER
const int LeaveItemLog_Set_item_info_list::kUnknown2FieldNumber;
const int LeaveItemLog_Set_item_info_list::kLocationFieldNumber;
const int LeaveItemLog_Set_item_info_list::kUnknown4FieldNumber;
const int LeaveItemLog_Set_item_info_list::kItemIdFieldNumber;
const int LeaveItemLog_Set_item_info_list::kCountFieldNumber;
#endif  // !_MSC_VER

LeaveItemLog_Set_item_info_list::LeaveItemLog_Set_item_info_list()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_FpdLogMessage.LeaveItemLog.Set_item_info_list)
}

void LeaveItemLog_Set_item_info_list::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  location_ = const_cast< ::DS3_FpdLogMessage::Vector*>(
      ::DS3_FpdLogMessage::Vector::internal_default_instance());
#else
  location_ = const_cast< ::DS3_FpdLogMessage::Vector*>(&::DS3_FpdLogMessage::Vector::default_instance());
#endif
}

LeaveItemLog_Set_item_info_list::LeaveItemLog_Set_item_info_list(const LeaveItemLog_Set_item_info_list& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_FpdLogMessage.LeaveItemLog.Set_item_info_list)
}

void LeaveItemLog_Set_item_info_list::SharedCtor() {
  _cached_size_ = 0;
  unknown_2_ = 0u;
  location_ = NULL;
  unknown_4_ = 0u;
  item_id_ = 0u;
  count_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LeaveItemLog_Set_item_info_list::~LeaveItemLog_Set_item_info_list() {
  // @@protoc_insertion_point(destructor:DS3_FpdLogMessage.LeaveItemLog.Set_item_info_list)
  SharedDtor();
}

void LeaveItemLog_Set_item_info_list::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete location_;
  }
}

void LeaveItemLog_Set_item_info_list::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const LeaveItemLog_Set_item_info_list& LeaveItemLog_Set_item_info_list::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFpdLogMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFpdLogMessage_2eproto();
#endif
  return *default_instance_;
}

LeaveItemLog_Set_item_info_list* LeaveItemLog_Set_item_info_list::default_instance_ = NULL;

LeaveItemLog_Set_item_info_list* LeaveItemLog_Set_item_info_list::New() const {
  return new LeaveItemLog_Set_item_info_list;
}

void LeaveItemLog_Set_item_info_list::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<LeaveItemLog_Set_item_info_list*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 31) {
    ZR_(unknown_2_, count_);
    if (has_location()) {
      if (location_ != NULL) location_->::DS3_FpdLogMessage::Vector::Clear();
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool LeaveItemLog_Set_item_info_list::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_FpdLogMessage.LeaveItemLog.Set_item_info_list)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 unknown_2 = 2;
      case 2: {
        if (tag == 16) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_2_)));
          set_has_unknown_2();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_location;
        break;
      }

      // required .DS3_FpdLogMessage.Vector location = 3;
      case 3: {
        if (tag == 26) {
         parse_location:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_location()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_unknown_4;
        break;
      }

      // required uint32 unknown_4 = 4;
      case 4: {
        if (tag == 32) {
         parse_unknown_4:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_4_)));
          set_has_unknown_4();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_item_id;
        break;
      }

      // required uint32 item_id = 5;
      case 5: {
        if (tag == 40) {
         parse_item_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &item_id_)));
          set_has_item_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_count;
        break;
      }

      // required uint32 count = 6;
      case 6: {
        if (tag == 48) {
         parse_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &count_)));
          set_has_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_FpdLogMessage.LeaveItemLog.Set_item_info_list)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_FpdLogMessage.LeaveItemLog.Set_item_info_list)
  return false;
#undef DO_
}

void LeaveItemLog_Set_item_info_list::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_FpdLogMessage.LeaveItemLog.Set_item_info_list)
  // required uint32 unknown_2 = 2;
  if (has_unknown_2()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->unknown_2(), output);
  }

  // required .DS3_FpdLogMessage.Vector location = 3;
  if (has_location()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->location(), output);
  }

  // required uint32 unknown_4 = 4;
  if (has_unknown_4()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->unknown_4(), output);
  }

  // required uint32 item_id = 5;
  if (has_item_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->item_id(), output);
  }

  // required uint32 count = 6;
  if (has_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->count(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_FpdLogMessage.LeaveItemLog.Set_item_info_list)
}

int LeaveItemLog_Set_item_info_list::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 unknown_2 = 2;
    if (has_unknown_2()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_2());
    }

    // required .DS3_FpdLogMessage.Vector location = 3;
    if (has_location()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->location());
    }

    // required uint32 unknown_4 = 4;
    if (has_unknown_4()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_4());
    }

    // required uint32 item_id = 5;
    if (has_item_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->item_id());
    }

    // required uint32 count = 6;
    if (has_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->count());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LeaveItemLog_Set_item_info_list::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const LeaveItemLog_Set_item_info_list*>(&from));
}

void LeaveItemLog_Set_item_info_list::MergeFrom(const LeaveItemLog_Set_item_info_list& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_unknown_2()) {
      set_unknown_2(from.unknown_2());
    }
    if (from.has_location()) {
      mutable_location()->::DS3_FpdLogMessage::Vector::MergeFrom(from.location());
    }
    if (from.has_unknown_4()) {
      set_unknown_4(from.unknown_4());
    }
    if (from.has_item_id()) {
      set_item_id(from.item_id());
    }
    if (from.has_count()) {
      set_count(from.count());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void LeaveItemLog_Set_item_info_list::CopyFrom(const LeaveItemLog_Set_item_info_list& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LeaveItemLog_Set_item_info_list::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;

  if (has_location()) {
    if (!this->location().IsInitialized()) return false;
  }
  return true;
}

void LeaveItemLog_Set_item_info_list::Swap(LeaveItemLog_Set_item_info_list* other) {
  if (other != this) {
    std::swap(unknown_2_, other->unknown_2_);
    std::swap(location_, other->location_);
    std::swap(unknown_4_, other->unknown_4_);
    std::swap(item_id_, other->item_id_);
    std::swap(count_, other->count_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string LeaveItemLog_Set_item_info_list::GetTypeName() const {
  return "DS3_FpdLogMessage.LeaveItemLog.Set_item_info_list";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int LeaveItemLog::kSetItemInfoListFieldNumber;
#endif  // !_MSC_VER

LeaveItemLog::LeaveItemLog()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_FpdLogMessage.LeaveItemLog)
}

void LeaveItemLog::InitAsDefaultInstance() {
}

LeaveItemLog::LeaveItemLog(const LeaveItemLog& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_FpdLogMessage.LeaveItemLog)
}

void LeaveItemLog::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LeaveItemLog::~LeaveItemLog() {
  // @@protoc_insertion_point(destructor:DS3_FpdLogMessage.LeaveItemLog)
  SharedDtor();
}

void LeaveItemLog::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void LeaveItemLog::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const LeaveItemLog& LeaveItemLog::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFpdLogMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFpdLogMessage_2eproto();
#endif
  return *default_instance_;
}

LeaveItemLog* LeaveItemLog::default_instance_ = NULL;

LeaveItemLog* LeaveItemLog::New() const {
  return new LeaveItemLog;
}

void LeaveItemLog::Clear() {
  set_item_info_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool LeaveItemLog::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_FpdLogMessage.LeaveItemLog)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated group Set_item_info_list = 1 {
      case 1: {
        if (tag == 11) {
         parse_set_item_info_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadGroupNoVirtual(
                1, input, add_set_item_info_list()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(11)) goto parse_set_item_info_list;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_FpdLogMessage.LeaveItemLog)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_FpdLogMessage.LeaveItemLog)
  return false;
#undef DO_
}

void LeaveItemLog::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_FpdLogMessage.LeaveItemLog)
  // repeated group Set_item_info_list = 1 {
  for (int i = 0; i < this->set_item_info_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteGroup(
      1, this->set_item_info_list(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_FpdLogMessage.LeaveItemLog)
}

int LeaveItemLog::ByteSize() const {
  int total_size = 0;

  // repeated group Set_item_info_list = 1 {
  total_size += 2 * this->set_item_info_list_size();
  for (int i = 0; i < this->set_item_info_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::GroupSizeNoVirtual(
        this->set_item_info_list(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LeaveItemLog::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const LeaveItemLog*>(&from));
}

void LeaveItemLog::MergeFrom(const LeaveItemLog& from) {
  GOOGLE_CHECK_NE(&from, this);
  set_item_info_list_.MergeFrom(from.set_item_info_list_);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void LeaveItemLog::CopyFrom(const LeaveItemLog& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LeaveItemLog::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->set_item_info_list())) return false;
  return true;
}

void LeaveItemLog::Swap(LeaveItemLog* other) {
  if (other != this) {
    set_item_info_list_.Swap(&other->set_item_info_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string LeaveItemLog::GetTypeName() const {
  return "DS3_FpdLogMessage.LeaveItemLog";
}


// ===================================================================

#ifndef _MSC_VER
const int SaleItemLog_Sale_item_info_list::kUnknown2FieldNumber;
const int SaleItemLog_Sale_item_info_list::kLocationFieldNumber;
const int SaleItemLog_Sale_item_info_list::kUnknown4FieldNumber;
const int SaleItemLog_Sale_item_info_list::kItemIdFieldNumber;
const int SaleItemLog_Sale_item_info_list::kCountFieldNumber;
#endif  // !_MSC_VER

SaleItemLog_Sale_item_info_list::SaleItemLog_Sale_item_info_list()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_FpdLogMessage.SaleItemLog.Sale_item_info_list)
}

void SaleItemLog_Sale_item_info_list::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  location_ = const_cast< ::DS3_FpdLogMessage::Vector*>(
      ::DS3_FpdLogMessage::Vector::internal_default_instance());
#else
  location_ = const_cast< ::DS3_FpdLogMessage::Vector*>(&::DS3_FpdLogMessage::Vector::default_instance());
#endif
}

SaleItemLog_Sale_item_info_list::SaleItemLog_Sale_item_info_list(const SaleItemLog_Sale_item_info_list& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_FpdLogMessage.SaleItemLog.Sale_item_info_list)
}

void SaleItemLog_Sale_item_info_list::SharedCtor() {
  _cached_size_ = 0;
  unknown_2_ = 0u;
  location_ = NULL;
  unknown_4_ = 0u;
  item_id_ = 0u;
  count_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SaleItemLog_Sale_item_info_list::~SaleItemLog_Sale_item_info_list() {
  // @@protoc_insertion_point(destructor:DS3_FpdLogMessage.SaleItemLog.Sale_item_info_list)
  SharedDtor();
}

void SaleItemLog_Sale_item_info_list::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete location_;
  }
}

void SaleItemLog_Sale_item_info_list::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SaleItemLog_Sale_item_info_list& SaleItemLog_Sale_item_info_list::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFpdLogMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFpdLogMessage_2eproto();
#endif
  return *default_instance_;
}

SaleItemLog_Sale_item_info_list* SaleItemLog_Sale_item_info_list::default_instance_ = NULL;

SaleItemLog_Sale_item_info_list* SaleItemLog_Sale_item_info_list::New() const {
  return new SaleItemLog_Sale_item_info_list;
}

void SaleItemLog_Sale_item_info_list::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<SaleItemLog_Sale_item_info_list*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 31) {
    ZR_(unknown_2_, count_);
    if (has_location()) {
      if (location_ != NULL) location_->::DS3_FpdLogMessage::Vector::Clear();
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool SaleItemLog_Sale_item_info_list::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_FpdLogMessage.SaleItemLog.Sale_item_info_list)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 unknown_2 = 2;
      case 2: {
        if (tag == 16) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_2_)));
          set_has_unknown_2();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_location;
        break;
      }

      // required .DS3_FpdLogMessage.Vector location = 3;
      case 3: {
        if (tag == 26) {
         parse_location:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_location()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_unknown_4;
        break;
      }

      // required uint32 unknown_4 = 4;
      case 4: {
        if (tag == 32) {
         parse_unknown_4:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_4_)));
          set_has_unknown_4();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_item_id;
        break;
      }

      // required uint32 item_id = 5;
      case 5: {
        if (tag == 40) {
         parse_item_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &item_id_)));
          set_has_item_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_count;
        break;
      }

      // required uint32 count = 6;
      case 6: {
        if (tag == 48) {
         parse_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &count_)));
          set_has_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_FpdLogMessage.SaleItemLog.Sale_item_info_list)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_FpdLogMessage.SaleItemLog.Sale_item_info_list)
  return false;
#undef DO_
}

void SaleItemLog_Sale_item_info_list::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_FpdLogMessage.SaleItemLog.Sale_item_info_list)
  // required uint32 unknown_2 = 2;
  if (has_unknown_2()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->unknown_2(), output);
  }

  // required .DS3_FpdLogMessage.Vector location = 3;
  if (has_location()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->location(), output);
  }

  // required uint32 unknown_4 = 4;
  if (has_unknown_4()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->unknown_4(), output);
  }

  // required uint32 item_id = 5;
  if (has_item_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->item_id(), output);
  }

  // required uint32 count = 6;
  if (has_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->count(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_FpdLogMessage.SaleItemLog.Sale_item_info_list)
}

int SaleItemLog_Sale_item_info_list::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 unknown_2 = 2;
    if (has_unknown_2()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_2());
    }

    // required .DS3_FpdLogMessage.Vector location = 3;
    if (has_location()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->location());
    }

    // required uint32 unknown_4 = 4;
    if (has_unknown_4()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_4());
    }

    // required uint32 item_id = 5;
    if (has_item_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->item_id());
    }

    // required uint32 count = 6;
    if (has_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->count());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SaleItemLog_Sale_item_info_list::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SaleItemLog_Sale_item_info_list*>(&from));
}

void SaleItemLog_Sale_item_info_list::MergeFrom(const SaleItemLog_Sale_item_info_list& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_unknown_2()) {
      set_unknown_2(from.unknown_2());
    }
    if (from.has_location()) {
      mutable_location()->::DS3_FpdLogMessage::Vector::MergeFrom(from.location());
    }
    if (from.has_unknown_4()) {
      set_unknown_4(from.unknown_4());
    }
    if (from.has_item_id()) {
      set_item_id(from.item_id());
    }
    if (from.has_count()) {
      set_count(from.count());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void SaleItemLog_Sale_item_info_list::CopyFrom(const SaleItemLog_Sale_item_info_list& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SaleItemLog_Sale_item_info_list::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;

  if (has_location()) {
    if (!this->location().IsInitialized()) return false;
  }
  return true;
}

void SaleItemLog_Sale_item_info_list::Swap(SaleItemLog_Sale_item_info_list* other) {
  if (other != this) {
    std::swap(unknown_2_, other->unknown_2_);
    std::swap(location_, other->location_);
    std::swap(unknown_4_, other->unknown_4_);
    std::swap(item_id_, other->item_id_);
    std::swap(count_, other->count_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SaleItemLog_Sale_item_info_list::GetTypeName() const {
  return "DS3_FpdLogMessage.SaleItemLog.Sale_item_info_list";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int SaleItemLog::kSaleItemInfoListFieldNumber;
#endif  // !_MSC_VER

SaleItemLog::SaleItemLog()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_FpdLogMessage.SaleItemLog)
}

void SaleItemLog::InitAsDefaultInstance() {
}

SaleItemLog::SaleItemLog(const SaleItemLog& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_FpdLogMessage.SaleItemLog)
}

void SaleItemLog::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SaleItemLog::~SaleItemLog() {
  // @@protoc_insertion_point(destructor:DS3_FpdLogMessage.SaleItemLog)
  SharedDtor();
}

void SaleItemLog::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void SaleItemLog::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SaleItemLog& SaleItemLog::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFpdLogMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFpdLogMessage_2eproto();
#endif
  return *default_instance_;
}

SaleItemLog* SaleItemLog::default_instance_ = NULL;

SaleItemLog* SaleItemLog::New() const {
  return new SaleItemLog;
}

void SaleItemLog::Clear() {
  sale_item_info_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool SaleItemLog::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_FpdLogMessage.SaleItemLog)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated group Sale_item_info_list = 1 {
      case 1: {
        if (tag == 11) {
         parse_sale_item_info_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadGroupNoVirtual(
                1, input, add_sale_item_info_list()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(11)) goto parse_sale_item_info_list;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_FpdLogMessage.SaleItemLog)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_FpdLogMessage.SaleItemLog)
  return false;
#undef DO_
}

void SaleItemLog::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_FpdLogMessage.SaleItemLog)
  // repeated group Sale_item_info_list = 1 {
  for (int i = 0; i < this->sale_item_info_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteGroup(
      1, this->sale_item_info_list(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_FpdLogMessage.SaleItemLog)
}

int SaleItemLog::ByteSize() const {
  int total_size = 0;

  // repeated group Sale_item_info_list = 1 {
  total_size += 2 * this->sale_item_info_list_size();
  for (int i = 0; i < this->sale_item_info_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::GroupSizeNoVirtual(
        this->sale_item_info_list(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SaleItemLog::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SaleItemLog*>(&from));
}

void SaleItemLog::MergeFrom(const SaleItemLog& from) {
  GOOGLE_CHECK_NE(&from, this);
  sale_item_info_list_.MergeFrom(from.sale_item_info_list_);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void SaleItemLog::CopyFrom(const SaleItemLog& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SaleItemLog::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->sale_item_info_list())) return false;
  return true;
}

void SaleItemLog::Swap(SaleItemLog* other) {
  if (other != this) {
    sale_item_info_list_.Swap(&other->sale_item_info_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SaleItemLog::GetTypeName() const {
  return "DS3_FpdLogMessage.SaleItemLog";
}


// ===================================================================

#ifndef _MSC_VER
const int StrengthenWeaponLog_Strengthen_weapon_info_list::kFromItemIdFieldNumber;
const int StrengthenWeaponLog_Strengthen_weapon_info_list::kToItemIdFieldNumber;
#endif  // !_MSC_VER

StrengthenWeaponLog_Strengthen_weapon_info_list::StrengthenWeaponLog_Strengthen_weapon_info_list()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_FpdLogMessage.StrengthenWeaponLog.Strengthen_weapon_info_list)
}

void StrengthenWeaponLog_Strengthen_weapon_info_list::InitAsDefaultInstance() {
}

StrengthenWeaponLog_Strengthen_weapon_info_list::StrengthenWeaponLog_Strengthen_weapon_info_list(const StrengthenWeaponLog_Strengthen_weapon_info_list& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_FpdLogMessage.StrengthenWeaponLog.Strengthen_weapon_info_list)
}

void StrengthenWeaponLog_Strengthen_weapon_info_list::SharedCtor() {
  _cached_size_ = 0;
  from_item_id_ = 0u;
  to_item_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

StrengthenWeaponLog_Strengthen_weapon_info_list::~StrengthenWeaponLog_Strengthen_weapon_info_list() {
  // @@protoc_insertion_point(destructor:DS3_FpdLogMessage.StrengthenWeaponLog.Strengthen_weapon_info_list)
  SharedDtor();
}

void StrengthenWeaponLog_Strengthen_weapon_info_list::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void StrengthenWeaponLog_Strengthen_weapon_info_list::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const StrengthenWeaponLog_Strengthen_weapon_info_list& StrengthenWeaponLog_Strengthen_weapon_info_list::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFpdLogMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFpdLogMessage_2eproto();
#endif
  return *default_instance_;
}

StrengthenWeaponLog_Strengthen_weapon_info_list* StrengthenWeaponLog_Strengthen_weapon_info_list::default_instance_ = NULL;

StrengthenWeaponLog_Strengthen_weapon_info_list* StrengthenWeaponLog_Strengthen_weapon_info_list::New() const {
  return new StrengthenWeaponLog_Strengthen_weapon_info_list;
}

void StrengthenWeaponLog_Strengthen_weapon_info_list::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<StrengthenWeaponLog_Strengthen_weapon_info_list*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(from_item_id_, to_item_id_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool StrengthenWeaponLog_Strengthen_weapon_info_list::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_FpdLogMessage.StrengthenWeaponLog.Strengthen_weapon_info_list)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 from_item_id = 2;
      case 2: {
        if (tag == 16) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &from_item_id_)));
          set_has_from_item_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_to_item_id;
        break;
      }

      // required uint32 to_item_id = 3;
      case 3: {
        if (tag == 24) {
         parse_to_item_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &to_item_id_)));
          set_has_to_item_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_FpdLogMessage.StrengthenWeaponLog.Strengthen_weapon_info_list)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_FpdLogMessage.StrengthenWeaponLog.Strengthen_weapon_info_list)
  return false;
#undef DO_
}

void StrengthenWeaponLog_Strengthen_weapon_info_list::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_FpdLogMessage.StrengthenWeaponLog.Strengthen_weapon_info_list)
  // required uint32 from_item_id = 2;
  if (has_from_item_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->from_item_id(), output);
  }

  // required uint32 to_item_id = 3;
  if (has_to_item_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->to_item_id(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_FpdLogMessage.StrengthenWeaponLog.Strengthen_weapon_info_list)
}

int StrengthenWeaponLog_Strengthen_weapon_info_list::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 from_item_id = 2;
    if (has_from_item_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->from_item_id());
    }

    // required uint32 to_item_id = 3;
    if (has_to_item_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->to_item_id());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StrengthenWeaponLog_Strengthen_weapon_info_list::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const StrengthenWeaponLog_Strengthen_weapon_info_list*>(&from));
}

void StrengthenWeaponLog_Strengthen_weapon_info_list::MergeFrom(const StrengthenWeaponLog_Strengthen_weapon_info_list& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_from_item_id()) {
      set_from_item_id(from.from_item_id());
    }
    if (from.has_to_item_id()) {
      set_to_item_id(from.to_item_id());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void StrengthenWeaponLog_Strengthen_weapon_info_list::CopyFrom(const StrengthenWeaponLog_Strengthen_weapon_info_list& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StrengthenWeaponLog_Strengthen_weapon_info_list::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void StrengthenWeaponLog_Strengthen_weapon_info_list::Swap(StrengthenWeaponLog_Strengthen_weapon_info_list* other) {
  if (other != this) {
    std::swap(from_item_id_, other->from_item_id_);
    std::swap(to_item_id_, other->to_item_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string StrengthenWeaponLog_Strengthen_weapon_info_list::GetTypeName() const {
  return "DS3_FpdLogMessage.StrengthenWeaponLog.Strengthen_weapon_info_list";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int StrengthenWeaponLog::kStrengthenWeaponInfoListFieldNumber;
#endif  // !_MSC_VER

StrengthenWeaponLog::StrengthenWeaponLog()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_FpdLogMessage.StrengthenWeaponLog)
}

void StrengthenWeaponLog::InitAsDefaultInstance() {
}

StrengthenWeaponLog::StrengthenWeaponLog(const StrengthenWeaponLog& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_FpdLogMessage.StrengthenWeaponLog)
}

void StrengthenWeaponLog::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

StrengthenWeaponLog::~StrengthenWeaponLog() {
  // @@protoc_insertion_point(destructor:DS3_FpdLogMessage.StrengthenWeaponLog)
  SharedDtor();
}

void StrengthenWeaponLog::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void StrengthenWeaponLog::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const StrengthenWeaponLog& StrengthenWeaponLog::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFpdLogMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFpdLogMessage_2eproto();
#endif
  return *default_instance_;
}

StrengthenWeaponLog* StrengthenWeaponLog::default_instance_ = NULL;

StrengthenWeaponLog* StrengthenWeaponLog::New() const {
  return new StrengthenWeaponLog;
}

void StrengthenWeaponLog::Clear() {
  strengthen_weapon_info_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool StrengthenWeaponLog::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_FpdLogMessage.StrengthenWeaponLog)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated group Strengthen_weapon_info_list = 1 {
      case 1: {
        if (tag == 11) {
         parse_strengthen_weapon_info_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadGroupNoVirtual(
                1, input, add_strengthen_weapon_info_list()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(11)) goto parse_strengthen_weapon_info_list;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_FpdLogMessage.StrengthenWeaponLog)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_FpdLogMessage.StrengthenWeaponLog)
  return false;
#undef DO_
}

void StrengthenWeaponLog::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_FpdLogMessage.StrengthenWeaponLog)
  // repeated group Strengthen_weapon_info_list = 1 {
  for (int i = 0; i < this->strengthen_weapon_info_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteGroup(
      1, this->strengthen_weapon_info_list(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_FpdLogMessage.StrengthenWeaponLog)
}

int StrengthenWeaponLog::ByteSize() const {
  int total_size = 0;

  // repeated group Strengthen_weapon_info_list = 1 {
  total_size += 2 * this->strengthen_weapon_info_list_size();
  for (int i = 0; i < this->strengthen_weapon_info_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::GroupSizeNoVirtual(
        this->strengthen_weapon_info_list(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StrengthenWeaponLog::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const StrengthenWeaponLog*>(&from));
}

void StrengthenWeaponLog::MergeFrom(const StrengthenWeaponLog& from) {
  GOOGLE_CHECK_NE(&from, this);
  strengthen_weapon_info_list_.MergeFrom(from.strengthen_weapon_info_list_);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void StrengthenWeaponLog::CopyFrom(const StrengthenWeaponLog& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StrengthenWeaponLog::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->strengthen_weapon_info_list())) return false;
  return true;
}

void StrengthenWeaponLog::Swap(StrengthenWeaponLog* other) {
  if (other != this) {
    strengthen_weapon_info_list_.Swap(&other->strengthen_weapon_info_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string StrengthenWeaponLog::GetTypeName() const {
  return "DS3_FpdLogMessage.StrengthenWeaponLog";
}


// ===================================================================

#ifndef _MSC_VER
const int VisitResultLog::kMapIdFieldNumber;
const int VisitResultLog::kLocationFieldNumber;
const int VisitResultLog::kOnlineAreaIdSourceFieldNumber;
const int VisitResultLog::kOnlineAreaIdDestinationFieldNumber;
const int VisitResultLog::kUnknown2FieldNumber;
#endif  // !_MSC_VER

VisitResultLog::VisitResultLog()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_FpdLogMessage.VisitResultLog)
}

void VisitResultLog::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  location_ = const_cast< ::DS3_FpdLogMessage::Vector*>(
      ::DS3_FpdLogMessage::Vector::internal_default_instance());
#else
  location_ = const_cast< ::DS3_FpdLogMessage::Vector*>(&::DS3_FpdLogMessage::Vector::default_instance());
#endif
}

VisitResultLog::VisitResultLog(const VisitResultLog& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_FpdLogMessage.VisitResultLog)
}

void VisitResultLog::SharedCtor() {
  _cached_size_ = 0;
  map_id_ = 0u;
  location_ = NULL;
  online_area_id_source_ = 0u;
  online_area_id_destination_ = 0u;
  unknown_2_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

VisitResultLog::~VisitResultLog() {
  // @@protoc_insertion_point(destructor:DS3_FpdLogMessage.VisitResultLog)
  SharedDtor();
}

void VisitResultLog::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete location_;
  }
}

void VisitResultLog::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const VisitResultLog& VisitResultLog::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFpdLogMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFpdLogMessage_2eproto();
#endif
  return *default_instance_;
}

VisitResultLog* VisitResultLog::default_instance_ = NULL;

VisitResultLog* VisitResultLog::New() const {
  return new VisitResultLog;
}

void VisitResultLog::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<VisitResultLog*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 31) {
    ZR_(map_id_, unknown_2_);
    if (has_location()) {
      if (location_ != NULL) location_->::DS3_FpdLogMessage::Vector::Clear();
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool VisitResultLog::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_FpdLogMessage.VisitResultLog)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 map_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &map_id_)));
          set_has_map_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_location;
        break;
      }

      // required .DS3_FpdLogMessage.Vector location = 2;
      case 2: {
        if (tag == 18) {
         parse_location:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_location()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_online_area_id_source;
        break;
      }

      // required uint32 online_area_id_source = 3;
      case 3: {
        if (tag == 24) {
         parse_online_area_id_source:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &online_area_id_source_)));
          set_has_online_area_id_source();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_online_area_id_destination;
        break;
      }

      // required uint32 online_area_id_destination = 4;
      case 4: {
        if (tag == 32) {
         parse_online_area_id_destination:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &online_area_id_destination_)));
          set_has_online_area_id_destination();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_unknown_2;
        break;
      }

      // required uint32 unknown_2 = 5;
      case 5: {
        if (tag == 40) {
         parse_unknown_2:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_2_)));
          set_has_unknown_2();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_FpdLogMessage.VisitResultLog)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_FpdLogMessage.VisitResultLog)
  return false;
#undef DO_
}

void VisitResultLog::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_FpdLogMessage.VisitResultLog)
  // required uint32 map_id = 1;
  if (has_map_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->map_id(), output);
  }

  // required .DS3_FpdLogMessage.Vector location = 2;
  if (has_location()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->location(), output);
  }

  // required uint32 online_area_id_source = 3;
  if (has_online_area_id_source()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->online_area_id_source(), output);
  }

  // required uint32 online_area_id_destination = 4;
  if (has_online_area_id_destination()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->online_area_id_destination(), output);
  }

  // required uint32 unknown_2 = 5;
  if (has_unknown_2()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->unknown_2(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_FpdLogMessage.VisitResultLog)
}

int VisitResultLog::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 map_id = 1;
    if (has_map_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->map_id());
    }

    // required .DS3_FpdLogMessage.Vector location = 2;
    if (has_location()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->location());
    }

    // required uint32 online_area_id_source = 3;
    if (has_online_area_id_source()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->online_area_id_source());
    }

    // required uint32 online_area_id_destination = 4;
    if (has_online_area_id_destination()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->online_area_id_destination());
    }

    // required uint32 unknown_2 = 5;
    if (has_unknown_2()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_2());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void VisitResultLog::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const VisitResultLog*>(&from));
}

void VisitResultLog::MergeFrom(const VisitResultLog& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_map_id()) {
      set_map_id(from.map_id());
    }
    if (from.has_location()) {
      mutable_location()->::DS3_FpdLogMessage::Vector::MergeFrom(from.location());
    }
    if (from.has_online_area_id_source()) {
      set_online_area_id_source(from.online_area_id_source());
    }
    if (from.has_online_area_id_destination()) {
      set_online_area_id_destination(from.online_area_id_destination());
    }
    if (from.has_unknown_2()) {
      set_unknown_2(from.unknown_2());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void VisitResultLog::CopyFrom(const VisitResultLog& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VisitResultLog::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;

  if (has_location()) {
    if (!this->location().IsInitialized()) return false;
  }
  return true;
}

void VisitResultLog::Swap(VisitResultLog* other) {
  if (other != this) {
    std::swap(map_id_, other->map_id_);
    std::swap(location_, other->location_);
    std::swap(online_area_id_source_, other->online_area_id_source_);
    std::swap(online_area_id_destination_, other->online_area_id_destination_);
    std::swap(unknown_2_, other->unknown_2_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string VisitResultLog::GetTypeName() const {
  return "DS3_FpdLogMessage.VisitResultLog";
}


// ===================================================================

#ifndef _MSC_VER
const int QuickMatchResultLog::kUnknown1FieldNumber;
const int QuickMatchResultLog::kUnknown2FieldNumber;
const int QuickMatchResultLog::kUnknown3FieldNumber;
const int QuickMatchResultLog::kUnknown4FieldNumber;
const int QuickMatchResultLog::kUnknown5FieldNumber;
const int QuickMatchResultLog::kUnknown6FieldNumber;
const int QuickMatchResultLog::kUnknown7FieldNumber;
const int QuickMatchResultLog::kUnknown8FieldNumber;
const int QuickMatchResultLog::kUnknown9FieldNumber;
#endif  // !_MSC_VER

QuickMatchResultLog::QuickMatchResultLog()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_FpdLogMessage.QuickMatchResultLog)
}

void QuickMatchResultLog::InitAsDefaultInstance() {
}

QuickMatchResultLog::QuickMatchResultLog(const QuickMatchResultLog& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_FpdLogMessage.QuickMatchResultLog)
}

void QuickMatchResultLog::SharedCtor() {
  _cached_size_ = 0;
  unknown_1_ = 0u;
  unknown_2_ = 0u;
  unknown_3_ = 0u;
  unknown_4_ = 0u;
  unknown_5_ = 0u;
  unknown_6_ = 0u;
  unknown_7_ = 0u;
  unknown_8_ = 0u;
  unknown_9_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

QuickMatchResultLog::~QuickMatchResultLog() {
  // @@protoc_insertion_point(destructor:DS3_FpdLogMessage.QuickMatchResultLog)
  SharedDtor();
}

void QuickMatchResultLog::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void QuickMatchResultLog::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const QuickMatchResultLog& QuickMatchResultLog::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFpdLogMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFpdLogMessage_2eproto();
#endif
  return *default_instance_;
}

QuickMatchResultLog* QuickMatchResultLog::default_instance_ = NULL;

QuickMatchResultLog* QuickMatchResultLog::New() const {
  return new QuickMatchResultLog;
}

void QuickMatchResultLog::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<QuickMatchResultLog*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(unknown_1_, unknown_8_);
  }
  unknown_9_ = 0u;

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool QuickMatchResultLog::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_FpdLogMessage.QuickMatchResultLog)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 unknown_1 = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_1_)));
          set_has_unknown_1();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_unknown_2;
        break;
      }

      // required uint32 unknown_2 = 2;
      case 2: {
        if (tag == 16) {
         parse_unknown_2:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_2_)));
          set_has_unknown_2();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_unknown_3;
        break;
      }

      // required uint32 unknown_3 = 3;
      case 3: {
        if (tag == 24) {
         parse_unknown_3:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_3_)));
          set_has_unknown_3();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_unknown_4;
        break;
      }

      // required uint32 unknown_4 = 4;
      case 4: {
        if (tag == 32) {
         parse_unknown_4:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_4_)));
          set_has_unknown_4();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_unknown_5;
        break;
      }

      // required uint32 unknown_5 = 5;
      case 5: {
        if (tag == 40) {
         parse_unknown_5:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_5_)));
          set_has_unknown_5();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_unknown_6;
        break;
      }

      // required uint32 unknown_6 = 6;
      case 6: {
        if (tag == 48) {
         parse_unknown_6:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_6_)));
          set_has_unknown_6();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_unknown_7;
        break;
      }

      // required uint32 unknown_7 = 7;
      case 7: {
        if (tag == 56) {
         parse_unknown_7:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_7_)));
          set_has_unknown_7();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_unknown_8;
        break;
      }

      // required uint32 unknown_8 = 8;
      case 8: {
        if (tag == 64) {
         parse_unknown_8:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_8_)));
          set_has_unknown_8();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_unknown_9;
        break;
      }

      // required uint32 unknown_9 = 9;
      case 9: {
        if (tag == 72) {
         parse_unknown_9:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_9_)));
          set_has_unknown_9();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_FpdLogMessage.QuickMatchResultLog)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_FpdLogMessage.QuickMatchResultLog)
  return false;
#undef DO_
}

void QuickMatchResultLog::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_FpdLogMessage.QuickMatchResultLog)
  // required uint32 unknown_1 = 1;
  if (has_unknown_1()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->unknown_1(), output);
  }

  // required uint32 unknown_2 = 2;
  if (has_unknown_2()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->unknown_2(), output);
  }

  // required uint32 unknown_3 = 3;
  if (has_unknown_3()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->unknown_3(), output);
  }

  // required uint32 unknown_4 = 4;
  if (has_unknown_4()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->unknown_4(), output);
  }

  // required uint32 unknown_5 = 5;
  if (has_unknown_5()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->unknown_5(), output);
  }

  // required uint32 unknown_6 = 6;
  if (has_unknown_6()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->unknown_6(), output);
  }

  // required uint32 unknown_7 = 7;
  if (has_unknown_7()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->unknown_7(), output);
  }

  // required uint32 unknown_8 = 8;
  if (has_unknown_8()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->unknown_8(), output);
  }

  // required uint32 unknown_9 = 9;
  if (has_unknown_9()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->unknown_9(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_FpdLogMessage.QuickMatchResultLog)
}

int QuickMatchResultLog::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 unknown_1 = 1;
    if (has_unknown_1()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_1());
    }

    // required uint32 unknown_2 = 2;
    if (has_unknown_2()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_2());
    }

    // required uint32 unknown_3 = 3;
    if (has_unknown_3()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_3());
    }

    // required uint32 unknown_4 = 4;
    if (has_unknown_4()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_4());
    }

    // required uint32 unknown_5 = 5;
    if (has_unknown_5()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_5());
    }

    // required uint32 unknown_6 = 6;
    if (has_unknown_6()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_6());
    }

    // required uint32 unknown_7 = 7;
    if (has_unknown_7()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_7());
    }

    // required uint32 unknown_8 = 8;
    if (has_unknown_8()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_8());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // required uint32 unknown_9 = 9;
    if (has_unknown_9()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_9());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void QuickMatchResultLog::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const QuickMatchResultLog*>(&from));
}

void QuickMatchResultLog::MergeFrom(const QuickMatchResultLog& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_unknown_1()) {
      set_unknown_1(from.unknown_1());
    }
    if (from.has_unknown_2()) {
      set_unknown_2(from.unknown_2());
    }
    if (from.has_unknown_3()) {
      set_unknown_3(from.unknown_3());
    }
    if (from.has_unknown_4()) {
      set_unknown_4(from.unknown_4());
    }
    if (from.has_unknown_5()) {
      set_unknown_5(from.unknown_5());
    }
    if (from.has_unknown_6()) {
      set_unknown_6(from.unknown_6());
    }
    if (from.has_unknown_7()) {
      set_unknown_7(from.unknown_7());
    }
    if (from.has_unknown_8()) {
      set_unknown_8(from.unknown_8());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_unknown_9()) {
      set_unknown_9(from.unknown_9());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void QuickMatchResultLog::CopyFrom(const QuickMatchResultLog& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool QuickMatchResultLog::IsInitialized() const {
  if ((_has_bits_[0] & 0x000001ff) != 0x000001ff) return false;

  return true;
}

void QuickMatchResultLog::Swap(QuickMatchResultLog* other) {
  if (other != this) {
    std::swap(unknown_1_, other->unknown_1_);
    std::swap(unknown_2_, other->unknown_2_);
    std::swap(unknown_3_, other->unknown_3_);
    std::swap(unknown_4_, other->unknown_4_);
    std::swap(unknown_5_, other->unknown_5_);
    std::swap(unknown_6_, other->unknown_6_);
    std::swap(unknown_7_, other->unknown_7_);
    std::swap(unknown_8_, other->unknown_8_);
    std::swap(unknown_9_, other->unknown_9_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string QuickMatchResultLog::GetTypeName() const {
  return "DS3_FpdLogMessage.QuickMatchResultLog";
}


// ===================================================================

#ifndef _MSC_VER
const int QuickMatchEndLog::kUnknown1FieldNumber;
const int QuickMatchEndLog::kUnknown2FieldNumber;
const int QuickMatchEndLog::kUnknown3FieldNumber;
const int QuickMatchEndLog::kUnknown4FieldNumber;
const int QuickMatchEndLog::kUnknown5FieldNumber;
const int QuickMatchEndLog::kUnknown6FieldNumber;
#endif  // !_MSC_VER

QuickMatchEndLog::QuickMatchEndLog()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_FpdLogMessage.QuickMatchEndLog)
}

void QuickMatchEndLog::InitAsDefaultInstance() {
}

QuickMatchEndLog::QuickMatchEndLog(const QuickMatchEndLog& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_FpdLogMessage.QuickMatchEndLog)
}

void QuickMatchEndLog::SharedCtor() {
  _cached_size_ = 0;
  unknown_1_ = 0u;
  unknown_2_ = 0u;
  unknown_3_ = 0u;
  unknown_4_ = 0u;
  unknown_5_ = 0u;
  unknown_6_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

QuickMatchEndLog::~QuickMatchEndLog() {
  // @@protoc_insertion_point(destructor:DS3_FpdLogMessage.QuickMatchEndLog)
  SharedDtor();
}

void QuickMatchEndLog::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void QuickMatchEndLog::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const QuickMatchEndLog& QuickMatchEndLog::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFpdLogMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFpdLogMessage_2eproto();
#endif
  return *default_instance_;
}

QuickMatchEndLog* QuickMatchEndLog::default_instance_ = NULL;

QuickMatchEndLog* QuickMatchEndLog::New() const {
  return new QuickMatchEndLog;
}

void QuickMatchEndLog::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<QuickMatchEndLog*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 63) {
    ZR_(unknown_1_, unknown_6_);
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool QuickMatchEndLog::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_FpdLogMessage.QuickMatchEndLog)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 unknown_1 = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_1_)));
          set_has_unknown_1();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_unknown_2;
        break;
      }

      // required uint32 unknown_2 = 2;
      case 2: {
        if (tag == 16) {
         parse_unknown_2:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_2_)));
          set_has_unknown_2();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_unknown_3;
        break;
      }

      // required uint32 unknown_3 = 3;
      case 3: {
        if (tag == 24) {
         parse_unknown_3:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_3_)));
          set_has_unknown_3();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_unknown_4;
        break;
      }

      // required uint32 unknown_4 = 4;
      case 4: {
        if (tag == 32) {
         parse_unknown_4:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_4_)));
          set_has_unknown_4();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_unknown_5;
        break;
      }

      // required uint32 unknown_5 = 5;
      case 5: {
        if (tag == 40) {
         parse_unknown_5:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_5_)));
          set_has_unknown_5();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_unknown_6;
        break;
      }

      // required uint32 unknown_6 = 6;
      case 6: {
        if (tag == 48) {
         parse_unknown_6:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_6_)));
          set_has_unknown_6();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_FpdLogMessage.QuickMatchEndLog)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_FpdLogMessage.QuickMatchEndLog)
  return false;
#undef DO_
}

void QuickMatchEndLog::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_FpdLogMessage.QuickMatchEndLog)
  // required uint32 unknown_1 = 1;
  if (has_unknown_1()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->unknown_1(), output);
  }

  // required uint32 unknown_2 = 2;
  if (has_unknown_2()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->unknown_2(), output);
  }

  // required uint32 unknown_3 = 3;
  if (has_unknown_3()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->unknown_3(), output);
  }

  // required uint32 unknown_4 = 4;
  if (has_unknown_4()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->unknown_4(), output);
  }

  // required uint32 unknown_5 = 5;
  if (has_unknown_5()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->unknown_5(), output);
  }

  // required uint32 unknown_6 = 6;
  if (has_unknown_6()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->unknown_6(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_FpdLogMessage.QuickMatchEndLog)
}

int QuickMatchEndLog::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 unknown_1 = 1;
    if (has_unknown_1()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_1());
    }

    // required uint32 unknown_2 = 2;
    if (has_unknown_2()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_2());
    }

    // required uint32 unknown_3 = 3;
    if (has_unknown_3()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_3());
    }

    // required uint32 unknown_4 = 4;
    if (has_unknown_4()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_4());
    }

    // required uint32 unknown_5 = 5;
    if (has_unknown_5()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_5());
    }

    // required uint32 unknown_6 = 6;
    if (has_unknown_6()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_6());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void QuickMatchEndLog::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const QuickMatchEndLog*>(&from));
}

void QuickMatchEndLog::MergeFrom(const QuickMatchEndLog& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_unknown_1()) {
      set_unknown_1(from.unknown_1());
    }
    if (from.has_unknown_2()) {
      set_unknown_2(from.unknown_2());
    }
    if (from.has_unknown_3()) {
      set_unknown_3(from.unknown_3());
    }
    if (from.has_unknown_4()) {
      set_unknown_4(from.unknown_4());
    }
    if (from.has_unknown_5()) {
      set_unknown_5(from.unknown_5());
    }
    if (from.has_unknown_6()) {
      set_unknown_6(from.unknown_6());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void QuickMatchEndLog::CopyFrom(const QuickMatchEndLog& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool QuickMatchEndLog::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003f) != 0x0000003f) return false;

  return true;
}

void QuickMatchEndLog::Swap(QuickMatchEndLog* other) {
  if (other != this) {
    std::swap(unknown_1_, other->unknown_1_);
    std::swap(unknown_2_, other->unknown_2_);
    std::swap(unknown_3_, other->unknown_3_);
    std::swap(unknown_4_, other->unknown_4_);
    std::swap(unknown_5_, other->unknown_5_);
    std::swap(unknown_6_, other->unknown_6_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string QuickMatchEndLog::GetTypeName() const {
  return "DS3_FpdLogMessage.QuickMatchEndLog";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

ConvertSaveDataLog::ConvertSaveDataLog()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_FpdLogMessage.ConvertSaveDataLog)
}

void ConvertSaveDataLog::InitAsDefaultInstance() {
}

ConvertSaveDataLog::ConvertSaveDataLog(const ConvertSaveDataLog& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_FpdLogMessage.ConvertSaveDataLog)
}

void ConvertSaveDataLog::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ConvertSaveDataLog::~ConvertSaveDataLog() {
  // @@protoc_insertion_point(destructor:DS3_FpdLogMessage.ConvertSaveDataLog)
  SharedDtor();
}

void ConvertSaveDataLog::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ConvertSaveDataLog::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ConvertSaveDataLog& ConvertSaveDataLog::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFpdLogMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFpdLogMessage_2eproto();
#endif
  return *default_instance_;
}

ConvertSaveDataLog* ConvertSaveDataLog::default_instance_ = NULL;

ConvertSaveDataLog* ConvertSaveDataLog::New() const {
  return new ConvertSaveDataLog;
}

void ConvertSaveDataLog::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool ConvertSaveDataLog::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_FpdLogMessage.ConvertSaveDataLog)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_FpdLogMessage.ConvertSaveDataLog)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_FpdLogMessage.ConvertSaveDataLog)
  return false;
#undef DO_
}

void ConvertSaveDataLog::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_FpdLogMessage.ConvertSaveDataLog)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_FpdLogMessage.ConvertSaveDataLog)
}

int ConvertSaveDataLog::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ConvertSaveDataLog::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ConvertSaveDataLog*>(&from));
}

void ConvertSaveDataLog::MergeFrom(const ConvertSaveDataLog& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void ConvertSaveDataLog::CopyFrom(const ConvertSaveDataLog& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConvertSaveDataLog::IsInitialized() const {

  return true;
}

void ConvertSaveDataLog::Swap(ConvertSaveDataLog* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ConvertSaveDataLog::GetTypeName() const {
  return "DS3_FpdLogMessage.ConvertSaveDataLog";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

AccessWarehouseLog_Access_warehouse_info_list::AccessWarehouseLog_Access_warehouse_info_list()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_FpdLogMessage.AccessWarehouseLog.Access_warehouse_info_list)
}

void AccessWarehouseLog_Access_warehouse_info_list::InitAsDefaultInstance() {
}

AccessWarehouseLog_Access_warehouse_info_list::AccessWarehouseLog_Access_warehouse_info_list(const AccessWarehouseLog_Access_warehouse_info_list& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_FpdLogMessage.AccessWarehouseLog.Access_warehouse_info_list)
}

void AccessWarehouseLog_Access_warehouse_info_list::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AccessWarehouseLog_Access_warehouse_info_list::~AccessWarehouseLog_Access_warehouse_info_list() {
  // @@protoc_insertion_point(destructor:DS3_FpdLogMessage.AccessWarehouseLog.Access_warehouse_info_list)
  SharedDtor();
}

void AccessWarehouseLog_Access_warehouse_info_list::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void AccessWarehouseLog_Access_warehouse_info_list::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const AccessWarehouseLog_Access_warehouse_info_list& AccessWarehouseLog_Access_warehouse_info_list::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFpdLogMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFpdLogMessage_2eproto();
#endif
  return *default_instance_;
}

AccessWarehouseLog_Access_warehouse_info_list* AccessWarehouseLog_Access_warehouse_info_list::default_instance_ = NULL;

AccessWarehouseLog_Access_warehouse_info_list* AccessWarehouseLog_Access_warehouse_info_list::New() const {
  return new AccessWarehouseLog_Access_warehouse_info_list;
}

void AccessWarehouseLog_Access_warehouse_info_list::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool AccessWarehouseLog_Access_warehouse_info_list::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_FpdLogMessage.AccessWarehouseLog.Access_warehouse_info_list)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_FpdLogMessage.AccessWarehouseLog.Access_warehouse_info_list)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_FpdLogMessage.AccessWarehouseLog.Access_warehouse_info_list)
  return false;
#undef DO_
}

void AccessWarehouseLog_Access_warehouse_info_list::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_FpdLogMessage.AccessWarehouseLog.Access_warehouse_info_list)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_FpdLogMessage.AccessWarehouseLog.Access_warehouse_info_list)
}

int AccessWarehouseLog_Access_warehouse_info_list::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AccessWarehouseLog_Access_warehouse_info_list::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const AccessWarehouseLog_Access_warehouse_info_list*>(&from));
}

void AccessWarehouseLog_Access_warehouse_info_list::MergeFrom(const AccessWarehouseLog_Access_warehouse_info_list& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void AccessWarehouseLog_Access_warehouse_info_list::CopyFrom(const AccessWarehouseLog_Access_warehouse_info_list& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AccessWarehouseLog_Access_warehouse_info_list::IsInitialized() const {

  return true;
}

void AccessWarehouseLog_Access_warehouse_info_list::Swap(AccessWarehouseLog_Access_warehouse_info_list* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string AccessWarehouseLog_Access_warehouse_info_list::GetTypeName() const {
  return "DS3_FpdLogMessage.AccessWarehouseLog.Access_warehouse_info_list";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
#endif  // !_MSC_VER

AccessWarehouseLog::AccessWarehouseLog()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_FpdLogMessage.AccessWarehouseLog)
}

void AccessWarehouseLog::InitAsDefaultInstance() {
}

AccessWarehouseLog::AccessWarehouseLog(const AccessWarehouseLog& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_FpdLogMessage.AccessWarehouseLog)
}

void AccessWarehouseLog::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AccessWarehouseLog::~AccessWarehouseLog() {
  // @@protoc_insertion_point(destructor:DS3_FpdLogMessage.AccessWarehouseLog)
  SharedDtor();
}

void AccessWarehouseLog::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void AccessWarehouseLog::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const AccessWarehouseLog& AccessWarehouseLog::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFpdLogMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFpdLogMessage_2eproto();
#endif
  return *default_instance_;
}

AccessWarehouseLog* AccessWarehouseLog::default_instance_ = NULL;

AccessWarehouseLog* AccessWarehouseLog::New() const {
  return new AccessWarehouseLog;
}

void AccessWarehouseLog::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool AccessWarehouseLog::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_FpdLogMessage.AccessWarehouseLog)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_FpdLogMessage.AccessWarehouseLog)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_FpdLogMessage.AccessWarehouseLog)
  return false;
#undef DO_
}

void AccessWarehouseLog::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_FpdLogMessage.AccessWarehouseLog)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_FpdLogMessage.AccessWarehouseLog)
}

int AccessWarehouseLog::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AccessWarehouseLog::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const AccessWarehouseLog*>(&from));
}

void AccessWarehouseLog::MergeFrom(const AccessWarehouseLog& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void AccessWarehouseLog::CopyFrom(const AccessWarehouseLog& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AccessWarehouseLog::IsInitialized() const {

  return true;
}

void AccessWarehouseLog::Swap(AccessWarehouseLog* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string AccessWarehouseLog::GetTypeName() const {
  return "DS3_FpdLogMessage.AccessWarehouseLog";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RepairEquipmentLog_Repair_equipment_info_list::RepairEquipmentLog_Repair_equipment_info_list()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_FpdLogMessage.RepairEquipmentLog.Repair_equipment_info_list)
}

void RepairEquipmentLog_Repair_equipment_info_list::InitAsDefaultInstance() {
}

RepairEquipmentLog_Repair_equipment_info_list::RepairEquipmentLog_Repair_equipment_info_list(const RepairEquipmentLog_Repair_equipment_info_list& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_FpdLogMessage.RepairEquipmentLog.Repair_equipment_info_list)
}

void RepairEquipmentLog_Repair_equipment_info_list::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RepairEquipmentLog_Repair_equipment_info_list::~RepairEquipmentLog_Repair_equipment_info_list() {
  // @@protoc_insertion_point(destructor:DS3_FpdLogMessage.RepairEquipmentLog.Repair_equipment_info_list)
  SharedDtor();
}

void RepairEquipmentLog_Repair_equipment_info_list::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RepairEquipmentLog_Repair_equipment_info_list::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RepairEquipmentLog_Repair_equipment_info_list& RepairEquipmentLog_Repair_equipment_info_list::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFpdLogMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFpdLogMessage_2eproto();
#endif
  return *default_instance_;
}

RepairEquipmentLog_Repair_equipment_info_list* RepairEquipmentLog_Repair_equipment_info_list::default_instance_ = NULL;

RepairEquipmentLog_Repair_equipment_info_list* RepairEquipmentLog_Repair_equipment_info_list::New() const {
  return new RepairEquipmentLog_Repair_equipment_info_list;
}

void RepairEquipmentLog_Repair_equipment_info_list::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RepairEquipmentLog_Repair_equipment_info_list::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_FpdLogMessage.RepairEquipmentLog.Repair_equipment_info_list)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_FpdLogMessage.RepairEquipmentLog.Repair_equipment_info_list)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_FpdLogMessage.RepairEquipmentLog.Repair_equipment_info_list)
  return false;
#undef DO_
}

void RepairEquipmentLog_Repair_equipment_info_list::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_FpdLogMessage.RepairEquipmentLog.Repair_equipment_info_list)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_FpdLogMessage.RepairEquipmentLog.Repair_equipment_info_list)
}

int RepairEquipmentLog_Repair_equipment_info_list::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RepairEquipmentLog_Repair_equipment_info_list::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RepairEquipmentLog_Repair_equipment_info_list*>(&from));
}

void RepairEquipmentLog_Repair_equipment_info_list::MergeFrom(const RepairEquipmentLog_Repair_equipment_info_list& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RepairEquipmentLog_Repair_equipment_info_list::CopyFrom(const RepairEquipmentLog_Repair_equipment_info_list& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RepairEquipmentLog_Repair_equipment_info_list::IsInitialized() const {

  return true;
}

void RepairEquipmentLog_Repair_equipment_info_list::Swap(RepairEquipmentLog_Repair_equipment_info_list* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RepairEquipmentLog_Repair_equipment_info_list::GetTypeName() const {
  return "DS3_FpdLogMessage.RepairEquipmentLog.Repair_equipment_info_list";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
#endif  // !_MSC_VER

RepairEquipmentLog::RepairEquipmentLog()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_FpdLogMessage.RepairEquipmentLog)
}

void RepairEquipmentLog::InitAsDefaultInstance() {
}

RepairEquipmentLog::RepairEquipmentLog(const RepairEquipmentLog& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_FpdLogMessage.RepairEquipmentLog)
}

void RepairEquipmentLog::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RepairEquipmentLog::~RepairEquipmentLog() {
  // @@protoc_insertion_point(destructor:DS3_FpdLogMessage.RepairEquipmentLog)
  SharedDtor();
}

void RepairEquipmentLog::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RepairEquipmentLog::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RepairEquipmentLog& RepairEquipmentLog::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFpdLogMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFpdLogMessage_2eproto();
#endif
  return *default_instance_;
}

RepairEquipmentLog* RepairEquipmentLog::default_instance_ = NULL;

RepairEquipmentLog* RepairEquipmentLog::New() const {
  return new RepairEquipmentLog;
}

void RepairEquipmentLog::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RepairEquipmentLog::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_FpdLogMessage.RepairEquipmentLog)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_FpdLogMessage.RepairEquipmentLog)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_FpdLogMessage.RepairEquipmentLog)
  return false;
#undef DO_
}

void RepairEquipmentLog::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_FpdLogMessage.RepairEquipmentLog)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_FpdLogMessage.RepairEquipmentLog)
}

int RepairEquipmentLog::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RepairEquipmentLog::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RepairEquipmentLog*>(&from));
}

void RepairEquipmentLog::MergeFrom(const RepairEquipmentLog& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RepairEquipmentLog::CopyFrom(const RepairEquipmentLog& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RepairEquipmentLog::IsInitialized() const {

  return true;
}

void RepairEquipmentLog::Swap(RepairEquipmentLog* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RepairEquipmentLog::GetTypeName() const {
  return "DS3_FpdLogMessage.RepairEquipmentLog";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

LevelUpLog::LevelUpLog()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_FpdLogMessage.LevelUpLog)
}

void LevelUpLog::InitAsDefaultInstance() {
}

LevelUpLog::LevelUpLog(const LevelUpLog& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_FpdLogMessage.LevelUpLog)
}

void LevelUpLog::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LevelUpLog::~LevelUpLog() {
  // @@protoc_insertion_point(destructor:DS3_FpdLogMessage.LevelUpLog)
  SharedDtor();
}

void LevelUpLog::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void LevelUpLog::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const LevelUpLog& LevelUpLog::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFpdLogMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFpdLogMessage_2eproto();
#endif
  return *default_instance_;
}

LevelUpLog* LevelUpLog::default_instance_ = NULL;

LevelUpLog* LevelUpLog::New() const {
  return new LevelUpLog;
}

void LevelUpLog::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool LevelUpLog::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_FpdLogMessage.LevelUpLog)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_FpdLogMessage.LevelUpLog)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_FpdLogMessage.LevelUpLog)
  return false;
#undef DO_
}

void LevelUpLog::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_FpdLogMessage.LevelUpLog)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_FpdLogMessage.LevelUpLog)
}

int LevelUpLog::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LevelUpLog::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const LevelUpLog*>(&from));
}

void LevelUpLog::MergeFrom(const LevelUpLog& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void LevelUpLog::CopyFrom(const LevelUpLog& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LevelUpLog::IsInitialized() const {

  return true;
}

void LevelUpLog::Swap(LevelUpLog* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string LevelUpLog::GetTypeName() const {
  return "DS3_FpdLogMessage.LevelUpLog";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

BrokenEquipmentLog::BrokenEquipmentLog()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_FpdLogMessage.BrokenEquipmentLog)
}

void BrokenEquipmentLog::InitAsDefaultInstance() {
}

BrokenEquipmentLog::BrokenEquipmentLog(const BrokenEquipmentLog& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_FpdLogMessage.BrokenEquipmentLog)
}

void BrokenEquipmentLog::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BrokenEquipmentLog::~BrokenEquipmentLog() {
  // @@protoc_insertion_point(destructor:DS3_FpdLogMessage.BrokenEquipmentLog)
  SharedDtor();
}

void BrokenEquipmentLog::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void BrokenEquipmentLog::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BrokenEquipmentLog& BrokenEquipmentLog::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFpdLogMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFpdLogMessage_2eproto();
#endif
  return *default_instance_;
}

BrokenEquipmentLog* BrokenEquipmentLog::default_instance_ = NULL;

BrokenEquipmentLog* BrokenEquipmentLog::New() const {
  return new BrokenEquipmentLog;
}

void BrokenEquipmentLog::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool BrokenEquipmentLog::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_FpdLogMessage.BrokenEquipmentLog)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_FpdLogMessage.BrokenEquipmentLog)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_FpdLogMessage.BrokenEquipmentLog)
  return false;
#undef DO_
}

void BrokenEquipmentLog::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_FpdLogMessage.BrokenEquipmentLog)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_FpdLogMessage.BrokenEquipmentLog)
}

int BrokenEquipmentLog::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BrokenEquipmentLog::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BrokenEquipmentLog*>(&from));
}

void BrokenEquipmentLog::MergeFrom(const BrokenEquipmentLog& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void BrokenEquipmentLog::CopyFrom(const BrokenEquipmentLog& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BrokenEquipmentLog::IsInitialized() const {

  return true;
}

void BrokenEquipmentLog::Swap(BrokenEquipmentLog* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string BrokenEquipmentLog::GetTypeName() const {
  return "DS3_FpdLogMessage.BrokenEquipmentLog";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

EquipMagicLog::EquipMagicLog()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_FpdLogMessage.EquipMagicLog)
}

void EquipMagicLog::InitAsDefaultInstance() {
}

EquipMagicLog::EquipMagicLog(const EquipMagicLog& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_FpdLogMessage.EquipMagicLog)
}

void EquipMagicLog::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EquipMagicLog::~EquipMagicLog() {
  // @@protoc_insertion_point(destructor:DS3_FpdLogMessage.EquipMagicLog)
  SharedDtor();
}

void EquipMagicLog::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void EquipMagicLog::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const EquipMagicLog& EquipMagicLog::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFpdLogMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFpdLogMessage_2eproto();
#endif
  return *default_instance_;
}

EquipMagicLog* EquipMagicLog::default_instance_ = NULL;

EquipMagicLog* EquipMagicLog::New() const {
  return new EquipMagicLog;
}

void EquipMagicLog::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool EquipMagicLog::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_FpdLogMessage.EquipMagicLog)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_FpdLogMessage.EquipMagicLog)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_FpdLogMessage.EquipMagicLog)
  return false;
#undef DO_
}

void EquipMagicLog::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_FpdLogMessage.EquipMagicLog)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_FpdLogMessage.EquipMagicLog)
}

int EquipMagicLog::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EquipMagicLog::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const EquipMagicLog*>(&from));
}

void EquipMagicLog::MergeFrom(const EquipMagicLog& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void EquipMagicLog::CopyFrom(const EquipMagicLog& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EquipMagicLog::IsInitialized() const {

  return true;
}

void EquipMagicLog::Swap(EquipMagicLog* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string EquipMagicLog::GetTypeName() const {
  return "DS3_FpdLogMessage.EquipMagicLog";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

ChaneEstusFlaskNumLog::ChaneEstusFlaskNumLog()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_FpdLogMessage.ChaneEstusFlaskNumLog)
}

void ChaneEstusFlaskNumLog::InitAsDefaultInstance() {
}

ChaneEstusFlaskNumLog::ChaneEstusFlaskNumLog(const ChaneEstusFlaskNumLog& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_FpdLogMessage.ChaneEstusFlaskNumLog)
}

void ChaneEstusFlaskNumLog::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ChaneEstusFlaskNumLog::~ChaneEstusFlaskNumLog() {
  // @@protoc_insertion_point(destructor:DS3_FpdLogMessage.ChaneEstusFlaskNumLog)
  SharedDtor();
}

void ChaneEstusFlaskNumLog::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ChaneEstusFlaskNumLog::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ChaneEstusFlaskNumLog& ChaneEstusFlaskNumLog::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFpdLogMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFpdLogMessage_2eproto();
#endif
  return *default_instance_;
}

ChaneEstusFlaskNumLog* ChaneEstusFlaskNumLog::default_instance_ = NULL;

ChaneEstusFlaskNumLog* ChaneEstusFlaskNumLog::New() const {
  return new ChaneEstusFlaskNumLog;
}

void ChaneEstusFlaskNumLog::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool ChaneEstusFlaskNumLog::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_FpdLogMessage.ChaneEstusFlaskNumLog)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_FpdLogMessage.ChaneEstusFlaskNumLog)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_FpdLogMessage.ChaneEstusFlaskNumLog)
  return false;
#undef DO_
}

void ChaneEstusFlaskNumLog::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_FpdLogMessage.ChaneEstusFlaskNumLog)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_FpdLogMessage.ChaneEstusFlaskNumLog)
}

int ChaneEstusFlaskNumLog::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ChaneEstusFlaskNumLog::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ChaneEstusFlaskNumLog*>(&from));
}

void ChaneEstusFlaskNumLog::MergeFrom(const ChaneEstusFlaskNumLog& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void ChaneEstusFlaskNumLog::CopyFrom(const ChaneEstusFlaskNumLog& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChaneEstusFlaskNumLog::IsInitialized() const {

  return true;
}

void ChaneEstusFlaskNumLog::Swap(ChaneEstusFlaskNumLog* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ChaneEstusFlaskNumLog::GetTypeName() const {
  return "DS3_FpdLogMessage.ChaneEstusFlaskNumLog";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

CreateBloodMessageLog::CreateBloodMessageLog()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_FpdLogMessage.CreateBloodMessageLog)
}

void CreateBloodMessageLog::InitAsDefaultInstance() {
}

CreateBloodMessageLog::CreateBloodMessageLog(const CreateBloodMessageLog& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_FpdLogMessage.CreateBloodMessageLog)
}

void CreateBloodMessageLog::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CreateBloodMessageLog::~CreateBloodMessageLog() {
  // @@protoc_insertion_point(destructor:DS3_FpdLogMessage.CreateBloodMessageLog)
  SharedDtor();
}

void CreateBloodMessageLog::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CreateBloodMessageLog::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CreateBloodMessageLog& CreateBloodMessageLog::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFpdLogMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFpdLogMessage_2eproto();
#endif
  return *default_instance_;
}

CreateBloodMessageLog* CreateBloodMessageLog::default_instance_ = NULL;

CreateBloodMessageLog* CreateBloodMessageLog::New() const {
  return new CreateBloodMessageLog;
}

void CreateBloodMessageLog::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CreateBloodMessageLog::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_FpdLogMessage.CreateBloodMessageLog)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_FpdLogMessage.CreateBloodMessageLog)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_FpdLogMessage.CreateBloodMessageLog)
  return false;
#undef DO_
}

void CreateBloodMessageLog::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_FpdLogMessage.CreateBloodMessageLog)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_FpdLogMessage.CreateBloodMessageLog)
}

int CreateBloodMessageLog::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CreateBloodMessageLog::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CreateBloodMessageLog*>(&from));
}

void CreateBloodMessageLog::MergeFrom(const CreateBloodMessageLog& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CreateBloodMessageLog::CopyFrom(const CreateBloodMessageLog& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CreateBloodMessageLog::IsInitialized() const {

  return true;
}

void CreateBloodMessageLog::Swap(CreateBloodMessageLog* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CreateBloodMessageLog::GetTypeName() const {
  return "DS3_FpdLogMessage.CreateBloodMessageLog";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

EvaluateBloodMessageLog::EvaluateBloodMessageLog()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DS3_FpdLogMessage.EvaluateBloodMessageLog)
}

void EvaluateBloodMessageLog::InitAsDefaultInstance() {
}

EvaluateBloodMessageLog::EvaluateBloodMessageLog(const EvaluateBloodMessageLog& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DS3_FpdLogMessage.EvaluateBloodMessageLog)
}

void EvaluateBloodMessageLog::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EvaluateBloodMessageLog::~EvaluateBloodMessageLog() {
  // @@protoc_insertion_point(destructor:DS3_FpdLogMessage.EvaluateBloodMessageLog)
  SharedDtor();
}

void EvaluateBloodMessageLog::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void EvaluateBloodMessageLog::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const EvaluateBloodMessageLog& EvaluateBloodMessageLog::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_DS3_5fFpdLogMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_DS3_5fFpdLogMessage_2eproto();
#endif
  return *default_instance_;
}

EvaluateBloodMessageLog* EvaluateBloodMessageLog::default_instance_ = NULL;

EvaluateBloodMessageLog* EvaluateBloodMessageLog::New() const {
  return new EvaluateBloodMessageLog;
}

void EvaluateBloodMessageLog::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool EvaluateBloodMessageLog::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:DS3_FpdLogMessage.EvaluateBloodMessageLog)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:DS3_FpdLogMessage.EvaluateBloodMessageLog)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DS3_FpdLogMessage.EvaluateBloodMessageLog)
  return false;
#undef DO_
}

void EvaluateBloodMessageLog::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DS3_FpdLogMessage.EvaluateBloodMessageLog)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:DS3_FpdLogMessage.EvaluateBloodMessageLog)
}

int EvaluateBloodMessageLog::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EvaluateBloodMessageLog::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const EvaluateBloodMessageLog*>(&from));
}

void EvaluateBloodMessageLog::MergeFrom(const EvaluateBloodMessageLog& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void EvaluateBloodMessageLog::CopyFrom(const EvaluateBloodMessageLog& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EvaluateBloodMessageLog::IsInitialized() const {

  return true;
}

void EvaluateBloodMessageLog::Swap(EvaluateBloodMessageLog* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string EvaluateBloodMessageLog::GetTypeName() const {
  return "DS3_FpdLogMessage.EvaluateBloodMessageLog";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace DS3_FpdLogMessage

// @@protoc_insertion_point(global_scope)
